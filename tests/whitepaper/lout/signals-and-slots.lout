@Section
    @Title { Signals and Slots }
    @Tag { signals.and.slots }
@Begin
@QuotedDisplay { @I {
Signals and slots provide inter-object communication. They are easy
to understand and use and are fully supported by @QDR.
} }
@PP
GUI applications respond to user actions. For example, when a user
clicks a menu item or toolbar button, the program executes some
code.  More generally, we want objects of any kind to be able to
communicate with each other. The programmer must relate events to the
relevant code. Older toolkits use mechanisms that are not type safe
(i.e. are crash prone), are inflexible, and are not object oriented.
Trolltech has invented a solution called `signals and slots'. Signals
and slots is a powerful inter-object communication mechanism that can
be used to completely replace the crude callbacks and message maps
used by legacy toolkits. Signals and slots are type safe, flexible,
fully object oriented and implemented in C++.
  signal @Index { Signal }
  slot @Index { Slot }
@PP
To associate some code with a button using the old callback
mechanism, it is necessary to pass a pointer to a function to the
button. When the button is clicked, the function is then called. Old
toolkits do not ensure that arguments of the right type are given to
the function when it is called, which makes crashes more likely.
Another problem with the callback approach is that it tightly binds
the GUI element to the functionality, making it difficult to develop
classes independently.
@PP
Qt's signals and slots mechanism is different. Qt widgets emit
signals when events occur. For example, a button will emit a
`clicked' signal when it is clicked. The programmer can choose to
connect to a signal by creating a function (called a slot) and
calling the @Func connect() function to relate the signal to the
slot. Qt's signals and slots mechanism does not require classes to
have knowledge of each other, which makes it much easier to develop
highly reusable classes. Signals and slots are type safe, with type
errors being reported by the compiler rather than by crashes.
  callback @Index { Callback }
  communication @Index { Communication }
  connection @Index { Connection }
  event @Index { Event }
  mfc @Index { MFC }
  messagemap @Index { Message map }
  motif @Index { Motif }
  qobject @Index { QObject }
  connect @Index { connect() }
@PP
For example, if a @Button Quit button's @Func clicked() signal is
connected to the application's @Func quit() slot, a user's click on
@Button Quit makes the application terminate. In code, this is
written as
  clicked @Index { clicked() }
  quit @Index { quit() }
@IndentedDisplay @CP @Begin
connect( button, SIGNAL(clicked()), qApp, SLOT(quit()) );
@End @CP
Connections can be added or removed at any time during the execution
of a Qt application.
  objectorientedprogramming @Index { Object-oriented programming }
  typesafety @Index { Type safety }
@PP
The signals and slots implementation smoothly extends C++'s syntax
and takes full advantage of C++'s object-orientated features. Signals
and slots are type safe, can be overloaded or reimplemented and may
appear in the public, protected or private sections of a class.
  components @Index { Component }
  reusability @Index { Reusability }
@BeginSubSections
@SubSection
    @Title { A Signals and Slots Example }
    @Tag { a.signals.and.slots.example }
@Begin
@PP
To benefit from signals and slots, a class must inherit from @Class
QObject or one of its subclasses and include the @F Q_OBJECT macro in
the class's definition. Signals are declared in the @F signals
section of the class, while slots are declared in the @F public @F
slots, @F protected @F slots or @F private @F slots sections.
  inheriting @Index { Inheriting }
  qobject @Index { QObject }
  subclassing @Index { Subclassing }
@PP
Here's an example @Class QObject subclass:
@IndentedDisplay @CP @Begin
class BankAccount : public QObject
{
    Q_OBJECT
public:
    BankAccount() { curBalance = 0; }
    int balance() const { return curBalance; }
public slots:
    void setBalance( int newBalance );

signals:
    void balanceChanged( int newBalance );

private:
    int curBalance;
};
@End @CP
@PP
In the style of most C++ classes, the class @Class BankAccount has a
constructor, a get function @Func balance(), and a set function @Func
setBalance().
@PP
The class also has a signal @Func balanceChanged(), which announces
that the balance in the account has changed. Signals are not
implemented; when a signal is emitted, the slots it is connected to
are executed.
@PP
The set function is declared in the @F public @F slots section, so it
is a slot. Slots are standard member functions with an implementation
that can be called like any other function, and which can also be
connected to signals.
  emittingasignal @Index { Emitting a signal }
  preprocessorcpp @Index { Preprocessor }
@PP
Here's the implementation of the slot @Func setBalance():
@IndentedDisplay @CP @Begin
void BankAccount::setBalance( int newBalance )
{
    if ( newBalance != curBalance ) {
	curBalance = newBalance;
	emit balanceChanged( curBalance );
    }
}
@End @CP
The statement
@IndentedDisplay @CP @Begin
	emit balanceChanged( curBalance );
@End @CP
causes the @Func balanceChanged() signal to be emitted with the new
current balance as its argument. The keyword @F emit, like @F signals
and @F slots, is provided by Qt and is transformed into standard C++
by the C++ preprocessor.
@PP
Here's an example of how to connect two @Class{BankAccount}s:
@IndentedDisplay @CP @Begin
BankAccount x, y;
connect( &x, SIGNAL(balanceChanged(int)),
	    &y, SLOT(setBalance(int)) );
x.setBalance( 2450 );
@End @CP
When the balance in @F x is set to 2450, the @Func balanceChanged()
signal is emitted. The signal is received by @F y's @Func
setBalance() slot, which sets @F y's balance to 2450.
@PP
One object's signal can be connected to many different slots, and
many signals can be connected to one slot in a particular object.
Connections can be made between any signal and slot, provided that
their arguments are compatible.
@End @SubSection
@SubSection
    @Title { Meta Object Compiler }
    @Tag { meta.object.compiler }
@Begin
@PP
The signals and slots mechanism is implemented in pure standard C++.
The implementation uses the C++ preprocessor and the Meta Object
Compiler (@Cmd{moc}) included with the Qt toolkit.
  compilerfeatures @Index { Compiler features }
  metaobjectcompiler @Index { Meta Object Compiler }
  moc @Index { moc }
@PP
The @Cmd moc reads the application's header files and generates the
necessary code to support the signals and slots mechanism. Developers
never have to edit or even look at the generated code. The @Cmd qmake
build tool generates the correct Makefiles for the target platform.
  makefile @Index { Makefile }
  qmake @Index { qmake }
@PP
In addition to handling signals and slots, @Cmd moc supports Qt's
translation mechanism, its property system and extended run-time type
information. The @Cmd moc also makes the cross-platform introspection
of C++ programs possible.
  introspection @Index { Introspection }
  magic @Index { Magic }
  property @Index { Property }
  rtti @Index { RTTI }
  runtimetypeinformation @Index { Run-time type information }
  translation @Index { Translation }
@DP
@OLREF @LP
@Href{"http://www.trolltech.com/3.0/object.html"}@LLP
@Href{"http://www.trolltech.com/3.0/signalsandslots.html"}@LLP
@Href{"http://www.trolltech.com/3.0/moc.html"}@LLP
@End @SubSection
@EndSubSections
@End @Section
