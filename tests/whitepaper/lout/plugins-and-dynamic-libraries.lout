@Section
    @Title { Plugins and Dynamic Libraries }
    @Tag { plugins.and.dynamic.libraries }
@Begin
@QuotedDisplay { @I {
  codec @Index { Codec }
  customwidget @Index { Custom widget }
  database @Index { Database }
  image @Index { Image }
  plugin @Index { Plugin }
  style @Index { Style }
Qt can access functions from dynamic libraries platform-independently.
Qt also supports plugins, which allow developers to create and
distribute Qt codecs, database drivers, image format converters,
styles and custom widgets as independent components. 
} }
@BeginSubSections
@SubSection
    @Title { Dynamic Libraries }
    @Tag { dynamic.libraries }
@Begin
@PP
The @Class QLibrary class provides cross-platform dynamic library
loading, a more powerful mechanism than the more restrictive
build-time linking.
  dll @Index { DLL }
  dynamiclibrary @Index { Dynamic library }
  library @Index { Library }
  linking @Index { Linking }
  qlibrary @Index { QLibrary }
  sharedlibrary @Index { Shared library }
@PP
Below is an example of the most basic way to dynamically load and use
a library. The example attempts to obtain a pointer to the @F
print_str symbol from the @F mylib library (@File mylib.dll on Windows,
@File mylib.so on Unix).
@IndentedDisplay @CP @Begin
typedef void (StrFunc)( const char *str );

QLibrary lib( "mylib" );
StrFunc *func = (StrFunc *) lib.resolve( "print_str" );
if ( func )
    func( "Hello world!" );
@End @CP
Calling a function this way is not type safe, and only symbols with C
linkage are supported (due to C++ name mangling). These limitations
do not apply to Qt plugins.
@End @SubSection
@SubSection
    @Title { Plugins }
    @Tag { plugins }
@Begin
@PP
Converting a Qt codec, database driver, image format converter, style
or custom widget into a plugin is achieved by subclassing the
appropriate plugin base class, implementing a few simple functions,
and adding a macro.
  inheriting @Index { Inheriting }
  subclassing @Index { Subclassing }
@PP
For example, if a developer has created a @Class QStyle subclass
called @Class CopperStyle that they want to make available as a plugin,
they would create a subclass like this: 
  qstyle @Index { QStyle }
@IndentedDisplay @CP @Begin
class CopperStylePlugin : public QStylePlugin
{
public:
    CopperStylePlugin() { }
    ~CopperStylePlugin() { }

    QStringList keys() const {
        return QStringList() << "CopperStyle"; 
    }

    QStyle *create( const QString& key ) { 
        if ( key == "CopperStyle" ) 
            return new CopperStyle;
        return 0;
    }
};

Q_EXPORT_PLUGIN( CopperStylePlugin )
@End @CP
The new style can be set like this:
  qapplication @Index { QApplication }
@IndentedDisplay @CP @Begin
QApplication::setStyle( QStyleFactory::create("CopperStyle") );
@End @CP
Database drivers, codecs, custom widgets and image formats that are
supplied as plugins are detected and used by the application
automatically.
@PP
Companies already provide Qt components in source form, as
precompiled dynamic libraries or as plugins.
  calendar @Index { Calendar }
@Figure
    @Caption { One of Klar{@Char{adieresis}}lvdalens Datakonsult's
               many commercial components }
0.5 @Scale @IncludeGraphic { "images/klaralvdalen.eps" }
@DP
@OLREF @LP
@Href{"http://doc.trolltech.com/3.0/plugins-howto.html"}@LLP
@End @SubSection
@EndSubSections
@End @Section
