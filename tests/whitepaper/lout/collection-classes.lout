@Section
    @Title { Collection Classes }
    @Tag { collection.classes }
@Begin
@QuotedDisplay { @I {
Collection classes are used to store groups of items in memory. Qt
provides a set of classes that are compatible with the Standard
Template Library (STL), and that work regardless of whether the
compiler supports STL or not.
} }
@PP
Applications often need to manage items in memory, for example,
groups of images, widgets or custom objects. Many C++ compilers
support the STL, which provides read-made data structures for storing
items. Qt provides lists, stacks, queues and dictionaries with
STL-syntax. Qt's collection classes work with both STL and non-STL
compilers.
stl @Index { STL }
collectionclasses @Index { Collection classes }
containers @Index { Containers }
@PP
Qt's rich set of portable collection classes (`containers')
and associated iterators are heavily used internally, and are
provided as part of the Qt API. Qt's containers are optimized for
speed and memory efficiency using two techniques, `private
classes' and `implicit sharing'. Programmers can also use STL
containers on the platforms that support them, at the cost of losing
Qt's optimizations.
iterators @Index { Iterators }
templates @Index { Templates }
@PP
Template classes usually increase the size of executables
dramatically, because the compiler generates essentially the same
code for each specialized type. Qt's template collection classes
reduce code bloat because they are a thin layer over non-template
private classes.
bloatproblem @Index { Bloat problem }
codebloatproblem @Index { Code bloat problem }
privateclasses @Index { Private classes }
@BeginSubSections
@SubSection
    @Title { Value-based Collections }
    @Tag { value.based.collections }
@Begin
@PP
Qt provides five value-based collection classes: @Class
QMap<Key,T>, @Class QValueList<T>, @Class QValueStack<T>,
@Class QValueVector<T> and @Class QStringList. They have an
interface very similar to the STL containers and are fully compatible
with the STL algorithms. Qt provides some STL-equivalent algorithms:
@Func qCopy(), @Func qFind(), @Func qHeapSort(), etc. On platforms
with STL support, Qt provides automatic conversion operators between
STL and Qt containers.
qtl @Index { QTL }
algorithms @Index { Algorithms }
lists @Index { Lists }
maps @Index { Maps }
stacks @Index { Stacks }
valuebasedcollections @Index { Value-based collections }
vectors @Index { Vectors }
@PP
Qt's value-based collection classes are implicitly shared, also
called `copy on write'. Copies of instances of these classes share
the same data in memory. The data sharing is handled automatically;
if the application modifies the contents of one of the copied
objects, a deep copy of the data is made so that the other objects
are left unchanged. When an object is copied, only a pointer is
passed and a reference count incremented, which is much faster than
actually copying the data and also saves memory.
copyonwrite @Index { Copy on write }
implicitsharing @Index { Implicit sharing }
referencecounting @Index { Reference counting }
sharing @Index { Sharing }
@PP
Implicit sharing is used wherever it makes sense: in Qt's value-based
collection classes, and in @Class QBitmap, @Class QBrush, @Class
QCursor, @Class QFont, @Class QIconSet, @Class QPalette, @Class QPen,
@Class QPicture, @Class QPixmap, @Class QRegion, @Class QRegExp,
@Class QString, etc. Programmers can safely and efficiently copy
objects of these classes by value, avoiding the risks related to
using pointers and hand optimization. In particular, the implicitly
shared @Class QString class makes string processing easy and fast.
strings @Index { Strings }
@PP
Qt also provides the low-level @Class QMemArray<T> class with its
subclasses @Class QBitArray, @Class QByteArray and @Class
QPointArray. These classes are very efficient for handling basic
`plain old data' types.
pod @Index { POD }
arrays @Index { Arrays }
memoryarrays @Index { Memory arrays }
plainolddata @Index { Plain old data }
@End @SubSection
@SubSection
    @Title { Pointer-based Collections }
    @Tag { pointer.based.collections }
@Begin
@PP
Qt provides many low-level, generic, pointer-based collection
classes: @Class QDict<Key,T>, @Class QPtrList<T>, @Class
QPtrQueue<T>, @Class QPtrStack<T>, @Class QPtrVector<T> and
@Class QCache<T>. These classes store pointers rather than values.
They are especially useful for storing pointers to @Class {QWidget}s
and @Class {QObject}s. The pointer-based collection classes can
optionally take ownership of the objects they contain and
automatically delete them when the collection is destroyed.
autodeletion @Index { Auto-deletion }
caches @Index { Caches }
delete @Index { Delete }
dictionaries @Index { Dictionaries }
lists @Index { Lists }
ownership @Index { Ownership }
pointerbasedcollections @Index { Pointer-based collections }
queues @Index { Queues }
stacks @Index { Stacks }
vectors @Index { Vectors }
@DP
@OLREF @LP
@Href{"http://www.trolltech.com/3.0/qtl.html"}@LLP
@Href{"http://www.trolltech.com/3.0/collections.html"}@LLP
@Href{"http://www.trolltech.com/3.0/shclass.html"}@LLP
@End @SubSection
@EndSubSections
@End @Section
