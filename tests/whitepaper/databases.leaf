\chapter Databases

  \index Microsoft SQL Server
  \index MySQL
  \index OCI
  \index ODBC
  \index Oracle
  \index PostgreSQL
  \index SQL
  \index Sybase
  \index TDS

The Qt SQL module provides a cross-platform API (application
programmer interface) for accessing SQL databases. Qt includes native
drivers for Oracle, Microsoft SQL Server, Sybase Adaptive Server,
PostgreSQL, MySQL and ODBC. The drivers work on all supported
platforms and programs can access multiple databases using multiple
drivers simultaneously.

Programmers can easily execute any arbitrary SQL statements. Qt also
provides a high-level C++ interface that programmers can use which
generates the appropriate SQL statements automatically.

Any Qt widget, including custom widgets, can be made data-aware. Qt
also includes some database-specific convenience widgets, to simplify
the creation of dialogs and windows that present records as forms or
in tables. Data-aware widgets automatically support browsing, updating
and deleting records. Most database designs require that new records
have a unique key which cannot be guessed by Qt, so insertion usually
needs a small amount of code to be written. The programmer can
easily force the user to confirm actions, e.g. deletions.

The Qt SQL module is fully integrated into \l{Qt Designer} which
provides templates and wizards to make the creation of database forms
as quick and easy as possible. The wizards can create forms with
navigation buttons, and with update, insert and delete buttons.

The Qt SQL module allows programmers to execute SQL statements and to
create GUI applications that use foreign key lookups, present
master-detail relationships, and have drill-down.

\section1 Executing SQL Commands

  \index DDL
  \index DML
  \index queries
  \index SELECT

The \Class QSqlQuery class can be used to directly execute SQL DDL and
DML statements. The \Class QSqlQuery class is also used to navigate
the result sets produced by \c SELECT statements.

In the example below, a query is executed, and the result set navigated
using the \Func QSqlQuery::next() function:
\code
    QSqlQuery query( "SELECT id, surname FROM staff" );
    while ( query.next() ) {
	cout << "id: " 
	     << query.value(0).toInt() 
	     << " surname: "  
	     << query.value(1).toString() << endl;
    }
\endcode
Field values are indexed in the order they appear in the \c SELECT
statement. \Class QSqlQuery also provides the first(), prev(), last()
and seek() navigation functions.

  \index DELETE
  \index INSERT
  \index UPDATE

\c INSERT, \c UPDATE and \c DELETE are equally simple. Below is an \c
UPDATE example:
\code
    QSqlQuery query( "UPDATE staff SET salary = salary * 1.10"
		     " WHERE id > 1155 AND id < 8155" );
    if ( query.isActive() ) {
	cout << "Pay rise given to " 
	     << query.numRowsAffected() 
	     << " staff" << endl;
    }
\endcode

  \index tables
  \index views

For programmers who are not comfortable writing raw SQL, the \Class
QSqlCursor class provides a high-level interface for browsing and
editing records in SQL tables or views without the need to write SQL
statements. For example:
\code
    QSqlCursor cur( "staff" );
    while ( cur.next() ) {
	cout << "id: " 
	     << cur.value("id").toInt() 
	     << " surname: " 
	     << cur.value("surname").toString() << endl;
    }
\endcode

\Class QSqlCursor also supports the ordering and filtering that are
achieved using \c{ORDER BY} and \c WHERE clauses in the SQL statements
used by \Class QSqlQuery.

Calculated fields are useful both for real calculations (e.g.
calculating totals) and for performing foreign key lookups, (e.g. to
display names rather than codes). Calculated fields can be created by
subclassing \Class QSqlCursor, adding additional \Class{QSqlField}s
with their calculated property set to TRUE, and by reimplementing
QSqlCursor::calculateField().

Database drivers can be asked about the features they support,
including whether they support query size reporting and transations.
The \Func transaction(), \Func commit() and \Func rollback() functions
can be used if the underlying database supports transactions.

\section1 Data-aware Widgets

\Class QDataTable is a \Class QTable that displays records from a
result set using a \Class QSqlCursor. \Class QDataTable, like \Class
QTable, supports in-place editing.  Programmers can force users to
confirm all or selected changes (e.g. deletions) by setting
\Class{QDataTable}'s confirmation properties. The editor widget chosen
for each type of data depends on the data type. For example, a \Class
QLineEdit is used for \c CHAR fields, whereas a \Class QSpinBox is
used for \c INTEGER fields. The programmer can override the defaults
by creating a property map for the table which matches fields
(columns) to the editor widget type the programmer prefers. 

Records can be updated and deleted without writing any code.
Insertions require some code since most database designs expect new
records to be created with a unique key. This can easily be achieved
by generating the key in a slot which is connected to the \Func
QDataTable::beforeInsert() signal.

\Class QDataTable uses intelligent buffering to make the loading of
large result sets fast, while keeping the user interface responsive.
For databases that are capable of reporting query sizes, the scroll
bar slider is displayed proportionally immediately.

Qt also includes \Class QDataBrowser and \Class QDataView which are
used to display records as forms, typically with one or perhaps just a
few records shown at a time. These classes provide buttons with
ready-made connections for navigating through the records. \Class
QDataView is used for read only data. \Class QDataBrowser is used for
editing, and can provide ready-made insert, update and delete buttons.

Both editable widgets, \Class QDataTable and \Class QDataBrowser, have
both a popup context menu and keyboard shortcuts for editing records.

Programmers can manipulate data retrieved from the database before it
is displayed, e.g. by implementing a slot and connecting it to the
\Func primeInsert() and \Func primeUpdate() signals. Data can also be
manipulated or actions logged just before changes are written back to
the database, for example, converting a foreign key's display text
into its id by implementing a slot connected to \Func beforeInsert(),
\Func beforeUpdate() and \Func beforeDelete().

Developers can create their own forms for displaying database records.
Unlike older toolkits which duplicate their widgets with data-aware
versions, any Qt widget (including custom widgets) can be made
data-aware. All that is necessary is to include the widget in a \Class
QSqlForm and set up a property map to relate the relevant database
field to the widget that will present and edit the field's data.

Master-detail relationships are easily set up by filtering the detail
form or table's cursor by the master form or table's current record.
Drill-down is also easy to achieve, for example, by associating a
button, menu item or keyboard shortcut with a drill-down form that is
invoked with the current record's key as a parameter.

Qt's SQL module is fully integrated with \l {Qt Designer}. \l {Qt
Designer} can preview database forms and tables using live data if
desired, allowing programmers to browse, delete and update records.
\l{Qt Designer} has templates and wizards to make creating database
forms fast and simple.
