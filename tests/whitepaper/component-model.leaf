\chapter Component Model

\quote
The Qt Component Model provides a cross-platform framework similar to
COM on Windows. Using components makes it easier to upgrade or
enhance functionality without having to replace an entire
application. Components can also be used to share functionality among
a group of applications. Qt components can be products in their own
right, like COM components.
\endquote

\section1 Concepts

  \index COM
  \index QCOM
  \index Qt Component Model
  \index UCM
  \index component model

  \index components
  \index interfaces

The component model is built around two key concepts: \e interfaces
and \e components. An interface is a \Class QUnknownInterface
subclass that provides pure virtual functions. A component is a class
that implements one or more interfaces.

  \index binary compatibility

Components are stored in dynamic libraries. Application programmers
always use a component through its interfaces. This eliminates the
binary compatibility problem.

  \index GUID
  \index UUID

Universally Unique Identifiers (UUIDs) are 128-bit integers that
identify interfaces. A component knows the UUIDs of all the
interfaces it implements, and will not allow itself to be cast to an
interface type it does not support. This guarantees type safety. The
use of UUIDs also eliminates version conflicts.

\section1 Dynamic Library Loading

  \index DLL
  \index dynamic libraries
  \index libraries
  \index linking
  \index shared libraries

The \Class QLibrary class provides cross-platform dynamic library
loading, a more powerful mechanism than the more restrictive
build-time linking.

Below is an example of the most basic way to dynamically load and use
a library. The example attempts to obtain a pointer to the \c
print_str symbol from the \c mylib library.
\code
    typedef void (Prototype)( const char *str );

    QLibrary lib( "mylib" );
    Prototype *func = (Protoype *) lib.resolve( "print_str" );
    if ( func )
	func( "Hello world!" );
\endcode
Calling a function this way is not type safe, and only symbols with C
linkage are supported (due to C++ name mangling). These limitations
are removed by using Qt components.

\section1 Using Components

Qt components can be used as \e {unregistered components}, \e
{registered components} and as \e {plugins}.

\section2 Unregistered Components

If the application knows where the shared library containing the
component is located, it can construct a \Class QLibrary object and
query for the interface it requires.

  \index .dll
  \index .so

In the following example, we expect \c blur.dll (on Windows) or \c
blur.so (on Unix) to contain a component that implements the \Class
ImageFilterInterface.
\code
    QLibrary lib( "blur" );
    ImageFilterInterface *iface;
    lib->queryInterface( IID_ImageFilter,
			 (QUnknownInterface **) &iface );
    if ( iface ) {
	iface->applyFilter( image );
	iface->release();
    }
\endcode

This approach is very similar to conventional build-time linking, but
with the following advantages: the application can search for the
component at run time; it can load the component when the
functionality is required; and it can unload the component to
conserve memory. Unregistered components are most often used to split
an application's functionality into easily manageable and upgradable
components.

\section2 Registered Components

  \index installed components
  \index registered components

The \Class QComponentFactory class provides functions to register and
to look up components. Applications that know which components they
need can access them through the component register using the
component's UUID:
\code
    const QUuid BlurFilterUuid =
	    "{DD19964B-A2C8-42AE-AAF9-8ADC509BCA03}";

    ImageFilterInterface *iface;
    QComponentFactory::createInstance( BlurFilterUuid,
	    IID_ImageFilter, (QUnknownInterface **) &iface );
    if ( iface ) {
	iface->applyFilter( image );
	iface->release();
    }
\endcode

Registered components are usually specialized components that define
their own interfaces and that can be used by many unrelated
applications. They may be supplied with a particular application, but
in many cases registered components will be supplied by component
vendors as additional tools for developers.

\section2 Plugins

  \index plugins

Applications can load any number of \e plugin components that
implement the plugin interface defined by the application. Plugins
are distinguished from each other by the features they implement. The
\Class QPluginManager\<T\> provides access to the available features.
The following code obtains a list of filters (e.g. 'blur', 'sharpen')
from all the plugins that supply image filters.
\code
    QPluginManager<ImageFilterInterface> manager( IID_ImageFilter,
						  "./plugins" );
    QStringList features = manager->featureList();

    for ( int i = 0; i < features.count(); i++ ) {
	ImageFilterInterface *iface;
	manager->queryInterface( features[i],
				 (QUnknownInterface **) &iface );
	add_to_filter_menu( features[i], iface->description() );
	iface->release();
    }
\endcode  

Plugins are used, for example, in text processors to provide
spell-checking functionality, in web browsers to support unknown file
formats, etc.

\section1 Writing Components

To write a component, the interfaces that it will implement must be
defined. Here is the definition of an interface with one function:
\code
    struct ImageFilterInterface : public QUnknownInterface
    {
	virtual void applyFilter( QImage *img ) = 0;
    };
\endcode

A component that implements the interface above must implement three
functions from \Class QUnknownInterface, \Func queryInterface(),
\Func addRef() and \Func release(), and one function from \Func
ImageFilterInterface. For convenience, the macro \c Q_REFCOUNT
provides standard implementations for \Func addRef() and \Func
release().
\code
    class BlurFilter : public ImageFilterInterface
    {
    public:
	BlurFilter();

	Q_REFCOUNT( ref )
	QRESULT queryInterface( const QUuid&,
				QUnknownInterface ** );
	virtual void applyFilter( QImage *img );

    private:
	ulong ref;
    };
\endcode

The \Func queryInterface() function provides a pointer to an
interface of the required type if the interface is supported by the
component:
\code
    QRESULT BlurFilter::queryInterface( const QUuid& uuid,
					QUnknownInterface **iface )
    {
	*iface = 0;

	if ( uuid == IID_QUnknown ) {
	    *iface = this;
	} else if ( uuid == IID_ImageFilter ) {
	    *iface = this;
	} else {
	    return QE_NOINTERFACE;
	}
	(*iface)->addRef();
	return QS_OK;
    }
\endcode

Finally, the \Func applyFilter() function must be implemented to
provide the image-filtering capability.

  \index multiple inheritance

A component can implement multiple interfaces by using multiple
inheritance. Such a component's \Func queryInterface() implementation
must cast the \c this pointer to the appropriate interface type;
apart from that, implementing multiple interfaces is as
straightforward as implementing a single interface.

\section1 Placing Components in Shared Libraries

  \index exporting components

When compiling a component in a library, the component has to be \e
exported so that \Class QLibrary is aware of it. Qt provides macros
to portably export components. \Class BlurFilter is exported like
this:
\code
    Q_EXPORT_COMPONENT()
    {
	Q_CREATE_INSTANCE( BlurFilter )
    }
\endcode

This method allows one component to be exported per shared library.
More components can be provided by exporting a \e factory component
(a \Class QComponentFactoryInterface subclass) to create instances of
any component from the library. \Class QComponentFactory
automatically recognizes factory components and uses them to deliver
components transparently to the application.

  \index qmake

Makefiles for shared libraries can easily be generated for any
platform supported by Qt using Trolltech's \l qmake tool.

\ONLINES
\Online component.html
\ENDONLINES
