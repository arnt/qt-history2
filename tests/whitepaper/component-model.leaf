\chapter Component Model

\section1 Dynamic Library Loading

  \index DLL
  \index dynamic libraries
  \index libraries
  \index linking
  \index shared libraries

The \Class QLibrary class provides cross-platform dynamic library
loading, a more powerful mechanism than the commoner build-time
linking.

  \index addins
  \index components
  \index plugins

Dynamic library loading opens a new world of possibilities. It allow
applications to be extended by adding special components called
plugins. Also, if a dynamic library is missing, an application can
continue running with limited functionality rather than aborting.

Here is how a developer would load a library at run time and call a
library function called \c print_str:
\code
    typedef void (*Prototype)( const char *str );

    QLibrary lib( "mylib" );
    Prototype func = (Protoype) lib.resolve( "print_str" );
    if ( func )
	func( "Hello world!" );
\endcode
Calling a function this way is not type safe, and only symbols with C
linkage are supported (due to C++ name mangling). These limitations
are removed by the Qt Component Model.

\section1 The Qt Component Model

  \index COM
  \index QCOM
  \index Qt Component Model
  \index UCM
  \index component model

The Qt Component Model provides a portable framework similar to COM
on Windows. It helps break monolithic applications into components
that can be dynamically loaded and possibly used by other
applications.

  \index components
  \index interfaces

The component model is built around two key concepts: \e interfaces
and \e components. An interface is a \Class QUnknownInterface
subclass that exclusively provides pure virtual functions. A
component is a class that implements one or more interfaces.

Components are stored in shared libraries. Application programmers
never use components directly, but always through the interfaces they
implement. This guarantees binary compatiblitity.

  \index GUID
  \index UUID

128-bit integers known as Universally Unique Identifiers (UUIDs)
identify interfaces. A component knows the UUIDs of all the
interfaces it implements, and will not allow itself to be casted to
interface types it does not supports. This guarantees type safety.
Components also are identified by UUIDs, so that applications can
verify that they use a certain component if they need to.

\section1 Using Components

Most applications use components in one of three ways.

\section2 Unregistered Components

If the application knows where the shared library containing the
interesting component is located, it can construct a \Class QLibrary
object and query for an interface.

  \index .dll
  \index .so

In the following example, we expect \c blur.dll (on Windows) or \c
blur.so (on Unix) to contain a component that implements the \Class
ImageFilterInterface, and use the component on an image:
\code
    QLibrary lib( "blur" );
    ImageFilterInterface *iface;
    lib->queryInterface( IID_ImageFilter,
			 (QUnknownInterface **) &iface );
    if ( iface ) {
	iface->applyFilter( image );
	iface->release();
    }
\endcode

This approach is very similar to conventional build-time linking,
except that the application has more control over where to look for
the library.

\section2 Registered Components

  \index installed components
  \index registered components

Applications that know which component they need but not its location
in the file system can look up a component by UUID among the
registered components in the system. The \Class QComponentFactory
class provides functions to register and to look up components.
\code
    const QUuid BlurFilterUuid =
	    "{DD19964B-A2C8-42AE-AAF9-8ADC509BCA03}";

    ImageFilterInterface *iface;
    QComponentFactory::createInstance( BlurFilterUuid,
	    IID_ImageFilter, (QUnknownInterface **) &iface );
    if ( iface ) {
	iface->applyFilter( image );
	iface->release();
    }
\endcode

Registered components is used mostly for specialized components that
define their own interfaces and that are used by many unrelated
applications. For example, a sophisticated JPEG or PNG library makes
sense as a registered components.

\section2 Plugins

  \index plugins

Some applications are ready to load any number of \e plugin
components that implement a certain interface defined by the
application. Plugins are distinguished from each other by the feature
(or features) they implement. The \Class QPluginManager\<T\> provides
access to the available features.

For example, if a 'Blur' and a 'Sharpen' plugin are installed, the
following code will execute the \Func applyFilter() function on each:
\code
    QPluginManager<ImageFilterInterface> manager( IID_ImageFilter );
    manager->addLibraryPath( "./plugins" );

    QStringList features = manager->featureList();

    for ( int i = 0; i < features.count(); i++ ) {
	ImageFilterInterface *iface;
	manager->queryInterface( features[i],
				 (QUnknownInterface **) &iface );
	iface->applyFilter( image );
	iface->release();
    }
\endcode  

Plugins are useful for supporting any number of similar components.
They are used in text processors to provide spell-checking
functionality, in web browsers to support unknown file formats, etc.

\section1 Writing Components

Writing a component usually starts by defining one or many interfaces
that it will implement. Here is the definition of an interface with
one function:
\code
    struct ImageFilterInterface : public QUnknownInterface
    {
	virtual void applyFilter( QImage *img ) = 0;
    };
\endcode

A component that implements the above interface must implement three
functions from \Class QUnknownInterface, \Func queryInterface(),
\Func addRef() and \Func release(), and one function from \Func
ImageFilterInterface. For convenience, the macro \c Q_REFCOUNT
provides reasonable implementations for \Func addRef() and \Func
release().
\code
    class BlurFilter : public ImageFilterInterface
    {
	BlurFilter();

	QRESULT queryInterface( const QUuid&,
				QUnknownInterface ** );
	Q_REFCOUNT

	virtual void applyFilter( QImage *img );
    };
\endcode

The \Func queryInterface() function provides a pointer to an
interface of the asked type if the interface is supported by the
component:
\code
    QRESULT BlurFilter::queryInterface( const QUuid& uuid,
					QUnknownInterface **iface )
    {
	if ( uuid == IID_QUnknown || uuid == IID_Integer ) {
	    *iface = this;
	    addRef();
	    return QS_OK;
	} else {
	    *iface = 0;
	    return QE_NOINTERFACE;
	}
    }
\endcode

Finally, the \Func applyFilter() function must be implemented to
provide the image-filtering capability.

  \index multiple inheritance

A component can implement multiple interfaces by using multiple
inheritance. Such a component's \Func queryInterface() implementation
must cast the \c this pointer to the appropriate interface type;
otherwise, implementing multiple interfaces is as straight-forward as
implementing a single interface.

\section1 Bulding Components in Shared Libraries

  \index exporting components

When compiling a component in a library, the component has to be \e
exported so that \Class QLibrary is aware of it. Qt provides macros
to export components portably. \Class BlurFilter is exported like
this:
\code
    Q_EXPORT_COMPONENT()
    {
	Q_CREATE_INSTANCE( BlurFilter )
    }
\endcode

This method allows only one component to be exported per shared
library. More components can be provided by exporting a \e factory
component (a \Class QComponentFactoryInterface subclass) to create
instances of any component in the library on request, rather than any
other component. \Class QLibrary automatically recognizes factory
components and uses them to deliver components transparently to the
application.

  \index qmake

Makefiles for shared libraries can easily be generated for any
platform supported by Qt using Trolltech's \l qmake tool. Here's the
\l qmake project file for the \Class BlurFilter component:
\code
    TEMPLATE    = lib
    CONFIG      = qt dll
    TARGET      = blur
    VERSION     = 1.0.0
    DESTDIR     = .

    SOURCES     = blurfilter.cpp
\endcode
