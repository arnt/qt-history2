\chapter Signals and Slots

\quote
Signals and slots provide inter-object communication. They are easy to
understand and use, simple to hand code, and are fully supported by \l{Qt
Designer}.
\endquote

GUI applications respond to user actions. For example, when a user
clicks a menu item or toolbar button, the program executes some code.
More generally, we want objects of any kind to be able to communicate
with one another. For example, if we were parsing an XML file we might
want to notify a list view that we're using to represent the XML
file's structure whenever we encounter a new tag. The programmer must
relate events to the relevant code. Older toolkits use mechanisms
which are not type-safe (i.e. are crash-prone), are inflexible, and
make it difficult to do component programming. Qt uses a mechanism,
invented by Trolltech, called \e {signals and slots}. Signals and
slots is a powerful inter-object communication mechanism
that can be used to completely replace the crude callbacks and message
maps used by older toolkits. Signals and slots are type-safe,
flexible, and well suited to component programming. 

If a programmer wants to associate some code with a button, using the
old callback mechanism, they would have to pass a pointer to a
function to the button. When the button is clicked, the function would
then be called. There is no way of ensuring that arguments of the
right type are given to the function when it is called, which makes
crashes more likely. The other problem with the callback approach is
that it tightly binds the GUI element to the functionality, making it
difficult to develop classes independently.

Qt's signals and slots mechanism is different. Qt widgets emit signals
when events occur. For example, a button will emit a 'clicked' signal
when it is clicked. The programmer can choose to connect to a signal
by creating a function (called a \e slot) and calling the \Func
connect() function to relate the signal with the slot. Qt's signals
and slots mechanism does not require classes to have knowledge of each
other, which makes it much easier to develop highly reusable software
components. Signals and slots are type-safe, with type errors being
reported by the compiler rather than by crashes.

  \index MFC
  \index Motif
  \index QObject
  \index callbacks
  \index communication
  \index message maps
  \index objects
  \index signals
  \index slots

  \index events
  \index state of widgets

Objects, typically widgets, emit \e signals to indicate state
changes. Signals can be connected to member functions, \e slots, that
implement the required behavior.

  \index connect()

For example, if a \Button Quit button's \Func clicked() signal is
connected to the application's \Func quit() slot, a user's click on
\Button Quit makes the application quit. In code, this is written as
\code
    connect( button, SIGNAL(clicked()), qApp, SLOT(quit()) );
\endcode
Connections can be added or removed at any time during the execution
of a Qt application.

  \index OOP
  \index object-oriented programming
  \index type safety

The signals and slots implementation smoothly extends C++'s syntax
and takes full advantage of C++'s object-orientated features. Signals
and slots are type safe, can be overloaded or reimplemented and may
appear in the public, protected or private sections of a class.

  \index components
  \index reusability

\section1 A Signals and Slots Example

  \index QObject

To benefit from signals and slots, a class needs to inherit from
\Class QObject or one of its subclasses and must include the \c
Q_OBJECT macro in the class's definition. Signals are declared in the
\c signals section of the class, while slots are declared in the \c
{public slots}, \c {protected slots} or \c {private slots} sections.

  \index inheriting in Qt
  \index subclassing in Qt

Here's an example \Class QObject subclass:
\code
    class BankAccount : public QObject
    {
	Q_OBJECT
    public:
	BankAccount() { curBalance = 0; }
	int balance() const { return curBalance; }
    public slots:
	void setBalance( int newBalance );

    signals:
	void balanceChanged( int newBalance );

    private:
	int curBalance;
    };
\endcode

The class \Class BankAccount has a constructor, a get function, \Func
balance(), and a set function, \Func setBalance(), like almost any
C++ class.

The class also has a signal, \Func balanceChanged(), that announces
that the balance in the account has changed. Signals are not
implemented; when a signal is emitted, the slots it is connected to
are executed.

The set function is declared in the \c {public slots} section, so it
is a slot. Slots are standard member functions with an implementation
that can be called like any other function, and which can also be
connected to signals.

  \index emitting a signal
  \index preprocessor (C++)

Here's the implementation of the slot \Func setBalance():
\code
    void BankAccount::setBalance( int newBalance )
    {
	if ( newBalance != curBalance ) {
	    curBalance = newBalance;
	    emit balanceChanged( curBalance );
	}
    }
\endcode
The statement
\code
    emit balanceChanged( curBalance );
\endcode
causes the \Func balanceChanged() signal to be emitted with the new
current balance as its argument. The keyword \c emit, like \c signals
and \c slots, is provided by Qt and is transformed into standard C++
by the C++ preprocessor.

Here's an example of how to use \Class BankAccount:
\code
    BankAccount x, y;
    connect( &x, SIGNAL(balanceChanged(int)),
	     &y, SLOT(setBalance(int)) );
    x.setBalance( 2450 );
\endcode
We create two \Class BankAccount objects, \c x and \c y, and connect
\c x's \Func balanceChanged() signal to \c y's \Func setBalance()
slot. When we set the balance in \c x to 2450, the \Func
balanceChanged() signal is emitted and is received by \c y's \Func
setBalance() slot, which sets \c y's balance to 2450.

One object's signal can be connected to many different slots and many
signals can be connected to one slot in a particular object. Connections
can be made between any signal and slot, provided that their arguments
are compatible.

\section1 Meta Object Compiler

  \index Meta Object Compiler
  \index compiler features
  \index header files
  \index moc
  \index qmake

The signals and slots mechanism is implemented in pure standard C++.
The implementation uses the C++ preprocessor and the Meta Object
Compiler (\e moc) included with the Qt library. 

The \e moc reads the application's header files and generates the
necessary code to support the signals and slots mechanism. Developers
never have to edit or even look at the generated code, and the \l
qmake build tool generates the correct makefiles for the target
platform.

  \index introspection
  \index magic
  \index properties
  \index rtti
  \index run-time type information
  \index translations

In addition to handling signals and slots, \e moc supports Qt's \l
{translation mechanism}, its property system and extended run-time type
information. The \e moc also makes the cross-platform introspection
of C++ programs possible.

\section1 Further Reading

\list
\i \l http://doc.trolltech.com/object.html
\i \l http://doc.trolltech.com/signalsandslots.html
\i \l http://doc.trolltech.com/moc.html
\endlist
