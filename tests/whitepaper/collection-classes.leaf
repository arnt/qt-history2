\chapter Collection Classes

  \index STL
  \index collection classes
  \index containers
  \index iterators
  \index templates

Qt provides a rich set of portable collection classes (\e containers)
and associated iterators. They are heavily used internally, and are
provided as part of the Qt API. Qt's containers are optimized for
speed and memory efficiency using two techniques, \e {private
classes} and \e {implicit sharing}. Programmers can also use STL
containers on the platforms that support them, at the cost of losing
Qt's optimizations.

  \index bloat problem
  \index code bloat problem
  \index private classes

Template classes usually increase the size of executables
dramatically, because the compiler generates essentially the same
code for each specialized type. The Qt collection classes use
templates but reduce code bloat by using the private classes
approach. Most of the collection class functionality is provided by
non-template private classes. The actual collection classes are
implemented as a thin layer over these private classes.

\section1 Value-based Collections

  \index QTL
  \index algorithms
  \index lists
  \index maps
  \index stacks
  \index value-based collections
  \index vectors

Qt provides six value-based collection classes: \Class QMap\<Key,T\>,
\Class QValueList\<T\>, \Class QValueStack\<T\>, \Class
QValueVector\<T\> and \Class QStringList. They have an interface very
similar to the STL containers and are fully compatible with the STL
algorithms. Qt provides some STL-equivalent algorithms: \Func
qCopy(), \Func qFind(), \Func qHeapSort(), etc. On platforms with STL
support, Qt provides automatic conversion operators between STL and
Qt containers.

  \index copy on write
  \index implicit sharing
  \index reference counting
  \index sharing

Qt's value-based collection classes are implicitly shared, also known
as 'copy on write'. Copies of instances of these classes share the
same data in memory. The data sharing is handled automatically; if
the application modifies the contents of one of the copied objects, a
deep copy of the data is made so that the other objects are left
unchanged. When an object is copied, only a pointer is passed and a
reference count incremented, which is much faster than actually
copying the data and saves memory.

  \index strings

Implicit sharing is used wherever it makes sense: in Qt's value-based
collection classes, and in \Class QBitmap, \Class QBrush, \Class
QCursor, \Class QFont, \Class QIconSet, \Class QPalette, \Class QPen,
\Class QPicture, \Class QPixmap, \Class QRegion, \Class QRegExp,
\Class QString, etc. Programmers can safely and efficiently copy
objects of these classes by value, avoiding the risks related to
using pointers and hand optimization. In particular, the implicitly
shared \Class QString class makes string processing fast and easy.

  \index POD
  \index arrays
  \index memory arrays
  \index plain old data

Qt also provides the low-level \Class QMemArray\<T\> class with its
subclasses \Class QBitArray, \Class QByteArray and \Class
QPointArray. These classes are very efficient for handling basic
"plain old data" types.

\section1 Pointer-based Collections

  \index auto-deletion
  \index caches
  \index delete
  \index dictionaries
  \index lists
  \index ownership
  \index pointer-based collections
  \index queues
  \index stacks
  \index vectors

Qt provides many low-level, generic pointer-based collection classes:
\Class QDict\<Key,T\>, \Class QPtrList\<T\>, \Class QPtrQueue\<T\>,
\Class QPtrStack\<T\>, \Class QPtrVector\<T\> and \Class QCache\<T\>.
These classes store pointers rather than values. They are especially
useful for storing pointers to \Class {QWidget}s and \Class
{QObject}s. The pointer-based collection classes can optionally take
ownership of the objects they contain and automatically delete them
when the collection is destroyed.

\section1 Further Reading

\list
\i \l http://doc.trolltech.com/qtl.html
\i \l http://doc.trolltech.com/collections.html
\i \l http://doc.trolltech.com/shclass.html
\endlist
