<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- ./plugins-and-dynamic-libraries.leaf:3 -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Plugins and Dynamic Libraries</title>
</head>
<body>
<p align="right">[<a href="whitepaper-13.html">Prev: Collection Classes</a>] [<a href="whitepaper.html">Home</a>] [<a href="whitepaper-15.html">Next: Qt's Architecture</a>]</p>
<h2 align="center">Plugins and Dynamic Libraries</h2>
<!-- index codecs --><!-- index database drivers --><!-- index image formats --><!-- index styles --><blockquote>
<p>Qt can access functions from dynamic libraries platform-independently. Qt also supports plugins, which allow developers to create and distribute Qt codecs, database drivers, image format converters, styles and custom widgets as independent components.</p>
</blockquote>
<h3><a name="1"></a>Dynamic Libraries</h3>
<!-- index DLL --><!-- index dynamic libraries --><!-- index libraries --><!-- index linking --><!-- index shared libraries --><p>The <font color=darkblue><b>QLibrary</b></font> class provides cross-platform dynamic library loading, a more powerful mechanism than the more restrictive build-time linking.</p>
<p>Below is an example of the most basic way to dynamically load and use a library. The example attempts to obtain a pointer to the <tt>print_str</tt> symbol from the <tt>mylib</tt> library.</p>
<pre>
    typedef void (Prototype)( const char *str );

    QLibrary lib( "mylib" );
    Prototype *func = (Protoype *) lib.resolve( "print_str" );
    if ( func )
	func( "Hello world!" );
</pre>
<p>Calling a function this way is not type safe, and only symbols with C linkage are supported (due to C++ name mangling). These limitations do not apply to Qt plugins.</p>
<h3><a name="2"></a>Plugins</h3>
<p>Converting a Qt codec, database driver, image format converter, style or custom widget into a plugin is achieved by subclassing the appropriate plugin base class, implementing a few simple functions, and adding a macro.</p>
<p>For example, if a developer has created a <font color=darkblue><b>QStyle</b></font> subclass called 'HeavenlyStyle' that they want to make available as a plugin, they would create a subclass like this:</p>
<pre>
    class HeavenlyStylePlugin : public QStylePlugin
    {
    public:
	HeavenlyStylePlugin() { }
	~HeavenlyStylePlugin() { }

	QStringList keys() const {
	    return QStringList() &lt;&lt; "HeavenlyStyle"; 
	}

	QStyle* create( const QString&amp; key ) { 
	    if ( key == "HeavenlyStyle" ) 
		return new HeavenlyStyle;
	    return 0;
	}
    };

    Q_EXPORT_PLUGIN( HeavenlyStylePlugin )
</pre>
<p>The new style can be set like this:</p>
<pre>
    QApplication::setStyle( QStyleFactory::create("MyStyle") );
</pre>
<p>Database drivers, codecs, custom widgets and image formats that are supplied as plugins are detected and used by the application automatically.</p>
<p>Companies already provide Qt components in source form, as precompiled dynamic libraries and as plugins.</p>
<p align="center"><img align="middle" src="klaralvdalen.png" alt="Calendar widget" width="261" height="182">
</p>
<blockquote><p align="center"><em>One of <a href= http://www.klaralvdalens-datakonsult.se/ >Klar&auml;lvdalens Datakonsult</a>'s many commercial components</em></p></blockquote>
<!-- eof -->
<p align="right">[<a href="whitepaper-13.html">Prev: Collection Classes</a>] [<a href="whitepaper.html">Home</a>] [<a href="whitepaper-15.html">Next: Qt's Architecture</a>]</p>
</body>
</html>
