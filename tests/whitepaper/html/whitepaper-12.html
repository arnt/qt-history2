<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- ./input-output-and-networking.leaf:3 -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Input/Output and Networking</title>
</head>
<body>
<p align="right">[<a href="whitepaper-11.html">Prev: Events</a>] [<a href="whitepaper.html">Home</a>] [<a href="whitepaper-13.html">Next: Collection Classes</a>]</p>
<h2 align="center">Input/Output and Networking</h2>
<blockquote>
<p>Qt can load and save data in plain text, XML and binary format. Qt handles local files using its own classes, and remote files using the FTP and HTTP protocols. Inter-process communication and socket-based TCP and UDP networking are also fully supported.</p>
</blockquote>
<h3><a name="1"></a>Input/Output</h3>
<!-- index Unicode --><!-- index binary serialization --><!-- index input/output --><!-- index serialization --><p>Qt provides classes to perform advanced I/O on multiple platforms. The <font color=darkblue><b>QTextStream</b></font> class has a similar interface to the standard <tt>&lt;iostream&gt;</tt> classes, and supports the encodings provided by <font color=darkblue><b>QTextCodec</b></font>. The <font color=darkblue><b>QDataStream</b></font> class is used to serialize the basic C++ types and many Qt types in a platform-independent binary format. For example, the following code writes a Unicode string, a font and a color to the file <tt>splash.dat</tt>:</p>
<pre>
    QFile file( "splash.dat" );
    if ( file.open(IO_WriteOnly) ) {
	QDataStream out( &amp;file );
	out &lt;&lt; QString( "SplashWidgetStyle" )
	    &lt;&lt; QFont( "Times", 18, QFont::Bold )
	    &lt;&lt; QColor( "skyblue" );
    }
</pre>
<p>The data can easily be retrieved and used, for example:</p>
<pre>
    QString str;
    QFont font;
    QColor color;

    QFile file( "splash.dat" );
    if ( file.open(IO_ReadOnly) ) {
	QDataStream in( &amp;file );
	in &gt;&gt; str &gt;&gt; font &gt;&gt; color;

	if ( str == "SplashWidgetStyle" ) {
	    splashWidget-&gt;setFont( font );
	    splashWidget-&gt;setColor( color );
	}
    }
</pre>
<p>In practice, the above example would be written more concisely and easily using <a href="whitepaper-4.html#5">settings</a>.</p>
<p><font color=darkblue><b>QTextStream</b></font> and <font color=darkblue><b>QDataStream</b></font> operate on any <font color=darkblue><b>QIODevice</b></font> subclass. Qt includes the <font color=darkblue><b>QFile</b></font>, <font color=darkblue><b>QBuffer</b></font>, <font color=darkblue><b>QSocket</b></font> and <font color=darkblue><b>QSocketDevice</b></font> subclasses, and programmers can implement their own custom devices. <font color=darkblue><b>QIODevice</b></font> also provides low-level functions such as <font color=darkblue>readLine()</font> and <font color=darkblue>writeBlock()</font> that can be used independently of any stream.</p>
<p>Directories are read and traversed using <font color=darkblue><b>QDir</b></font>. <font color=darkblue><b>QDir</b></font> can be used to manipulate path names and access the underlying file system (e.g. create a directory or delete a file). <font color=darkblue><b>QFileInfo</b></font> provides more detailed information about a file, such as its size, permissions, creation time, last modification time, etc.</p>
<p>The following example lists the hidden files in the user's home directory along with their size, in decreasing size order:</p>
<pre>
    QDir dir = QDir::home();
    dir.setFilter( QDir::Files | QDir::Hidden );
    dir.setSorting( QDir::Size | QDir::Reversed );
    QStringList names = dir.entryList();

    for ( int i = 0; i &lt; names.count(); i++ ) {
	QFileInfo info( dir, names[i] );
	cout &lt;&lt; names[i].latin1() &lt;&lt; " "
	     &lt;&lt; info.size() &lt;&lt; endl;
    }
</pre>
<!-- index FTP --><!-- index HTTP --><!-- index URL --><!-- index networking --><p>Transparent access to remote files is provided by <font color=darkblue><b>QUrlOperator</b></font>. In addition to local file system access, Qt supports the the FTP and HTTP protocols and can be extended to support other protocols. For example, files can be downloaded using FTP like this:</p>
<pre>
    QUrlOperator op;
    op.copy( QString("ftp://ftp.trolltech.com/qt/INSTALL"),
	     QString("file:/tmp") );
</pre>
<p>URLs can easily be parsed and recomposed using <font color=darkblue><b>QUrl</b></font>.</p>
<p>Image files are usually read by creating a <font color=darkblue><b>QImage</b></font> with the file name as argument. Printing text and images is handled by <font color=darkblue><b>QPainter</b></font>. These classes are described in <a href="whitepaper-6.html#1">2D Graphics</a>.</p>
<h3><a name="2"></a>XML</h3>
<!-- index DOM --><!-- index Java --><!-- index SAX --><!-- index W3C --><!-- index XML --><p>Qt's XML module provides a SAX parser and a DOM parser, both of which read well-formed XML and are non-validating. The SAX (Simple API for XML) implementation follows the design of the SAX2 Java implementation, with adapted naming conventions. The DOM (Document Object Model) Level 2 implementation follows the W3C recommendation and includes namespace support.</p>
<p>Many Qt applications use XML format to store their persistent data. The SAX parser is used for reading data incrementally and is especially suitable for simple parsing requirements and for very large files. The DOM parser reads the entire file into a tree structure in memory that can be traversed at will.</p>
<h3><a name="3"></a>Inter-Process Communication</h3>
<!-- index IPC --><!-- index asynchronous I/O --><!-- index processes --><p>The <font color=darkblue><b>QProcess</b></font> class is used to start external programs and to communicate with them from a Qt application in a platform-independent way. Communication is achieved by writing to the external program's standard input and potentially by reading its standard output and standard error.</p>
<p><font color=darkblue><b>QProcess</b></font> works asynchronously, reporting the availability of data by emitting signals. Qt applications can connect to the signals to retrieve and process the data, and optionally respond by sending data back to the external program.</p>
<h3><a name="4"></a>Networking</h3>
<!-- index networking --><p>Qt provides a cross-platform interface for writing TCP/IP clients and servers.</p>
<p>The <font color=darkblue><b>QSocket</b></font> class provides an asynchronous buffered TCP connection. <font color=darkblue><b>QSocket</b></font> is a <font color=darkblue><b>QIODevice</b></font>, making it easy to use <font color=darkblue><b>QTextStream</b></font> and <font color=darkblue><b>QDataStream</b></font> on a socket.</p>
<p><font color=darkblue><b>QSocket</b></font> is designed to work well within a GUI application. A live currency converter application illustrates this:</p>
<p align="center"><img align="middle" src="converter.png">
</p>
<p>The application uses the fictional protocol CCP (Currency Conversion Protocol) to access the latest exchange rates from a server. Only lines related to networking are presented.</p>
<pre>        socket = new QSocket( this );
        connect( socket, SIGNAL(readyRead()),
                 this, SLOT(updateTargetAmount()) );
</pre>
 <p>The socket is created in the <font color=darkblue><b>Converter</b></font> constructor. Socket communication is asynchronous, and the socket emits the <font color=darkblue>readyRead()</font> signal when there is data available to read.</p>
<pre>    void Converter::convert()
    {
        QString command = "CONV " + sourceAmount-&gt;text() + " " +
                          sourceCurrency-&gt;currentText() + " " +
                          targetCurrency-&gt;currentText() + "\r\n";
        socket-&gt;connectToHost( "ccp.banca-monica.nu", 123 );
        socket-&gt;writeBlock( command.latin1(), command.length() );
    }
</pre>
 <p>The <font color=darkblue>convert()</font> slot is called when the user clicks the <font color=darkgreen><em>Convert</em></font> button. It opens the connection and sends a <tt>CONV</tt> request (e.g. <tt>CONV</tt> <tt>100</tt> <tt>EUR</tt> <tt>USD</tt>) to port 123 on the server <tt>ccp.banca-monica.nu</tt>. <font color=darkblue><b>QSocket</b></font> automatically uses <font color=darkblue><b>QDns</b></font> to resolve <tt>cpp.banca-monica.nu</tt> to its IP address. All these operations are non-blocking to keep the user interface responsive.</p>
<pre>    void Converter::updateTargetAmount()
    {
        if ( socket-&gt;canReadLine() ) {
            targetAmount-&gt;setText( socket-&gt;readLine() );
            socket-&gt;close();
        }
    }
</pre>
 <p>The <font color=darkblue>updateTargetAmount()</font> function is called when the server replies to the <tt>CONV</tt> request. It reads the reply, updates the display and closes the connection.</p>
<p>Simple TCP servers can be implemented by subclassing <font color=darkblue><b>QServerSocket</b></font>, which works asynchronously like <font color=darkblue><b>QSocket</b></font>. <font color=darkblue><b>QServerSocket</b></font> sets up a listening socket that accepts incoming connections, and calls a virtual function to serve the client.</p>
<p>The <font color=darkblue><b>QSocketDevice</b></font> class provides a platform-independent wrapper for the native socket APIs. It provides the underlying functionality for <font color=darkblue><b>QSocket</b></font> and <font color=darkblue><b>QServerSocket</b></font>, and can be used for UDP.</p>
<p><hr><ul> <li><a href=http://doc.trolltech.com/3.0/xml.html>http://doc.trolltech.com/3.0/xml.html</a> <li><a href=http://doc.trolltech.com/3.0/datastreamformat.html>http://doc.trolltech.com/3.0/datastreamformat.html</a> </ul></p>
<!-- eof -->
<p align="right">[<a href="whitepaper-11.html">Prev: Events</a>] [<a href="whitepaper.html">Home</a>] [<a href="whitepaper-13.html">Next: Collection Classes</a>]</p>
</body>
</html>
