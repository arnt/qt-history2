2001-06-01 - db

Current improvements to Qt 3.0 beta1 SQL Module
==============================================

The following work should be focused on during the 3.0 beta period and just
after the initial release of 3.0 final.

Binary data
-----------

There needs to be a uniform method of handling binary data.  Some
definition of binary data should be made, and applied to all supported
databases.  For example, MySQL has several binary data tyeps: BLOB,
TINYBLOB, LONGBLOB, etc.  The default binary format (probably a QByteArray
or QCString?) should be big enough to handle some of the larger binary
types (they can be as big as 64K and up).  It may be worth adding an option
to stream binary data fields to disk to avoid filling all available memory
when doing a select.  This will allow programmers to store binary data
(like images, etc) in a database and retrieve them using Qt in a uniform
way.  Note that there may be some platform differences and byte order
issues with binary data as well.

Additional drivers
------------------

Some work has been done to get a TDS driver working.  This will allow
connections to Sybase and MS SQL Server from both Windows and Unix.  Since
MS SQL Server is huge in the windows world, this is an important driver to
get working.  It may be important enought to include in the Qt 3.0 release,
especially since we have several months before it ships. Note that the
implementation of FreeTDS (which is an open source implementation of the
TDS protocols for unix) is not very good at the moment.  It may be worth
devoting some resources to this project to get it at least to the level
where it works with the Qt drivers.  This would give the Qt SQL module a
better foothold in the unix realm since FreeTDS would become the de facto
way to connect to MS SQL Server from unix.  The only other alternative is
to use the Sybase client libraries for unix, but I don't think there is any
source available for that.  Note that, like the OCI driver, we may not want
to distribute the TDS driver with the free edition. Other potential drivers
which should be considered include: DB2, Informix, Adabas, YARD, mSQL,
BeagleSQL, GNU SQL, InterBase (or Firebird).  Note that someone outside of
Trolltech was working on an Adabas driver (contact Helmut at
dynalog@t-online.de) but I have not heard about any progress lately.
Writing new drivers is straightforward, and there are plenty of docs and
existing examples.

Threading
---------

There are some issues with threading and the database plugins.  Since the
Qt database driver plugins load other shared object files, there is often a
mix of different threading models.  On unix, this often results in a
segfault on program exit.  I started to do some research on this, but all I
could come up with was "don't mix threading models among shared objects"
(duh).  This problem needs to be investigated further so that appropriate
docs and workarounds can be found.  For example, the OCI driver currently
links with a threaded oracle client library (libclntsh.so).  If the Qt lib
is not also threaded, this causes problems.  In some cases, even when the
Qt lib is also threaded, there are still problems, which leads me to think
there are some remaining issues with the plugin manager, but the internals
have been changing too much to keep up with.

Other features
--------------

Depending on customer feedback, other features should be focused on or
added.  For example, I have seen a few requests for higher level database
manipulation (some sort of wrapper for CREATE TABLE or LOCK DATABASE).  A
lot of these types of features are very database-specific, and would be
difficult to abstract out into a general API.  They should be considered on
a case-by-case basis.  It is very easy to have horrible feature creep with
database libraries (I already regret adding too much to the initial version
already), so be very conservative with this.  It is much better to have a
nicely functioning, but simple, API, than to have a massive amount of
inconsistent functions that give the illusion of completeness.  Take
inspiration from the QThread API which focused on a well-defined set of
functionality rather than an over-the-top bag of features.

Future Qt SQL Module Features
=============================

Going forward, there are several new features that can be added to the core
Qt SQL module which will increase its power and ease-of-use.  Mainly, the
Designer should be enhanced to automate most of this (as it already does
with, for example, form creation), but the core SQL library needs to be
enhanced to support these automations.

Foreign Key Support
-------------------

This is a big one.  Basically, there needs to be a concept of a 'foreign
key'.  A foreign key is one or more fields in a table which link to one or
more primary index fields in another table, establishing a relationship
between the tables.  For example:

table:  COMPANY
fields: ID int
        NAME string

table:  EMP
fields: ID int
	COMPANYID int
	NAME string

The EMP table above would have a foreign key based on the EMP.COMPANYID
field which links to the COMPANY.ID primary index field.  Each EMP record
'belongs to' one COMPANY.  This is a 1:M (one to many) relationship.  There
are also 1:1, M:1 and M:M relationships (see 'Relation Manager' below).

Foreign keys are useful in many ways.  The can establish automatic lookups:
for example, when displaying the EMP table, the corresponding COMPANY
record can be retrieved based on the foreign key.  Foreign keys can also
establish referential integrity relationships: for example, when a COMPANY
record is deleted, all associated EMP records (based on the EMP.COMPANYID
foreign key) can also be deleted.  Note that the vast majority of
relational database provide referential integrity as a part of the database
itself, so this may be an almost useless feature.

QSqlIndex can probably be extended slightly (if at all) to handle foreign
key responsibilites.  And, in combination with a 'relation manager' (see
below), foreign key support can be added to the Qt SQL module.  Note, by
itself 'foreign key' support will not mean very much except when it is
employed by Designer to automate many very common application tasks (like
foreign key lookups).

Relation Manager
----------------

A relation manager class (QSqlRelation) can be used to manage the
relationship between two tables in a database.  It is initialized with two
QSqlCursor objects (represeting the two tables) and two indexes defining
the relationship.  There should be support for different types of
relations: one-to-one, one-to-many, many-to-many(? this one may not make
sense) and many-to-one.

QSqlRelation should be able to 'synchronize' the tables, so that the
relationship remains valid.  In fact, the API may be similar to QSqlCursor
with next(), first(), last(), etc., except that both tables would be
navigated simultaneously.  For example:

COMPANY
ID	NAME
-------------
1	tt
2	bar


EMP
ID	COMPANYID	NAME
-------------------------------
1	1 		db
2	1		trond
3	2		foo


If a QSqlRelation was setup between these two cursors, the code may look
like this:

	QSqlCursor company( "COMPANY" );
	QSqlCursor emp( "EMP" );
	QSqlRelation rel( &company, &emp );
	rel.relate( company.primaryIndex(), emp.index( "COMPANYID" ), QSqlRelation::OneToMany );
	rel.select();
	while ( rel.next() ) {
		qDebug( company.value( "NAME" ).toString() + " " + emp.value( "NAME" ) );
	}

The above would print out:

	tt db
	tt trond
	bar foo

QSqlRelation would retrieve the data using the QSqlCursor API, so it would
not be as efficient as creating a custom query.  Maybe there could be
another class that could do that?  The essential thing here is that
QSqlRelation would handle the navigation of the cursors according to the
relationship between them.

Each QSqlRelation would have a 'driving' table (or cursor).  There could
even be an API to relate more than two tables.  This is almost sounding
like a client-side VIEW class -- although it would be -much- less efficient
than a real view.

QSqlRelation could also be used to generate appropriate filter conditions
for related tables.

Table/Database Locking, High Level Database Functions
-----------------------------------------------------
Case-Insensitive Index Sorting (?)
DROP TABLE
CREATE TABLE? 

The problem with very high level database functions is: we are starting to
encroach on the territory of DBAs.  It is their job to do this type of
work.  Incorporating this functionality into an API will always be
sub-optimal.  It may be helpful for a few clueless developers, but that's
about it.  My main vote is to stay away from database -design-
functionality.  The Qt SQL module should allow programmers to access an
already built database, not attempt to build one from scratch itself.

In-process Database
-------------------

LocalSQL is still alive at Sourceforge.  It works quite well, and
development should continue.  There is no reason that it shouldn't ship by
default with designer.  There may be some extra work involved getting it
working on windows, however.

QDataRelationship
-----------------
 - links multiple data-aware controls based on a QSqlRelation

Foreign Key Lookups
-------------------

This may fall under QSqlRelation.  However, there may be room for a
separate API which allows automatic foreign key lookups.  Maybe just for
Designer....

Additional Data-Aware Widgets
-----------------------------

These should include things like a data-aware listbox (probably for
automatic foreign key lookups).  Also, automatic 'one field' controls would
be nice, like drop-down listboxes with automatic editing capabilities.

configure
---------

configure should auto-detect installed client libraries and automatically
configure the make process for drivers.

Future Designer Features
========================

Importing
---------

Indexes should be imported from database and relationships among tables
should be automatically deduced.  

Editing
-------

There should be a table and relationship editor.  The table editor will
define relationships among tables, edit generated cursor code for each
table, etc.  Tables can be linked together, etc.  Probably use QCanvas for
this?

UIC
---

uic should generate separate files for cursors, relationships
