@Chapter
    @Title { Creating Database Applications }
    @Tag { creating.database.applications }
@Begin
@LP
This chapter shows you how to use Qt's data-aware widgets from
databases @Index{ Databases } sql @Index{ SQL } within @QDR. It
demonstrates @Code{INSERT}, @Code{UPDATE} and @Code{DELETE} in both
@Class{QDataTable}qdatatable @Index{ QDataTable }s (tables) and
@Class{QDataBrowser}qdatabrowser @Index{ QDataBrowser }s (forms). It
also shows how to code Master-Detail relationships and Drilldown. A
simple approach to foreign key handling is presented here; a more
sophisticated approach is shown in the online SQL module
documentation.

@LP
If you wish to run the examples or create your own applications
databases @RawIndex{ Databases }
databases.drivers @SubIndex{ Drivers }
qodbc.database.driver @Index{ QODBC3, Database driver }
qoci.database.driver @Index{ QOCI8, Database driver }
qpsql.database.driver @Index{ QPSQL7, Database driver }
qmysql.database.driver @Index{ QMYSQL3, Database driver }
databases @RawIndex{ Databases }
drivers.qodbc @SubSubIndex{ QODBC3 }
databases @RawIndex{ Databases }
drivers.qoci @SubSubIndex{ QOCI8 }
databases @RawIndex{ Databases }
drivers.qpsql @SubSubIndex{ QPSQL7 }
databases @RawIndex{ Databases }
drivers.qmysql @SubSubIndex{ QMYSQL3 }
using these widgets you need access to an SQL database and a
Qt database driver that can connect to the database. At the time
of writing the drivers that Qt supports are QODBC3 (Open Database
Connectivity), QOCI8 (Oracle), QPSQL7 (PostgreSQL 6 and 7) and
QMYSQL3 (MySQL).

@LP
Although you can use the Qt data-aware widgets to browse and
widgets @RawIndex{ Widgets }
widgets.data.aware @SubIndex{ Data Aware }
data.aware.widgets @Index{ Data Aware Widgets }
databases @RawIndex{ Databases }
databases.data.aware.widgets @SubIndex{ Data Aware Widgets }
edit data in SQL databases without having to write any SQL, a
basic understanding of SQL is highly recommended. We assume that
you have some familiarity with @Code{SELECT}, @Code{INSERT},
@Code{UPDATE} and @Code{DELETE} statements. We
also assume a basic understanding of the concepts of normalisation
and of primary and foreign keys. A standard text covering SQL
databases is @I{An Introduction to Database Systems (7th ed.)}
by C. J. Date, ISBN 0201385902.

@Figure
    @Caption { 
@I{The Book Application} }
 0.45 @Scale @IncludeGraphic { "images/book-main.eps.gz" }

In the following text we describe the creation of a 'book' database
in.place.editing @Index{ In-place Editing } databases @RawIndex{
Databases } databases.in.place.editing @SubIndex{ In-place Editing }
application. The application demonstrates how to use
@Class{QDataTable}qdatatable @Index{ QDataTable }s including in-place
record editing and how to set up master-detail relationships between
@Class{QDataTable}qdatatable @Index{ QDataTable }s. It also explains
how to drill down from a @Class{QDataTable}qdatatable @Index{
QDataTable } to another widget, for example, to a
@Class{QDataBrowser}qdatabrowser @Index{ QDataBrowser } or a
@Class{QDataView}qdataview @Index{ QDataView } and how to perform
record editing in a @Class{QDataBrowser}qdatabrowser @Index{
QDataBrowser }. A great deal of functionality is available from the
classes directly in @QDR although subclassing is always available for
finer control. If you want to build the 'book' examples you will need
to create the example schema on your database.
@LP
{ The Example Schema} @Sidebar {
Note that the examples in this chapter all use the tables, views and
records which are defined in the
@File{"qt/tools/designer/examples/book/book.sql"} file. This file has
been tested with PostgreSQL 6 and PostgreSQL 7. You may need to modify
the SQL in this file to recreate the example database on your own
system.
@SidebarPP
Schema @Code{CREATE TABLE} Statements
@LD @Code @RawVerbatim @Begin
    CREATE TABLE author (
        id integer primary key,
        forename varchar(40),
        surname varchar(40)
    );
    CREATE TABLE book (
        id integer primary key,
        title varchar(40),
        price numeric(10,2),
        authorid integer,
        notes varchar(255)
    );
    CREATE TABLE sequence (
        tablename varchar(10),
        sequence numeric
    );
@End @RawVerbatim
The 'book' table is simplified for the purposes of the example.
It can only relate a book to a single author (authorid) and lacks
an ISBN field. The 'sequence' table is used for generating unique
index values for the example tables. Note that SQL databases
often provide their own method for creating sequences (for example,
using the @Code{CREATE SEQUENCE} command) which is very
likely to be a more optimal solution. For the sake of portability
the examples will use a 'sequence' table which will work with
the vast majority of SQL databases.
}
@BeginSections
@Section
    @Title { Setting Up Database Connections }
    @Tag { setting.up.database.connections }
@Begin
@LP
There are two aspects of database connections that we must consider.
databases @RawIndex{ Databases }
databases.connecting.to.database.servers @SubIndex{ Connecting to Database Servers }
connecting @RawIndex{ Connecting }
connecting.databases.to.database.servers @SubIndex{ Databases to Database Servers }
Firstly the connection we wish to use within @QDR
itself, and secondly the connection we wish to use in the applications
that we create.

@BeginSubSections
@SubSection
    @Title { Setting Up Qt Designer's Connections }
    @Tag{setting.up.qt.designer.s.connections}
@Begin
@LP
Choose @Option{Project"|"Database Connections} from the menu bar.
The @Win{Database Connections} dialog will appear. Click @B{New
Connection}. For applications that use a single database it will
probably be most convenient to use the default connection name
of '(default)'. If you use more than one database then each one
must be given a unique name. A driver must be chosen from the
Driver combo box. The database name may be available in the Database
Name combo box or may have to be typed in. The database name,
username, password and hostname should be provided by your database
system administrator. When the Connection information has been
completed click @Option{Connect}. If the connection is made the connection
name will appear in the list box on the left hand side of the
dialog. You can now close the dialog; the connection settings
will remain in effect until you change or delete them or exit
from @QDR.

@Figure
    @Caption { @I{Database Connections Dialog} }
 0.45 @Scale @IncludeGraphic { "images/database-connections.eps.gz" }
@LP
@QDR can remember database connection settings in
projects @RawIndex{ Projects }
projects.database.connections @SubIndex{ Database Connections }
@File{"qmake"} project files. Create a new project, e.g.
click @Option{File"|"New}, then click the '@Cpp Project' icon to invoke
the @Win{Project Settings} dialog. Click the ellipsis button to
invoke the @Win{Save As} dialog; navigate to the project's directory
(creating it if necessary). Make sure you're in the project's
directory, then enter a project name of 'book.pro'. Click the
@Option{Save} button to return to the @Win{Project Settings} dialog,
then click @OK. Next time you start @QDR instead
of opening individual @File{".ui"} files open the @File{".pro"}
project file instead and @QDR will automatically reload
the project's connection settings. To activate the connection
click @Option{Project"|"Database Connections}. The connections previously
saved with the project will be listed in the left hand list box.
Click the connection you wish to use and then click @Option{Connect}.
This connection will be used from now on, e.g. for previewing
@Class{QDataTable}qdatatable @Index{ QDataTable }s. Opening a project file also causes @QDR
to load in the list of forms associated with the project into
the Form List window. In most of the explanation that follows
we will assume that you use project files and have clicked @Option{Connect}
so that there is always a connection available when you work
in @QDR.

@End @SubSection
@SubSection
    @Title { Setting Up Connections for Applications }
    @Tag{setting.up.connections.for.applications}
@Begin
@LP
The applications you create must make their own connections to
the SQL database. We provide an example function, @Func{createConnections()},
createconnections @Index{ createConnections() }
qsqldatabase @Index{ QSqlDatabase }
qpsql @Index{ QPSQL7 }
that you can use as a basis for your own code.
@LD @Code @RawVerbatim @Begin
    bool createConnections()
    {
        // create the default database connection
        QSqlDatabase *defaultDB = QSqlDatabase::addDatabase( "QPSQL7" );
@End @RawVerbatim
@LD @Code @RawVerbatim @Begin
        if ( ! defaultDB ) {
            qWarning( "Failed to connect to driver" );
            return FALSE;
        }
        defaultDB->setDatabaseName( "book" );
        defaultDB->setUserName( "bookuser" );
        defaultDB->setPassword( "bookpw" );
        defaultDB->setHostName( "bookhost" );
        if ( ! defaultDB->open() ) {
            qWarning( "Failed to open books database: " +
                      defaultDB->lastError().driverText() );
            qWarning( defaultDB->lastError().databaseText() );
            return FALSE;
        }
    
        return TRUE;
    }
@End @RawVerbatim
@LP
We call @Func{addDatabase()} passing it the name of the adddatabase
@Index{ addDatabase() } driver we wish to use. We then set the
connection information by calling the @Code{set}... functions. Finally
we attempt to open the connection. If we succeed we return @TRUE,
qapplication @Index{ QApplication }
otherwise we output some error information and return @FALSE.
@LD @Code @RawVerbatim @Begin
    int main( int argc, char *argv[] )
    {
        QApplication app( argc, argv );

        if ( ! createConnections() )
            return 1;
@End @RawVerbatim
@LD @Code @RawVerbatim @Begin
        BookForm bookForm;
        app.setMainWidget( &bookForm );
        bookForm.show();

        return app.exec();
    }
@End @RawVerbatim
@Filename{"qt/tools/designer/examples/book/book1/main.cpp"}
/0.1vx
@LP
All the examples presented in this chapter call
@Func{createConnections()} databases @RawIndex{ Databases }
databases.connecting.to.multiple.database.servers @SubIndex{
Connecting to Multiple Database Servers } createconnections @Index{
createConnections() } main.cpp @Index{ main.cpp } adddatabase @Index{
addDatabase() } after creating the @Class{QApplication}qapplication
@Index{ QApplication } object in their @File{"main.cpp"} file and make
use of the default connection. If you need to connect to multiple
databases use the two-argument form of @Func{addDatabase()}, passing
it both the name of the driver and a unique identifier. This is
explained further in the Qt SQL Module documentation.

@LP
You do not need to keep a reference to database connections.
qsqldatabase.database @Index{ QSqlDatabase::database() }
If you use a single database connection, this becomes the default
connection and database functions will use this connection automatically.
We can always get a pointer to any of our connections by calling
@Func{QSqlDatabase::database()}.

@LP
If you create a @File{"main.cpp"} file using @QDR,
this file will @I{not} include @Func{createConnections()}.
We do not include this function because it needs the username
and password for the database connection, and you may prefer
to handle these differently from our simple example function.
As a result, applications that preview correctly in @QDR
will not run unless you implement your own database connections
function.

@End @SubSection
@EndSubSections
@End @Section
@Section
    @Title { Using QDataTable }
    @Tag { using.qdatatable }
@Begin
@LP
@Class{QDataTable}qdatatable @Index{ QDataTable }s may be placed on
any form to provide browsing of database tables and views.
@Class{QDataTable}qdatatable @Index{ QDataTable }s can also be used to
update or delete records in-place, i.e. inside the cells themselves.
Inserting records via a @Class{QDataTable}qdatatable @Index{
QDataTable } usually requires connecting to the
primeinsert @Index{ primeInsert() } @Func{primeInsert()} signal, so
that we can generate primary keys for example, or provide default
values. If we wish to present records using a form view (perhaps
combining data from several tables and views) we might use several
@Class{QDataBrowser}s and @Class{QDataView}s.

@BeginSubSections
@SubSection
    @Title { Quickly Viewing a Database Table }
    @Tag{quickly.viewing.a.database.table}
@Begin
@LP
This example, along with all the other examples in this chapter, has
the project name 'book' and uses the database created by the book.sql
@Index{ book.sql } @File{"book.sql"} script. As we work through the
chapter we will build the 'book' application step by step. Create or
copy the @File{"qt/tools/designer/"} @File{"examples/book/book1/main.cpp"} file
shown earlier. The project file for this first example is
@File{"qt/tools/designer/examples/book/book1/book.pro"}. Start a new
project by clicking @Option{File"|"New}, then click the '@Cpp Project'
icon to invoke the @Win{Project Settings} dialog. Click the ellipsis
button to invoke the @Win{Save As} dialog; navigate to the project's
directory (creating it if necessary). Make sure you're in the
project's directory, then enter a project name of 'book.pro'. Click
the @Option{Save} button to return to the @Win{Project Settings}
dialog, then click @OK. Now click @Option{Project"|"Database
Connections}. Fill in the connection information appropriate to your
database then press @Option{Connect}. The connection name should now
appear in the left hand list box. (If this doesn't happen you'll need
to contact your database systems administrator for help.) Close the
dialog.

@LP
We will now create a new form with a @Class{QDataTable}qdatatable
@Index{ QDataTable } that's connected to one of our database tables.

@LP
Click @Option{File"|"New}. The @Win{New File} dialog presents us with
a number of form templates to choose from. Choose the 'Dialog'
form and click @OK. Now click @Option{File"|"Save}. You will be
prompted for a filename, call it @File{"book.ui"}.

@BeginSubSubSections
@SubSubSection
    @Title { Setting up a QDataTable}
    @Tag{setting.up.a.qdatatable}
@Begin
@LP
To place a @Class{QDataTable}qdatatable @Index{ QDataTable } widget on
the form either click @Option{Tools"|"Views"|"QDataTable} databases
@RawIndex{ Databases } databases.sql.table.wizard @SubIndex{ SQL Table
Wizard } wizards @RawIndex{ Wizards } wizards.sql.table @SubIndex{ SQL
Table } or click the @Class{QDataTable}qdatatable @Index{ QDataTable }
toolbar button. Click on the form and the SQL Table Wizard will
appear.

@NumberedList
@LI{
The @Win{Database Connection and Table} wizard page is used to
set up a connection if one doesn't exist and to choose the table
or view for the @Class{QDataTable}qdatatable @Index{ QDataTable }.
(See @NamePageRef{setting.up.qt.designer.s.connections}.)
@LP
Click the connection you wish to use, listed in the left hand
list box, e.g. "\""(default)"\"". The available tables and views will
appear in the right hand Table list box. Click the 'author' table
and then click the @Option{Next} button.
}
@LI{
The @Win{Displayed Fields} wizard page provides a means of selecting
which fields should be displayed in the @Class{QDataTable}qdatatable
@Index{ QDataTable } and in what order. By default all fields except
the primary key (if there is one) are in the Displayed Fields
[p.~@PageOf{displayed.fieldsxx}] list box. The left- and
right-pointing blue arrow buttons can be used to move fields between
the Displayed Fields and the
Available Fields list boxes. The blue up and down pointing arrow
buttons are used to select the display order of the displayed fields.
@LP
The default settings are the ones we want so simply click @Option{Next}.
}
@LI{
The @Win{Table Properties} wizard page provides convenient access
properties @RawIndex{ Properties } properties.datatable @SubIndex{
DataTable } to some of the database-related properties of the
@Class{QDataTable}qdatatable @Index{ QDataTable }.
@LP
Make sure the Confirm Deletes checkbox is checked, then click
@Option{Next}.
}
@LI{
The @Win{SQL} wizard page is used to set the
@Class{QDataTable}qdatatable @Index{ QDataTable }'s Filter and Sort
properties. The Filter is an SQL @Code{WHERE} clause (without the word
'WHERE'). For example, to only list authors whose surnames begin with
'P', we would enter @Code{title LIKE 'P%'}. We'll leave the filter
empty. The Available Fields list box lists all the fields. The Sort By
list box lists the fields that the @Class{QDataTable}qdatatable
@Index{ QDataTable } is to sort by and the direction of their sorting
(ASCending or DESCending). The left and right blue arrows are used to
move fields between the two list boxes. The up and down blue arrows
move fields up and down within the Sort By list box. The ASC or DESC
setting is changed with the 'sort order' toolbar button.
@LP
Move the surname and forename fields into the Sort By list box
and click @Option{Next}.
}
@LI{
The @Win{Finish} wizard page gives us the opportunity to go back and
change any of our settings. We will be able to change them later
through the @Class{QDataTable}qdatatable @Index{ QDataTable }'s
properties so we can finish with the wizard.
@LP
Click @Option{Finish}.
}
@EndList

The table will appear on the form with each column labelled with a
default column name. If you wish to change the settings then most of
them are available in the property window. The display names, the
fields they are based upon, and the order of appearance of the columns
can be changed using the @Win{Edit Table} dialog (explained later) by
right clicking the @Class{QDataTable}qdatatable @Index{ QDataTable }
and left clicking @Option{Edit}.

@End @SubSubSection
@SubSubSection
    @Title { Laying out the Form }
    @Tag{laying.out.the.form}
@Begin
@LP
Click on the form and click the @Option{Lay Out Vertically} toolbar
button. Now click @Option{Preview"|"Preview Form}; the form will run
and the table will automatically display all the records.

@LP
To turn the form we've created into an executable application we must
add the main.cpp @Index{ main.cpp } @File{"main.cpp"} file to the
project file and make the project. We should also do some renaming to
make things easier to understand.
@NumberedList
@LI{
Click on the form and change its name to 'BookForm' and its caption
to 'Book'. Click on the @Class{QDataTable}qdatatable @Index{ QDataTable } and change its name to
'AuthorDataTable'.
}
@LI{
Click @Option{File"|"Save All}.
}
@LI{
Open the project file, e.g. book.pro @Index{ book.pro }
@File{"book.pro"}, in a plain text editor and add the line:
@LD @Code @RawVerbatim @Begin
    SOURCES += main.cpp
@End @RawVerbatim
at the end of the file.}
@LI{
Run @File{"qmake"} to generate the make file, e.g. @Code{qmake -o
Makefile book.pro}, then make and run the @File{"book"} program.
}
@EndList
This example shows how easy it is to use @Class{QDataTable}qdatatable
@Index{ QDataTable } to show the contents of a database table or view.
You can use the application we've just built to update and delete
author records. In the examples that follow we will cover insertions,
setting up master-detail relationships, drilldown and foreign key
lookups.
@LP
{ A Note on Foreign Keys} @Sidebar {
In most relational databases tables contain fields which are
foreign.keys @Index{ Foreign Keys }
databases @RawIndex{ Databases }
databases.foreign.keys @SubIndex{ Foreign Keys }
foreign keys into other tables. In our 'book' database example
the authorid in the book table is a foreign key into the author
table. When we present a form to the end user we do not usually
want the foreign key itself to be visible but rather the text
associated with it. Thus, we would want the author's name to
appear rather than the author id when we show book information.
In many databases, this can be achieved by using a view. See
your database's documentation for details.

}
@End @SubSubSection
@EndSubSubSections
@End @SubSection
@SubSection
    @Title { Inserting Records in QDataTables}
    @Tag{inserting.records.in.qdatatables}
@Begin
@LP
Record insertion into a relational database usually requires
inserting.records @Index{ Inserting Records } databases @RawIndex{
Databases } databases.inserting.records @SubIndex{ Inserting Records }
the generation of a primary key value which uniquely identifies the
record in the table. Also we often want to create default values for
some fields to minimize the user's work. We will create a slot to
capture the @Class{QDataTable}qdatatable @Index{ QDataTable }s
primeinsert @Index{ primeInsert() } @Func{primeInsert()} signal and
populate the @Class{QSqlRecord} insertion buffer with a unique primary
key.
@NumberedList
@LI{
Click @Option{Edit"|"Slots} to invoke the @Win{Edit Slots} dialog. Click
@Option{New Slot}, then enter the slot name @Func{primeInsertAuthor(QSqlRecord*)}
into the Slot Properties' Slot line edit box. Click @OK.
}
@LI{
Click the @Option{Connect Signals"/"Slots} toolbar button, then click
the AuthorDataTable, drag to the form and release the mouse.
The @Win{Edit Connections} dialog will now appear. Click the
primeinsert @Index{ primeInsert() } @Func{primeInsert()} signal and then the @Func{primeInsertAuthor()} slot to make the connection. Now click @OK.}
@LI{
Click the Source tab of the Object Hierarchy window (click @B{Window"|"Object
Hierarchy} to make the window visible if necessary). Click the
@Func{primeInsertAuthor()} slot and an editor window will
appear.
}
@LI{
We must change the @Func{BookForm::primeInsertAuthor()}
slot to specify the parameter name and perform the necessary
qsqlrecord @Index{ QSqlRecord }
qsqlquery @Index{ QSqlQuery }
action:
@LD @Code @RawVerbatim @Begin
    void BookForm::primeInsertAuthor( QSqlRecord * buffer )
    {
        QSqlQuery query;
        query.exec( "UPDATE sequence SET sequence = sequence + 1 "
                    "WHERE tablename='author';" );
        query.exec( "SELECT sequence FROM sequence "
                    "WHERE tablename='author';" );
        if ( query.next() ) {
            buffer->setValue( "id", query.value( 0 ) );
        }
    }
@End @RawVerbatim
A @Class{QSqlQuery}qsqlquery @Index{ QSqlQuery } object is used to
increment and retrieve a unique 'sequence' number for the author
table. The signal passed us a pointer to the insertion buffer and we
then put the value we've retrieved, i.e. the next sequence number,
into the buffer's id field. (Again, note that SQL databases often
support a native 'sequence' function. The method used here is
inappropriate for production systems, and is for example purposes
only. See your database's documentation for details on how to generate
unique keys in code. In many cases, the database can generate them
automatically, or the database may provide a special syntax for
dealing with sequences.)
}
@EndList

If we rebuild the application it will now support @Code{INSERT}
deleting @RawIndex{ Deleting } records.databases @SubSubIndex{
Databases } databases @RawIndex{ Databases }
databases.deleting.records @SubIndex{ Deleting Records }
updating.records @Index{ Updating Records } databases @RawIndex{
Databases } databases.updating.records @SubIndex{ Updating Records }
as well as @Code{UPDATE} and @Code{DELETE}. We could easily have added
additional code to insert default values, e.g. today's date into a
date field, if necessary.

@LP
Browsing is supported by clicking records and by using the arrow
databases @RawIndex{ Databases } databases.browsing @SubIndex{
Browsing } databases @RawIndex{ Databases } databases.confirmations
@SubIndex{ Confirmations } browsing.databases @Index{ Browsing
Databases } keys. Once a record is active (highlighted) we can edit
the it. Press the @Option{Insert} key to @Code{INSERT} a new record;
press @Option{F2} to @Code{UPDATE} the current record; press the
@Option{Del} key to @Code{DELETE} the current record. All these
operations take place immediately. Users can be given the opportunity
to confirm their edits by setting the @Class{QDataTable}qdatatable
@Index{ QDataTable }'s confirmEdits property to True. If the
confirmEdits property is True then user confirmation will be required
for all insertions, updates and deletes. For finer control you can set
the confirmInsert, confirmUpdate and confirmDelete properties
individually.

@LP
{ QDataTable User Interface Interaction } @Sidebar {
The default user-interface behaviour for @Class{QDataTable}qdatatable
@Index{ QDataTable }s is as databases @RawIndex{ Databases }
databases.user.interface.interaction @SubIndex{ User Interface
Interaction } user.interface.interaction.databases @Index{ User
Interface Interaction, Databases } follows:
@BulletList
@LI{
Users can move to records by clicking the scrollbar and clicking
records with the mouse. They can also use the keyboard's navigation
keys, e.g. @Option{Left Arrow}, @Option{Right Arrow}, @Option{Up
Arrow}, @Option{Down Arrow}, @Option{Page Up}, @Option{Page Down},
@Option{Home} and @Option{End}.
}
@LI{
@Code{INSERT} is initiated by right-clicking the record
and clicking Insert or by pressing the @Option{Ins} (Insert) key.
The user moves between fields using @Option{Tab} and @Option{Shift+Tab}.
The @Code{INSERT} will take place if the user presses
@Option{Enter} or @Option{Tab}s off the last field. If autoEdit is @TRUE
the insert will take place if the user navigates to another record.
@Code{INSERT} is cancelled by pressing @Option{Esc} (Escape).
If autoEdit is @FALSE navigating to another record also cancels
the @Code{INSERT}. Setting confirmInsert to @TRUE will
require the user to confirm each @Code{INSERT}.
}
@LI{
@Code{UPDATE} is initiated by right-clicking the record
and clicking Update or by pressing @Option{F2}. The update will take
place if the user presses Enter or Tabs off the last field. If
autoEdit is @TRUE the update will take place if the user navigates
to another record. @Code{UPDATE} is cancelled by pressing
@Option{Esc}. If autoEdit is @FALSE navigating to another record also
cancels the @Code{UPDATE}. Setting confirmUpdate to @TRUE
will require the user to confirm each @Code{UPDATE}.
}
@LI{
@Code{DELETE} is achieved by right-clicking the record
and clicking Delete or by pressing the @Option{Del} (Delete) key.
Setting confirmDelete to @TRUE will require the user to confirm
each @Code{DELETE}.
}
@EndList
You can change this default behaviour programmatically if required.
}
@End @SubSection
@SubSection
    @Title { Relating Two Tables Together (Master-Detail)}
    @Tag{relating.two.tables.together.master.detail}
@Begin
@LP
Databases often have pairs of tables that are related. For example,
databases @RawIndex{ Databases } databases.master.detail.relationships
@SubIndex{ Master-Detail Relationships } master.detail.relationships
@Index{ Master-Detail Relationships } an invoice table might list the
numbers, dates and customers for invoices, but not the actual invoice
items, which an invoice item table might store. In the 'book'
application we wish to have a @Class{QDataTable}qdatatable @Index{
QDataTable } that we can use to browse through the authors table and a
second @Class{QDataTable}qdatatable @Index{ QDataTable } to show the
books they've written.

@LP
Open the book project if it isn't already open @QDR. We will modify
this project to show two @Class{QDataTable}qdatatable @Index{
QDataTable }s that relate the author table to the book table.

@NumberedList
@LI{
Click the author @Class{QDataTable}qdatatable @Index{ QDataTable } and then click the @Option{Break Layout}
toolbutton.
}
@LI{
Resize the @Class{QDataTable}qdatatable @Index{ QDataTable } so that it only occupies the top half
of the form.
}
@LI{
Now click on the @Class{QDataTable}qdatatable @Index{ QDataTable }
toolbutton and click on the bottom half of the form. The SQL Table
Wizard will appear. (This Wizard is explained in 
@NamePageRef{quickly.viewing.a.database.table}.)
@List style { 3.num }
@LI{
Click the connection you're using and click the book table. Click
the @Option{Next} button.
}
@LI{
Since we do not want them visible, make sure the authorid and
id fields are moved to the Available Fields list box by using
the arrow buttons. Move the title field to the top of the Displayed
Fields, and move the price field above the notes field. Click
the @Option{Next} button.
}
@LI{
On the Table Properties [p.~@PageOf{table.properties}] page click the Read Only checkbox then
click the @Option{Next} button.
}
@LI{
On the SQL page we will leave the Filter (@Code{WHERE}
clause) empty. Move the title field to the Sort By list box and
click @Option{Next}. Now click @Option{Finish}.
}
@LI{
Change this @Class{QDataTable}qdatatable @Index{ QDataTable }'s name to "\""BookDataTable"\"".
}
@EndList}
@LI{
@Option{Shift+Click} the top @Class{QDataTable}qdatatable @Index{ QDataTable } so that both @Class{QDataTable}qdatatable @Index{ QDataTable }s
are selected and then click the @Option{Lay Out Vertically (in Splitter)}
toolbar button.
}
@LI{
Click on the form and click the @Option{Lay Out Vertically} toolbar
button.
}
@EndList

Preview the form by clicking @Option{Preview"|"Preview Form}. All the
authors are displayed in the top @Class{QDataTable}qdatatable @Index{
QDataTable } and all the books are displayed in the bottom
@Class{QDataTable}qdatatable @Index{ QDataTable }. However we only
want the books of the currently selected author showing in the bottom
@Class{QDataTable}qdatatable @Index{ QDataTable }. We will deal with
this by filtering the records in the book table according to the
author selected in the author table.

@BeginSubSubSections
@SubSubSection
    @Title { Filtering One QDataTable by Another }
    @Tag{filtering.one.qdatatable.by.another}
@Begin
@LP
To filter the book table's records we need to capture the author
databases @RawIndex{ Databases } databases.relating.tables @SubIndex{
Relating Tables } @Class{QDataTable}qdatatable @Index{ QDataTable }'s
currentchanged @Index{ currentChanged() } @Func{currentChanged()}
signal and change the BookDataTable's filter accordingly.
@NumberedList
@LI{
Click @Option{Edit"|"Slots}. In the @Win{Edit Slots} dialog click
@Option{New Slot} and enter a slot name of @Func{newCurrent}- @Func{Author(QSqlRecord*)}.
Click @OK.
}
@LI{
Click @Option{Edit"|"Connections} to invoke the @Win{View and Edit Connections}
dialog. Create a new connection, connecting the AuthorDataTable's
currentChanged() signal to the form's newCurrentAuthor() slot.
Click @OK.
}
@LI{
Click the Source tab of the Object Hierarchy window (click @Option{Window"|"Object Hierarchy} to make the window visible if necessary). Click the
@Func{newCurrentAuthor()} slot and an editor window will
appear.
}
@LI{
We must change the @Func{BookForm::newCurrentAuthor()}
slot to specify the parameter name and perform the necessary
qsqlrecord @Index{ QSqlRecord }
action:
@LD @Code @RawVerbatim @Begin
    void BookForm::newCurrentAuthor( QSqlRecord *author )
    {
        BookDataTable->setFilter( "authorid=" +
                                  author->value( "id" ).toString() );
        BookDataTable->refresh();
    }
@End @RawVerbatim
All that's required now is to change the BookDataTable's filter and
refresh the @Class{QDataTable}qdatatable @Index{ QDataTable } to show
the results of the filter.
}
@EndList
{ Using the Table Editor} @Sidebar {
@CD
@Figure
    @Caption { @I{Edit Table Dialog} }
    @Location { Raw }
    0.45 @Scale @IncludeGraphic { "images/edit-dbtable-dialog.eps.gz" }

@Class{QDataTable}qdatatable @Index{ QDataTable }s are created and set
up using the SQL Table Wizard. value.editors @RawIndex{ Value Editors
} value.editors.sql.table.editor @SubIndex{ SQL Table Editor } Like
any other @QDR widget their properties may be changed in the
Properties window. Some of the column and row based properties can
also be be changed using the @Win{Edit Table} dialog. This dialog is
invoked by right clicking the @Class{QDataTable}qdatatable @Index{
QDataTable } and left clicking the @Option{Edit} menu item. The right
hand half of the @Win{Edit Table} dialog is where we choose the fields
we wish to display, their order and their labels. The procedure for
creating columns is as follows:
@NumberedList
@LI{
Click the @Option{New Column} button.
}
@LI{
Drop down the Field combobox to list the available fields.
}
@LI{
Click the field you wish to include at this point.
}
@LI{
@I{Optionally} edit the Label if the default isn't appropriate.
}
@LI{
@I{Optionally} click the Pixmap ellipsis (@Option{...}) button to
choose a pixmap to be displayed to the left of the column's label.
(The ellipsis button appears when you click in the Value part
of the Properties list by a @Prop{pixmap} or @Prop{iconSet} property.)
}
@EndList

Repeat the steps listed above for each column you wish to add.
Once all the fields have been added you can change their ordering
by using the blue up and down arrow buttons. At any point you
can press @Option{Apply} to see how the table will look. Finally click
the @OK button to save the properties you have set. You can
always return to the table editor to change these settings later.
}
@End @SubSubSection
@SubSubSection
    @Title { Preparing the Interface for Drilldown }
    @Tag{preparing.the.interface.for.drilldown}
@Begin
@LP
We can now browse and edit authors and see their books in the
databases @RawIndex{ Databases } databases.drilldown @SubIndex{
Drilldown } drilldown @Index{ Drilldown } BookDataTable. In the next
section we explore @Class{QDataBrowser}qdatabrowser @Index{
QDataBrowser }, which will allow us to drill down to a dialog through
which we can edit books. For now we will add some buttons to the main
BookForm which we will use to invoke the book editing dialog.
@NumberedList
@LI{
Click the form, then click the @Option{Break Layout} toolbar button.
Resize the form to make room for some buttons at the bottom.
}
@LI{
Add two buttons to the bottom of the form. Change their names
and labels to the following:
@BulletList
@LI{
EditPushButton -- "&"Edit Books
}
@LI{
QuitPushButton -- "&"Quit
}
@EndList
Hold down the Shift key and Click both buttons (i.e. @Option{Shift+Click}
the buttons) and click the @Option{Lay Out Horizontally} toolbar button.
Click the form and click the @Option{Lay Out Vertically} toolbar button.
}
@LI{
We will provide the Quit button with functionality now and work
on the rest shortly. Click @Option{Edit"|"Connections}, then connect
the the Quit button's clicked() signal to the form's accept()
slot. Click @OK.
}
@EndList
@End @SubSubSection
@EndSubSubSections
@End @SubSection
@EndSubSections
@End @Section
@Section
    @Title { Using QDataBrowser and QDataView }
    @Tag { using.qdatabrowser.and.qdataview }
@Begin
@Figure
    @Caption { @I{The Book Application's Edit Books Dialog} }
 0.45 @Scale @IncludeGraphic { "images/book-dialog.eps.gz" }

@BeginSubSections
@SubSection
    @Title { Drilling Down to a Form using QDataBrowser}
    @Tag{drilling.down.to.a.form.using.qdatabrowser}
@Begin
@BeginSubSubSections
@SubSubSection
    @Title { Setting up a QDataBrowser}
    @Tag{setting.up.a.qdatabrowser}
@Begin
@LP
We will now create a new form to allow users to edit book records.
databases @RawIndex{ Databases } databases.drilldown @SubIndex{
Drilldown } drilldown @Index{ Drilldown } databases @RawIndex{
Databases } databases.data.browser.wizard @SubIndex{ Data Browser
Wizard } wizards @RawIndex{ Wizards } wizards.data.browser @SubIndex{
Data Browser } Click the @Option{New} toolbar button, click the Dialog
template from the @Win{New File} dialog and click @OK. Change the name
of the form to EditBookForm and its caption to 'Edit Books'. Click the
@Option{Save} toolbar button and call the file @File{"editbook.ui"}.
Now that we have the form we can add a
@Class{QDataBrowser}qdatabrowser @Index{ QDataBrowser } to show the
book records.
@NumberedList
@LI{
Click the @Option{Data Browser} toolbar button, then click the form.
The Data Browser Wizard [p.~@PageOf{data.browser.wizard}] will appear.
}
@LI{
The @Win{Database Connection and Table} wizard page is used to set up
a connection if one doesn't exist and to choose the table or view for
the @Class{QDataBrowser}qdatabrowser @Index{ QDataBrowser }. (See
@NamePageRef{setting.up.qt.designer.s.connections}.)
@LP
Click the connection you wish to use, listed in the Connection
list box, e.g. "\""(default)"\"". The available tables and views will
appear in the Table list box. Click the book table and then click
the @Option{Next} button.
}
@LI{
The @Win{Displayed Fields} wizard page provides a means of selecting
which fields should be displayed in the
@Class{QDataBrowser}qdatabrowser @Index{ QDataBrowser } and in what
order. By default all fields except the primary key (if there is one)
are in the right hand Displayed Fields
[p.~@PageOf{displayed.fieldsxx}] list box. The left and right blue
arrow buttons can be used to move fields between the Displayed Fields
and the Available Fields list boxes.
The blue up and down arrow buttons are used to select the display
order of the displayed fields.
@LP
We don't want to see the authorid foreign key field on the form,
so move it to the Available Fields list box. Also, move the title
field to the top of the Displayed Fields list. Click the @Option{Next}
button.
}
@LI{
The @Win{Navigation and Editing} wizard page allows us to choose
which navigation and editing buttons should appear on the form.
@LP
We will accept the defaults and simply click the @Option{Next} button.
}
@LI{
The @Win{SQL} wizard page is used to set the
@Class{QDataBrowser}qdatabrowser @Index{ QDataBrowser }'s Filter and
Sort properties. The Filter is an SQL @Code{WHERE} clause (without the
word 'WHERE'). For example, to only list books that cost less than 50
(of some currency, e.g. dollars), we would enter @Code{price < 50}. We
will leave the filter empty. The Available Fields list box lists all
the fields. The Sort By list box lists the fields that the
@Class{QDataBrowser}qdatabrowser @Index{ QDataBrowser } is to sort by
and the direction of their sorting (ASCending or DESCending). The left
and right blue arrows are used to move fields between the two list
boxes. The up and down blue arrows move fields up and down within the
Sort By list box. The ASC or DESC setting is changed with the sort
order button.
@LP
Move the title field into the Sort By list box and click @Option{Next}.
}
@LI{
The @Win{Layout} wizard page is used to specify the initial layout
of the form.
@LP
Change the Number of Columns to 1, then click @Option{Next}. Now click
@Option{Finish}.
}
@LI{
The @Class{QDataBrowser}qdatabrowser @Index{ QDataBrowser } will now
appear on the form. Resize the form to make it smaller. Click the
@Class{QDataBrowser}qdatabrowser @Index{ QDataBrowser } then click the
@Option{Break Layout} toolbar button. Click the buttons then click the
@Option{Break Layout} toolbar button. Add another button called
'PushButtonClose' with the text '"&"Close' and place it to the right
of the Delete button.
}
@LI{
@Option{Shift+Click} the Insert, Update, Delete and Close buttons,
then click the @Option{Lay Out Horizontally} toolbar button. Click the
@Class{QDataBrowser}qdatabrowser @Index{ QDataBrowser }, then click
the @Option{Lay Out in a Grid} toolbar button. Finally click the form
and click the @Option{Lay Out Vertically} toolbar button. Now click
the @Class{QDataBrowser}qdatabrowser @Index{ QDataBrowser } and rename
it 'BookDataBrowser'.
}
@LI{
@QDR will generate the necessary code to make the browser operational
(including generating the appropriate cursor, sort and filter code).
@LP
For finer control over the form, we will be creating our own
database cursor. Therefore, set the BookDataBrowser's frameworkCode
property to @FALSE in the Properties window to prevent @QDR
from generating redundant code for the cursor.
}
@EndList
@LP
{ QDataBrowser User Interface Interaction } @Sidebar {
The user-interface behaviour for @Class{QDataBrowser}qdatabrowser
@Index{ QDataBrowser }s is created by connecting slots and signals.
The slots provided are:
@BulletList
@LI{
@Func{insert()},
update @Index{ update() } @Func{update()} and
insert @Index{ insert() }
del @Index{ del() } @Func{del()} for editing;}
@LI{
@Func{first()},
first @Index{ first() }
next @Index{ next() } @Func{next()},
prev @Index{ prev() } @Func{prev()}, and
last @Index{ last() } @Func{last()} for navigation;}
@LI{
@Func{refresh()} refresh @Index{ refresh() }to refresh the cursor from
the database;}
@LI{
@Func{readFields()} to read data from the cursor's edit buffer and
readfields @Index{ readFields() } writefields @Index{ writeFields() }
@Func{writeFields()} to write the form's data to the cursor's edit
buffer;} 
@LI{ 
@Func{clearValues()} clearvalues @Index{ clearValues() } to clear the form's values.}
@EndList

If you use @QDR's @Class{QDataBrowser}qdatabrowser @Index{ QDataBrowser } wizard you will
be given the option of creating a default set of buttons for
navigation and editing. The behaviour of these buttons is set
up using the slots described above to provide the following functionality:

@BulletList
@LI{
@Code{INSERT} is initiated by pressing the @Option{Ins} (Insert)
key. The user moves between fields using @Option{Tab} and @Option{Shift+Tab}.
If the user presses the Update button the @Code{INSERT}
will take place and the user will be taken to the record they
have just inserted. If the user presses the Insert button (i.e.
a second time) the @Code{INSERT} will take place and a
new insertion will be initiated. If autoEdit is @TRUE the @Code{INSERT}
will take place if the user navigates to another record. @Code{INSERT}
is cancelled by pressing the @Option{Esc} key or by pressing the @Option{Del}
(Delete) key. If autoEdit is @FALSE then navigating to another
record also cancels the @Code{INSERT}. Setting confirmInsert
to @TRUE will require the user to confirm each @Code{INSERT}.
}
@LI{
@Code{UPDATE} is automatically initiated whenever the
user navigates to a record. An update will take place if the
user presses the Update button. If autoEdit is @TRUE the update
will take place if the user navigates to another record. @Code{UPDATE}
is cancelled by pressing the @Option{Esc} key or by pressing the @Option{Del}
button. If autoEdit is @FALSE then navigating to another record
also cancels the @Code{UPDATE}. Setting confirmUpdate
to @TRUE will require the user to confirm each @Code{UPDATE}.
}
@LI{
@Code{DELETE} is achieved by pressing the @Option{Del} key.
Setting confirmDelete to @TRUE will require the user to confirm
each @Code{DELETE}.
}
@EndList
}
@End @SubSubSection
@EndSubSubSections
@End @SubSection
@SubSection
    @Title { Performing the Drilldown }
    @Tag{performing.the.drilldown}
@Begin
@LP
We now have a working form for editing book records. We need
databases @RawIndex{ Databases }
databases.drilldown @SubIndex{ Drilldown }
drilldown @Index{ Drilldown }
to start the form when the user clicks our 'Edit Books' button,
and to navigate to the record they have selected in the BookDataTable.
We also need to provide a means of editing the foreign keys,
e.g. authorid.

@NumberedList
@LI{
We need to make a new slot to connect the Edit Books' button's clicked
@Index{ clicked() } @Func{clicked()} signal to. Click on the Book form
to make it @QDR's active form. Invoke the @Win{Edit Slots} dialog and
create a new slot called @Func{editClicked()}. Now click
@Option{Edit"|"Connections}. Connect the Edit Books button's clicked()
signal to the form's editClicked() slot. Clicked() slot. Click @OK to
leave the dialog. object.hierarchy @Index{ Object Hierarchy }}
@LI{
In the Object Hierarchy window click Source and then click the
@Func{editClicked()} function. We need to change it to the
qsqlcursor @Index{ QSqlCursor }
qsqlindex @Index{ QSqlIndex }
following:
@LD @Code @RawVerbatim @Begin
    void BookForm::editClicked()
    {
        EditBookForm *dialog = new EditBookForm( this,
                                                 "Edit Book Form",
                                                 TRUE );
        QSqlCursor cur( "book" );
        dialog->BookDataBrowser->setSqlCursor( &cur );
        dialog->BookDataBrowser->setFilter( BookDataTable->filter() );
        dialog->BookDataBrowser->setSort(QSqlIndex::fromStringList(
            BookDataTable->sort(), &cur ) );
        dialog->BookDataBrowser->refresh();
        int i = BookDataTable->currentRow();
        if ( i == -1 ) i = 0; // Always use the first row
        dialog->BookDataBrowser->seek( i );
        dialog->exec();
        delete dialog;
        BookDataTable->refresh();
    }
@End @RawVerbatim
We create our dialog as before. We also create a cursor over the book
table and set the dialog's @Class{QDataBrowser}qdatabrowser @Index{
QDataBrowser }, BookDataBrowser, to use this new cursor. We set the
@Class{QDataBrowser}qdatabrowser @Index{ QDataBrowser }'s filter and
sort to those that applied to the main form's book
@Class{QDataTable}qdatatable @Index{ QDataTable }. We refresh the
@Class{QDataBrowser}qdatabrowser @Index{ QDataBrowser } and seek to
the same record the user was viewing on the main form. Then we exec
the dialog and delete it when the user has finished with it. Finally
we update the BookDataTable in the main form to reflect any changes
that were made in the dialog.
}
@LI{
Because our code refers to a class declared in @File{"editbook.h"} and
to a @Class{QDataBrowser}qdatabrowser @Index{ QDataBrowser } we need
to add two additional include files. Click on the BookForm, then click
on the Source tab of the Object Hierarchy window. Right click the
'Includes (In Declaration)' item and click New. Type in
@File{"editbook.h"}. Now add a second include, this time,
@File{<qdatabrowser.h>}.
}
@EndList
Now when we navigate through the author and book records in the
BookForm we can click the Edit Books button to launch our Edit Books
dialog. Although the dialog supports @Code{UPDATE}, @Code{DELETE} and
navigation over the book table, we cannot edit the foreign keys nor
perform inserts. We will deal with insertion in the same way as we did
with the @Class{QDataTable}qdatatable @Index{ QDataTable }, then we
will handle the foreign key relationship to author.

@End @SubSection
@SubSection
    @Title { Inserting into a QDataBrowser}
    @Tag{inserting.into.a.qdatabrowser}
@Begin
@LP
We will create a slot to receive the Edit Books form's primeinsert
@Index{ primeInsert() } @Func{primeInsert()} signal so that we can
insert a unique primary key.
@NumberedList
@LI{
Click on the Edit Books form, then create a new Slot called 
@Func{primeInsertBook(QSqlRecord*)}.
@LP
Click @Option{Edit"|"Slots}, then click the @Option{New Slot} button and
type the new slot name in the Slot Properties Slot edit box.
Click @OK.
}
@LI{
Connect the BookDataBrowser's
primeinsert @Index{ primeInsert() } @Func{primeInsert()} signal to the @Func{primeInsertBook()} slot.
@LP
Click the @Option{Connect Signals"/"Slots} toolbar button, then click
the BookDataBrowser and drag to the form; release the mouse on
the form. Now click the
primeinsert @Index{ primeInsert() } @Func{primeInsert()} signal and the primeInsertBook slot. Click @OK.}
@LI{
In the Object Hierarchy window click Source and then click the
@Func{primeInsertBook()} slot. We need to change it to the
qsqlrecord @Index{ QSqlRecord }
qsqlquery @Index{ QSqlQuery }
following:
@LD @Code @RawVerbatim @Begin
    void EditBookForm::primeInsertBook( QSqlRecord * buffer )
    {
        QSqlQuery query;
        query.exec( "UPDATE sequence SET sequence = sequence + 1 "
                    "WHERE tablename='book';" );
        query.exec( "SELECT sequence FROM sequence WHERE tablename='book';" );
        if ( query.next() ) {
            buffer->setValue( "id", query.value( 0 ) );
        }
    }
@End @RawVerbatim
}
@LI{
We will also tidy up the user interface slightly. Click the Update
clicked @Index{ clicked() }
accept @Index{ accept() } 
button and set its default property to True. Connect the Close
button's @Func{clicked()} signal to the EditBookForm's
@Func{accept()} slot.
}
@EndList
@End @SubSection
@SubSection
    @Title { Handling Foreign Keys in a QDataBrowser}
    @Tag{handling.foreign.keys.in.a.qdatabrowser}
@Begin
@LP
Qt's SQL module provides two approaches to dealing with foreign
foreign.keys @Index{ Foreign Keys }
databases @RawIndex{ Databases }
databases.foreign.keys @SubIndex{ Foreign Keys }
keys. The most powerful and flexible approach is to subclass
widgets and use property maps to relate the widgets to the database.
This approach is described in the Qt SQL Module documentation,
particularly the StatusPicker example. A simpler approach that
can be taken wholly within @QDR is presented here.

@LP
We will add a new field to the EditBookForm so that authors can
be edited along with the title and price. Once we've handled
the visual design we'll write the code to make it all work.

@NumberedList
@LI{
First we'll add the new widgets. Click the BookDataBrowser and
click the @Option{Break Layout} toolbar button. Resize the form to
make it larger and drag each set of buttons down to make some
room below the title and price QLineEdits. Click the @B{Text
Label} toolbar button and click on the form beneath the Price
label. Click the @I{Text Label} and change its text to 'Author'.
Click the @Option{ComboBox} toolbar button and click on the form beneath
the price QLineEdit. In the Property Window change the @I{ComboBox}'s
@Prop{name} to ComboBoxAuthor and change its @Prop{sizePolicy} @Prop{hSizeType}
to Expanding.
}
@LI{
Now we'll lay out the dialog. @Option{Shift+Click} the Author label
and the @I{ComboBox} then click the @Option{Lay Out Horizontally}
toolbar button. Now click the BookDataBrowser and click the @B{Lay
Out in a Grid} toolbar button.
}
@EndList
We need to write some code so that the @I{ComboBox} will be populated
with author names and scroll to the current book's author. We
also need to ensure that we put the author's id into the book
table's authorid field when a book record is inserted or updated.
We'll ensure the code is executed at the right time by putting
it in slots and connecting signals to our slots.

@NumberedList
@LI{
Create two new slots called @Func{beforeUpdateBook(QSqlRecord *buffer)}
and @Func{primeUpdate}- @Func{Book(QSqlRecord *buffer)}. (Click
@Option{Edit"|"Slots}, then in the @Win{Edit Slots} dialog click New
Slot and enter the first new slot. Click New Slot again and enter the
second slot then click @OK.)
}
@LI{
When the user navigates through the dialog, each time they move to a
new record, a primeupdate @Index{ primeUpdate() } @Func{primeUpdate()}
signal is emitted. We connect to this so that we can update the
@I{ComboBox}'s display. Just before a record is updated or inserted
into the database a beforeupdate @Index{ beforeUpdate() }
@Func{beforeUpdate()} or beforeinsert @Index{ beforeInsert() }
@Func{beforeInsert()} signal is emitted. We connect our
@Func{beforeUpdateBook()} slot to both these signals so that we can
ensure that the book's authorid field is correctly populated.
@LP
Click the BookDataBrowser and drag the mouse to the form; release the
mouse and the @Win{Edit Connections} dialog will appear. Connect the
beforeupdate @Index{ beforeUpdate() } @Func{beforeUpdate()} signal to
our @Func{beforeUpdateBook()} slot. Connect the beforeinsert @Index{
beforeInsert() } @Func{beforeInsert()} signal to our
@Func{beforeUpdateBook()} slot. Finally connect the primeupdate
@Index{ primeUpdate() } @Func{primeUpdate()} signal to our
@Func{primeUpdateBook()} slot.}
@LI{
All that remains is to write the underlying code. All the code
snippets are taken from
@File{"qt/"} @File{"tools/designer/examples/book/book7/editbook.ui"}.
@List style { 3.num }
@LI{
We start with the init @Index{ init() } @Func{init()} function; this
is called after the dialog is constructed and we will use it to
qsqlquery @Index{ QSqlQuery }
populate the @I{ComboBox} with author names.
@LD @Code @RawVerbatim @Begin
    void EditBookForm::init()
    {
        QSqlQuery query( "SELECT surname FROM author ORDER BY surname;" );
        while ( query.next() )
            ComboBoxAuthor->insertItem( query.value( 0 ).toString());
    }
@End @RawVerbatim
Here we execute a query to get a list of author names and insert
each one into the @I{ComboBox}.
}
@LI{
We next write the code which will be executed just before a record
qsqlrecord @Index{ QSqlRecord }
qsqlquery @Index{ QSqlQuery }
is updated (or inserted) in the database.
@LD @Code @RawVerbatim @Begin
    void EditBookForm::beforeUpdateBook( QSqlRecord * buffer )
    {
        QSqlQuery query( "SELECT id FROM author WHERE surname ='" +
            ComboBoxAuthor->currentText() + "';" );
        if ( query.next() )
            buffer->setValue( "authorid", query.value( 0 ) );
    }
@End @RawVerbatim
We look up the id of the @I{ComboBox}'s current author and place
it in the update (or insert) buffer's authorid field.
}
@LI{
As the user navigates through the records we ensure that the
qsqlrecord @Index{ QSqlRecord }
qsqlquery @Index{ QSqlQuery }
qstring @Index{ QString }
@I{ComboBox} reflects the current author.
@LD @Code @RawVerbatim @Begin
    void EditBookForm::primeUpdateBook( QSqlRecord * buffer )
    {
        // Who is this book's author?
        QSqlQuery query( "SELECT surname FROM author WHERE id='" +
            buffer->value( "authorid" ).toString() + "';" );
        QString author = "";
        if ( query.next() )
            author = query.value( 0 ).toString();
        // Set the ComboBox to the right author
        for ( int i = 0; i < ComboBoxAuthor->count(); i++ ) {
            if ( ComboBoxAuthor->text( i ) == author ) {
                ComboBoxAuthor->setCurrentItem( i ) ;
                break;
            }
        }
    }
@End @RawVerbatim
Firstly we look up the book's author and secondly we iterate
through the @I{ComboBox}'s items until we find the author and
set the @I{ComboBox}'s current item to the matching author.
}
@EndList}
@EndList

If the author name has changed or been deleted the query will fail and
no author id will be inserted into the buffer causing the
@Code{INSERT} to fail. An alternative is to record the author id's as
we populate the @I{ComboBox} and store them in a @Class{QMap}qmap
@Index{ QMap } which we can then look up as required. This approach
requires changes to the
init @Index{ init() } @Func{init()}, @Func{beforeUpdateBook()} and @Func{primeInsertBook()} functions and the addition of a new function, @Func{mapAuthor()}. The relevant code from @File{"qt/tools/designer/examples/book/book8/editbook.ui"} is shown below.
@NumberedList
@LI{
First we need to create a class variable to map author names
to author id's. Click in the Source tab of the Object Hierarchy,
then right click the Class Variables item and click @Option{New}.
Type in 'QMap<QString,int> authorMap;'.
}
@LI{
We now record the author id's in the
qsqlquery @Index{ QSqlQuery }
init @Index{ init() } @Func{init()} function.
@LD @Code @RawVerbatim @Begin
    void EditBookForm::init()
    {
        QSqlQuery query( "SELECT surname, id FROM author ORDER BY surname;" );
        while ( query.next() ) {
            ComboBoxAuthor->insertItem( query.value( 0 ).toString() );
            int id = query.value( 1 ).toInt();
            mapAuthor( query.value( 0 ).toString(), id, TRUE );
        }
    }
@End @RawVerbatim
After inserting each author's name into the @I{ComboBox} we populate
a @Class{QMap}qmap @Index{ QMap } with the author's name and id.
}
@LI{
Instead of looking up the author's id in the database we look
qsqlrecord @Index{ QSqlRecord }
it up in the @Class{QMap}qmap @Index{ QMap }.
@LD @Code @RawVerbatim @Begin
    void EditBookForm::beforeUpdateBook( QSqlRecord * buffer )
    {
        int id;
        mapAuthor( ComboBoxAuthor->currentText(), id, FALSE );
        buffer->setValue( "authorid", id );
    }
@End @RawVerbatim
}
@LI{
We use a single function for storing author id's and returning
qstring @Index{ QString }
them so that we can use a static data structure.
@LD @Code @RawVerbatim @Begin
    void EditBookForm::mapAuthor( const QString & name,
                                  int & id, bool populate )
    {
        if ( populate )
            authorMap[ name ] = id;
        else
            id = authorMap[ name ];
    }
@End @RawVerbatim
If the populate flag is @TRUE, we store the author's name and
id in the @Class{QMap}qmap @Index{ QMap }, otherwise we look up the given author name
and set id appropriately.
}
@LI{
Before we perform an update we need to know who the book's author
qsqlrecord @Index{ QSqlRecord }
qsqlquery @Index{ QSqlQuery }
qstring @Index{ QString }
is, and we need to update the combobox.
@LD @Code @RawVerbatim @Begin
    void EditBookForm::primeUpdateBook( QSqlRecord * buffer )
    {
        // Who is this book's author?
        QSqlQuery query( "SELECT surname FROM author WHERE id=" +
            buffer->value( "authorid" ).toString() + ";" );
        QString author = "";
        if ( query.next() )
            author = query.value( 0 ).toString();
        // Set the ComboBox to the right author
        for ( int i = 0; i < ComboBoxAuthor->count(); i++ ) {
            if ( ComboBoxAuthor->text( i ) == author ) {
                ComboBoxAuthor->setCurrentItem( i ) ;
                break;
            }
        }
    }
@End @RawVerbatim
}
@EndList

Another approach which is especially useful if the same foreign
databases @RawIndex{ Databases }
databases.foreign.keys @SubIndex{ Foreign Keys }
foreign.keys @Index{ Foreign Keys }
key lookups are required in different parts of the application
is to subclass a cursor and use this for our lookups. This is
described in the Qt SQL Module documentation, particulary the
section on subclassing @Class{QSqlCursor}qsqlcursor @Index{ QSqlCursor }.

@LP
The 'book' example demonstrates the basic techniques needed for
SQL programming with Qt. Additional information on the Qt SQL
classes, especially the @Class{QSqlQuery}qsqlquery @Index{ QSqlQuery } and @Class{QSqlCursor}qsqlcursor @Index{ QSqlCursor } classes
is provided in the Qt SQL Module documentation.

@End @SubSection
@EndSubSections
@End @Section
@EndSections
@End @Chapter
