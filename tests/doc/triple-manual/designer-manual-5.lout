@Chapter
    @Title {  The Designer Approach }
    @Tag { the.designer.approach }
@Begin
@BeginSections
@Section
    @Title { Introduction }
    @Tag { introductionxxxxxxx }
@Begin
@LP
In Qt 2.x, @QDR was a visual form designer for editing
files in the @File{.ui} file format. @QDR's
primary goal was to turn the most tedious part of GUI programming
-- dialog design -- into a pleasant experience. From an architectural
point of view, @QDR in 2.x is a fairly simple program.
It reads and writes @File{.ui} files. Each @File{.ui}
file contains an XML description of a single dialog form. A second
utility -- the user interface compiler @File{uic} -- is
used during the build process of an application to generate @Cpp
code from those XML descriptions.

@LP
For Qt 3.0 our ambitions for @QDR have grown beyond
single dialog editing. In addition to many new design features
like the ability to creating main windows and actions, the new
version introduces:

@BulletList
@LI{
@I{Project management} for the user interface part of your application;
}
@LI{
@I{Code in forms} @QDR provides a code editor so that
you can code your slots directly; the code is stored in @File{.ui.h}
files and eliminates the need for sub-classing (although you
can still subclass if you prefer);
}
@LI{
@I{Dynamic form loading} allows you to load @File{.ui}
files at runtime which provides great scope for design customization
separate from the underlying code.
}
@EndList
@LP
The purpose of this chapter is to explain the motivation for
making these changes, describe the new concepts involved and
show how these features work internally.

@LP
@QDR is and remains a visual design tool: it is not
a complete integrated development environment. Our policy is
to make GUI development as easy and powerful as possible without
locking our users into any particular tool: @QDR makes
it easy to create and modify GUI designs, but you can still achieve
the same results directly in code using a plain text editor if
you prefer.

@LP
To make working more convenient, @QDR now includes
a @Cpp editor (as a plugin). If you want to create or edit a form,
use @QDR. If you want edit code for that form, you
can use the @Cpp editor in @QDR as well. This built-in
editor has certain benefits stemming from its tight integration
with the visual form design process that we will explain later.
However, if you prefer using the editor you're used to, @File{vim},
@File{emacs}, @File{notepad}, Microsoft Visual
Studio, etc. you can still do so.
@End @Section
@Section
    @Title { Project management }
    @Tag { project.management }
@Begin
@LP
Reading and writing single, non-connected @File{.ui} files
is conceptually simple and worked fairly well in Qt 2.x. However,
it lacked certain features that made us introduce project management
for the GUI part of an application in @QDR. The main
benefits of project management are:
@BulletList
@LI{
Grouping forms that belong together.
}
@LI{
Sharing images between different forms.
}
@LI{
Sharing database information between different forms.
}
@EndList
@LP
The following sections explain these benefits in more detail,
and why project management is required to achieve them.

@BeginSubSections
@SubSection
    @Title { Grouping forms }
    @Tag{grouping.forms}
@Begin
@LP
Grouping forms means that @QDR maintains a list of
the @File{.ui} files that belong to the same project.
This makes it easy to switch between forms with a single mouse
click.
@End @SubSection
@SubSection
    @Title { Sharing images in a image collection }
    @Tag{sharing.images.in.a.image.collection}
@Begin
@LP
In Qt 2.x's @QDR each form included the images it
required and no images were shared. This led to duplication when
several forms needed to use the same images. Furthermore the
images were stored in the XML @File{.ui} files which made
them large.

@LP
As a workaround, we introduced a pixmap-loading function that
you could define in @QDR. It then was your responsibility
to provide the implementation of this function in your application
code. The big disadvantage of this approach was that you couldn't
see the images during the design process in @QDR.
This not only makes designing a form less visually interesting,
but also has a noticeable impact on geometry management.

@LP
In the Qt 3.0 version of @QDR we've introduced the
concept of a project image collection. If you use a project you
can add images to the project's image collection, and these images
can be shared and used by any of the forms you include in the
project. The images are stored as PNGs (portable network graphics)
in a subdirectory, @File{"images/"}, inside the project's
directory. Whenever you modify the image collection, @QDR
creates a source file which contains both the image data in binary
format and a function to instantiate the images. The images are
accessible by all forms in the project and the data is shared.

@LP
A further benefit of using an image collection is that the images
are added to the default QMimeSourceFactory. This way they are
accessible from rich-text labels, What's This? context help and
even tooltips through standard HTML image tags. The @I{source}
argument of the image tag is simply the image's name in the image
collection. This also works during the design process in @I{Qt
Designer}.

@End @SubSection
@SubSection
    @Title { Sharing database settings }
    @Tag{sharing.database.settings}
@Begin
@LP
Qt 3.0 introduces a brand new database module, the Qt SQL module.
@QDR is fully integrated with the SQL module and can
show live data from the databases that you connect to.

@LP
When you've opened or created a project you can set up its database
connections using the @Win{Edit Database Connections} dialog (invoked
by the @Option{Project"|"Database Connections} menu option). The connections
you make are stored in a @File{.db} file. When you reload
a project you can reconnect by going to the @I{Edit Database
Connections} dialog, clicking a connection in the list and clicking
the @Option{Connect} button.

@LP
In most non-trivial database applications you will want to access
the database from more than one form. This is why the @File{.db}
file is part of a project, not just part of a single form.

@End @SubSection
@SubSection
    @Title { Project (.pro) files }
    @Tag{project.pro.files}
@Begin
@LP
@QDR needs to store information on projects, for example,
the list of forms, the image collection and information about
available databases and how to access them. The majority of Qt
users already use a project file format to create multiplatform
makefiles: @File{tmake} (and with Qt 3.0 @File{qmake})
project @File{.pro} files. These files already contain
the list of forms, @File{.ui} files, used in the project
for @File{uic}.

@LP
We've extended the sections in the @File{.pro} file to
include the extra information that @QDR needs to manage
projects. For example, when you add a form to your project in
@QDR, it is automatically added to the FORMS section
of the project file, and thus @File{qmake} will generate
the required build rules without any further work. Similarly,
the images are added to the IMAGES section and thus gets automatically
compiled into your executable.

@LP
We don't force you to use @File{qmake}; if you prefer
another build system, for example automake"/"autoconf or jam,
you can still continue to use it. Look upon the @File{.pro}
file as a file that describes the GUI part of your application.
All you need to do -- as previously -- is add the @File{.ui}
files and the images collection to your own Makefiles.
@End @SubSection
@EndSubSections
@End @Section
@Section
    @Title { Extending the functionality of a form }
    @Tag { extending.the.functionality.of.a.form }
@Begin
@LP
First let us look at a figure that shows the relationship
between @File{.ui} files, generated code and application
code:

@DP
@Figure
    @Caption { Code files and user interface files }
@Diag 
    font { Helvetica Base }
    hsize { 24s }
    bfont { Helvetica Slope -2p }
    bhsize { 30s }
    bhindent { left }
    boutline { box }
{
@Tbl
#    rule { yes } rulecolour { red }
    indent { ctr }
    marginvertical { 0.75f }
    marginhorizontal { 1.0f }
    aformat { @Cell A | @Cell B | @Cell C | @Cell D }
{
    @Rowa A { A:: @CurveBox paint { darkgrey } { white @Colour @QDR } }
	  B { B:: @Box { form.ui } }
    @Rowa B { C:: @CurveBox paint { darkgrey } { white @Colour uic } }
	  C { D:: @Box paint { lightgrey } { form.h } }
    @Rowa A {
	      @BNode paint { lightgrey } { Generated }
	      /0c
	      @BNode { Revision Controlled }}
	  C { E:: @Box paint { lightgrey } { form.cpp } }
	  D { F:: @Box { main.cpp } }
}
//
@Link arrow { both } from { A } to { B } ylabel { { 0.666vx clines }  @Break {
reads
and
writes } }
@Arrow from { C } to { B } ylabel { reads }
@Arrow from { C } to { D } pathstyle { dashed } ylabel { 90d @Rotate generates }
@VHCurveArrow from { C } to { E } pathstyle { dashed } ylabel { ~~generates }
@Arrow from { E } to { D } pathstyle { dotted } ylabel { "#"includes }
@VHCurveArrow from { F } to { D } pathstyle { dotted } ylabel { "#"includes }
}

@PP
@QDR reads and writes @File{.ui} files, e.g.
@File{form.ui}. The user interface compiler, @File{uic},
creates both a header file, e.g. @File{form.h}, and an
implementation file, e.g. @File{form.cpp}, from the @File{.ui} file.
The application code in @File{main.cpp}
@Code{"#"include}s @File{form.h}. Typically @File{main.cpp} is used to
instantiate the @Class{QApplication} qapplication @Index {
QApplication } object and start off the event loop.

@LP
While this approach is simple, it isn't sufficient for more complex
dialogs. Complex dialogs tend to have quite a lot of logic attached
to the form's widgets, more logic than can usually be expressed
with predefined signals and slots. One way of handling this extra
logic is to write a controller class in the application code
that adds functionality to the form. This is possible because
@File{uic} generated classes expose a form's controls
and their signals to the public space. The big disadvantage of
this method is that it's not exactly Qt-style. If you were not
using @QDR, you would almost always add the logic
to the form itself, where it belongs.

@LP
This is why the capability of adding custom slots and member
variables to a form was added to @QDR early on. The
big additional benefit with this approach is that you can use
@QDR to connect signals to those custom slots, in
the same elegant graphical way that is used to connect signals
to predefined slots. The @File{uic} then adds an empty
stub for each custom slot to the generated @File{form.cpp}
implementation file.

@LP
The big question now is how to add custom implementation code
to those custom slots. Adding code to the generated @File{form.cpp}
is not an option, as this file gets recreated by the @File{uic}
whenever the form changes -- and we don't want a combination
of generated and handwritten code. There are two possible solutions,
which we'll cover next.

@BeginSubSections
@SubSection
    @Title { The subclassing approach }
    @Tag{the.subclassing.approach}
@Begin
@LP
A very clean way to implement custom slots for generated forms
is via @Cpp inheritance as shown in the next figure:

@DP
@Figure
    @Caption { Code files and user interface files (subclassing) }
@Diag 
    font { Helvetica Base }
#    hsize { 22s }
    bfont { Helvetica Slope -2p }
    bhsize { 30s }
    bhindent { left }
    boutline { box }
    cfont { Helvetica Base }
    chsize { 23s }
    coutline { box }
{
@Tbl
#    rule { yes } rulecolour { red }
    indent { ctr }
    marginvertical { 0.75f }
    marginhorizontal { 1.0f }
    aformat { @Cell A | @Cell B | @Cell C | @Cell D | @Cell E }
{
    @Rowa A { A:: @CurveBox paint { darkgrey } { white @Colour @QDR } }
	  B { B:: @Box hsize { 16s } { form.ui } }
    @Rowa B { C:: @CurveBox hsize { 16s } paint { darkgrey } { white @Colour uic } }
	  C { D:: @CNode paint { lightgrey } { form.h } }
	  D { G:: @CNode { formimpl.h } }
    @Rowa A {
	      @BNode paint { lightgrey } { Generated }
	      /0c
	      @BNode { Revision Controlled }}
	  C { E:: @CNode paint { lightgrey } { form.cpp } }
	  D { H:: @CNode { formimpl.cpp } }
	  E { F:: @Box { main.cpp } }
}
//
@Link arrow { both } from { A } to { B } ylabel { { 0.666vx clines }  @Break {
reads
and
writes } }
@Arrow from { C } to { B } ylabel { reads }
@Arrow from { C } to { D } pathstyle { dashed } ylabel { 90d @Rotate generates }
@VHCurveArrow from { C } to { E } pathstyle { dashed } ylabel { ~~generates }
@Arrow from { E } to { D } pathstyle { dotted } ylabel { "#"includes }
@VHCurveArrow from { F } to { G } pathstyle { dotted } ylabel { "#"includes }
@Arrow from { G } to { D } pathstyle { dotted } ylabel { 90d @Rotate inherits } 
@Arrow from { H } to { G } pathstyle { dotted } ylabel { "#"includes }
}

@PP
Here the user wrote an additional class @Option{FormImpl}, which is
split into the header file @File{formimpl.h} and the implementation
file @File{formimpl.cpp}. The header file includes the
@File{uic} generated @File{form.h} and reimplements
all the custom slots. This is possible because @File{uic}
generated custom slots are virtual. In addition to implementing
custom slots, this approach gives the user a way to do extra
initialization work in the constructor of the subclass, and extra
cleanups in the destructor.

@LP
Because of these benefits and its flexibility, this approach
became the primary way of using @QDR in Qt 2.x.

@LP
@B{Note:} To keep the namespace clean, most users did not follow
the Form and FormImpl naming scheme shown in the figure, but
instead named their @QDR forms FormBase and their
subclasses Form. This made a lot of sense, because they always
subclassed and were using those subclasses in application code.

@End @SubSection
@SubSection
    @Title { The ui.h extension approach }
    @Tag{the.ui.h.extension.approach}
@Begin
@LP
Despite its flexibility and cleanness, the subclassing approach
has some disadvantages:

@NumberedList
@LI{
Subclassing is not natural and easy for everybody. Newcomers
to object-oriented techniques may feel uneasy about being @I{forced}
to subclass for such a simple and natural thing like the implementation
of a custom slot.
}
@LI{
Inheriting generated classes is an additional possible source
of programming mistakes, especially if the number of reimplemented
functions is high and the signatures change often during the
design process. To make the development process smoother, @File{uic} generates empty stubs for custom slots rather
than pure virtual functions. While this approach keeps the code
compiling and running, programmers can find themselves in a situation
where they miss a runtime warning message and lose time before
they find a small spelling error in their subclass.
}
@LI{
In larger projects with hundreds of forms, the additional subclasses
can make a noticeable difference in terms of compilation speed
and code size.
}
@EndList
@LP
There may be more disadvantages, but these were reason enough
for us to investigate alternative solutions. For Qt 3.0, we came
up with a new concept, the @I{ui.h extension}.

@LP
This is how it works:

@DP
@Figure
    @Caption { Code files and user interface files (using .ui.h files) }
@Diag 
    font { Helvetica Base }
    hsize { 24s }
    bfont { Helvetica Slope -2p }
    bhsize { 30s }
    bhindent { left }
    boutline { box }
    cfont { Helvetica Base }
    chsize { 24s }
    coutline { box }
{
@Tbl
#    rule { yes } rulecolour { red }
    indent { ctr }
    marginvertical { 1.0f }
    marginhorizontal { 1.0f }
    aformat { @Cell marginleft { 0c } A | @Cell marginleft { 0c } B |
	      @Cell C | @Cell D }
    bformat { @Cell marginleft { 0c } A |
	      @StartHSpan @Cell marginleft { 0c } B | @HSpan | @Cell D }
{
    @Rowb B { A:: @CurveBox paint { darkgrey } { white @Colour @QDR } }
    @Rowa B { B:: @Box { form.ui } }
	  C { I:: @Box { form.ui.h } }
    @Rowa B { C:: @CurveBox paint { darkgrey } { white @Colour uic } }
	  C { D:: @CNode paint { lightgrey } { form.h } }
    @Rowa A {
	      @BNode paint { lightgrey } { Generated }
	      /0c
	      @BNode { Revision Controlled }}
	  C { E:: @CNode paint { lightgrey } { form.cpp } }
	  D { F:: @Box { main.cpp } }
}
//
@Link arrow { both } from { A } to { B } ylabeladjust { -0.666c -0.25c }
ylabel { { 0.666vx clines }  @Break {
reads
and
writes } }
@Link arrow { both } from { A } to { I } ylabeladjust { 0.666c -0.25c }
ylabel { { 0.666vx clines }  @Break {
reads
and
writes } }
@Arrow from { C } to { B } ylabel { reads }
@Arrow from { C } to { D } pathstyle { dashed } ylabel { 90d @Rotate generates }
@VHCurveArrow from { C } to { E } pathstyle { dashed } ylabel { ~~generates }
@Arrow from { E } to { D } pathstyle { dotted } ylabel { "#"includes }
@VHCurveArrow from { F } to { D } pathstyle { dotted } ylabel { "#"includes }
@Link from { E@S } to { 0.64,0.1 } pathstyle { dotted }
@RVLCurveArrow from { 0.64,0.1 } to { I } bias { 10f } pathstyle { dotted } ylabel { "#"includes }
}

@PP
In addition to the @File{.ui} file, @File{form.ui},
@QDR reads and writes another associated file @File{form.ui.h}.
This @File{.ui.h} file is an @I{ordinary @Cpp source file}
that contains @I{implementations} of custom slots. The file gets
included from the generated form implementation file @File{form.cpp}
and thus can be totally ignored by other user code. The reason
we use a @File{.h} extension for the @File{.ui.h}
file even though it contains @Cpp code is because it is always
@I{included}, and because it is easier to integrate into the
build process with a @File{.h} extension.

@LP
The @File{form.ui.h} file has a special position among
all other files. It is a @I{shared} source file that gets written
and read by both the user and @QDR. As such it is
an ordinary revision controlled source file and not generated
by @File{uic}. @QDR's responsibility is to
keep the file in sync with the custom slot definitions of the
associated form:

@BulletList
@LI{
Whenever the users adds a new slots to the form, @QDR
adds a stub to the @File{.ui.h} file.
}
@LI{
Whenever the user changes a custom slot's signature, @QDR
updates the corresponding implementation.
}
@LI{
Whenever the user removes a custom slot, @QDR removes
it from the @File{.ui.h} file.
}
@EndList

This way integrity is guaranteed, there is no more need for subclassing
and no more danger of forgotten or misspelled slots in subclasses.

@LP
You can edit @File{.ui.h} files either directly in @I{Qt
Designer} with the built-in @Cpp editor plugin, or with whatever
editor you prefer. You should only put slot implementations in
the @File{.ui.h} file and you should @I{always} add, delete
or rename slots @I{within} @QDR. You can edit the
implementations of the slots either within @QDR or
using your own editor; if you use your own editor @QDR
will keep your changes.

@BeginSubSubSections
@SubSubSection
    @Title { Construction and destruction }
    @Tag{construction.and.destruction}
@Begin
@LP
The @File{ui.h} extension approach has one disadvantage
compared to subclassing. The @File{ui.h} file only contains
custom slot implementations, but the objects are still entirely
constructed and destructed inside the generated @File{form.cpp}
code. This leaves the user without the possibility of doing further
form initializations or cleanups that you normally would do within
the constructor and destructor functions of a @Cpp class.

@LP
To work around this limitation, we created the init"/"destroy
convention. If you add a slot @Func{Form::init()} to your
form, this slot will be called automatically at the end of the
generated form constructor. Similarly, if you add a slot @Func{Form::destroy()}
to your form, the slot will automatically be invoked by the destructor
before any form controls get deleted. (These slots should return
void.) If you prefer to use your own editor you must still create
these functions in @QDR; once created you can then
write your implementation code either using @QDR's
@Cpp editor plugin or using your own editor.
@End @SubSubSection
@EndSubSubSections

@End @SubSection
@EndSubSections
@End @Section
@Section
    @Title { Loading forms dynamically }
    @Tag { loading.forms.dynamically }
@Begin
@LP
We extracted the part of @QDR that is responsible
for loading and previewing a form into a library of its own,
@File{libqui}. A new class @Class{QWidgetFactory}qwidgetfactory @Index{ QWidgetFactory } makes it
possible to load @File{.ui} files at runtime and instantiate
forms from them.

@LP
This dynamic approach keeps the GUI design and the code separate
and is useful in environments where the GUI may have to change
more often than the underlying application logic. Ultimately,
you can provide users of your application the ability to modify
the graphical user interface without the need for a complete
@Cpp development environment.

@LP
Since the .ui file is not compiled it cannot include any @Cpp
code, (e.g. custom slot implementations). We provide a way of
adding those implementations via a controlling QObject subclass
that you pass as receiver to the widget factory.

@LP
This concept and its usage is explained in detail in
@NamePageRef{subclassing.and.dynamic.dialogs}.

@End @Section
@EndSections
@End @Chapter
