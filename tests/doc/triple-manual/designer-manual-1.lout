@Chapter
    @PartNumber { Part II }
    @PartTitle { Qt Designer }
    @Title { Preface }
    @Tag { preface }
@Begin
@BeginSections
@Section
    @Title { Introduction }
    @Tag { introductionx }
@Begin
@LP
This manual presents @I{Qt Designer}, a tool for designing and
implementing user interfaces built with the Qt multiplatform
application development framework. @I{Qt Designer} makes it easy
to experiment with user interface design. At any time you can
generate the code required to reproduce the user interface from
the files @I{Qt Designer} produces, changing your design as often
as you like. If you used the previous version you will find yourself
immediately productive in the new version since the interface
is very similar. But you will find new widgets and new and improved
functionality which have been developed as a result of your feedback.

@PP
@I{Qt Designer} helps you build user interfaces with layout tools
that move and scale your widgets (@I{controls} in Windows terminology)
automatically at runtime. The resulting interfaces are both functional
and attractive, comfortably suiting your users' operating environments
and preferences. @I{Qt Designer} supports Qt's signals and slots
mechanism for type-safe communication between widgets. @I{Qt
Designer} includes a code editor which you can use to embed your
own custom slots inside the generated code. Those who prefer
to separate generated code from hand crafted code can continue
to use the subclassing approach pioneered in the first version
of @I{Qt Designer}.

controls @RawIndex{ Controls }
controls.widgets @SubIndex{ Widgets }
@PP
The manual introduces you to @I{Qt Designer} by leading you through
the development of example applications. The first seven chapters
are tutorials, each designed to be as self-contained as possible.
Every chapter, except the first three, assumes that you are familiar
with the material in chapters two and three which cover the basics
of building a Qt application with @I{Qt Designer}. Here's a brief
overview of the chapters:

@BulletList
@LI{
The @TitlePageRef{quick.start} chapter is a fast hands-on tutorial that takes
you through the creation of a short, simple dialog application.
The aim of this chapter is to give you a feel for how @I{Qt Designer}
works, with explanations and details deferred to later chapters.
}
@LI{
The @TitlePageRef{creating.a.main.window.application} chapter introduces @I{Qt
Designer} and takes you step by step through the creation of
a small but fully functional application. Along the way you will
learn how to create a main window with menus, toolbars and a
status bar. Most of the application's implementation will be
covered, but the custom dialogs will be deferred until chapter
three. In the course of this chapter you will use the form and
property editors to customize the application. You'll also learn
how to use Qt's signals and slots mechanism and @I{Qt Designer}'s
built-in code editor to make the application functional. We will
also explain how to use @F @Verbatim{qmake} to generate a Makefile
so that you can compile and run the application.
}
@LI{
The @TitlePageRef{creating.dialogs} chapter we will create the custom
dialogs required by the main window application created in chapter
two. In addition to demonstrating various ways of creating dialogs,
you will also learn how to lay out forms using the layout tools.
}
@LI{
The @TitlePageRef{the.designer.approach} chapter provides information on
the @I{Qt Designer} approach to developing applications, and
explains some of the rationale behind @I{Qt Designer}.
}
@LI{
The @TitlePageRef{subclassing.and.dynamic.dialogs} chapter will show you
how to subclass a form; this allows you to clearly separate the
user interface from the underlying code that implements its functionality.
Additional information on @F @Verbatim{qmake} and @F @Verbatim{uic}
is included in this chapter. This chapter will also explain how
you can dynamically load dialogs from

ui @Index{ .ui } @F @Verbatim{.ui} files into your application using @B{QWidgetFactory} and how to access the widgets and sub-widgets of these dialogs.}
@LI{
The @TitlePageRef{creating.custom.widgets} chapter explains how you can create
your own custom widgets. Both the simple method, that was introduced
with the first version of @I{Qt Designer}, and the new more powerful
method using plugins, are explained.
}
@LI{
The @TitlePageRef{creating.database.applications} chapter introduces Qt's
SQL classes and takes you through an example that demonstrates
how to execute SQL queries and how to set up master-detail relationships,
perform drilldown and handle foreign keys.
}
@LI{
The @TitlePageRef{customizing.and.integrating.qt.designer} chapter focuses
on @I{Qt Designer} itself, showing you how to customize Designer,
how to integrate Designer with Visual Studio and how to create
Makefiles.
}
@EndList

The remaining chapters provide reference material that explains
@I{Qt Designer}'s menu options, toolbars, key bindings and dialogs
in detail.

@End @Section
@Section
    @Title { What You Should Know }
    @Tag { what.you.should.know }
@Begin
@LP
This manual assumes that you have some basic knowledge of C++
and the Qt application development framework. If you need to
learn more about C++ or Qt there are a vast number of C++ books
available, and a small but increasing number of Qt books. Qt
comes with extensive online documentation and many example applications
that you can try.

@PP
The Enterprise Edition of Qt includes the Qt SQL module. In Creating
Database Applications we demonstrate how to build SQL applications
with @I{Qt Designer}; this chapter requires some knowledge of
SQL and relational databases.

@End @Section
@Section
    @Title { What's New in @I{Qt Designer} for Qt 3.0? }
    @Tag { what.s.new.in.qt.designer.for.qt }
@Begin
@LP
This version of @I{Qt Designer} has a great deal more functionality
than its predecessor. The code for custom slots can be edited
directly in @I{Qt Designer}; main windows with actions, toolbars
and menus can be created; layouts that incorporate splitters
can be used; plugins allow you to package any number of custom
widgets and make them available to @I{Qt Designer}. Many other
enhancements have been incorporated, from small improvements
in the user interface to improved efficiency, for example the
ability to share pixmaps across all the forms in an application.

@PP
This version of @I{Qt Designer} introduces project files which
make it easy to switch between all the forms in an application,
and to maintain a common set of database settings and images.
Although subclassing is fully supported, writing code directly
in @I{Qt Designer} offers a number of advantages which are covered
in The Designer Approach chapter.

@PP
A new library @F @Verbatim{libqui} has also been introduced which
allows you to load dialogs dynamically at runtime from @I{Qt
Designer}'s @F @Verbatim{.ui} files. This allows you to provide
your application's users with considerable interface customizability
without them needing to use C++.

@PP
Although the new version of @I{Qt Designer} introduces new approaches
and techniques you can ignore these aspects and simply use it
in exactly the same way as you used the version supplied with
Qt 2.x, if you just want a simple but powerful single dialog
visual design tool.

@LD @Heading { What's New in @I{Qt Designer} for Qt 3.1?{@PageMark{what.s.new.in.qt.designer.for.qtx}} }
@NumberedList
@LI{
@I{Qt Designer} now features a start-up dialog for fast access
to recently used files, etc. (It can be switched off if you don't
want it.)
}
@LI{
The signals and slots dialog has changed significantly. It is
far easier to use and much faster for creating lots of connections
in one go. You can still click and drag to create connections,
but the new dialog is much quicker.
}
@LI{
Widgets are now accessible using the Toolbox. (All the original
toolbars are still available.) This provides the same easy access
as toolbar buttons, and also shows the names of the widgets and
takes up less space.
}
@LI{
@B{QWidgetStack}qwidgetstack @Index{ QWidgetStack } is now available as a container widget. The
new example demonstrates its use.
}
@LI{
@F @Verbatim{.ui.h} files may now contain arbitrary C++, including
@F @Verbatim{const} definitions, @F @Verbatim{#include}s, plain
functions, etc.
}
@LI{
When you select multiple-widgets their common properties are
shown in the property editor and can be changed collectively.
}
@EndList
@PP
@Figure
    @Caption { 
@I{Qt Designer} }
 0.35 @Scale @IncludeGraphic { "images/qd-preface.eps.gz" }
@End @Section
@Section
    @Title { Feedback }
    @Tag { feedback }
@Begin
@LP
If you have any comments, suggestions, criticisms or even praise
regarding this manual, please let us know at @F @Verbatim{doc@trolltech.com}.
Bug reports on Qt or @I{Qt Designer} should be sent to @F @Verbatim{qt-bugs@trolltech.com}.
You might also like to join the @I{qt-interest} mailing list,
which @I{Qt Designer}'s developers read and contribute to; see
@Http{lists.trolltech.com} for further details.

@End @Section
@EndSections
@End @Chapter
