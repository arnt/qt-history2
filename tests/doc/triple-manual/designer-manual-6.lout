@Chapter
    @Title { Subclassing and Dynamic Dialogs }
    @Tag { subclassing.and.dynamic.dialogs }
@Begin
@LP
This subclassing @Index{ Subclassing } dynamic.dialogs @Index{ Dynamic
Dialogs } dialogs @RawIndex{ Dialogs } dialogs.dynamic @SubIndex{
Dynamic } chapter describes two different approaches that you can take
to creating forms with @QDR. Subclassing is used to extend the
functionality of a form by creating your own class based upon a form
you create in @QDR. Dynamic dialogs are ui @Index{ .ui } @File{.ui}
files which can be executed by a Qt application; this keeps the GUI
design and the code separate and is useful in environments where the
GUI may have to change more often than the underlying application
logic.
@BeginSections
@Section
    @Title { Subclassing }
    @Tag { subclassing }
@Begin
@LP
We'll start with a general description of how to subclass a form and
follow with a short example. Note that subclassing has some
disadvantages compared with putting your code into a form directly;
see Extending the functionality of a form
[p.~@PageOf{extending.the.functionality.of.a.form}] in The Designer
Approach [p.~@PageOf{the.designer.approach}] chapter for details.

@BeginSubSections
@SubSection
    @Title { Generating Source Code from @QDR .ui Files}
    @Tag{generating.source.code.from.qt.designer.ui.files}
@Begin
@LP
@QDR reads and writes @File{qmake} pro @Index{ .pro } @File{.pro}
(project) files which are used to record the files used to build the
application and from which Makefiles are generated. @QDR also reads
and writes ui @Index{ .ui } @File{.ui} (user interface) files. These
are XML files that record the widgets, layouts, source code and
settings you've used for a form. Every ui @Index{ .ui } @File{.ui}
file is converted by the @File{uic} (user interface compiler) into a
@Cpp h @Index{ .h } @File{.h} file and a @Cpp cpp @Index{ .cpp }
@File{.cpp} file. These @Cpp files are then read by @File{moc} (meta
object compiler), and finally compiled by your compiler into a working
application.

@LP
If you create applications wholly within @QDR you only need to create
a makefiles @Index{ Makefiles } projects @RawIndex{ Projects }
projects.adding.files @SubIndex{ Adding Files } adding @RawIndex{
Adding } adding.files.to.projects @SubIndex{ Files to Projects }
main.cpp @Index{ main.cpp } @File{main.cpp}.

@LP
If you create the @File{main.cpp} file within @QDR,
it will automatically be added to your project file by @I{Qt
Designer}. If you create the @File{main.cpp} file outside
of @QDR you must add it to the project file manually
by adding the following line at the end of your project's
pro @Index{ .pro } @File{.pro} file:
@LD @Code @RawVerbatim @Begin
SOURCES += main.cpp
@End @RawVerbatim
You can then use @File{qmake} to generate the Makefile.
(For example @C{qmake -o}~~@C{Makefile}~~@C{myproject.pro}.)
Running @File{make} (Linux, Unix or Borland compilers),
or @File{nmake} (Visual @Cpp), will then call @File{uic},
@File{moc} and your compiler as necessary to build your
errors @RawIndex{ Errors }
errors.undefined.reference @SubIndex{ Undefined reference }
undefined.references.error @Index{ Undefined references, Error }
qmake @RawIndex{ qmake }
qmake.headers @SubIndex{ HEADERS }
qmake @RawIndex{ qmake }
qmake.sources @SubIndex{ SOURCES }
application.

@LP
If you use @QDR to create your main window and dialogs, but also add
other @Cpp files, or if you subclass any of your forms you will need
to add these files to the pro @Index{ .pro } @File{.pro} file so that
they are compiled with the rest of your application's source files.
Each h @Index{ .h } @File{.h} file that you create separately from
@I{Qt Designer} should be added to the @Code{HEADERS} line, and each
cpp @Index{ .cpp } @File{.cpp} file should be added to the
@Code{SOURCES} line, just as we've done for main.cpp @Index{ main.cpp
} @File{main.cpp}. If you get undefined reference errors it is worth
checking that you've added the names of all your header and
implementation files to the pro @Index{ .pro } @File{.pro} file.

@End @SubSection
@SubSection
    @Title {Subclassing a Form }
    @Tag{subclassing.a.form}
@Begin
@LP
When subclassing a form it is helpful to use a naming convention
to help us identify which files are generated from @QDR's
ui @Index{ .ui } @File{.ui} files and which are hand coded.
@LP
Suppose, for example, that we are developing a dialog and writing the
code directly in @QDR. We might call our dialog 'OptionsForm' and the
ui @Index{ .ui } @File{.ui} file, @File{optionsform.ui}. The
automatically generated files will be @File{optionsform.h} and
@File{optionsform.cpp}.
@LP
If we were developing another dialog, but this time one that we
intended to subclass, we want to make it easy to distinguish between
the automatically generated files and our hand coded files. For
example, we might call our dialog 'SettingsFormBase' and the ui
@Index{ .ui } @File{.ui} file @File{settingsformbase.ui}. The
automatically generated files would then be called
@File{settingsformbase.h} and @File{settingsformbase.cpp}. We would
then call our subclass 'SettingsForm' and code it in the files
q.object @RawIndex{ Q_OBJECT }
q.object.macros @SubIndex{ Macros }
macros @RawIndex{ Macros }
macros.q.object @SubIndex{ Q_OBJECT }
signals.and.slots @RawIndex{ Signals and Slots }
signals.and.slots.q.object @SubIndex{ Q_OBJECT }
@File{settingsform.h} and @File{settingsform.cpp}.

@LP
Any subclass of a form should include the @Code{Q_OBJECT} macro so
that slots and signals will work correctly. Once you've created your
subclass be sure to add the h @Index{ .h } @File{.h} and the cpp
@Index{ .cpp } @File{.cpp} files to the pro @Index{ .pro } @File{.pro}
project file. For example we would add the following lines for our
subclassed 'SettingsForm' at the end of the pro @Index{ .pro }
@File{.pro} file:
@LD @Code @RawVerbatim @Begin
HEADERS += settingsform.h
SOURCES += settingsform.cpp
@End @RawVerbatim
The simplest way to create a new source file is by clicking
@Option{File"|"New} to invoke the 'New File' dialog, then click '@Cpp
Source' or '@Cpp Header' as appropriate, then click @OK. A new empty
source window will appear. You don't need to manually edit the
@File{.pro} file since @QDR will add them for you automatically.

@LP
@QDR will have added
@LD @Code @RawVerbatim @Begin
FORMS = settingsformbase.ui
@End @RawVerbatim
to the project file. The @File{settingsformbase.h} and
@File{settingsformbase.cpp} files will be generated from the ui
@Index{ .ui } @File{.ui} file automatically.
@End @SubSection
@SubSection
    @Title {A Subclassing Example}
    @Tag{a.subclassing.example}
@Begin
@LP
We will write a small example dialog to show the use of subclassing in
practice. The dialog will present a choice of customer credit ratings
with an option of choosing a 'special' rating for which a specific
amount must be given. We'll implement the functionality in a subclass.
We'll start by creating the base form and connecting its signals and
slots, then we'll create the subclass and a simple main.cpp @Index{
main.cpp } @File{main.cpp} so that we can test it. 

@BeginSubSubSections
@SubSubSection
    @Title { Designing the Form}
    @Tag{designing.the.form}
@Begin
@LP
We'll begin by creating a new project. Click @Option{File"|"New},
projects @RawIndex{ Projects }
projects.creating.new @SubIndex{ Creating New }
then click the '@Cpp Project' icon to invoke the @Win{Project Settings}
dialog. Click the ellipsis button to invoke the @Win{Save As} dialog;
navigate to the project's directory (creating it if necessary).
Make sure you're in the project's directory, then enter a project
name of 'credit.pro'. Click the @Option{Save} button to return to
the @Win{Project Settings} dialog, then click @OK. Now we'll
add a form to the project. Click @Option{File"|"New} to invoke the
@Win{New File} dialog. The default form is Dialog which is what
we want; click @OK. Resize the form to make it smaller; it
should be about 2 inches (5 cm) square. Change the form's name
to 'CreditFormBase' and the caption to 'Credit Rating'. Save
the form as @File{creditformbase.ui}.

@LP
We'll now add the widgets we need.
@NumberedList
@LI{
Click the @Option{Button Group} toolbar button, then click near the
top left of the form. Resize the button group so that it takes
up approximately half the form. Change the button group's @Prop{name}
to 'creditButtonGroup' and its @Prop{title} property to 'Credit
Rating'.
}
@LI{
We'll now add some radio buttons. @I{Double} click the @Option{Radio
Button} toolbar button. Click towards the top of the Credit Rating
button group and a radio button will appear. Click below this
button, to create a second radio button, then click below the
second button to create a third. Now we will switch off the effect
of the @I{double} click by clicking the @Option{Pointer} (arrow) toolbar
button. The pointer will now behave normally, i.e. clicking the
form will no longer create more radio buttons. Change the first
radio button's @Prop{name} to 'stdRadioButton' and its text to '"&"Standard'.
Change its @Prop{checked} property to True. Change the second button's
name to 'noneRadioButton' and its text to '"&"None'. Change the
third radio button's properties to 'specialRadioButton' and 'Sp"&"ecial'
respectively.
}
@LI{
If the user chooses the special credit rating they must specify
an amount. Click the @Option{SpinBox} toolbar button and click the
form just below the button group. Change the spin box's @Prop{name}
to 'amountSpinBox'. Change its @Prop{prefix} to '$ ' (note the space),
its @Prop{maxValue} to '100000' and its @Prop{lineStep} to '10000'.
Change its @Prop{enabled} property to False.
}
@LI{
Click the @Option{Push Button} toolbar button and click the form below
the spin box. Change the button's @Prop{name} to 'okPushButton',
its @Prop{text} to 'OK' and its @Prop{default} property to 'True'.
Add a second button to the right of the first. Change the second
button's @Prop{name} to 'cancelPushButton' and its @Prop{text} to 'Cancel'.
}
@EndList
@LP
We'll now lay out the widgets and connect up the slots we need.
@NumberedList
@LI{
Click the credit rating group box then press @Option{Ctrl+L} (lay
out vertically).
}
@LI{
Click the form so that the button group is no longer selected.
@Option{Ctrl+Click} the OK button and drag the rubber band to touch
the Cancel button, then release. Press @Option{Ctrl+H}.
}
@LI{
Click the form, then press @Option{Ctrl+L}.
The widgets will be laid out vertically, each one stretching
layouts @RawIndex{ Layouts }
layouts.spacers @SubIndex{ Spacers }
to fill up the maximum space both vertically and horizontally.
The buttons look rather large since they've expanded to take
up the full width of the form. It might look more attractive
to make the buttons smaller using spacers. Click the OK button,
then press @Option{Ctrl+B} (break layout). Resize both buttons to
make them narrower leaving space on either side of them. Click
the @Option{Spacer} toolbar button then click to the left of the OK
button; click Horizontal from the pop up spacer menu. Copy this
spacer and place the copy between the two buttons. Copy the spacer
again and place the copy to the right of the Cancel button. (For
the second and third spacers, click on the first spacer, press
@Option{Ctrl+C} then @Option{Ctrl+V}. Drag the new spacer to the desired
position.) Ctrl+Click the left most spacer and drag the rubber
band so that it touches the buttons and the spacers, then release.
Press @Option{Ctrl+H}. Click the form then press @Option{Ctrl+L}.
}
@EndList
We'll now connect the signals and slots. Click
@Option{Edit"|"Connections} signals.and.slots @Index{ Signals and
Slots } to invoke the @Win{View and Edit Connections} dialog.

@LP
Create a new connection that connects the OK button's clicked() signal
to the form's accept() slot. Create a second connection that connects
the Cancel button's clicked() signal to the form's reject() slot. (See
Creating Signals and Slots Connections
[p.~@PageOf{signals.and.slots.connections}].)

@LP
We want the amount spin box to be enabled only if the special
radio button is checked. Create another connection, this time
connecting the special radio button's toggled() signal to the
amount spin box's setEnabled() slot.

@LP
If the user checks the standard or none radio buttons we want
to set the amount accordingly. Connect the credit rating button
group's clicked() signal to a new custom setAmount() slot (which
you create by clicking the @Option{Edit Slots...} button).

@LP
We'll subclass the form to set the amount in the spin box depending
on which radio button is checked. Save the form as 'creditformbase.ui'
(press @Option{Ctrl+S}).

@End @SubSubSection
@SubSubSection
    @Title { Creating the Test Harness }
    @Tag{creating.the.test.harness}
@Begin
@LP
Although we intend our dialog to be used within an application forms
@RawIndex{ Forms } forms.creating.test.harnesses @SubIndex{ Creating
Test Harnesses } creating.test.harnesses.for.forms @Index{ Creating
Test Harnesses for Forms } subclassing @Index{ Subclassing } it is
useful to create a test harness so that we can develop and test it
stand-alone. Click @Option{File"|"New} to invoke the 'New File'
dialog, then click '@Cpp Source', then click @OK. In the editor window
qapplication @Index{ QApplication }
that pops up, enter the following code:
@LD @Code @RawVerbatim @Begin
#include <qapplication.h>
#include "creditformbase.h"

int main( int argc, char *argv[] ) 
{
    QApplication app( argc, argv );

    CreditFormBase creditForm;
    app.setMainWidget( &creditForm );
    creditForm.show();

    return app.exec();
}
@End @RawVerbatim
@LP
Note that we're including @File{creditformbase.h} and
instantiating a CreditFormBase object; once we've written our
subclass we'll replace the header with our subclass, @File{creditform.h},
and instantiate a CreditForm.

@LP
We can now generate the application with @File{qmake},
e.g. @Code{qmake -o Makefile credit.pro}, make it and
run it. The form should run fine, but doesn't yet have the behaviour
we require.

@End @SubSubSection
@SubSubSection
    @Title {Creating the Subclass }
    @Tag{creating.the.subclass}
@Begin
@LP
We need to create a header and an implementation file for our
subclass. The code for our subclass is minimal. The header file
qwidget @Index{ QWidget }
macros @RawIndex{ Macros }
macros.q.object @SubIndex{ Q_OBJECT }
q.object @Index{ Q_OBJECT } 
is @File{"qt/tools/designer/examples/credit/creditform.h"}:
@LD @Code @RawVerbatim @Begin
    #include "creditformbase.h"

    class CreditForm : public CreditFormBase
    {
        Q_OBJECT
    public:
        CreditForm( QWidget* parent = 0, const char* name = 0,
                    bool modal = FALSE, WFlags fl = 0 );
        ~CreditForm();
    public slots:
        void setAmount();
    };
@End @RawVerbatim
We've declared the slot, @Func{setAmount()}, that we created
in @QDR. The @Code{Q_OBJECT} macro is included
because it is essential for classes that use signals and slots.

@LP
The implementation in
@File{"qt/tools/designer/examples/credit/creditform.cpp"}
qwidget @Index{ QWidget }
is simple:
@LD @Code @RawVerbatim @Begin
    #include <qradiobutton.h>
    #include <qspinbox.h>
    #include "creditform.h"

    CreditForm::CreditForm( QWidget* parent, const char* name,
                            bool modal, WFlags fl )
        : CreditFormBase( parent, name, modal, fl )
    {
        setAmount();
    }

    CreditForm::~CreditForm() { /* NOOP */ }

    void CreditForm::setAmount()
    {
        if ( stdRadioButton->isChecked() )
            amountSpinBox->setValue( amountSpinBox->maxValue() / 2 );
        else if ( noneRadioButton->isChecked() )
            amountSpinBox->setValue( amountSpinBox->minValue() );
    }
@End @RawVerbatim
We call @Func{setAmount()} in the constructor to ensure
that the correct amount is shown when the form starts based on
whichever radio button we checked in @QDR. In @Func{setAmount()}
we set the amount if the standard or none radio button is checked.
If the user has checked the special radio button they are free
to change the amount themselves.

@LP
To be able to test our subclass we change makefiles @Index{ Makefiles
} qmake @RawIndex{ qmake } qmake.headers @SubIndex{ HEADERS } qmake
@RawIndex{ qmake } qmake.sources @SubIndex{ SOURCES } main.cpp @Index{
main.cpp } @File{main.cpp} to include @File{creditform.h} rather than
@File{creditformbase.h} and change the instantiation of the creditForm
qapplication @Index{ QApplication }
object:
@LD @Code @RawVerbatim @Begin
    #include <qapplication.h>
    #include "creditform.h"

    int main( int argc, char *argv[] )
    {
        QApplication app( argc, argv );

        CreditForm creditForm;
        app.setMainWidget( &creditForm );
        creditForm.show();

        return app.exec();
    }
@End @RawVerbatim
If you created the @File{creditform.h} and @File{creditform.cpp}
files in @QDR, they are already in the project file,
but if you created them manually you must also update the project
file by adding these two new lines at the end:
@LD @Code @RawVerbatim @Begin
HEADERS += creditform.h
SOURCES += creditform.cpp
@End @RawVerbatim
@LP
To test the form rerun @File{qmake} to regenerate the
Makefile, then make and run.

@LP
The subclassing example we've used is simple, but this reflects
subclassing forms in Qt: it is easy to do.

@End @SubSubSection
@EndSubSubSections
@End @SubSection
@EndSubSections
@End @Section
@Section
    @Title { Creating Dynamic Dialogs from .ui Files }
    @Tag { creating.dynamic.dialogs.from.ui.files }
@Begin
@LP
Qt programs are capable of loading @QDR dynamic.dialogs @Index{
Dynamic Dialogs } dialogs @RawIndex{ Dialogs } dialogs.dynamic
@SubIndex{ Dynamic } code.editing @RawIndex{ Code Editing }
code.editing.not.in.dynamic.dialogs @SubIndex{ Not in Dynamic Dialogs
} ui @Index{ .ui } @File{.ui} files and instantiating the forms
represented by the ui @Index{ .ui } @File{.ui} files. Since the ui
@Index{ .ui } @File{.ui} file is not compiled it cannot include any
@Cpp code, (e.g. slot implementations). In this section we will
explain how to load a dynamic dialog and how to create a class that
can be used to implement the dynamic dialog's custom slots.
@LP
We will use the credit form that we created in the subclassing
section as our example form. We will start by simply instantiating
and running the form and then we'll cover how to implement custom
slots.

@LP
We'll create a main.cpp @Index{ main.cpp } @File{main.cpp} file to use
as a test harness, and manually create a project file.

@BeginSubSections
@SubSection
    @Title { Creating the Project File }
    @Tag {creating.the.project.file}
@Begin
@LP
The project file
@File{"qt/tools/designer/examples/receiver1/receiver.pro"}
qtdir @Index{ QTDIR }
looks like this:
@LD @Code @RawVerbatim @Begin
TEMPLATE     = app
CONFIG      += qt warn_on release
TARGET       = receiver
SOURCES     += main.cpp
unix:LIBS   += -lqui
win32:LIBS  += $(QTDIR)/lib/qui.lib
FORMS        = mainform.ui
LANGUAGE     = C++
INCLUDEPATH += $(QTDIR)/tools/designer/uilib
@End @RawVerbatim
We do @I{not} include the @File{creditformbase.ui} file
since this file will be read at runtime, as we'll see shortly.
We must include the @File{qui} library since the functionality
we require is not part of the standard Qt library.

@End @SubSection
@SubSection
    @Title { Creating main.cpp}
    @Tag {creating.main.cppx}
@Begin
@LP
The main.cpp @Index{ main.cpp } @File{main.cpp} is quite standard. It
will invoke the form we're going to create in @QDR as its main form.
qapplication @Index{ QApplication }
This form will then load and execute the dynamic dialog.
@LD @Code @RawVerbatim @Begin
    #include <qapplication.h>
    #include "mainform.h"

    int main( int argc, char *argv[] )
    {
        QApplication app( argc, argv );

        MainForm *mainForm = new MainForm;
        app.setMainWidget( mainForm );
        mainForm->show();

        return app.exec();
    }
@End @RawVerbatim
We create a new instance of our MainForm class, set it to be
the main widget, show it and enter the event loop in the @Code{app.exec()}
call.

@End @SubSection
@SubSection
    @Title { Creating the Main Form}
    @Tag {creating.the.main.form}
@Begin
@BeginSubSubSections
@SubSubSection 
    @Title{ Designing the Form }
    @Tag{designing.the.formx}
@Begin
@BulletList
@LI{
Open the receiver.pro @Index{ receiver.pro } @File{receiver.pro}
project file in @QDR. We'll create a dialog as our main window which
we'll use to invoke the dynamic dialog. Press @Option{Ctrl+N} to
launch the @Win{New File} dialog and click @OK to get the default
which is a dialog. Change the dialog's name to 'MainForm' and its
caption to 'Main Form'. Add two buttons, one called 'creditPushButton'
with the text '"&"Credit Dialog', and the other called
'quitPushButton' with the text '"&"Quit'. (For each button click the
@Option{Push Button} toolbar button, then click the form. Change the
properties in the property window to those we've just described.)}
@LI{
We will now add a couple of labels so that we can show the settings
the user chose in the dynamic dialog. Click the @Option{Text Label}
toolbar button, then click the form below the Credit Dialog button.
Change the label's @Prop{text} to 'Credit Rating'. Add another text
label below the Quit button. Change its @Prop{name} to 'ratingTextLabel'
and its @Prop{text} to 'Unrated'.
}
@LI{
We'll now lay out the widgets. Click the form then press @Option{Ctrl+G}
(lay out in a grid).
}
@LI{
We'll now handle the signals and slots connections. Invoke the
signals.and.slots @RawIndex{ Signals and Slots }
signals.and.slots.connecting.to.close.a.dialog @SubIndex{ Connecting
to Close a Dialog } @Win{View and Edit Connections} dialog and connect
the credit dialog button's clicked() signal to a new creditDialog()
custom slot (which is created by clicking the @Option{Edit Slots...}
button). Now connect the Quit button's
clicked @Index{ clicked() } @Func{clicked()} signal to the dialog's
accept @Index{ accept() } @Func{accept()} function.
}
@EndList
Save the form and call it @File{mainform.ui}. (Press @Option{Ctrl+S}
and enter the filename.) In the next section we'll write the
code for loading and launching the dynamic dialog directly in
@QDR.

@End @SubSubSection
@EndSubSubSections
@End @SubSection
@SubSection
    @Title { Loading and Executing a Dynamic Dialog }
    @Tag{loading.and.executing.a.dynamic.dialog}
@Begin
@LP
We'll now add the code to invoke the credit dialog. Before we
dynamic.dialogs @RawIndex{ Dynamic Dialogs }
dynamic.dialogs.loading.and.executing @SubIndex{ Loading and Executing }
dialogs @RawIndex{ Dialogs }
dialogs.dynamic @SubIndex{ Dynamic }
forms @RawIndex{ Forms }
forms.forward.declarations @SubIndex{ Forward declarations }
forward.declarations @Index{ Forward declarations }
includes @Index{ Includes }
can do this we need to add the widget factory's header file to
the form. Click the Source tab in the Object Hierarchy. Right
click Includes (in Implementation), then click @Option{New}. Type
in '@File{<qwidgetfactory.h>}', then press @Option{Enter}.
Because we will need to access the spin box in the dynamic dialog
we must add its header file. Right click Includes (in Implmentation),
then click @Option{New}. Type in '@File{<qspinbox.h>}', then
press @Option{Enter}.

@LP
In our main form we created a slot called @Func{creditDialog()}.
We will implement this slot directly in @QDR and use
it to load and execute the dynamic dialog. The code is taken
from @File{"qt/tools/designer/examples/receiver1/mainform.ui.h"}
which contains the @Cpp implementation of @File{mainform.ui}'s
qdialog @Index{ QDialog }
qwidgetfactory @Index{ QWidgetFactory }
qspinbox @Index{ QSpinBox }
slots.
@LD @Code @RawVerbatim @Begin
    void MainForm::creditDialog()
    {
        QDialog *creditForm = (QDialog *)
            QWidgetFactory::create( "../credit/creditformbase.ui" );
        // Set up the dynamic dialog here

        if ( creditForm->exec() ) {
            // The user accepted, act accordingly
            QSpinBox *amount = (QSpinBox *) creditForm->child( "amountSpinBox", "QSpinBox" );
            if ( amount )
                ratingTextLabel->setText( amount->text() );
        }
        delete creditForm;
    }
@End @RawVerbatim
The create @Index{ create() } @Func{create()} function is a static
@Class{QWidgetFactory} function. It loads the specified ui @Index{ .ui
} @File{.ui} file and returns a pointer to the toplevel
@Class{QWidget} created from the ui @Index{ .ui } @File{.ui} file. We
have cast the pointer to @Class{QDialog} since we know that the
@File{creditformbase.ui} file defines a @Class{QDialog}. After
creating the dialog we exec @Index{ exec() } @Func{exec()} it. If the
user clicked @OK the dialog returns Accepted and we enter the body of
the @Code{if} statement. We want to know the amount of credit that the
user selected. We call the child @Index{ child() } @Func{child()}
function on the dialog passing it the name of the widget we're
interested in. The child @Index{ child() } @Func{child()} function
returns a pointer to the widget with the name we passed, or returns 0
if no widget of that name was found. In the example we call child
@Index{ child() } @Func{child()} to get a pointer to the
'amountSpinBox'. If the pointer we get back is not 0 we set the rating
text to the amount in the dialog's spin box. At the end we delete the
dynamic dialog. Deleting the dialog ensures that we free up its
resources as soon as it is no longer required. @LP We used the child
@Index{ child() } @Func{child()} to gain access to a widget within the
dynamic dialog, passing it the name of the widget we were interested
in. In some situations we might not know what a widget is called. We
can access the first widget of a specified class by calling child
@Index{ child() } @Func{child()} with a null widget name and a
classname, e.g. @Func{child(0,"QPushButton")}. This will return a
pointer to the first @Class{QPushButton} it finds (or 0 if there isn't
one). If you want pointers to all the widgets of a given class you can
call the qobject.querylist @Index{ QObject::queryList() }
@Func{QObject::queryList()} function, passing it the name of the
class. It returns a @Class{QObjectList} pointer which points to every
object in the dialog that is derived from the given class. See the
online @Class{QObject} documentation for further details.

@BeginSubSubSections
@SubSubSection
    @Title { Implementing Slots for Dynamic Dialogs }
    @Tag{implementing.slots.for.dynamic.dialogs}
@Begin
@LP
There is one outstanding issue that we haven't addressed: the
signals.and.slots @RawIndex{ Signals and Slots }
signals.and.slots.dynamic.dialogs @SubIndex{ Dynamic Dialogs }
dynamic.dialogs @Index{ Dynamic Dialogs } dynamic dialog does not have
the behaviour of the original credit dialog because we have not
implemented the @Func{setAmount()} slot. We can implement slots for
dynamic dialogs by creating a @Class{QObject}qobject @Index{ QObject }
subclass. We then create an instance of this subclass and pass a
pointer to it to the @C{QWidgetFactory::create()} function which will
connect the dynamic dialog's signals to the slots implemented in our
subclass.

We need to create a @Class{QObject}qobject @Index{ QObject } subclass
and change our @Func{creditDialog()} qwidgetfactory.create @Index{
QWidgetFactory::create() } @Func{QWidgetFactory::create()} function
which will connect the dynamic dialog's signals to the slots
implemented in our subclass. to create an instance of our subclass
that can be passed to the
@Func{QWidgetFactory::create()} function. Here is the modified
qwidgetfactory.create @Index{ QWidgetFactory::create() }
@Func{creditDialog()} function from the qdialog @Index{ QDialog }
qwidgetfactory @Index{ QWidgetFactory } qspinbox @Index{ QSpinBox }
@File{"qt/tools/designer/examples/receiver2/mainform.ui.h"} file that
contains the code for @File{mainform.ui}'s slots:
@LD @Code @RawVerbatim @Begin
    void MainForm::creditDialog()
    {
        Receiver *receiver = new Receiver;
        QDialog *creditForm = (QDialog *)
        QWidgetFactory::create( "../credit/creditformbase.ui", receiver );
        receiver->setParent( creditForm );

        // Set up the dynamic dialog here

        if ( creditForm->exec() ) {
            // The user accepted, act accordingly
            QSpinBox *amount = (QSpinBox *) creditForm->child( "amountSpinBox", "QSpinBox" );
            if ( amount )
                ratingTextLabel->setText( amount->text() );
        }

        delete receiver;
        delete creditForm;
    }
@End @RawVerbatim
We create a new instance of our 'Receiver' subclass. (We'll write the
code for this class shortly.) We then create the
@Class{QDialog}qdialog @Index{ QDialog } using qwidgetfactory.create
@Index{ QWidgetFactory::create() } @Func{QWidgetFactory::create()}.
This call differs from our previous example because we pass in the
subclass object so that the create @Index{ create() } @Func{create()}
function can set up the signals"/"slots connections automatically for
us. Since our slot must access the widgets in the dynamic form we pass
a pointer to the form to the receiver object through our
@Func{setParent()} function. The remainder of the function is the same
as before except that we delete our receiver object.
@LP
Since we are using the 'Receiver' subclass in our main form we
must include its header file. In @Win{Object Explorer}'s Members
tab, right click Includes (in Implmentation), then click @Option{New}.
Type in '@File{receiver.h}', then press @Option{Enter}.

@LP
We'll now look at the implementation of our 'Receiver' subclass.
dynamic.dialogs @Index{ Dynamic Dialogs }
The code is taken from
@File{"qt/tools/designer/examples/receiver2/receiver.h"}
and the corresponding @File{receiver.cpp} file. We'll
qobject @Index{ QObject }
qdialog @Index{ QDialog }
start with the header file.
@LD @Code @RawVerbatim @Begin
#include <qobject.h>
#include <qdialog.h>

class Receiver : public QObject
{
    Q_OBJECT
public:
    void setParent( QDialog *parent );
public slots:
    void setAmount();
private:
    QDialog *p;
};
@End @RawVerbatim

Our class must be a @Class{QObject}qobject @Index{ QObject } subclass
and because we're using macros @RawIndex{ Macros } macros.q.object
@SubIndex{ Q_OBJECT } q.object @RawIndex{ Q_OBJECT } q.object.macros
@SubIndex{ Macros } signals and slots it must include the
@Code{Q_OBJECT} macro. We declare a function and the
@Func{setAmount()} slot that we wish to implement as well as a private
@Class{QDialog}qdialog @Index{ QDialog } pointer.

@LP
The implementation requires the header files of the classes it
uses:
@LD @Code @RawVerbatim @Begin
    #include <qradiobutton.h>
    #include <qspinbox.h>
    #include "receiver.h"
@End @RawVerbatim
We'll discuss the implementation of each function in @File{receiver.cpp}
qdialog @Index{ QDialog }
separately.
@LD @Code @RawVerbatim @Begin
    void Receiver::setParent( QDialog *parent )
    {
        p = parent;
        setAmount();
    }
@End @RawVerbatim
@LP
The @Func{setParent()} function assigns a pointer to the dynamic
dialog to our private pointer. We could not do this in a constructor
call because we have to construct our Receiver object before we call
qwidgetfactory.create @Index{ QWidgetFactory::create() }
@Func{QWidgetFactory::create()}, since we must pass the Receiver
object to the create @Index{ create() } @Func{create()} function. Once
we've called create @Index{ create() } @Func{create()} we then have a
pointer to the dynamic dialog which we can then pass via
@Func{setParent()} to our Receiver class. In the subclass version of
this example we called @Func{setAmount()} in the constructor; but we
cannot do that here because the implementation of @Func{setAmount()}
depends on knowledge of the dynamic dialog which is not available at
construction time. Because of this we call @Func{setAmount()} in the
qspinbox @Index{ QSpinBox }
qradiobutton @Index{ QRadioButton }
@Func{setParent()} function.
@LD @Code @RawVerbatim @Begin
    void Receiver::setAmount()
    {
        QSpinBox *amount =
            (QSpinBox *) p->child( "amountSpinBox", "QSpinBox" );

        QRadioButton *radio =
            (QRadioButton *) p->child( "stdRadioButton", "QRadioButton" );
        if ( radio && radio->isChecked() ) {
            if ( amount )
                amount->setValue( amount->maxValue() / 2 );
            return;
        }

        radio =
            (QRadioButton *) p->child( "noneRadioButton", "QRadioButton" );
        if ( radio && radio->isChecked() )
            if ( amount )
                amount->setValue( amount->minValue() );
    }
@End @RawVerbatim
Since we may be updating the amount spin box we need to get a pointer
to it. We call child @Index{ child() } @Func{child()} on the pointer
@Code{p} which points to the dynamic dialog assigned in the
@Func{setParent()} call. We cast the resulting pointer to the correct
type so that we can call any functions relevant to that type. In the
example we call child @Index{ child() } @Func{child()} to get a
pointer to the amount spin box, and then call child @Index{ child() }
@Func{child()} again to get a pointer to the 'stdRadioButton'. If we
get a pointer to the radio button and the button is checked we set the
amount providing we have a pointer to the amount spin box. If this
radio button was checked we're finished so we return. If the
'stdRadioButton' isn't checked we get a pointer to the
'noneRadioButton' and set the amount if this button is checked. We do
nothing if the 'specialRadioButton' is checked because the user is
free to enter a value of their choice.
@LP
{ Compiling vs Dynamically Loading Dialogs} @Sidebar {
The differences between using a 'compiled in' dynamic.dialogs
@RawIndex{ Dynamic Dialogs } dynamic.dialogs.compared.with.compiling
@SubIndex{ Compared with Compiling } dynamic.dialogs @RawIndex{
Dynamic Dialogs } dynamic.dialogs.subclassing @SubIndex{ Subclassing }
subclassing @RawIndex{ Subclassing } subclassing.dynamic.dialogs
@SubIndex{ Dynamic Dialogs } ui @Index{ .ui } @File{.ui} file and a
dynamically loaded ui @Index{ .ui } @File{.ui} file are these:
@NumberedList
@LI{
Dynamic dialogs cannot have any @Cpp code in the ui @Index{ .ui }
@File{.ui} file; any custom slots must be implemented via a
@Class{QObject} subclass. Compiled dialogs can contain code either in
the ui @Index{ .ui } @File{.ui} file or in a subclass.}
@LI{
Dynamic dialogs will load slower because the ui @Index{ .ui }
@File{.ui} file must be read and a @Class{QWidget} instance
instantiated based on the ui @Index{ .ui } @File{.ui} file's parse
tree. Compiled code will load much faster because no file reading or
parsing is necessary. Note that the user may not notice any difference
in speed since the difference may be mere fractions of a second.}
@LI{
Dynamic dialogs allow you to change the ui @Index{ .ui } @File{.ui}
file independently of the code so long as none of the changes impact
the code. This means that you can change the appearance of the form,
e.g. move widgets and lay them out differently. If you want to change
a compiled dialog you must change the ui @Index{ .ui } @File{.ui} file
and recompile. If you are building an application and want your
customers to be able to customize aspects of the user interface you
can give them a copy of @QDR (if your license permits this) and use
dynamic dialogs.}
@EndList
}
@End @SubSubSection
@EndSubSubSections
@End @SubSection
@EndSubSections
@End @Section
@EndSections
@End @Chapter
