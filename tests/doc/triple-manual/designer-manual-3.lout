@Chapter
    @Title { Creating a Main Window Application }
    @Tag { creating.a.main.window.application }
@Begin
@LP
In this chapter and in chapter three we will create a small but
complete Qt application. This chapter will cover the main window,
and the next chapter covers the dialogs.

@LP
The application is called @File{colortool}; it is used
to associate names with colors. The application is a standard
main window application with some custom dialogs to facilitate
some of the user interaction.

@BeginSections
@Section
    @Title { The Color Tool Application }
    @Tag { the.color.tool.application }
@Begin
@Figure
    @Caption { colortool -- icon view }
    0.45 @Scale @IncludeGraphic { "images/mw-colortool1.eps.gz" }
@LP
The @File{colortool} application is a multiplatform application
that allows users to create, edit and save lists of colors. Each
color has a user defined name and an RGB (Red, Green, Blue) value.

@LP
This application presents the user with a view of a set of colors and
their names. We will provide two views (using a
@Class{QWidgetStack}qwidgetstack @Index{ QWidgetStack }) which the
user can switch between. The tabular view will show each color as a
small square followed by its name and hex value. It will also provide
the option of an indicator to show whether or not the color is one of
the 216 standard web colors. The iconic view will show each color as a
circular color swatch with the name of the color beneath.

@LP
The application will read and write files in the format used
by the X Consortium for the @File{rgb.txt} file. This
will allow our users to create their own color files and to load,
edit and save @File{rgb.txt} format files.

@LP
We will provide a simple search option so that users can quickly
locate a color: this is particularly useful when hundreds or
thousands of colors are shown. The search will be provided in
a modeless dialog so that the user can search and still interact
with the main form. We will also allow the user to add and delete
colors, and to set some user options; providing these facilities
will require us to create some modal dialogs.

@LP
Finally we'll ensure that the application loads user options
at start up and saves user options at termination. We will also
include the view and the size and position of the main window
with these options, so that the application will always start
with the size, position and view it had when the user last used
it.

@Figure
    @Caption { colortool -- list view }
    0.45 @Scale @IncludeGraphic { "images/mw-colortool2.eps.gz" }

@End @Section
@Section
    @Title { Starting and Exiting @QDR }
    @Tag { starting.and.exiting.qt.designerx }
@Begin
@LP
@QDR is controlled in the same way as any other modern
desktop application. To start @QDR under Windows click
the @Option{Start} button and click @Option{Programs"|"Qt X.x.x"|"Designer}.
(X.x.x is the Qt version number, e.g. 3.1.0.) If you're running
a Unix or Linux operating system you can either double click
the @QDR icon or enter @File{designer "&"}
in an @File{xterm}.
starting.qt.designer @Index{ Starting Qt Designer }

@LP
When @QDR starts it shows the @Win{New"/"Open} dialog.
(If you prefer the old behavior, check the @Option{Don't show this dialog
in the future} checkbox.) We'll just click @Cancel to skip
over it.

@Figure
    @Caption { The New"/"Open dialog }
    0.45 @Scale @IncludeGraphic { "images/mw-startdesign.eps.gz" }
@LP
When you've finished using @QDR click @Option{File"|"Exit};
you will be prompted to save any unsaved changes. Help is available
by pressing @Option{F1} or from the @Option{Help} menu.
exiting.qt.designer @Index{ Exiting Qt Designer }
getting.help @Index{ Getting Help }

@LP
To get the most benefit from the tutorial chapters we recommend
that you start @QDR now and create the example application
as you read. Most of the work involves using @QDR's
menus, dialogs and editors. The code can be entered directly
using @QDR's code editor; you can cut and paste it
from the on-line version of this manual or copy it from the example
source code. We recommend typing (or cut and pasting) as you
work through this manual.

@LP
When you start @QDR, by default, you will see a menu bar and various
toolbars at the top. widgets.and.source.window @RawIndex{ Widgets and
Source window } widgets.and.source.window.object.explorer @SubIndex{
Object Explorer } object.explorer @Index{ Object Explorer } pixmaps
@Index{ Pixmaps } On the left is the new Toolbox. This contains
buttons which you click to reveal a particular set of tools. On the
right there are three windows: the first is the @Win{Project Overview}
window, the second is the @Win{Object Explorer} and the third is the
@Win{Properties"/"Editor Signal Handlers} window. The @Win{Project
Overview} window lists the files and images associated with the
project; to open any form (@File{.ui} file), or the code associated
with it (in the @File{.ui.h} file), simply single click it. The
@Win{Object Explorer} window lists the current form's widgets and
members. The @Win{Properties"/"Editor} window is used to view and
change the properties of forms and widgets. We will cover the use of
@QDR's windows, dialogs, menu options and tools as we create the
example application.

@End @Section
@Section
    @Title { Creating the Project }
    @Tag { creating.the.projectx }
@Begin
@LP
Our @File{colortool} application is going to be a standard
@Cpp application, so we need to create a @Cpp project and add our
files and code to this project.

@LP
{ Using Projects } @Sidebar {
Whenever you create a new application we @I{strongly} recommend that
you create a project file and open the project rather than individual
@PageMark{creating.a.project.sidebar} projects @Index{ Projects }
projects @RawIndex{ Projects } projects.creating.new @SubIndex{
Creating New } creating.projects @RawIndex{ Creating Projects }
creating.projects.projects @SubIndex{ Projects } pixmaps @RawIndex{
Pixmaps } pixmaps.in.projects @SubIndex{ In Projects } pixmaps
@RawIndex{ Pixmaps } pixmaps.adding.to.forms @SubIndex{ Adding to
Forms } ui @Index{ .ui } @File{.ui} files. Using a project has the
advantage that all the forms you create for the project are available
via a single mouse click rather than having to be loaded individually
through file open dialogs. An additional benefit of using project
files is that they allow you to store all your images in a single file
rather than duplicate them in each form in which they appear. See
@NamePageRef{the.designer.approach} chapter's
@NamePageRef{project.management} section for detailed information on
the benefits of using project files.
@SidebarPP
Project files use the @File{.pro} suffix and are used
by the @File{qmake} tool to create makefiles for the relevant
target platforms.
}
@LP
Create a new project as follows:
@NumberedList
@LI{
Click @Option{File"|"New} to invoke the @Win{New File} dialog.
}
@LI{
Click @Option{@Cpp Project} to create a @Cpp project, then click @OK
to pop up the @Win{Project Settings} dialog.
}
@LI{
Click the ellipsis button to invoke the @Win{Save As} dialog. Use
this dialog to navigate to where you want to create the new project,
ideally creating a new folder for it (e.g. called @File{colortool}),
using the @Option{Create New Folder} toolbar button.
}
@LI{
Enter a filename of @File{colortool.pro}, then click @OK. The project's
name will now be @File{colortool}; click @OK to close the
@Win{Project Settings} dialog.
@LLP
@Figure
    @Caption { The Project Settings dialog }
    @Location { Raw }
    0.45 @Scale @IncludeGraphic { "images/mw-projset.eps.gz" }

}
@LI{
Click @Option{File"|"Save} to save the project.
}
@EndList
@Figure
    @Caption { The New File dialog }
    0.45 @Scale @IncludeGraphic { "images/mw-newfile.eps.gz" }
@LP
The @Win{New File} dialog is used to create all the files that
can be used in a @QDR project. This includes @Cpp source
files, an automatically generated @File{main.cpp} file
(if you are in a project), and a variety of forms based on pre-defined
templates. (You can create your own templates too.)

@LP
For the @File{colortool} application we want to start with a main
window form. When we create this form, @QDR will present a wizard
which we can use to automatically create menu and toolbar options and
automatically create the relevant signal"/"slot connections. For every
menu option or toolbar button, @QDR will create a single
@Class{QAction}qaction @Index{ QAction } (see the ``Actions and Action
Groups'' @PageRef{actions.and.action.groups.sidebar} sidebar).
@End @Section
@Section
    @Title { Creating the Main Window }
    @Tag { creating.the.main.window }
@Begin
@LP
We will use the main window wizard to build a main window. The
wizard allows us to create actions and a menu bar and a toolbar
through which the user can invoke the actions. We will also create
our own actions, menus and toolbar buttons, and add a main widget
main.window @RawIndex{ Main Window }
main.window.creating @SubIndex{ Creating }
creating.main.windows @Index{ Creating Main Windows }
main.window @RawIndex{ Main Window }
main.window.wizard @SubIndex{ Wizard }
wizards @RawIndex{ Wizards }
wizards.main.window @SubIndex{ Main Window }
creating.menus @Index{ Creating Menus }
menus @RawIndex{ Menus }
menus.adding @SubIndex{ Adding }
adding @RawIndex{ Adding }
adding.menus @SubIndex{ Menus }
creating.toolbars @Index{ Creating Toolbars }
toolbars.creating @Index{ Toolbars, Creating }
toolbar.buttons @RawIndex{ Toolbar Buttons }
toolbar.buttons.adding @SubIndex{ Adding }
adding @RawIndex{ Adding }
adding.toolbars @SubIndex{ Toolbars }
adding @RawIndex{ Adding }
adding.actions.and.action.groups @SubIndex{ Actions and Action Groups }
adding @RawIndex{ Adding }
adding.toolbar.buttons @SubIndex{ Toolbar Buttons }
to the main window.
@LP
Click @Option{File"|"New} to invoke the @Win{New File} dialog, click
@Option{Main Window} to create a main window form, then click @OK.
A new @Class{QMainWindow}qmainwindow @Index{ QMainWindow } form will
be created and the @Win{Main Window Wizard} will pop up.

@LP
Click @Option{File"|"Save} to save the form as @File{mainform.ui}.

@BeginSubSections
@SubSection
    @Title { Using the Main Window Wizard }
    @Tag{using.the.main.window.wizard}
@Begin
@BulletList
@LI{
The @Win{Choose available menus and toolbars} wizard page appears
first. It presents three categories of default actions, File
Actions, Edit Actions and Help Actions. For each category you
can choose to have @QDR create menu items, toolbar
buttons and signal"/"slots connections for the relevant actions.
You can always add or delete actions, menu items, toolbar buttons
and connections later.
@LP
We will accept the defaults for File Actions and for the Edit
Actions, i.e. have menu items, toolbar buttons and the relevant
connections created. In fact we'll be changing the Edit actions
considerably later on, but it is still convenient to create them
now. We won't have any Help Actions on the toolbar so uncheck
the Help Action's Toolbar checkbox. Click @Option{Next} to move on
to the next wizard page.
creating.menus @Index{ Creating Menus }
menus @RawIndex{ Menus }
menus.adding @SubIndex{ Adding }
creating.toolbars @Index{ Creating Toolbars }
toolbars.creating @Index{ Toolbars, Creating }
toolbar.buttons @RawIndex{ Toolbar Buttons }
toolbar.buttons.adding @SubIndex{ Adding }
adding @RawIndex{ Adding }
adding.menus @SubIndex{ Menus }
adding @RawIndex{ Adding }
adding.toolbars @SubIndex{ Toolbars }
adding @RawIndex{ Adding }
adding.actions.and.action.groups @SubIndex{ Actions and Action Groups }
adding @RawIndex{ Adding }
adding.toolbar.buttons @SubIndex{ Toolbar Buttons }
signals.and.slots @RawIndex{ Signals and Slots }
signals.and.slots.connecting.actions @SubIndex{ Connecting Actions }
@Figure
    @Caption { The Main Window Wizard: Choosing menus and toolbars }
 0.45 @Scale @IncludeGraphic { "images/mw-menuwiz.eps.gz" }}
@LI{
The @NamePageRef{setup.toolbar} wizard page is used to populate a toolbar
with actions from each of the default action categories. The
Category combobox is used to select which set of actions you
wish to work on. The Actions list box lists the actions available
for the current category. The Toolbar [p.~@PageOf{the.toolbar}] listbox lists the toolbar
buttons you want to create. The blue left and right arrow buttons
are used to move actions into or out of the Toolbar list box.
The blue up and down arrow buttons are used to move actions up
and down within the Toolbar list box. Note that the '<Separator>'
item in the Actions list box may be moved to the Toolbar list
box as often as required and will cause a separator to appear
in the finished toolbar.
creating.toolbars @Index{ Creating Toolbars }
toolbars.creating @Index{ Toolbars, Creating }
toolbar.buttons @RawIndex{ Toolbar Buttons }
toolbar.buttons.adding @SubIndex{ Adding }
adding @RawIndex{ Adding }
adding.toolbar.buttons @SubIndex{ Toolbar Buttons }
separator @RawIndex{ Separator }
separator.menu.item @SubIndex{ Menu item }
separator @RawIndex{ Separator }
separator.toolbar.button @SubIndex{ Toolbar button }
@LP
Copy the New, Open and Save Actions to the Toolbar list box.
Copy a <Separator> to the Toolbar list box. Change the Category
to Edit and copy the Cut Copy and Find actions to the Toolbar
list box. Click @Option{Next} and then click @Option{Finish}.
@Figure
    @Caption { The Main Window Wizard: Setting up the toolbar }
    0.45 @Scale @IncludeGraphic { "images/mw-settoolwiz.eps.gz" }}
@EndList
@LP
If you preview the form (@Option{Ctrl+T}) the File and Edit menus
will be available and you'll be able to drag the toolbar either
into an independent window of its own, or to dock it to the left,
right, bottom or top of the window. The menus and toolbars are
not yet functional, but we will rectify this as we progress.
You leave preview mode by clicking the form's Close box (or the
platform-specific equivalent).
@Figure
    @Caption { Previewing the form }
    0.45 @Scale @IncludeGraphic { "images/mw-previewform.eps.gz" }
@LP
Now that we've created the form we will need to change some of
its properties. (See the ``Using the Property Editor''
@PageRef{using.the.property.editor.sidebar} sidebar.)
@LP
{ Actions and Action Groups } @Sidebar {
An @PageMark{actions.and.action.groups.sidebar} @I{action} is an
operation that the user initiates through the user interface, for
example, saving a file or changing some text's font weight to bold.
@SidebarPP
We often want the user to be able to perform an action using a variety
of means. For example, to save a file we might want the user to be
able to press @Option{Ctrl+S}, or to click the @Option{Save} toolbar button or
to click the @Option{File"|"Save} menu option. Although the means of
invoking the action are all different, the underlying operation is the
same and we don't want to duplicate the code that performs the
operation. In Qt we can create an action (a @Class{QAction}qaction @Index{
QAction } object) which will call the appropriate function when the
action is invoked. We can assign an accelerator, (e.g. @Option{Ctrl+S}), to
an action. We can also add an action to a menu and to a toolbar.
@SidebarPP
If the action has an on"/"off state, e.g. bold is on or off,
when the user changes the state, for example by clicking a toolbar
button, the state of everything associated with the action, e.g.
menu items and toolbar buttons, are updated.
@SidebarPP
Some actions should operate together like radio buttons. For example,
if we have left align, center align and right align actions, only one
should be 'on' at any one time. An @I{action group} (a
@Class{QActionGroup}qactiongroup @Index{ QActionGroup } object) is used to
group a set of actions together. If the action group's @Prop{exclusive} property is @TRUE then only one of the actions in
the group can be on at any one time. If the user changes the state of
an action in an action group where @Prop{exclusive} is @TRUE,
everything associated with the actions in the action group, e.g. menu
items and toolbar buttons, are updated.
@SidebarPP
@QDR can create actions and action groups visually,
assign accelerators to them, and associate them with menu items
and toolbar buttons.
actions.and.action.groups @Index{ Actions and Action Groups }
}
@End @SubSection
@SubSection
    @Title { Setting Properties }
    @Tag{setting.properties}
@Begin
@LP
Click the form. This will make all the form's properties appear
in the Property Editor. Change the form's @Prop{name} to `MainForm'
and its @Prop{caption} to `Color Tool'.

@LP
The main window wizard created a few slots and actions that are
not relevant to our application, so we'll delete them.

@LP
Click the @Win{Object Explorer}'s @Option{Members} tab. Right click the @Func{filePrint()}
slot, then click @Option{Delete} from the popup menu. In the same way
delete the @Func{editUndo()}, @Func{editRedo()} and @Func{editPaste()} slots. (Right
click @Func{editUndo()}, then click @Option{Delete}, etc.) Later we'll see how
to create new slots when we add further functionality to the
application.

@LP
Right click the filePrintAction action in the Action Editor window,
then click @Option{Delete Action} from the popup menu. In the same way
delete the editUndoAction, editRedoAction and editPasteAction
actions.

@LP
One side effect of these deletions is that the menus now have
some redundant separators.

@LP
{Using the Property Editor} @Sidebar {
    @Tbl
	#rule { yes } rulecolour {red}
	margin { 0c }
	cmarginabove { 0.666f }
	bformat { @Cell A | @Cell width { 4.333c } indent { right } iv { ctr } B }
	cformat { @StartHSpan @Cell A | @HSpan }
    {
	@Rowb A { 
The Property Editor has two columns, the Property column which
lists property names and the Value column which lists the values.
Some property names have a plus sign '+' in a square to their
left; this signifies that the name is the collective
name for a set of related properties. Click a form or widget
to make the Property Editor show its properties.
@PageMark{using.the.property.editor.sidebar}
using.the.property.editor @Index{ Using the Property Editor }
properties @Index{ Properties }
@SidebarPP
For example, click the @Prop{sizePolicy} property's plus sign to
reveal the hSizeType, vSizeType, horizontalStretch and verticalStretch
properties. The revealed properties can be edited just like any other
properties.
@SidebarPP
If you want to set a property to the same value for a whole set of widgets,
(e.g. to give them all a common cursor, tooltip,
color, etc.), @Option{Click} one of the widgets, then
@Option{Shift+Click} the others to select them all. (Alternatively,
click the first widget's name in @Win{Object Explorer}, then
@Option{Shift+Click} all the others in @Win{Object Explorer}: this
technique is especially useful for forms with lots of nested widgets
and layouts.) Their common properties will be shown in the
property editor, and any change made to one property will be made to
that same property for all the selected widgets.
@SidebarPP
Some properties have simple values, such as text or a number. To
change a text value click the existing text and type in your new text.
To change a numeric value click the value and either type in a new
number, or use the spin buttons to increase or decrease the existing
number until it reaches the value you want. Some properties have a
fixed list of values. If you click the @Prop{cursor} property property
the value will be shown in a drop down combobox; click the down arrow
to see what values are available. 
	    }
	    B {
@Figure
    @Location { Raw }
    @Caption { The Property Editor }
    0.45 @Scale @IncludeGraphic { "images/mw-propedit.eps.gz" }
}
	@Rowc A {
Some properties have complex sets of values or special values; for
example the @Prop{font} property and the @Prop{iconSet} property. If
you click the font property an ellipsis button (@Option{...}) will
appear; click this button and a @Win{Select Font} dialog will pop up
which you can use to change any of the font settings. Other properties
have ellipsis buttons which lead to different dialogs depending on
what settings the property can have. For example, if you have a lot of
text to enter for a @Prop{text} property you could click the ellipsis
button to invoke the @Win{Multi-line Edit} dialog.
@SidebarPP
The names of properties which have changed are shown in bold.
If you've changed a property but want to revert it to its default
value click the property's value and then click the red 'X' button
to the right of the value. Some properties have an @I{initial}
value, e.g. 'TextEdit1', but no default value; if you revert
a property that has an initial value but no default value (by
clicking the red 'X') the value will become empty unless the
properties @RawIndex{ Properties }
properties.reverting.changes @SubIndex{ Reverting changes }
properties @RawIndex{ Properties }
properties.initial.values @SubIndex{ Initial values }
property, e.g. name, is not allowed to be empty.
The property editor also supports Undo and Redo (@Option{Ctrl+Z}
undo.and.redo @RawIndex{ Undo and Redo }
undo.and.redo.properties @SubIndex{ Properties }
properties @RawIndex{ Properties }
undo.and.redo.undo.and.redo @SubSubIndex{ Undo and Redo }
redo @RawIndex{ Redo }
redo.undo.and.redo @SubIndex{ Undo and Redo }
and @Option{Ctrl+Y}).
	}
}
}
@LP
Click the form's @Option{File} menu. (Note, we're clicking our newly
created form's @Option{File} menu, not @QDR's @Option{File}
menu!) There are @I{two} separators above the Exit menu option
(the @Option{File"|"Print} option was in-between until we deleted
it). Right click one of these separators, then click @Option{Delete
Separator}.
Don't worry if you miss and delete a menu option by accident:
if you delete the wrong thing click @Option{Edit"|"Undo} to undelete.
The form's @Option{Edit} menu has a redundant separator at the top
(the undo and redo options were there). Delete this separator
in the same way. (Click the form's @Option{Edit} menu, right click
the separator, click @Option{Delete Separator}.) Again, don't worry if
you delete a menu option by mistake, just press @Option{Ctrl+Z} to
undo.

@LP
Click @Option{File"|"Save} to save the form.

@LP
The form can now be previewed by clicking @Option{Preview"|"Preview
Form} (or press @Option{Ctrl+T}).

@End @SubSection
@SubSection
    @Title { Adding Custom Actions }
    @Tag{adding.custom.actions}
@Begin
@LP
We want to provide the user with actions that are specific to
our application. We want to provide the ability to switch between
the two views we will be offering, and allow the user to add
colors and set their preferred options. We'll prepare the way
by creating a new menu for the view options and by adding a separator
to the toolbar.

@LP
Right click the form's menu bar to pop up its context menu, then
click the @Option{Add Menu Item} option. This creates a new menu item
called `Menu' to the right of the existing menu bar items. Click
`Menu' and drag it to the left of the `Help' menu and release
it there. (A vertical red line indicates its position.) Right
click @Option{Menu}, then click @Option{Rename Menu Item}. Change its name
to `"&"View'. The "&" (ampserand) makes the following letter
an @Option{Alt} key accelerator (i.e. in this case @Option{Alt+V} will
pop up the @Option{View} menu).

@LLP
{ Duplicate Accelerators } @Sidebar {
In an application that has dialogs with lots of widgets it is
easy to accidentally duplicate accelerators. @QDR
provides the @Option{Edit"|"Check Accelerators} menu option (@Option{Alt+R})
which will highlight any two or more widgets which have the same
accelerators, making it easy to spot the problem if it occurs.
}
@LP
We could create a new toolbar for the view menu items, but instead
we'll put a separator at the end of the existing toolbar and add the
view options after the separator. (Alternatively we could have created
an entirely new toolbar. See the ``Creating and Populating Toolbars''
@PageRef{creating.and.populating.toolbars} sidebar for more
information on doing this.) Right click the right-most toolbar button
(@Option{Find}), then click @Option{Insert Separator}.

@Figure 
    @Caption { Adding a new menu }
    0.666 @Scale @IncludeGraphic { "images/mw-addmenuitem.eps.gz" }

@LP
Now we'll create our form's custom actions.
//0c
{ Creating and Populating Toolbars } @Sidebar {
A @PageMark{creating.and.populating.toolbars} new toolbar is created
by right clicking on the menu bar (or to the right of the existing
toolbar(s)) then clicking @Option{Add Toolbar}. The new toolbar is
empty and is visible only by its @I{toolbar handle}. (Toolbar handle's
are usually represented as a gray area containing either two thick
vertical lines or with many small pits).
creating.toolbars @Index{ Creating Toolbars }
adding @RawIndex{ Adding }
adding.toolbars @SubIndex{ Toolbars }
toolbars.creating @Index{ Toolbars, Creating }
@LLP
@Figure
    @Location { Raw }
    @Caption { Toolbar Handle }
    0.75 @Scale @IncludeGraphic { "images/mw-toolbarpits.eps.gz" }
@LP
Actions are added to toolbars simply by dragging them from the
Action Editor to the toolbar, and dropping them on the toolbar
in the position we want them. (The position is indicated by a
vertical red line.)
actions.and.action.groups @RawIndex{ Actions and Action Groups }
actions.and.action.groups.adding.to.a.toolbar @SubIndex{ Adding to a Toolbar }
separator @RawIndex{ Separator }
separator.toolbar.button @SubIndex{ Toolbar button }
adding @RawIndex{ Adding }
adding.actions.and.action.groups.to.a.toolbar @SubIndex{ Actions and Action Groups to a Toolbar }
adding @RawIndex{ Adding }
adding.toolbar.separators @SubIndex{ Toolbar Separators }
@LLP
@Figure
    @Location { Raw }
    @Caption { Dragging the action group to the toolbar }
 0.75 @Scale @IncludeGraphic { "images/mw-dragaction.eps.gz" }
@LP
All the actions in an action group are added to a toolbar in
one go, simply by dragging the action group from the Action Editor
and dropping it on the toolbar.
@SidebarPP
Since toolbar buttons normally only show an image, all actions
that are to be used in toolbars should have their @Prop{iconSet}
property set to a suitable image.
@SidebarPP
Toolbar buttons and separators (usually represented as indented
vertical gray lines), can be dragged and dropped into new positions
in the toolbar at any time. Separators can be inserted by right
clicking a toolbar button and clicking @Option{Insert Separator}.
Toolbar buttons and separators can be deleted by right clicking
them and then clicking @Option{Delete Item}. Toolbars can be deleted by
right clicking their toolbar handle and then clicking @Option{Delete
Toolbar}.
separator @RawIndex{ Separator }
separator.toolbar.button @SubIndex{ Toolbar button }
deleting @RawIndex{ Deleting }
deleting.toolbar.separators @SubIndex{ Toolbar Separators }
deleting @RawIndex{ Deleting }
deleting.toolbars @SubIndex{ Toolbars }
@SidebarPP
If you preview an application you'll find that all the toolbars
can be dragged to different docking points (top, left, right
and bottom of a @Class{QMainWindow}qmainwindow @Index{ QMainWindow } or subclass), or dragged out
of the application as independent tool windows.
previewing @RawIndex{ Previewing }
previewing.toolbars @SubIndex{ Toolbars }
@LLP
@Figure
    @Location { Raw }
    @Caption { Toolbar with all the actions added }
 0.75 @Scale @IncludeGraphic { "images/mw-actiongroup.eps.gz"
}
@SidebarPP
@Heading { Adding Widgets to the Toolbar{@PageMark{adding.widgets.to.the.toolbar}} }
@SidebarPP
Sometimes a simple button is insufficient for our needs. For
example, if we wanted the user to be able to choose a font name
and font size from the toolbar we might want to provide a direct
means rather than having a toolbar button launch a font dialog.
toolbars @RawIndex{ Toolbars }
toolbars.adding.widgets @SubIndex{ Adding Widgets }
widgets @RawIndex{ Widgets }
widgets.adding.to.toolbars @SubIndex{ Adding to Toolbars }
adding @RawIndex{ Adding }
adding.widgets @SubIndex{ Widgets }
@SidebarPP
It is perfectly feasible to add @I{ComboBox}es and @I{SpinBox}es
to toolbars. For example, a @I{ComboBox} could be used to list
the available font names and the @I{SpinBox} used to select a
font size.
widgets @RawIndex{ Widgets }
widgets.combobox @SubIndex{ ComboBox }
widgets @RawIndex{ Widgets }
widgets.spinbox @SubIndex{ SpinBox }
separator @RawIndex{ Separator }
separator.toolbar.button @SubIndex{ Toolbar button }
@SidebarPP
Although you can put any widget into a toolbar we recommend that
widgets which can be associated with an action should @I{not}
be added to the toolbar directly. For these widgets, i.e. menu
items, toolbar buttons and lists of items, you should create
an action (drop down action for a list of items), associate the
action with the widget, and add the action to the toolbar. Widgets
that can sensibly be inserted directly into a toolbar are @I{ComboBox}es,
@I{SpinBox}es and @I{Line Edit}s.
}

@BeginSubSubSections
@SubSubSection
    @Title { Adding the Options Action }
    @Tag{adding.the.options.action}
@Begin
@LP
Right click the first action in the @Win{Action Editor}, then click
@Option{New Action}. The @Win{Property Editor} now shows the new action's
properties. Change the action's name to `optionsAction'. Click
the @Option{...} button on the @Prop{iconSet} property to pop up the
@Win{Choose an Image} dialog. Click the @Option{Add...} button to pop
up the @Win{Choose Images...} file selection dialog. Navigate to
@File{"qt/tools/designer/pics/small"}; click the
@File{tabwidget.png} image, then click @Option{Open}. The @File{tabwidget.png} image now appears highlighted in the
@Win{Choose an Image} dialog; click @OK to use it. Change the
@Prop{text} property to `Options' and change the @Prop{menuText} property
to `"&"Options...'.

@LP
Click the optionsAction in the Action Editor and drag it to the
Edit menu. The Edit menu will pop up; drag the optionsAction
down the menu (a horizontal red line indicates its position),
and drop it at the end after the `Find' option.

@LP
Since we also want to make this option available from the toolbar,
click the optionsAction again, and this time drag it to the toolbar.
Drop it to the left of the scissors (Cut) toolbar button. (A
horizontal red line indicates its position during the drag.)

@LP
The options action ought to be visually separated from the other
Edit menu options. Click the form's @Option{Edit} menu, then right click
the @Option{Find} option, then click @Option{Insert Separator}.

@LP
We'll connect and code this action later.

@End @SubSubSection
@SubSubSection
    @Title { Adding the Add Action }
    @Tag{adding.the.add.action}
@Begin
@LP
Right click the first action in the @Win{Action Edito}r, then click
@Option{New Action}. Change the action's @Prop{name} property to
`editAddAction'.
Change its @Prop{iconSet} property to @File{widgetstack.png}.
(Click the @Prop{iconSet} property's ellipsis button, click @Option{Add...},
click @File{widgetstack.png}, then click @Option{Open}, then
click @OK.) Change the @Prop{text} property to `Add' and the
@Prop{menuText} property to `"&"Add...'. Change the @Prop{accel} property
to `Ctrl+A'.

@LP
Click the editAddAction and drag it to be the first item in the
Edit menu. (Drag it to the edit menu and drop it when the horizontal
red line is above the `Cut' menu option.)

@LP
Click the editAddAction again, and this time drag it to the toolbar.
Drop it to the left of the scissors (Cut) toolbar button.

@End @SubSubSection
@SubSubSection
    @Title { Tidying Up }
    @Tag{tidying.up}
@Begin
@LP
We're going to use `Cut' for deleting colors, so we'll change
the user-visible name to `Delete' to make its meaning clearer.
Click the editCutAction in the Action Editor to make its properties
appear in the Property Editor. Change its @Prop{text} property to
`Delete' and change its @Prop{menuText} property to `"&"Delete'.

@LP
A side-effect of the above change is that @Option{Alt+C} (originally
used for `Cut') is now unused. Click the editCopyAction action
in the Action Editor, and change its @Prop{menuText} property to
`"&"Copy'.

@LP
We can always check to see if there are any accelerator conflicts
by clicking @Option{Edit"|"Check Accelerators} (or @Option{Alt+R}).

@LP
{ Object Explorer} @Sidebar {
    @Tbl
	#rule { yes } rulecolour {red}
	margin { 0c }
	cmarginabove { 0.45f }
	bformat { @Cell A |
		  @Cell width { 5.4c } indent { right } iv { ctr } B }
	cformat { @StartHSpan @Cell A | @HSpan }
    {
	@Rowb A {
View the Object Explorer window by clicking
@Option{Window"|"Views"|"} @Option{Object Explorer}. The Object
Explorer has two tabs, the Objects tab which shows the object
hierarchy, and the Members tab which shows
@PageMark{object.explorer.sidebar} object.explorer @Index{ Object
Explorer } the members you have added to the form. Clicking the name
of a widget in the Object tab will select the widget and show its
properties in the Property Editor. It is easy to see and select
widgets in the Object Explorer which is especially useful for forms
that have many widgets or which use layouts. Multiple widgets can be
selected by @Option{Click}ing the first one then
@Option{Shift+Click}ing the others.
@SidebarPP
In the original version of @QDR if you wanted to provide
code for a form you had to subclass the form and put your code
in the subclass. This version fully supports the subclassing
approach, but now provides an alternative: placing your code
directly into forms.
Writing code in @QDR is not quite
the same as subclassing, for example you cannot get direct access
to the form's constructor or destructor. If you need code to
be executed by the constructor create a slot called
init @Index{ init() } @Func{void init()}; if it exists it will
be called from the constructor.
Similarly, if you need
{code|2s to|2.4s be|2.4s executed|2.4s before|2.4s destruction|2.4s
create|2.4s a|2.4s slot|2.4s called}
	    }
	    B {
@Figure
    @Location { Raw }
    @Caption { Object Explorer }
 0.45 @Scale @IncludeGraphic { "images/mw-objexplor.eps.gz" }
}
    @Rowc A {
destroy @Index{ destroy() }
@Func{void destroy()}. You can also add your own class variables
which will be put in
the generated constructor's code, and you can add
forward declarations and any includes you require. To add a variable
or declaration, right click the appropriate item, e.g. Class
Variables, then click @Option{New} then enter your text, e.g. 
@Code{QString m_filename}. If one or more items exist, right
clicking will popup a menu that has @Option{New}, @Option{Edit} and
@Option{Delete} options.
@SidebarPP
If
you want to enter multiple items, e.g. multiple include files or
multiple data members, it is easiest to right click in the relevant
section, then click @Option{Edit} to invoke an Edit dialog. To edit code,
just click the name of a function to invoke the code editor. Code
editing and creating slots are covered later.
code.editing @Index{ Code Editing }
subclassing @Index{ Subclassing }
forward.declarations @Index{ Forward declarations }
includes @Index{ Includes }
adding @RawIndex{ Adding }
adding.code @SubIndex{ Code }
adding @RawIndex{ Adding }
adding.forward.declarations @SubIndex{ Forward declarations }
adding @RawIndex{ Adding }
adding.includes @SubIndex{ Includes }
adding @RawIndex{ Adding }
adding.class.variables @SubIndex{ Class variables }
class.variables @Index{ Class variables }
deleting @RawIndex{ Deleting }
deleting.forward.declarations @SubIndex{ Forward declarations }
deleting @RawIndex{ Deleting }
deleting.includes @SubIndex{ Includes }
deleting @RawIndex{ Deleting }
deleting.class.variables @SubIndex{ Class variables }
forms @RawIndex{ Forms }
forms.forward.declarations @SubIndex{ Forward declarations }
forms @RawIndex{ Forms }
forms.class.variables @SubIndex{ Class variables }
forms @RawIndex{ Forms }
forms.code.editing @SubIndex{ Code editing }
forms @RawIndex{ Forms }
forms.destructor @SubIndex{ destructor }
forms @RawIndex{ Forms }
forms.constructor @SubIndex{ constructor }
@SidebarPP
If you subclass the form you create your own subclassing @Index{
Subclassing } cpp @Index{ .cpp } @File{.cpp} files which can
contain your own constructor, destructor, functions, slots,
declarations and variables as your requirements dictate. (See
@NamePageRef{subclassing} for more information.)
}
}
}
@End @SubSubSection
@SubSubSection
    @Title { Adding an Action Group }
    @Tag{adding.an.action.group}
@Begin
@LP
We want to provide the user with a choice of views, but since
they can only use one view at a time we need to ensure that the
menu options and toolbar buttons they use to switch between views
always stay in sync. We don't have to write any code to achieve
this: we simply put the relevant actions in an action group and
let Qt take care of the details.

@LP
Right click an action in the @Win{Action Editor}, then click @Option{New Action Group}. The action group's properties are now showing
in the Property Editor. Change the action group's @Prop{name} property
to `viewActionGroup', and change its @Prop{text} property to `View'.
We want the action group to be @Prop{exclusive}, i.e. for only one
of its actions to be `on' at any one time; but there's no need
to set the @Prop{exclusive} property since it defaults to True which
is what we want.

@LP
We'll now create the view actions. The process is virtually the
same as for actions that are not in an action group; the only
difference is that when we right click to pop up the context
menu, we @I{must} right click the relevant action group, not
just anything in the @Win{Action Editor}.

@LP
Right click the viewActionGroup, then click @Option{New Action}. Change
this action's @Prop{name} property to `viewTableAction'. Set its
@Prop{toggleAction} property to True and set its @Prop{on} property
to True. We want it to be a toggle action because either the
user is using this view (it is `on') or another view (it is `off').
We set this action to `on' because it will be the default view.
Change its @Prop{iconSet} property to @File{table.png}. (Click
the @Prop{iconSet} property's ellipsis button, click @Option{Add..},
click @File{table.png}, then click @Option{Open}, then click
@OK.) Change the @Prop{text} property to `View Table' and the
@Prop{menuText} property to `View "&"Table'. Change the @Prop{accel}
property to `Ctrl+T, and set the @Prop{toolTip} property to `View
Table (Ctrl+T)'. When the user clicks the @Option{View} menu and hovers
the mouse over the `View Table' option the tool tip will appear
in the status bar. Similarly when the user hovers the mouse over
the `View Table' toolbar button, the tool tip text will appear
both in the status bar and in a temporary yellow label next to
the toolbar button.

@LP
Right click the viewActionGroup, then click @Option{New Action}. Change
this action's @Prop{name} property to `viewIconsAction'. Set its
@Prop{toggleAction} property to True. Change its @Prop{iconSet} property
to @File{iconview.png}. Change the @Prop{text} property to
`View Icons' and the @Prop{menuText} property to `View "&"Icons'.
Change the @Prop{toolTip} property to `View Icons (Ctrl+I)', and
set the @Prop{accel} property to `Ctrl+I'.

@LP
Note that the Action Editor window is dockable, so if you don't
want it to float freely you can drag it to one of @QDR's
dock areas (top, left, right, bottom of the main window) if preferred.

@End @SubSubSection
@SubSubSection
    @Title { Using an Action Group }
    @Tag{using.an.action.group}
@Begin
@LP
Now that we've created the view actions we need to make them
available to the user.

@LP
Click the viewActionGroup action group in the Action Editor,
and drag it to the View menu; drop it on this menu (when the
horizontal red line appears beneath the View menu). Because we
dragged the action group, @I{all} its actions (in our case the
viewTableAction and viewIconsAction) are added to the relevant
menu. We'll also make the view actions available on the toolbar.
Click the viewActionGroup once again, and drag it to the toolbar;
drop it the right of the separator at the far right of the toolbar,
and drop it on the toolbar's edge. (Again, a vertical red line
will indicate the position.)

@LP
Don't forget that you can preview to see things in action with
@Option{Ctrl+T}, and to click @Option{File"|"Save} (or press @Option{Ctrl+S})
regularly! If you preview now you will find that if you click
the view toolbar buttons and menu options that both the toolbar
buttons and the menu items automatically stay in sync.
@End @SubSubSection
@EndSubSubSections
@End @SubSection
@EndSubSections
@End @Section
@Section
    @Title { Creating the Main Widget }
    @Tag { creating.the.main.widget }
@Begin
@LP
Most main-window style applications consist of a menu bar, a
toolbar, a status bar and a central widget. We've already created
a menu bar and toolbar, and since we've created a @Class{QMainWindow}qmainwindow @Index{ QMainWindow }
(via the main window wizard), we also have a status bar. Widgets
commonly used as an application's main widget are @Class{QListView}qlistview @Index{ QListView }
(which provides a tree view), @Class{QTable}qtable @Index{ QTable } and @Class{QTextEdit}qtextedit @Index{ QTextEdit }. Since
we want to provide our users with two different views of the
same data, we'll use a @Class{QWidgetStack}qwidgetstack @Index{ QWidgetStack } as our main widget. The
@Class{QWidgetStack}qwidgetstack @Index{ QWidgetStack } has no visual representation of its own; you
place one or more widgets on each @Class{QWidgetStack}qwidgetstack
@Index{ QWidgetStack } `page', as
if each page was a form in its own right, and then provide the
user with some mechanism for switching between pages. (This is
similar in principle to using a @Class{QTabWidget}qtabwidget @Index{ QTabWidget }.) We want to provide
our users with two views: a tabular view that lists colors and
their names, and an icon-based view that shows color swatches.
In our example we only place a single widget on each @Class{QWidgetStack}qwidgetstack @Index{ QWidgetStack }
page; but this merely reflects the application's design -- we
could have placed any number of widgets on each page.

@LP
Click the @Win{Toolbox}'s @Option{Containers} button, then click
@Option{WidgetStack}.
Click approximately in the middle of the form to place the widget
stack. Change the widget stack's @Prop{name} property to
`colorWidgetStack'.

@Figure
    @Caption { Widget placement }
    0.40 @Scale @IncludeGraphic { "images/mw-addmainwidg.eps.gz" }
@LP
When placing widgets on forms using @QDR, you only
need to place things in @I{approximately} the right place. And
there is no need to worry about the size of the widgets placed.
If, for example, you place a label and then change its text so
that the text doesn't fit, this doesn't matter. The reason we
don't have to care about precise positions and sizes is that
@QDR uses Qt's layout classes to lay out forms automatically:
we just have to select sets of widgets and tell @QDR
how they should be laid out in relation to each other, e.g. vertically,
one above the other, or horizontally, side by side, or in a grid,
and @QDR will lay them out and size them appropriately.

@LP
In this chapter we only make the most minimal use of @QDR's
layout facilities, we make more use of them and provide more
information in chapter two, where we create several dialogs.

@LP
Click the form itself, then click the @Option{Lay Out Vertically}
toolbar button. The widget stack now fills the entire form. We're
now ready to populate the widget stack's pages with widgets.

@Figure
    @Caption { Laying out the widget stack }
    0.45 @Scale @IncludeGraphic { "images/mw-laymainwidg.eps.gz" }

@LP
Click the @Win{Toolbox}'s @Option{Views} button. Click @Option{Table},
then click approximately in the middle of the widget stack. Change the
table's @Prop{name} property to `colorTable', change its
@Prop{numRows} property to `0', and its @Prop{readOnly} property to
`True'.

@LP
If you right click a widget to pop up its context menu, in most
cases the first item will be an @Option{Edit} option. The Table widget
is no different in this respect, and its @Option{Edit} option leads
to a dialog through which columns and rows can have their titles
changed, etc.

@LP
Right click the table, then click @Option{Edit...} to invoke the @Win{Edit
Table} dialog. Change the Label for column 1 to `Name'. Click
`2' in the Columns list so that column 2's label is shown in
the Label line edit. Change column 2's label to `Hex'. In the
same way change column 3's label to `Web'. (The reference section
provides full information on this dialog.) Click @OK to close
the dialog.

@Figure
    @Caption { Adding the table }
    0.45 @Scale @IncludeGraphic { "images/mw-colortable.eps.gz" }
@LP
Click the widget stack, then click the @Option{Lay Out Vertically}
toolbar button. The table now fits inside the widget stack, and
will resize with the widget stack (which in turn will resize
with the form: try clicking @Option{Ctrl+T} to preview and resize
the previewed form).

@Figure
    @Caption { Laying out the table }
    0.45 @Scale @IncludeGraphic { "images/mw-laycolortable.eps.gz" }
@LP
Click the `page' object in @Win{Object Explorer}. Change its @Prop{name}
property to `tablePage'.

@LP
We're now ready to create the next page. Right click the widget
stack, then click @Option{Add Page} on the context menu. The table
has `disappeared', or rather the new widget stack page obscures
the first widget stack page which contains the table. Click IconView
in the Toolbox, then click approximately in the middle of the
widget stack. Change the IconView's @Prop{name} property to
`colorIconView'
and change its @Prop{resizeMode} property to `Adjust'. We want our
color swatches to appear in neat columns so change the @Prop{gridX}
property to `100'.

@Figure
    @Caption { Adding the icon view }
    0.45 @Scale @IncludeGraphic { "images/mw-coloriconv.eps.gz" }

@LP
It is often useful to create IconView items during design, but
it isn't appropriate for our application. Right click the IconView
to popup its context menu, then click @Option{Edit...} to invoke the
@Win{Edit IconView} dialog. Click @Option{Delete Item} to delete the
default item, then click @OK.

@LP
Click the widget stack, then click the @Option{Lay Out Vertically}
toolbar button. The icon view now fits inside the widget stack.

@Figure
    @Caption { Laying out the icon view }
    0.45 @Scale @IncludeGraphic { "images/mw-laycoloriconv.eps.gz" }
@LP
Click the `page' object in @Win{Object Explorer}. Change its name to
`iconsPage'.

@LP
Right click the widget stack, then click @Option{Previous Page}.

@LP
That completes the user interface design for our application's
main window. Note that if you preview the form clicking the
@Option{View}
menu options and toolbar buttons has no effect. This is because
we haven't written any code to be executed when the actions triggered
by these menu options and toolbar buttons occur. We'll write
the necessary code in the next section.

@End @Section
@Section
    @Title { Writing the Code }
    @Tag { writing.the.code }
@Begin
@LP
There are two approaches that can be taken when it comes to writing
code for forms designed with @QDR. The original approach
is to create a subclass of every form you create and put all
your code in the subclass. Since Qt 3.0, @QDR has
provided an alternative: you can write your code directly in
@QDR using the code editor. See The Designer Approach
for a comparative review. For this example we will write all
the code inside @QDR; for an example of the subclassing
approach see Subclassing and Dynamic Dialogs.

@LP
Before we launch into writing code we need to create some form
variables. For example, we need to keep track of whether a view
needs updating (because the user loaded a new set of colors,
or added or deleted colors in the other view).

@BeginSubSections
@SubSection
    @Title { Adding Member Variables }
    @Tag{adding.member.variables}
@Begin
@LP
Click @Win{Object Explorer}'s @Option{Members} tab. Right click @Option{Class
Variables} (towards the bottom), then click @Option{Edit}. The @I{Edit
Class Variables} dialog appears. Click the @Option{Add} button, and
type in @Code @Verbatim{QMap<QString,QColor> m_colors}. We will use
this map to relate user color names to colors. Click the @Option{Add}
button again, and type in @Code{bool m_changed}. We'll use this
variable to keep track of whether the data has changed or not; this is
useful for offering the user a prompt to save unsaved changes when
they exit or open a new file, for example.

@Figure
    @Caption { The Edit Variables dialog }
    0.45 @Scale @IncludeGraphic { "images/mw-editvar.eps.gz" }
@LP
In the same way add @Code{QString m_filename;} so that we can keep
track of the file the user has open. Add @Code{bool m_table_dirty}
and @Code{bool m_icons_dirty}. If the user adds a color when viewing
the table we'll mark the icons as 'dirty' so that the icon view
will be updated if the user changes to view the icons, and vice
versa. Add @Code{bool m_show_web;} -- we'll use this to record whether
or not the user wants a column in the table to indicate which
colors are web colors. Add @Code{int m_clip_as;} -- we'll use this
to choose what to put on the clipboard when the user clicks @Option{File"|"Copy}.
We'll keep a pointer to the global clipboard, so add @Code{QClipboard
*clipboard;}. Finally add @Code{QStringList m_comments;}. This is
used for loading and saving color files and is explained later.

@LP
You should now have the following variables:

@TaggedList labelwidth { 12f } gap { 0.75vx } indent { @ParaIndent }
@TagItem{ QMap<QString,QColor> }{m_colors; }
@TagItem{ bool }{m_changed; }
@TagItem{ QString }{m_filename; }
@TagItem{ bool }{m_icons_dirty; }
@TagItem{ bool }{m_table_dirty; }
@TagItem{ bool }{m_show_web; }
@TagItem{ int }{m_clip_as; }
@TagItem{ QClipboard *}{clipboard; }
@TagItem{ QStringList }{m_comments; }
@EndList

Press @Option{Enter}, to confirm the last variable, then click @Close
to close the dialog. All the variables now appear in @Win{Object
Explorer}'s
@Option{Members} tab.

@End @SubSection
@SubSection
    @Title { Adding Forward Declarations }
    @Tag{adding.forward.declarations}
@Begin
@LP
Some of the variables we've created are of classes that need
forward declarations. Right click @Option{Forward Declarations} (in
@Win{Object
Explorer}'s @Option{Members} tab), then click @Option{Edit}. This pops up the
@Win{Edit Forward Declarations} dialog. This dialog works in exactly
the same way as the @Win{Edit Class Variables} dialog that we've
just used. Add the following forward declarations: @Code{class
QString;}
and @Code{class QColor;}. Close the dialog and the forward declarations
appear in @Win{Object Explorer}.

@Figure
    @Caption { The Edit Forward Declarations dialog }
    0.45 @Scale @IncludeGraphic { "images/mw-editforw.eps.gz" }

@LP
You should now have the following forward declarations:
@ID {
class QString;
@LLP
class QColor;
}

@End @SubSection
@SubSection
    @Title { Adding Includes }
    @Tag{adding.includes}
@Begin
@LP
Our form will also need some included files. Includes may be added in
the declaration, or (for preference) in the implementation. Right
click @Option{Includes (in Implementation)}, then click @Option{Edit}.
Use the dialog that pops up to enter @Code @Verbatim{"qcolor.h"} and
@Code @Verbatim{"qstring.h"}. Since we're going to use the clipboard
we'll need access to the global clipboard object via
@Class{QApplication}qapplication @Index{ QApplication }, so also add
@Code @Verbatim{"qapplication.h"} and @Code @Verbatim{"qclipboard.h"}.
We'll also be doing some drawing (e.g. the color swatches), so add
@Code @Verbatim{"qpainter.h"} too, then close the dialog.

@Figure
    @Caption { The Edit Includes (in Implementation) dialog }
    0.45 @Scale @IncludeGraphic { "images/mw-editincimp.eps.gz" }
@LP
When entering include files you can include double quotes or
angle brackets if you wish; if you don't use either @QDR
will put in double quotes automatically.

@LP
You should now have added the following includes (in implementation):

@ID {
"\""qcolor.h"\""
@LLP
"\""qstring.h"\""
@LLP
"\""qapplication.h"\""
@LLP
"\""qclipboard.h"\""
@LLP
"\""qpainter.h"\""
}

@End @SubSection
@SubSection
    @Title { Signals and Slots Connections }
    @Tag{signals.and.slots.connections}
@Begin
@LP
Most of the signals and slots connections were created automatically
by the main window wizard when we created the main form. We have
added some new actions since then, and we need to ensure that
they are connected to slots so that we can code their behavior.

@Figure
    @Caption { Creating signals and slots connections }
 0.45 @Scale @IncludeGraphic { "images/mw-conn1.eps.gz" }
@LP
Click @Option{Edit"|"Connections} to invoke the @Win{View and Edit Connections}
dialog.

@LP
The use of this dialog usually follows the same pattern. We click
@Option{New} to create a new connection, then we select the Sender
widget, the sender's Signal and the Receiver (usually the form).
If we want to use a pre-defined slot, we select that slot; otherwise
we click @Option{Edit Slots...} create a new slot on-the-fly, and
select the newly created slot. (The old method of clicking and
dragging to create connections is still supported, but the new
method is a lot faster and easier, especially for creating lots
of connections in one go.)
@LP
We want to update the status bar so that the user can see information
about the color they're on. Click @Option{Edit"|"Connections} to invoke
the @Win{View and Edit Connections} dialog. Click @Option{New} to create
a new connection. Change the Sender to `colorTable' and the Signal
to @Func{currentChanged(int,int)}. Change the Receiver to `MainForm'.

@Figure
    @Caption { The View and Edit Connections dialog }
    0.45 @Scale @IncludeGraphic { "images/mw-conn2.eps.gz" }

@LP
We want to connect to our own custom slot which we haven't yet
created. Click the @Option{Edit Slots...} button to invoke the @I{Edit
Functions} dialog. Change the slot name (which defaults to `newSlot')
to @Func{changedTableColor(int,int)}. Click @OK to close the dialog.

@Figure
    @Caption { The Edit Functions dialog }
    0.45 @Scale @IncludeGraphic { "images/mw-editfunc.eps.gz" }

@LP
Now change the Slot in the @Win{View and Edit Connections} dialog
to our newly created @Func{changedTableColor(int,int)} slot.

@Figure
    @Caption { The View and Edit Connections dialog }
    0.45 @Scale @IncludeGraphic { "images/mw-conn3.eps.gz" }

@LP
Click @Option{New} to create a new connection. Change the Sender to
`colorIconView' and the Signal to
@Func{currentChanged(QIconViewItem*)}.
Change the Receiver to `MainForm'. Click the @Option{Edit Slots...}
button to invoke the @Win{Edit Functions} dialog. Change the slot
name to @Func{changedIconColor(QIconViewItem*)}. Click @OK to close
the dialog. Now change the Slot in the @Win{View and Edit Connections}
dialog to @Func{changedIconColor(QIconViewItem*)}.

@LP
Now we can implement our @Func{changedTableColor()} and
@Func{changedIconColor()} slots to update the status bar
with details about the current color.

@LP
We also want to ensure that when the user changes view, the colors
shown in the view are correct. For example, if the user deleted
a color in the table view and changed to the icon view, we must
ensure that the icon view does not show the deleted color.

@LP
Click @Option{New} to create a new connection. Change the Sender to
`colorWidgetStack', the Signal to @Func{aboutToShow(int)}, and the
Receiver to `MainForm'. Create a new slot called @Func{aboutToShow()}
and make this the Slot that the widget stack's @Func{aboutToShow(int)}
signal connects to. The signal includes the ID of the widget
that is about to be shown; but we don't need it so we create
a slot that doesn't take any parameters.

@LP
Once crucial piece of functionality is to allow the user to switch
between views. We could connect each of the view actions separately,
but it is more convenient (and easier to extend) if we connect
the action group as a whole.

@LP
Create a new connection with the `viewActionGroup' as the Sender.
Change the Signal to @Func{selected(QAction*)} and change the Receiver
to `MainForm'. Create a slot called @Func{changeView(QAction*)} and
make this the slot that the signal connects to.

@LP
Click @OK to close the @Win{View and Edit Connections} dialog.
We are now ready to write the code.

@Figure
    @Caption { The View and Edit Connections dialog }
    0.45 @Scale @IncludeGraphic { "images/mw-conn4.eps.gz" }

@End @SubSection
@SubSection
    @Title { Preparing to Add the Code }
    @Tag{preparing.to.add.the.code}
@Begin
@LP
There is quite a lot of code to include in the application, but
this does not mean that a lot of typing is required! All the
code is reproduced here so, if you're reading an electronic copy,
you can simply cut and paste. If you're reading a print copy,
all the code is provided in
@File{"qt/tools/designer/examples/colortool"};
simply open the relevant @File{.ui.h} files and copy and
paste from there into your own version of the project.

@LP
{ Cutting "&" Pasting into the Code Editor } @Sidebar {
If you cut and paste code from this manual, because we've indented
the code for readability, the code will be over-indented in @QDR. This
is easily solved. Simply select the function containing the pasted
code (either with the mouse, or @Option{Shift+Arrow}s) and press
@Option{Tab}: this will make @QDR fix the indentation. Note that you
must select the @I{entire} function, including its name and
parameters.
@SidebarPP
Remember that if you copy and paste just the body of functions
into the skeletons @QDR provides, you must manually
enter the names of the arguments in the functions' parameter
lists.
}
@LP
Click @File{mainform.ui.h} in the @Win{Project Overview} window.
A code editor window showing the empty slots appears.

@LP
Unfortunately all the slots are called `Form1::...' instead of
`MainForm::...' This is easily remedied. Click @Option{Search"|"Replace...},
to invoke the @Win{Replace Text} dialog. Enter `Form1' as the Find
text and `MainForm' as the Replace text, then click @Option{Replace All}. Click @Close.

@BeginSubSubSections
@SubSubSection
    @Title { Adding Constants }
    @Tag{adding.constants}
@Begin
@LD @Code @RawVerbatim @Begin
    const int CLIP_AS_HEX = 0;
    const int CLIP_AS_NAME = 1;
    const int CLIP_AS_RGB = 2;
    const int COL_NAME = 0;
    const int COL_HEX = 1;
    const int COL_WEB = 2;
    const QString WINDOWS_REGISTRY = "/QtExamples";
    const QString APP_KEY = "/ColorTool/";
@End @RawVerbatim
We define some useful constants for our form since it's easier
to remember @Code{CLIP_AS_RGB} than `2'. The two @Class{QString}qstring @Index{ QString }s are
used by @Class{QSettings}qsettings @Index{ QSettings } when we come to load and save user preferences;
they're explained when we cover @Func{loadOptions()} and
@Func{saveOptions()}. Note that we can insert any valid
@Cpp into a @File{.ui.h} file including constant declarations
as we've done here and @Code{"#"include}s, etc.
qstring @Index{ QString }
@End @SubSubSection
@EndSubSubSections
@End @SubSection
@SubSection
    @Title { Adding the Functions }
    @Tag {adding.the.functions }
@Begin
@LP
Since we're not subclassing if we want to have code executed
during construction we must create an @Func{init()} function;
this will be called at the end of the form's constructor.

@LD @Code @RawVerbatim @Begin
    void MainForm::init()
    {
        clipboard = QApplication::clipboard();
        if ( clipboard->supportsSelection() )
            clipboard->setSelectionMode( TRUE );
        findForm = 0;
        loadSettings();
        m_filename = "";
        m_changed = FALSE;
        m_table_dirty = TRUE;
        m_icons_dirty = TRUE;
        clearData( TRUE );
    }
@End @RawVerbatim
The @PageMark{init} first thing we do is take a pointer to the global clipboard
object. The @Func{setSelectionMode()} call ensures that
the clipboard works as expected on all all platforms. The @Code{findForm}
and @Code{loadSettings()} lines will be covered later; if you're entering
the code, comment them out for now. We set the filename to be
empty because the user hasn't opened a file. We set changed to
false since no changes have taken place yet. But we mark both
the table and the icon view as dirty since we want these to be
drawn straight away. We call the @Func{clearData()} function
that we'll write next; this function clears all the color data,
and if called with @Code{@TRUE}, it creates new colors with default
qapplication @Index{ QApplication }
values.
@LD @Code @RawVerbatim @Begin
    void MainForm::clearData( bool fillWithDefaults )
    {
        setCaption( "Color Tool" );
        m_colors.clear();
        m_comments.clear();
        if ( fillWithDefaults ) {
            m_colors["black"] = Qt::black;
            m_colors["blue"] = Qt::blue;
            m_colors["cyan"] = Qt::cyan;
            m_colors["darkblue"] = Qt::darkBlue;
            m_colors["darkcyan"] = Qt::darkCyan;
            m_colors["darkgray"] = Qt::darkGray;
            m_colors["darkgreen"] = Qt::darkGreen;
            m_colors["darkmagenta"] = Qt::darkMagenta;
            m_colors["darkred"] = Qt::darkRed;
            m_colors["darkyellow"] = Qt::darkYellow;
            m_colors["gray"] = Qt::gray;
            m_colors["green"] = Qt::green;
            m_colors["lightgray"] = Qt::lightGray;
            m_colors["magenta"] = Qt::magenta;
            m_colors["red"] = Qt::red;
@End @RawVerbatim
@LD @Code @RawVerbatim @Begin
            m_colors["white"] = Qt::white;
            m_colors["yellow"] = Qt::yellow;
        }
        populate();
    }
@End @RawVerbatim
This @PageMark{cleardata} function is used when we start the application and when
the user creates a new file or loads an existing file. It clears
out the data and optionally inserts default colors. We set the
application's caption because when we load and save files we
add the filename to the caption, so when we clear we need to
remove any filename from the caption. We clear the colors map
and the comments string list, then optionally fill the colors
map with some standard colors. Finally we call @Func{populate()}
which is the function we'll create next to fill the table and
icon view with data.

@LD @Code @RawVerbatim @Begin
    void MainForm::populate()
    {
        if ( m_table_dirty ) {
            for ( int row = 0; row < colorTable->numRows(); ++row )
                for ( int col = 0; col < colorTable->numCols(); ++col )
                    colorTable->clearCell( row, col );

            colorTable->setNumRows( m_colors.count() );
            QPixmap pixmap( 22, 22 );
            int row = 0;
            QMap<QString,QColor>::Iterator it;
            for ( it = m_colors.begin(); it != m_colors.end(); ++it ) {
                QColor color = it.data();
                pixmap.fill( color );
                colorTable->setText( row, COL_NAME, it.key() );
                colorTable->setPixmap( row, COL_NAME, pixmap );
                colorTable->setText( row, COL_HEX, color.name().upper() );
                if ( m_show_web ) {
                    QCheckTableItem *item = new QCheckTableItem( colorTable, "" );
                    item->setChecked( isWebColor( color ) );
                    colorTable->setItem( row, COL_WEB, item );
                }
                row++;
            }
            colorTable->adjustColumn( COL_NAME );
            colorTable->adjustColumn( COL_HEX );
@End @RawVerbatim
@LD @Code @RawVerbatim @Begin
            if ( m_show_web ) {
                colorTable->showColumn( COL_WEB );
                colorTable->adjustColumn( COL_WEB );
            }
            else
                colorTable->hideColumn( COL_WEB );
            m_table_dirty = FALSE;
        }
        if ( m_icons_dirty ) {
            colorIconView->clear();
            QMap<QString,QColor>::Iterator it;
            for ( it = m_colors.begin(); it != m_colors.end(); ++it )
                (void) new QIconViewItem( colorIconView, it.key(),
                                          colorSwatch( it.data() ) );
            m_icons_dirty = FALSE;
        }
    }
@End @RawVerbatim
This @PageMark{populate} function is at the heart of the application. It visually
presents the data to the user. If the table is `dirty' (e.g.
if the user has added or deleted colors in the icon view, or
has opened a color file) we will populate the table. We start
by deleting the contents of every cell. Next we change the number
of rows to equal the number of colors in the colors map. For
each color we want to display a little square that shows the
color, so we create a pixmap of the required size.
qpixmap @Index{ QPixmap }
qmap @Index{ QMap }
qstring @Index{ QString }
qcolor @Index{ QColor }
qchecktableitem @Index{ QCheckTableItem }
qiconviewitem @Index{ QIconViewItem }

@LP
We now create an iterator for our colors map, and iterate over
every color. The colors map has the user's color names as its
keys, and @Class{QColor}qcolor @Index{ QColor } instances as values. We retrieve the color
and fill our pixmap with that color. We then set the `Name' column
(column @Var{COL_NAME}), to have the color's name (@Code{it.key()}) and the pixmap we've just filled with that
color. @Class{QColor}qcolor @Index{ QColor }'s @Func{name()} function returns a string
that is the hex representation of a color, e.g. `"#"12AB2F';
we retrieve this and set the second (`Hex') column to this value.

@LP
If the user wants to see if which colors are web colors we create
a @Class{QCheckTableItem}qchecktableitem @Index{ QCheckTableItem }, and check it if it is a web color. (We'll
cover @Func{isWebColor()} shortly.) We then insert this
@Class{QCheckTableItem}qchecktableitem @Index{ QCheckTableItem } into
the `Web' column.

@LP
Having populated the table we call @Func{adjustColumn()}
to ensure that each column is just wide enough to show its widest
entry, and show or hide the `Web' column depending on the user's
preference.

@LP
Finally we set @Var{m_table_dirty} to @FALSE, since it
is now up-to-date.

@LP
If the icon view is `dirty' we @Func{clear()} it of any
existing data. We then iterate over each color in our colors
map. For each color we create a new @Class{QIconViewItem}qiconviewitem @Index{ QIconViewItem }; we label
the item with the user's color name and provide a pixmap (generated
by @Func{colorSwatch()}, covered shortly) in the relevant
color. Finally we set @Var{m_icons_dirty} to `@FALSE',
since it is now up-to-date.

@LD @Code @RawVerbatim @Begin
    bool MainForm::isWebColor( QColor color )
    {
        int r = color.red();
        int g = color.green();
        int b = color.blue();
@End @RawVerbatim
@LD @Code @RawVerbatim @Begin
        return ( ( r ==   0 || r ==  51 || r == 102 ||
                   r == 153 || r == 204 || r == 255 ) &&
                 ( g ==   0 || g ==  51 || g == 102 ||
                   g == 153 || g == 204 || g == 255 ) &&
                 ( b ==   0 || b ==  51 || b == 102 ||
                   b == 153 || b == 204 || b == 255 ) );
    }
@End @RawVerbatim
The @PageMark{iswebcolor} 216 web colors are those colors whose RGB (Red, Green, Blue)
values are all in the set (0, 51, 102, 153, 204, 255).
qcolor @Index{ QColor }


@LD @Code @RawVerbatim @Begin
    QPixmap MainForm::colorSwatch( const QColor color )
    {
        QPixmap pixmap( 80, 80 );
        pixmap.fill( white );
        QPainter painter;
        painter.begin( &pixmap );
        painter.setPen( NoPen );
        painter.setBrush( color );
        painter.drawEllipse( 0, 0, 80, 80 );
        painter.end();
        return pixmap;
    }
@End @RawVerbatim
We @PageMark{colorswatch} create a pixmap of a suitable size and fill it with white.
We then create a @Class{QPainter}qpainter @Index{ QPainter } which we'll use to paint on the
pixmap. We don't want a pen because we don't want an outline
around the shape we draw. We draw an ellipse (which will be circular
since we draw in an 80 x 80 pixel square). We return the resultant
pixmap.
qpixmap @Index{ QPixmap }
qcolor @Index{ QColor }
qpainter @Index{ QPainter }

@End @SubSection
@SubSection
    @Title { Creating main.cpp }
    @Tag{creating.main.cpp}
@Begin
@LP
Now that we've entered some of the code it would be nice to build
and run the application to get a feel for the progress we've
made. To do this we need to create a @Func{main()} function.
In Qt we typically create a small @File{main.cpp} file
for the @Func{main()} function. We can ask @QDR
to create this file for us.

@LP
Click @Option{File"|"New} to invoke the @Win{New File} dialog. Click
@Option{@Cpp Main-File}, then click @OK. The @Win{Configure Main-File} dialog
appears, listing the all the forms in the project. We've only
got one form, `MainForm', so it is already highlighted. Click
@OK to create a @File{main.cpp} file that loads our
MainForm.

@LD @Code @RawVerbatim @Begin
    #include <qapplication.h>
    #include "mainform.h"

    int main( int argc, char ** argv )
    {
        QApplication a( argc, argv );
        MainForm *w = new MainForm;
        w->show();
        return a.exec();
    }
@End @RawVerbatim
When @QDR generates a @File{main.cpp} file
it includes this line:
qapplication @Index{ QApplication }

@LD @Code @RawVerbatim @Begin
    a.connect( &a, SIGNAL( lastWindowClosed() ), &a, SLOT( quit() ) );
@End @RawVerbatim
If we left this code as-is, the user could by-pass our own termination
code by clicking the main window's @Close (@Multiply) button. Since we
want to give the user the option to save any unsaved changes
we need to ensure that we intercept any attempt to close the
application. To achieve this we delete the connection and add
a new slot, @Func{closeEvent()} which will intercept attempts
to close the application and call our @Func{fileExit()}
function.

@LP
Click @File{main.cpp} in the @Win{Project Overview} window.
The file will appear in an editing window. Delete the connect
line.

@LP
Click @File{mainform.ui.h} in the @Win{Project Overview} window;
(you may need to click @File{mainform.ui} first to reveal
@File{mainform.ui.h}). Right click @Func{fileExit()} in @Win{Object
Explorer}'s Members list (under Slots, public), then click @Option{Goto Implementation}. Add the following slot above the @Func{fileExit()}
slot:

@LD @Code @RawVerbatim @Begin
    void MainForm::closeEvent( QCloseEvent * )
    {
        fileExit();
    }
@End @RawVerbatim
Now, whatever the user clicks to close the application, our
@Func{fileExit()} slot will be called. We'll code the
@Func{fileExit()} slot right now:
qcloseevent @Index{ QCloseEvent }

@LD @Code @RawVerbatim @Begin
    void MainForm::fileExit()
    {
            QApplication::exit( 0 );
    }
@End @RawVerbatim
This ensures that our application will cleanly terminate. Later
we'll revise this function to give the user the opportunity to
save any unsaved data.
qapplication @Index{ QApplication }

@End @SubSection
@SubSection
    @Title { Building and Running }
    @Tag{building.and.running}
@Begin
@LP
We now have some code in the application and a @File{main.cpp}
containing the @Func{main()} function, so we should be
able to compile, link and run the application.

@LP
Click @Option{File"|"Save} to ensure that all our work is saved to
disk. Open a console (e.g. an xterm or DOS window), change directory
to where you have saved the @File{colortool} project,
and run @File{qmake} to generate a Makefile:

@LD @Code @RawVerbatim @Begin
    qmake -o Makefile colortool.pro
@End @RawVerbatim
Now make the project (run @File{nmake} on Windows, @File{make} on other platforms). Providing you commented
out the `findForm' and `loadSettings' lines in the @Func{init()}
function, the program should build. (If it doesn't build see
the Troubleshooting section.)

@LP
Once the make has finished, run the program. You still can't
change views since we haven't written the code for that yet,
but it does create a default set of colors. You can terminate
the application by clicking the @Close (@Multiply) button or by clicking
@Option{File"|"Exit}.

@End @SubSection
@SubSection
    @Title { Updating the Status Bar }
    @Tag{updating.the.status.bar}
@Begin
@LP
We want to show information about the current color in the status
bar, and we want to ensure that when the user changes their view
or loads in a color file, the relevant view is updated.


@LD @Code @RawVerbatim @Begin
    void MainForm::aboutToShow()
    {
        populate();
    }
@End @RawVerbatim
We @PageMark{abouttoshow} could have made @Func{populate()} a slot and connected
directly to it. We've used the indirection because it's clearer
and in a real application there would probably be more to do
in this slot.


@LD @Code @RawVerbatim @Begin
    void MainForm::changedTableColor( int row, int )
    {
        changedColor( colorTable->text( row, COL_NAME ) );
    }
@End @RawVerbatim
We @PageMark{changedtablecolor} connected to this slot so that we'd know whenever the user
moved or clicked in the table view. We call the @Func{changedColor()}
function (which we'll see in a moment) with the name of the current
color. Note that we don't care about the column argument, so
we could have left it out.


@LD @Code @RawVerbatim @Begin
    void MainForm::changedIconColor( QIconViewItem *item )
    {
        changedColor( item->text() );
    }
@End @RawVerbatim
This @PageMark{changediconcolor} slot is connected for the same purpose as @Func{changedTableColor()},
above. It also calls @Func{changedColor()} with the name
of the current color.
qiconviewitem @Index{ QIconViewItem }

@LP
The @Func{changedcolor()} function that we need to write from scratch. Simply
enter its code into @QDR's code editor and it will
automatically appear in @Win{Object Explorer}'s @Option{Members} tab (under
Functions, public).

@LP
By default any function that it typed directly into the code
editor becomes a public function. To change this, right click
the function's name in @Win{Object Explorer}'s @Option{Members} list, and click
@Option{Properties} to invoke the @Win{Edit Functions} dialog. This
dialog can be used to change various attributes of the function,
including changing it into a slot.

@LD @Code @RawVerbatim @Begin
    void MainForm::changedColor( const QString& name )
    {
        QColor color = m_colors[name];
        int r = color.red();
        int g = color.green();
        int b = color.blue();
        statusBar()->message( QString( "%1 \"%2\" (%3,%4,%5)%6 {%7 %8 %9}" ).
                                  arg( name ).
                                  arg( color.name().upper() ).
                                  arg( r ).arg( g ).arg( b ).
                                  arg( isWebColor( color ) ? " web" : "" ).
                                  arg( r / 255.0, 1, 'f', 3 ).
                                  arg( g / 255.0, 1, 'f', 3 ).
                                  arg( b / 255.0, 1, 'f', 3 )
                              );
    }
@End @RawVerbatim
This function looks up the color name in the colors map and retrieves
the color the name refers to. It then displays the name, hex
value and whether the color is a web color in the status bar.
qstring @Index{ QString }
qcolor @Index{ QColor }

@LP
Note that @Class{QMainWindow}qmainwindow @Index{ QMainWindow } only creates a status bar if you actually
use one. Since we haven't used one up until now we've had no
problem, but if we were to try compiling we'd get an error because
we're now using a status bar but haven't declared the relevant
header. Click @Win{Object Explorer}'s @Option{Members} tab and add a @Code
@Verbatim{"qstatusbar.h"}
to the @Option{Includes (In Implementation)} section. (Right click
@Option{Includes
(In Implementation)}, click @Option{New}, enter @Code
@Verbatim{"qstatusbar.h"} then
press @Option{Enter}.)

@LP
You should now have added the following declaration to your includes
(in implementation):

@ID{ "\""qstatusbar.h"\"" }

Try saving (press @Option{Ctrl+S}), making and running the application.
Move to different colors and see the status bar indicating the
color you are on. (If it doesn't build see the Troubleshooting
section.)

@End @SubSection
@SubSection
    @Title { Changing Views }
    @Tag{changing.views}
@Begin
@LP
Up to now we have not yet been able to see the icon view in action
because there's been no code in place to switch views. We'll
address this issue now.

@LP
We have already created a @Func{changeView()} slot that
is called when the user clicks one of the view toolbar buttons
or menu options, so we just need to write in the code.

@LD @Code @RawVerbatim @Begin
    void MainForm::changeView(QAction* action)
    {
        if ( action == viewTableAction )
            colorWidgetStack->raiseWidget( tablePage );
        else
            colorWidgetStack->raiseWidget( iconsPage );
    }
@End @RawVerbatim
(If you're cutting and pasting the code don't forget to name
the @Class{QAction}qaction @Index{ QAction } parameter `action'.)
qaction @Index{ QAction }

@End @SubSection
@SubSection
    @Title { File Handling }
    @Tag{file.handling}
@Begin
@LP
Since the X Consortium has already defined a file format for
relating colors to color names we will use their format rather
than creating one specially for the application. This has the
advantage that we will be able to read and write @File{rgb.txt},
and that our format will be familiar to many users.


@LD @Code @RawVerbatim @Begin
    void MainForm::fileNew()
    {
        if ( okToClear() ) {
            m_filename = "";
            m_changed = FALSE;
            m_table_dirty = TRUE;
            m_icons_dirty = TRUE;
            clearData( FALSE );
        }
    }
@End @RawVerbatim
This @PageMark{filenew} function doesn't load or save any data; it simply checks
to see if it is okay to clear the existing data (with the call
to @Func{okToClear()} which we'll look at next), and if
it is okay, it initializes the form.


@LP
Before @PageMark{oktoclear} we can create a new set of colors, or load an existing
set, we must check to see if there are any unsaved changes. If
there are, we must give the user the opportunity of saving their
data. That's what this function does.

@LD @Code @RawVerbatim @Begin
    bool MainForm::okToClear()
    {
        if ( m_changed ) {
            QString msg;
            if ( m_filename.isEmpty() )
                msg = "Unnamed colors ";
            else
                msg = QString( "Colors '%1'\n" ).arg( m_filename );
            msg += QString( "has been changed." );
@End @RawVerbatim
@LD @Code @RawVerbatim @Begin
            int ans = QMessageBox::information(
                            this,
                            "Color Tool -- Unsaved Changes",
                            msg, "&Save", "Cancel", "&Abandon",
                            0, 1 );
            if ( ans == 0 )
                fileSave();
            else if ( ans == 1 )
                return FALSE;
        }

        return TRUE;
    }
@End @RawVerbatim
If the data has changed (@Var{m_changed} is @TRUE), we
present the user with a message box offering the option of saving
their data, or cancelling the current operation (e.g. not loading
a new file, or not creating a new set of colors), or abandoning
their changes and continuing. We make the @Option{Save} button the
default button (pressed by @Option{Enter}) and the @Cancel button
the escape button (pressed by @Option{Esc}).
qstring @Index{ QString }
qmessagebox @Index{ QMessageBox }

@LP
Since we're using a @Class{QMessageBox}qmessagebox @Index{ QMessageBox } we need to include the relevant
header. (Right click @Option{Includes (in Implementation)}, then click
@Option{New}. Type @Code @Verbatim{"qmessagebox.h"} and press @Option{Enter}.)

@LP
You should now have added the following declaration to your includes
(in implementation):

@ID{ "\""qmessagebox.h"\"" }

@LD @Code @RawVerbatim @Begin
    void MainForm::fileOpen()
    {
        if ( ! okToClear() )
            return;
@End @RawVerbatim
@LD @Code @RawVerbatim @Begin
        QString filename = QFileDialog::getOpenFileName(
                                QString::null, "Colors (*.txt)", this,
                                "file open", "Color Tool -- File Open" );
        if ( ! filename.isEmpty() )
            load( filename );
        else
            statusBar()->message( "File Open abandoned", 2000 );
    }
@End @RawVerbatim
If @PageMark{fileopen} it isn't okay to clear the data (i.e. the user has unsaved
changes and clicked @Cancel in the message box poped up by
@Func{okToClear()}), we simply return. Otherwise we ask
the user for a filename using one of @Class{QFileDialog}qfiledialog @Index{ QFileDialog }'s static
functions, and if we got the filename we attempt to load the
file.
qstring @Index{ QString }
qfiledialog @Index{ QFileDialog }

@LP
Since we're using a @Class{QFileDialog}qfiledialog @Index{ QFileDialog } we need to include the relevant
header. (Right click @Option{Includes (in Implementation)}, then click
@Option{New}. Type @Code @Verbatim{"qfiledialog.h"} and press @Option{Enter}.)

@LP
You should now have added the following declaration to your includes
(in implementation):

@ID{ "\""qfiledialog.h"\"" }

@LD @Code @RawVerbatim @Begin
    void MainForm::load( const QString& filename )
    {
        clearData( FALSE );
        m_filename = filename;
        QRegExp regex( "^\\s*(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+(\\S+.*)$" );
        QFile file( filename );
        if ( file.open( IO_ReadOnly ) ) {
            statusBar()->message( QString( "Loading '%1'..." ).arg( filename ) );
            QTextStream stream( &file );
            QString line;
            while ( ! stream.eof() ) {
                line = stream.readLine();
                if ( regex.search( line ) == -1 )
                    m_comments += line;
                else
                    m_colors[regex.cap( 4 )] = QColor(
                                                regex.cap( 1 ).toInt(),
                                                regex.cap( 2 ).toInt(),
                                                regex.cap( 3 ).toInt() );
            }
            file.close();
            m_filename = filename;
            setCaption( QString( "Color Tool -- %1" ).arg( m_filename ) );
@End @RawVerbatim
@LD @Code @RawVerbatim @Begin
            statusBar()->message( QString( "Loaded '%1'" ).arg( m_filename ),
                                  3000 );
            QWidget *visible = colorWidgetStack->visibleWidget();
            m_icons_dirty = ! ( m_table_dirty = ( visible == tablePage ) );
            populate();
            m_icons_dirty = ! ( m_table_dirty = ( visible != tablePage ) );
            m_changed = FALSE;
        }
        else
            statusBar()->message( QString( "Failed to load '%1'" ).
                                      arg( m_filename ), 3000 );
    }
@End @RawVerbatim
Before @PageMark{load} loading new data, we clear out any existing data. The
format of an @File{rgb.txt} file is:
qstring @Index{ QString }
qregexp @Index{ QRegExp }
qfile @Index{ QFile }
qtextstream @Index{ QTextStream }
qcolor @Index{ QColor }
qwidget @Index{ QWidget }

@ID @Code @RawVerbatim @Begin
RED WHITESPACE GREEN WHITESPACE BLUE WHITESPACE NAME
@End @RawVerbatim
Where RED, GREEN and BLUE are decimal numbers in the range 0..255
taking up three characters padded with leading spaces where necessary.
The WHITESPACE between the colors is usually a single space,
and between BLUE and the NAME two tabs. The NAME may include
whitespace. For example:

@LD @Code @RawVerbatim @Begin
      0 191 255       deep sky blue
    176  48  96       maroon
    199  21 133       medium violet red
@End @RawVerbatim
The file may also include comment lines; these begin with '!'
for example.

@LP
There are numerous approaches we could have taken to parsing
these files, but we've opted for a simple regular expression
(regex). The regex is more `liberal' regarding the whitespace
in the input than the format demands.

@LP
If a line matches the regex we create a new entry in the @Var{m_colors}
@Class{QMap}qmap @Index{ QMap }, setting its text to be the name of the color
(@Func{regex.cap( 4 )}), and its value to be a new @Class{QColor}qcolor @Index{ QColor } created from the
red, green and blue values. Lines that don't match the regex
are treated as comments and are stored in the @Var{m_comments}
string list. (When we save the file we write all the comments
out first even if they appeared in the middle of the file.)

@LP
Once we've populated the @Var{m_colors} map we mark the
visible view as `dirty' and call @Func{populate()} to
update it. We then mark the visible view as not dirty and the
non-visible view as dirty. This ensures that when user changes
the view, the view they switch to will be updated. We could have
simply marked both views as dirty and updated them both, but
it is more efficient to update `lazily', after all the user may
only ever use one view, so why waste their time updating the
other one.

@LP
Since we're using @Class{QFile}qfile @Index{ QFile } and @Class{QRegExp}qregexp @Index{ QRegExp } we need to include
the relevant headers. (Right click @Option{Includes (in
Implementation)},
then click @Option{New}. Type @Code @Verbatim{"qfile.h"} and press @Option{Enter}. Repeat
this process to add @Code @Verbatim{"qregexp.h"}.)

@LP
You should now have added the following declarations to your
includes (in implementation):

@ID {
"\""qfile.h"\""
@LLP
"\""qregexp.h"\""
}

@LD @Box {
@Centre @Heading @Underline{ The Regular Expression }
@LP
The regex we've used can be broken up into the following pieces:
@LLP
@Centre @Tbl
    afont { Helvetica Base }
    indent { ctr }
    aformat { @Cell font { @InitialFont } indent { left } A |
	      @Cell B | @Cell C | @Cell D | @Cell E | @Cell F |
	      @Cell G | @Cell H | @Cell I | @Cell J | @Cell K }
    bformat { @Cell font { @InitialFont } indent { left } A |
	      @Cell B | @Cell C | @Cell D | @Cell E | @Cell F |
	      @Cell G | @Cell H | @Cell I | @Cell J | @Cell K }
{
    @Rowa
	A { Regex: }
	B { @Code @Verbatim{^} }
	C { @Code @Verbatim{\\s*} }
	D { @Code @Verbatim{(\\d+)} }
	E { @Code @Verbatim{\\s+} }
	F { @Code @Verbatim{(\\d+)} }
	G { @Code @Verbatim{\\s+} }
	H { @Code @Verbatim{(\\d+)} }
	I { @Code @Verbatim{\\s+} }
	J { @Code @Verbatim{(\\S+.*)} }
	K { @Code @Verbatim{$} }
    @Rowa
	A { Pieces: }
	B{A}C{B}   D{C}     E{B}   F{C}     G{B}   H{C}     I{B}   J{D}       K{E}
    @Rowb
	A { Captures: }
	D{@Code{cap(1)}} F{@Code{cap(2)}} H{@Code{cap(3)}} J{@Code{cap(4)}}
}
@LP
Piece @Sans{A} says the regex must match from the beginning of the string,
and piece @Sans{E} says the regex must match to the end of the string:
so the regex must match the whole string or not match at all.
The @Sans{B} pieces match zero or more whitespaces (i.e. the gaps
between each number), and the @Sans{C} pieces match one or more digits,
i.e. the numbers. Piece @Sans{D} matches one or more non-whitespace
followed by anything else, i.e. the name of the color.
@LP
The parentheses are used to @I{capture} the parts of the match
that they enclose. The captured parts are numbered from 1.
@LP
For more information on regexes see the @Class{QRegExp}qregexp @Index{ QRegExp } documentation.
}

@LD @Code @RawVerbatim @Begin
    void MainForm::fileSaveAs()
    {
        QString filename = QFileDialog::getSaveFileName(
                                QString::null, "Colors (*.txt)", this,
                                "file save as", "Color Tool -- File Save As" );
        if ( ! filename.isEmpty() ) {
            int ans = 0;
            if ( QFile::exists( filename ) )
                ans = QMessageBox::warning(
                                this, "Color Tool -- Overwrite File",
                                QString( "Overwrite\n'%1'?" ).arg( filename ),
                                "&Yes", "&No", QString::null, 1, 1 );
            if ( ans == 0 ) {
                m_filename = filename;
                fileSave();
                return;
            }
@End @RawVerbatim
@LD @Code @RawVerbatim @Begin
        }
        statusBar()->message( "Saving abandoned", 2000 );
    }
@End @RawVerbatim
If @PageMark{filesaveas} the user attempts to save data that has been edited but not
saved previously, or if they want to save some existing data
under a new name, this slot is called. The user is presented
with a standard file dialog which they can use to choose a filename.
If the filename already exists they are given the option of continuing
(overwriting) or cancelling. If the filename doesn't exist or
does but the user has elected to continue the @Var{m_filename}
member is set and @Func{fileSave()} is called.
qstring @Index{ QString }
qfiledialog @Index{ QFileDialog }
qfile @Index{ QFile }
qmessagebox @Index{ QMessageBox }


@LD @Code @RawVerbatim @Begin
    void MainForm::fileSave()
    {
        if ( m_filename.isEmpty() ) {
            fileSaveAs();
            return;
        }
@End @RawVerbatim
@LD @Code @RawVerbatim @Begin
        QFile file( m_filename );
        if ( file.open( IO_WriteOnly ) ) {
            QTextStream stream( &file );
            if ( ! m_comments.isEmpty() )
                stream << m_comments.join( "\n" ) << "\n";
            QMap<QString,QColor>::Iterator it;
            for ( it = m_colors.begin(); it != m_colors.end(); ++it ) {
                QColor color = it.data();
                stream << QString( "%1 %2 %3\t\t%4" ).
                            arg( color.red(), 3 ).
                            arg( color.green(), 3 ).
                            arg( color.blue(), 3 ).
                            arg( it.key() ) << "\n";
            }
            file.close();
            setCaption( QString( "Color Tool -- %1" ).arg( m_filename ) );
            statusBar()->message( QString( "Saved %1 colors to '%2'" ).
                                    arg( m_colors.count() ).
                                    arg( m_filename ), 3000 );
            m_changed = FALSE;
        }
        else
            statusBar()->message( QString( "Failed to save '%1'" ).
                                    arg( m_filename ), 3000 );
    }
@End @RawVerbatim
If @PageMark{filesave} there is no current filename we call @Func{fileSaveAs()};
that function will call this one if the user provides a filename.
qfile @Index{ QFile }
qtextstream @Index{ QTextStream }
qmap @Index{ QMap }
qstring @Index{ QString }
qcolor @Index{ QColor }

@LP
We write out any comment lines first. This means that a file
that we load and then save may not be the same (e.g. if the original
had comments scattered throughout, since our saved version will
have all the comments at the beginning). We then iterate over
every color in the @Var{m_colors} map, writing them out
in the @File{rgb.txt} file format.


@LD @Code @RawVerbatim @Begin
    void MainForm::fileExit()
    {
        if ( okToClear() ) {
            QApplication::exit( 0 );
        }
    }
@End @RawVerbatim
This @PageMark{fileexit} is the second revision of this function. Now we only exit
if the user has had the opportunity to save any unsaved changes.
(We'll make a third and final version of this function later,
when we deal with saving user settings.)
qapplication @Index{ QApplication }

@LP
Try making and running the program. If you have @File{rgb.txt}
on your system try loading it and saving it under a new name
for testing purposes. If you don't have this file, save the standard
colors and use those. In the next section we'll cover adding
and deleting colors so that you can create your own color files.
(If it doesn't build see the Troubleshooting section.)

@End @SubSection
@SubSection
    @Title { The Edit Options }
    @Tag{the.edit.options}
@Begin
@LP
Adding a new color, finding a color and handling user options
all require custom dialogs, so we'll defer them until the
@NamePageRef{creating.dialogs} chapter
where we deal with dialogs.

@LD @Code @RawVerbatim @Begin
    void MainForm::editCut()
    {
        QString name;
        QWidget *visible = colorWidgetStack->visibleWidget();
        statusBar()->message( QString( "Deleting '%1'" ).arg( name ) );

        if ( visible == tablePage && colorTable->numRows() ) {
            int row = colorTable->currentRow();
            name = colorTable->text( row, 0 );
            colorTable->removeRow( colorTable->currentRow() );
            if ( row < colorTable->numRows() )
                colorTable->setCurrentCell( row, 0 );
            else if ( colorTable->numRows() )
                colorTable->setCurrentCell( colorTable->numRows() - 1, 0 );
            m_icons_dirty = TRUE;
        }
@End @RawVerbatim
@LD @Code @RawVerbatim @Begin
        else if ( visible == iconsPage && colorIconView->currentItem() ) {
            QIconViewItem *item = colorIconView->currentItem();
            name = item->text();
            QIconViewItem *current = item->nextItem();
            if ( ! current )
                current = item->prevItem();
            delete item;
            if ( current )
                colorIconView->setCurrentItem( current );
            colorIconView->arrangeItemsInGrid();
            m_table_dirty = TRUE;
        }

        if ( ! name.isNull() ) {
            m_colors.remove( name );
            m_changed = TRUE;
            statusBar()->message( QString( "Deleted '%1'" ).arg( name ), 5000 );
        }
        else
            statusBar()->message( QString( "Failed to delete '%1'" ).arg( name ),
                                  5000 );
    }
@End @RawVerbatim
If @PageMark{editcut} the user is viewing the table view we delete the
current row. We set the new current cell to be the one following the
deleted row, or if the one we deleted was last, its predecessor. We
mark the @I{other} view (the icon view) as dirty, to make sure that it
is updated if the user switches views. Similarly, if the user is
viewing the icon view, we make the next (or previous if there is no
next) item current and delete the one they were on. We then mark the
table view as dirty. If we deleted a color (i.e. there was a current
color in one of the views), we remove it from the @Var{m_colors} map
and mark the data as changed.
qstring @Index{ QString }
qwidget @Index{ QWidget }
qiconviewitem @Index{ QIconViewItem }

@LD @Code @RawVerbatim @Begin
    void MainForm::editCopy()
    {
        QString text;
        QWidget *visible = colorWidgetStack->visibleWidget();
        if ( visible == tablePage && colorTable->numRows() ) {
            int row = colorTable->currentRow();
            text = colorTable->text( row, 0 );
        }
        else if ( visible == iconsPage && colorIconView->currentItem() ) {
            QIconViewItem *item = colorIconView->currentItem();
            text = item->text();
        }
@End @RawVerbatim
@LD @Code @RawVerbatim @Begin
        if ( ! text.isNull() ) {
            QColor color = m_colors[text];
            switch ( m_clip_as ) {
                case CLIP_AS_HEX: text = color.name(); break;
                case CLIP_AS_NAME: break;
                case CLIP_AS_RGB:
                        text = QString( "%1,%2,%3" ).
                            arg( color.red() ).
                            arg( color.green() ).
                            arg( color.blue() );
                        break;
            }
@End @RawVerbatim
@LD @Code @RawVerbatim @Begin
            clipboard->setText( text );
            statusBar()->message( "Copied '" + text + "' to the clipboard" );
        }
    }
@End @RawVerbatim
In @PageMark{editcopy} this function we retrieve the name of the color from the current
table row (or current icon, depending on the view). We then set
a @Class{QString}qstring @Index{ QString } to the text we want to copy into the clipboard
and copy it.
qstring @Index{ QString }
qwidget @Index{ QWidget }
qiconviewitem @Index{ QIconViewItem }
qcolor @Index{ QColor }
@End @SubSection
@EndSubSections
@End @Section
@Section
    @Title { Summary }
    @Tag { summary }
@Begin
@LP
In this chapter we have created a standard main-window style
application. We have implemented menus, a toolbar and a main
widget (a QWidgetStack). We've also created signal and slot connections
and implemented many custom slots. In the following chapter we
will complete the application by implementing custom dialogs,
and by making use of common dialogs where appropriate.

@End @Section
@EndSections
@End @Chapter
