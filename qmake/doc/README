
QMAKE 1.0
----- ---

Qmake will become the build system for internal and external releases of Qt
from 3.0.0 on. It is also possible outside parties will be using Qmake as a
replacement for tmake on their own projects. This document will outline
some of the new features of Qmake as well as go over the design as a whole
for people not familiar with tmake.


Qmake is only a language to describe a makefile, and in turn will generate
a project description as appropriate for your destination platform. This
means to describe to a project file (as documented below) will output
currently a:

    * borland make makefile
    * unix-style makefile, ie suitable for gmake, etc
    * msdev nmake makefile
    * msdev dsp project file

There has been a new system for describing your platform so the above
makefiles can be generated, in previous versions of tmake a TMAKEPATH would
point to a directory that contained all system specific settings (ie what
compiler to use, template files, etc). Qmake no longer uses template files
at all, so all that is actually necessary is a description of your platform
such that a suitable makefile can be made, this is where MKSPECS are
usefull. You can set an environment variable $MKSPECS that contains your
current platform (ie linux-g++). Qmake will then find a description of your
platform in $QTDIR/mkspecs/$MKSPECS. 

Use
---

Qmake will be used very similarly to tmake. It supports most of the same
commandline options as well as backwards compatability. 

  *Options*

Usage: qmake [options] project-files
Options:
        -nocache      Don't use a cache file
        -nodepend     Don't generate dependency information
        -o file       Write output to file
        -t templ      Use template templ overriding others set
        -unix         Run in unix mode
        -win32        Run in win32 mode
        -mkcache file Use file as cache
        -mkspec file  Use file as spec
        -d            Increase debug level

Language
--------

The language borrows heavily from tmake, and is infact completely backwards
compatible, it should be using qmake, and the new $MKSPECS described above,
you should be able to do most everything you did before Qmake in a tmake
way (except custom templates are no longer available, if you require this
you will have to translate to one of the established templates, or continue
using tmake). Below is an outline of language features, including holdovers from tmake:


  *Assignments*

Everything in Qmake is done through user defined variables, to facilitate
this there are several operators to work on a list of values for example:

  PIG=oink moo    #$$PIG contains oink and moo 
  PIG-=moo        #$$PIG contains only oink
  OTHERPIG=$$PIG  #$$OTHERPIG contains oink
  PIG+=snort      #$$PIG contains oink and snort
  OTHERPIG=eat    #$$OTHERPIG contains only eat

As is evident the five operators (~=, *=, =, -=, and +=) can be used
together to configure qmake to generate the proper makefiles, using $$ you
can refer to another variable defined in Qmake.

Qmake will then internally use specially defined variables (as described in
the variables section below) to generate makes files.


  *Scopes*

Qmake (like tmake) has the concept of scopes, and will only set variables
appropriatly if something is in "scope". For most purposes this means you
will do as below:

   farm:COW=moo

This means, if farm is in scope, then the assignment will take place. What
has changed drastically from tmake is the limitations on scopes, what "in
scope" means in this case is if the $$CONFIG variable currently contains
farm, however this has been extended to allow scoping to be based on other
kinds of tests for example:

   system(ls /etc):HAS_ETC=1 #if the system call succeeds then /etc exists, one must 
                             #be careful in using this as it may be platform specific.
   include(some.file):       #this will include some.file into this project and parse it
                             #into the same symbol table
   contains(PIG, oink):      #this will test if oink is in PIG

As can be seen all scopes must be terminated with a colon, however you are
not required to do anything with the test, but this system allows you to
handle if a include() fails for example. You can AND and NOT scopes as
well, however OR'ing must be done by using multiple tests for example:

   farm:UK:COW=mad cow #if farm and UK then COW will contain mad and cow

   farm:!US:COW=nongenetically engineered #if farm is in scope, and US is
                                          #not then the assignment will take place

You can also use this system to raise alerts to the user, the following
functions can be used for this:

   #this will include some.file, if however the include fails (for parsing
   #reasons or not being able to find the file, then an error message will
   #be generated, and parsing will fail on this file as a whole.
   !include(some.file):error(I must have some.file to actually work!): 

   #this will allow you to warn a user that something may not be right, but it will
   #not exit the parse completely.
   farm:contains(PIG, moo):message(Umm.. I don't thinks pigs moo):

Other test functions are:
   count(PIG, 2):message(I only know two pigs..) #if PIG only contains two
                                                 #values message will be 
						 #shown
   isEmpty(PIG):message(I know no pigs..) #if PIG is an empty variable the 
                                          #message will be shown 
					  #(same as count(PIG, 0))

Finally you may also block your scopes so you dont' have to continually
type the same test for example:

   contains(tasks, MOW_LAWN):morning {
      GET_LAWNMOWER = 1
      contains(tasks, SHARPEN_BLADE) {
         CONFIG += SHARP_BLADE
      }
      !SHARP_BLADE:message(the blade probably isn't sharp enough):
      tasks -= MOW_LAWN
   }

To quickly describe this syntax, if MOW_LAWN is in the tasks variable, and
it is morning then I will assign 1 to GET_LAWNMOWER, if SHARPEN_BLADE is in
the tasks variable then I will put SHARP_BLADE in scope. If SHARP_BLADE is
not in scope I will warn the user but continue on, and finally I will
remove MOW_LAWN from my task list.


  *Cache file*

Qmake has introduced a cache file to prevent mistaken
misconfiguration. Qmake will never generate a cache file on its own, it is
the obligation of some outside program to do this, however the syntax is
controlled and is similar to a standard .pro. You must call this file
.qmake.cache, you should put it at the top directory of your project, and
Qmake will later walk backwards in your project heirarchy to find
it. Currently defined in the .qmake.cache is the following:

   MKSPECS : This variable will tell qmake what mkspec was used for the
   previous qmakes, and will prefer to defautly use this spec.
   CONFIG : This variable will tell qmake what CONFIG's you had turned on
   in the previous qmake, it will use this list as its list of currently
   "in scope" variables.

Qmake does not require the use of a .qmake.cache - and if it does not exist
will silently ignore it and continue on. If however it exists and you want
to override it, you may use the -nocache option.




Variables
---------

Qmake internally will use the same variables tmake did, however all
internal variables starting with TMAKE_ will now be QMAKE_, though for
compatability TMAKE_ will be accepted for now and used appropriatly. The
following documents each variable and its intended purpose:

For portablity reasons, all directories specified in known variables blow
will be created upon executing Qmake.


 *CONFIG*

  Qmake allows you to use the CONFIG variable to see what is in scope,
  however it has special interpretation of the following values in it:

  qt        The target is a Qt application/library and requires Qt header files/library.
  opengl    The target requires the OpenGL (or Mesa) headers/libraries.
  thread    The target is a multi-threaded application or library.
  x11       The target is a X11 application or library.
  windows   The target is a Win32 window application (app.t only).
  console   The target is a Win32 console application (app.t only).
  dll       The target is a shared object/DLL.
  staticlib The target is a static library (lib.t only).

  release   Compile with optimization enabled, ignored if "debug" is specified.
  debug     Compile with debug options enabled.
  warn_on   The compiler should emit more warnings than normally, ignored if "warn_off" is specified.
  warn_off  The compiler should emit no warnings or as few as possible.

 *INSTALLS*

  Qmake allows you to define an install target for the output makefile
  (currently supported only by unix makefile backends). You enable this
  like the following:

    animals.path = /usr/local/animals
    animals.files = *.pig *.cow
    INSTALLS += animals

  This will copy all files that match *.pig and *.cow into /usr/local/animals.
  Each backend can support builtin INSTALLS (like animals). Currently target is
  the only supported one, this will allow you to do:

   target.path = /usr/local/myapp/bin
   INSTALLS += target

  This allows Qmake to define what files get copied in (usually just $$TARGET, but
  in the case of libs this will include symlinks created to the shared object). If
  you specify a target.files or a target.extra (described below) the builtin behaviour
  will not happen and will be overridden by your targets. You can specify as many INSTALLS
  as you like to install your whole project.

  If .files doesn't allow you enough control you can also use .extra to put literal commands
  into the makefile like this:

     msgfiles.path = /usr/local/myapp/msgs
     msgfiles.files = ../msgfiles/*.msg
     unix:msgfiles.extra = $(QTDIR)/bin/msg2qm $$msgfiles.path/*.msg $$msgfiles.path/msgfile.qm
     INSTALLS += msgfiles

  This will copy all .msg files from ../msgfiles/ into /usr/local/myapp/msgs
  after that it will run msg2qm on those files. 

 *TEMPLATE*

  Although qmake doesn't actually support custom templates, it does allow
  you to tell it what kind of project this is from a hardcoded list,
  currently this list is app, subdirs, and lib. The following variables
  will be used with their respective TEMPLATE:

  *APP and LIB template*

  These "templates" will generate a application and a library respectivly:

  HEADERS      Header files.
  SOURCES      Source files.
  TARGET       Name of executable (adds .exe if on Windows).
  DESTDIR      Where to put the target.
  DEFINES      Tell compiler to define C preprocessor macros (-D option).
  INCLUDEPATH  Sets the include file search path for the compiler (-I option). 
  INTERFACES   Sets the .ui files to be compiled into the project.
  OBJECTS_DIR  Sets the directory all object files will be dumped to.
  MOC_DIR      Sets the directory all move files output will be placed in.
  LEXSOURCES   Sets the files to be processed by lex before compiling
  YACCSOURCES  Sets the files to be process by yacc before compiling
  DEPENDPATH   Sets the dependency search path for tmake.

  DEF_FILE     Win32 only: Link with a .def file.
  RC_FILE      Win32 only: Use a .rc file (compile to temporary .res). 
  RES_FILE     Win32 only: Link with a .res file. 
  VERSION      Lib template only: Will specify the version number of the library
  INSTALLS     This defines values to use as install targets, see *INSTALLS* section.

  *Subdirs template*

  This template is usefull for wrapping a bunch of other makefiles into one:

  SUBDIRS     A list of directories to be made

 *MAKEFILE_GENERATOR*

  This tells qmake what kind of makefile it is to generate currently these
  map directly to the list of output makefiles above.



