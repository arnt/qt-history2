\chapter qmake's Advanced Concepts

\section1 qmake's Advanced Concepts

The \e qmake project files we've seen up to now have been very simple,
just a list of \e{name = value} and \e{name += value} lines. \e qmake
provides a lot more power, for example you can use a single project
file to produce makefiles for multiple platforms.

\section1 Operators

So far, you have seen the \e = operator and \e += operator being used
in a project file.  There are more operators available for use; but
some of these should be used carefully as they may change more than
you expect them to.

\section2 The '=' operator

This operator simply assigns a value to a variable, it is used like
this:

\code
    TARGET = myapp
\endcode

This sets the TARGET variable to \e myapp.  This will remove any
previously set TARGET.

\section2 The '+=' operator

This operator adds a value to the list of values in a variable.  It
is used like this:

\code
    DEFINES += QT_DLL
\endcode

This adds QT_DLL to the list of pre-processor defines to be put in the
makefile.

\section2 The '-=' operator

This operator removes a value from the list of values in a variable.
It is used like this:

\code
    DEFINES -= QT_DLL
\endcode

This removes QT_DLL from the list of pre-processor defines to be put
in the makefile.

\section2 The '*=' operator

This operator only adds a value to the list of values in a variable if
it doesn't already exist.  It is used like this:

\code
    DEFINES *= QT_DLL
\endcode

QT_DLL will only be added to the list of pre-processor defines if it
is not already defined.

\section2 The '~=' operator

This operator replaces any values that match the regexp with the
specified value.  It is used like this:

\code
    DEFINES ~= s/QT_[DT].+/QT
\endcode

This removes any values in the list that start with QT_D or QT_T with
QT.

\section1 Scopes

A scope are similar to 'if' statements, if a certain condition is
true, the settings inside the scope are processed.  A scope is written
like this:

\code
    win32 {
	DEFINES += QT_DLL
    }
\endcode

The above code will add the QT_DLL define to the makefile if \e qmake
is used on a Windows platform.  If \e qmake is used on a different
platform than Windows, the define will be ignored.

For example, suppose we want to process something on all platforms
\e except for Windows. We can achieve this by negating the scope like
this:

\code
    !win32 {
	DEFINES += QT_DLL
    }
\endcode

Any entry on the CONFIG line is also a scope. For example, if you
write this:
\code
    CONFIG += warn_on
\endcode
you will have a scope called 'warn_on'. This makes it easy to change
the configuration for a project without losing all the custom settings
that might be needed for a specific configuration.  Since it is
possible to put your own values on the CONFIG line, this provides you
with a very powerful configuration tool for your makefiles. For
example:

\code
    CONFIG += qt warn_on debug
    debug {
	TARGET = myappdebug
    }
    release {
	TARGET = myapp
    }
\endcode

In the above code, two scopes are created which depend on what
is put on the CONFIG line.  In the example, \e debug is on the config
line, so the TARGET variable is set to \e myappdebug.  If \e release
was on the config line, then the TARGET variable would be set to \e
myapp.

It is also possible to check for two things before processing some
settings.  For instance, if you want to check if the platform is
Windows and that the thread configuration is set, you would write
this:
\code
    win32 {
	thread {
	    DEFINES += QT_THREAD_SUPPORT
	}
    }
\endcode

To save writing many nested scopes, you can nest scopes using a colon
like this:

\code
    win32:thread {
	DEFINES += QT_THREAD_SUPPORT
    }
\endcode

\section1 Variables

The variables that we have encountered so far are system variables,
such as \e DEFINES, \e SOURCES and \e HEADERS.  It is possible for you
to create your own variables so that you use them in scopes.  It's
easy to create your own variable; just name it and assign something to
it. For example:

\code
    MY_VARIABLE = value
\endcode

There are no restricitions on what you do to your own variables, as \e
qmake will just ignore them unless it needs to look at them for a
scope.  

You can also assign the value of a current variable to another
variable by prefixing $$ to the variable name. For example:

\code
    MY_DEFINES = $$DEFINES
\endcode

Now the MY_DEFINES variable contains what is in the DEFINES variable
at this point in the project file.

\section1 Functions

\e qmake provides built-in functions that perform simple, yet powerful
tasks.  

\section2 contains( variablename, value )

If \e value is in the list of values stored in the variable called \e
variablename, then the settings inside the scope will be processed.
For example:

\code
    contains( CONFIG, thread ) {
	DEFINES += QT_THREAD_SUPPORT
    }
\endcode

If \e thread is in the list of values for the \e CONFIG variable, then
QT_THREAD_SUPPORT will be added to the list of values in the \e
DEFINES variable.

\section2 count( variablename, number )

If \e number matches the number of values stored in the variable
called \e variablename, then the settings inside the scope will be
processed.  For example:

\code
    count( DEFINES, 5 ) {
	CONFIG += debug
    }
\endcode

\section2 error( string )

This function outputs the string given and then makes \e qmake exit.
For example:

\code
    error( "An error has occured" )
\endcode

The text "An error has occured" will be displayed on the console and
\e qmake will exit.

\section2 exists( filename )

If the specified file exists, then the settings inside the scope will
be processed.  For example:

\code
    exists( /local/qt/qmake/main.cpp ) {
	SOURCES += main.cpp
    }
\endcode

If \e /local/qt/qmake/main.cpp exists then main.cpp is added to the
list of source files.

Note that "/" can be used as a directory separator regardless of the
platform.

\section2 include( filename )

The contents of filename are included at this point in the project
file, so any settings in the specified file will be processed.  An
example of this is:

\code 
    include( myotherapp.pro )
\endcode

Any settings in the \e myotherapp.pro project file are now processed.

\section2 isEmpty( variablename )

This is the equivalent of using count( variablename, 0 ).  If the
variable called \e variablename has no elements, then the settings
inside the scope will be processed.  An example of this is:

\code
    isEmpty( CONFIG ) {
	CONFIG += qt warn_on debug
    }
\endcode

\section2 message( string ) 

This function simply outputs a message on the console.

\code
    message( "This is a message" )
\endcode

The text "This is a message" is output to the console and
processing of the project file carries on.

\section2 system( command )

The specified command is performed and if it returns an exit code of
1, the settings inside the scope are processed.  For example:

\code
    system( ls /bin ) {
	SOURCES += bin/main.cpp
	HEADERS += bin/main.h
    }
\endcode

So if the command \e {ls /bin} returns 1 then \e bin/main.cpp is added
to the list of sources and \e bin/main.h is added to the list of
headers.
