<html>
<h1>The Q Window System Protocol</h1>

The <tt>qws</tt> server is a very simple window system. The objective is to make
a very small server, leaving the client libraries to do most of the work. This
architecture is well-suited to embedded systems as it allows for both small and
large client-server systems: for example a system that is initially just
<tt>qws</tt> and a few small clients can later have more clients added using
possibly more sophisticated client libraries.
<p>
The protocol used by QWS is documented in the sections below.

<h2>Client Initialization</h2>

When a client first runs, it makes a socket connection to port QWS_PORT (17986)
of the localhost.
All communication is on the local machine so no endianness considerations are
required for the data transfers.  The client first reads a header from the
socket:
<dl compact>
    <dt><tt>int width</tt>
	<dd>The width of the screen in pixels.
    <dt><tt>int height</tt>
	<dd>The height of the screen in pixels.
    <dt><tt>int depth</tt>
	<dd>The depth of the screen in bits.
    <dt><tt>int shmid</tt>
	<dd>The identifier for the memory address of the frame buffer.  In the
	dummy framebuffer server, this is a shared-memory identifier.
</dl>

<h2>Events to Clients</h2>
<p>
After initialization, the client then continues with application-specific
processing, regularly
draining any events from the socket connection. The client will usually be
structured as an event loop.
The possible events are:
<dl>
  <dt>QWSMouseEvent
    <dd>
    <pre>
    int type = QWSEvent::Mouse;
    int dummy_windowid;
    int x_root, y_root, state;
    int time;</pre>
    This event is sent to the client whenever the mouse moves. All clients
    <font color=red>[this may change]</font>
    get all mouse events.
    The position (<i>x_root</i>, <i>y_root</i>)
    is relative to the top-left corner of the screen. <i>time</i> is a value
    in milliseconds that indicates when (relative to some undefined epoch) the
    mouse event occurred, and should be used by the client to calculate such
    emergent events as double-clicks.
    </p>
  <dt>QWSFocusEvent
    <dd>
    <pre>
    int type = QWSEvent::Focus;
    int windowid;
    uchar get_focus; </pre>
    If <i>get_focus</i> is 1, this indicates that <i>window</i> now has keyboard
    focus.  If <i>get_focus</i> is 0, this indicates that <i>window</i> no longer
    has keyboard focus.
    <font color=red>[we don't currently define when this happens]</font>
    </p>
  <dt>QWSKeyEvent
    <dd>
    <pre>
    int type = QWSEvent::Key;
    int windowid;
    int unicode;
    int modifiers;
    uint is_press:1;
    uint is_auto_repeat:1; </pre>
    This event is sent to the client whenever a key is pressed, released, or is
    auto-repeating after it is pressed.
    The key event <i>unicode</i> and <i>modifiers</i> values should be
    interpretted as if generated by the QWS
    <a href=#vkb>Virtual Keyboard</a>. If <i>is_press</i> is 1 then the user has
    pressed the key.  If <i>is_press</i> is 0 then the user has released the key.
    If <i>is_auto_repeat</i> is 1 then <i>is_press</i> is 1 and some time has
    passed since the key was pressed. <i>windowid</i> is redundant as it will
    always be the identifier of the window which most recently received focus.
    All clients <font color=red>[this may change]</font> get this message.
    </p>
  <dt>QWSRegionEvent
    <dd>
    <pre>
    int type = QWSEvent::Region;
    int windowid;
    int eventid;
    int nrectangles;
    struct {
	int x, y, width, height;
    } rectangles[nrectangles]; </pre>
    This event is sent to the client whenever the set of rectangles allocated
    to the window changes. The client must acknowledge receipt of this event
    as soon as possible by sending a QWSRegionAck command with the same
    <i>eventid</i>. Note that there are no "exposure" events in QWS - when the
    region allocated to a window changes, the client is responsible for painting
    any new area (and for <em>not</em> painting outside that area).
    <p>
    The <i>rectangles</i> are in <a href=#yxbanded>YXBanded</a> format.
    </p>
  <dt>QWSCreationEvent
    <dd>
    <pre>
    int type = QWSEvent::Creation;
    int objectid;</pre>
    This event is sent to the client at some time after the client sends
    a QWSCreate command.
    </p>
</dl>

<h2>Commands from Clients</h2>

All commands have this basic structure:

<pre>
struct QWSCommand {
  int type;
  int rawLen;
  struct CommandSpecific {
    ...
  } simpleData;
}
</pre>

During processing, clients may send the following commands.

<dl>
  <dt>QWSCreate
    <dd>
    <pre>
    int type = QWSCommand::Create;</pre>
    This command is sent by the client to create an object identifier.
    The client will
    eventually receive a QWSCreationEvent containing an identifier.
    Object identifiers are initially untyped, but once the client uses
    an object identifier, such as for a window identifier, it cannot
    be reused for other purposes.
    </p>
  <dt>QWSDestroy
    <dd>
    <pre>
    int type = QWSCommand::Destroy;
    int objectid;</pre>
    This command is sent by the client to destroy an object identifier,
    including any object (such as a window) so identified.
    </p>
  <dt>QWSRegion
    <dd>
    <pre>
    int type = QWSCommand::Region;
    int windowid;
    int nrectangles;
    struct {
	int x, y, width, height;
    } rectangles[nrectangles]; </pre>
    This command is sent by the client to request that the region covered by
    the window be changed to the given set of rectangles. Note that the client
    must not paint in the requested area immediately; instead, it should delay
    repainting until it receives a subsequent QWSRegionEvent event which will
    define the actual rectangles allocated to the window (which may be any
    subset of the requested pixels).
    <p>
    The <i>rectangles</i> must be in <a href=#yxbanded>YXBanded</a> format.
    </p>
</dl>

<h2>Glossary</h2>

<a name=yxbanded><h3>YXBanded Rectangles Region Format</h3></a>

Regions of pixels in QWS are always specified in YXBanded format. This is a
list of rectangles for which the following rules hold:
<ol>
    <li>No rectangles intersect.
    <li>The rectangles are sorted by top edge first, then by left edge.
    <li>Every rectangle with the same top edge has the same bottom edge.
	    Each sublist of such rectangles is called a "band" containing
	    all rectangles with the same top edge.
    <li>No two rectangles in a band may be adjacent (they must be merge if
	this is the case).
    <li>No two adjacent bands may have exactly the same list of horizontal extents
	(they must be merged if this is the case).
</ol>
Any set of rectangles can be divided canonically into such a list of rectangles.

<a name=vkb><h3>The QWS Virtual Keyboard</h3></a>

Key events in QWS are specified as if they are generated by a huge keyboard that
is the union of all the world's keyboards and input methods. The keyboard has
a discreet key for all the Unicode characters. It has 6 "modifier" keys, only some
of which are valid for certain Unicode characters. The modifiers are:
<dl>
 <dt>LeftShift, RightShift, RightAlt
    <dd>Never valid with any Unicode character. (eg. you cannot try to distinguish
	"A", "a", "LeftShift+A", and "LeftShift+a" as four cases; for each of "a"
	and "A" the state of LeftShift should be ignored. Thus this modifier is
	only interesting as a key by itself.
 <dt>LeftControl, RightControl
    <dd>Only valid with Unicode characters above U001F.
 <dt>LeftAlt
    <dd>Valid with any Unicode character.
</dl>
When a modifier key is pressed or released, a QWSKeyEvent is sent with the
unicode field set to UFFFF (not a unicode character).
<p>
Every QWS server implementation provides some way to generate all distinct key
events, though only some will be "easy" to generate (eg. single key presses),
and this will vary from one locale to another.
