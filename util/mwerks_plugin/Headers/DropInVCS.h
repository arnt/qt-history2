/*	DropInVCS.h			Copyright (c) 1996-8, Metrowerks Corporation. All rights reserved.			This include contains the declarations needed to interface a version control system to	the CodeWarrior integrated development environment.*/#ifndef __DROPINVCS_H__#define __DROPINVCS_H__#ifdef macintosh#include <OSUtils.h>#include <Files.h>#endif#define VCS_API_VERSION_1			1						// 1.7 IDE through Pro 3#define VCS_API_VERSION_7			7						// Pro 4#define VCS_API_VERSION_8			8						// Pro 5#define VCS_API_VERSION_9			9						// Pro 6#define VCS_API_CURRENT_VERSION		VCS_API_VERSION_9#ifndef __CWPlugins_H__#include "CWPlugins.h"#endif#ifdef __MWERKS__#pragma options align=mac68k#endif#ifdef	_MSC_VER#pragma pack(push,2)#endif#ifndef __CWPluginErrors_H__#include "CWPluginErrors.h"#endif#ifdef MW_USES_PRAGMA_ONCE#pragma once#endif#ifdef __cplusplus	extern "C" {#endif#if CW_USE_PRAGMA_IMPORT#pragma import on#endif	// The following constants are to be used when specifying the flags through a	// flags callback.  For version 3 flags.enum {	vcsDoesntPrePostSingleFile		= 1L << 31,	/* this VCS plugin does NOT call Pre/PostFileAction routines for calls dealing with a single file (file must be accessible before call) */	vcsDoesntPrePostRecursive		= 1L << 30,	/* this VCS plugin does NOT call Pre/PostFileAction routines for files during recursive calls (files must be accessible before call) */	vcsRequiresEvents				= 1L << 29,	/* this flag specifies that the VCS is responding to either AppleEvents or other highLevelEvents and the IDE should not try to handle events during callbacks */	vcsWantsIdle					= 1L << 28,	/* this flag is turned on when the VCS plugin wants to receive idle events */	vcsSupportsPrefsChanged			= 1L << 27,	/* this flag is turned on when the VCS plugin supports the reqPrefsChanged request */	vcsDoesntUseLoginSettings		= 1L << 26,	/* this VCS plugin does not use the login settings in the VCS Setup panel */	vcsDoesntUseDatabaseSetting		= 1L << 25,	/* this VCS plugin does not use the database path setting in the VCS Setup panel */	vcsDoesntUseLocalRootSetting	= 1L << 24	/* this VCS plugin does not use the local root setting in the VCS Setup panel */};enum{	reqDatabaseConnect = 1,				// connect to database	reqDatabaseDisconnect,				// disconnect from database	reqDatabaseVariables,				// database variables list		reqFileAdd,							// add file	reqFileCheckin,						// checkin file	reqFileCheckout,					// checkout file	reqFileComment,						// set file comment	reqFileDelete,						// delete file	reqFileDestroy,						// destroy file	reqFileDifference,					// difference file	reqFileGet,							// get file	reqFileHistory,						// get file history	reqFileLabel,						// label file	reqFileProperties,					// get file properties	reqFilePurge,						// purge file	reqFileRename,						// rename file	reqFileRollback,					// rollback file	reqFileStatus,						// get file status	reqFileUndoCheckout,				// cancel file checkout	reqFileVersion,						// get file version	reqFileBranch,						// branch a shared file	reqFileShare,						// share a file	reqFileView							// view a file};typedef long CWVCSCommand;enum{	cwCommandStatusCommandUnknown	= -4,			// command unknown	cwCommandStatusUnknown			= -3,			// status unknown	cwCommandStatusUnsupported		= -2,			// command unsupported	cwCommandStatusSupported		= -1,			// command supported	cwCommandStatusSucceeded		= cwNoErr,		// successful	cwCommandStatusFailed			= 1,			// failed	cwCommandStatusPartial			= 2,			// partially successful	cwCommandStatusCancelled		= 3,			// user cancelled	cwCommandStatusConnectionLost	= 4,			// connection lost	cwCommandStatusInvalidLogin		= 5				// invalid username or password};typedef long CWVCSCommandStatus;enum{	cwItemStatusUnprocessed		= -2,							// item yet unprocessed	cwItemStatusUnknown			= -1,							// status unknown	cwItemStatusSucceeded		=  0,							// operation succeeded	cwItemStatusFailed			=  1,							// operation failed	cwItemStatusCancelled		=  2							// operation cancelled};typedef long CWVCSItemStatus;enum{	cwCheckoutStateUnknown								= 0xFFFFFFFF,	// unknown	cwCheckoutStateNotInDatabase						= 0x00000002,	// not in database		cwCheckoutStateNotCheckedOut						= 0x00000000,	// not checked out	cwCheckoutStateCheckedOut							= 0x00000001,	// checked out	cwCheckoutStateMultiplyCheckedOut					= 0x00000101,	// multiply checked out	cwCheckoutStateNotCheckedOutShared					= 0x00010000,	// not checked out and shared	cwCheckoutStateCheckedOutShared						= 0x00010001,	// checked out and shared	cwCheckoutStateMultiplyCheckedOutShared				= 0x00010101,	// multiply checked out and shared	cwCheckoutStateNotCheckedOutBranched				= 0x00020000,	// not checked out and branched	cwCheckoutStateCheckedOutBranched					= 0x00020001,	// checked out and branched	cwCheckoutStateMultiplyCheckedOutBranched			= 0x00020101,	// checked out and branched	cwCheckoutStateNotCheckedOutSharedBranched			= 0x00030000,	// not checked out, shared and branched	cwCheckoutStateCheckedOutSharedBranched				= 0x00030001,	// checked out, shared and branched	cwCheckoutStateMultiplyCheckedSharedOutBranched		= 0x00030101,	// checked out, shared and branched	cwCheckoutStateCheckedOutExclusive					= 0x00040001,	// exclusively checked out	cwCheckoutStateCheckedOutExclusiveShared			= 0x00050001,	// exclusively checked out and shared	cwCheckoutStateCheckedOutExclusiveBranched			= 0x00060001,	// exclusively checked out and branched	cwCheckoutStateCheckedOutExclusiveSharedBranched	= 0x00070001,	// exclusively checked out, shared and branched		cwCheckoutStateCheckedOutMask						= 0x00000001,	// checked out mask	cwCheckoutStateMultiplyCheckedOutMask				= 0x00000100,	// multiply checked out mask	cwCheckoutStateSharedMask							= 0x00010000,	// shared mask	cwCheckoutStateBranchedMask							= 0x00020000,	// branched mask	cwCheckoutStateExclusiveMask						= 0x00040000	// exclusive mask};typedef long CWVCSCheckoutState;enum{	cwVersionFormNone				= 0,			// no record	cwVersionFormNumeric			= 1,			// intergral numeric	cwVersionFormAlpha				= 2,			// alphabetic	cwVersionFormLabel				= 4,			// label	cwVersionFormDate				= 5				// date / time};typedef long CWVCSVersionForm;enum{	cwCommandDescriptionVersion = 1};typedef struct CWVCSCommandDescription{	long	version;	char	menuItem[40];	char	progressMessage[200];} CWVCSCommandDescription;typedef union CWVCSVersionData{	unsigned long		numeric;		// integral numeric	char*				pAlpha;			// alphabetic	CWFileTime			date;			// date / time	char*				pLabel;			// label} CWVCSVersionData, *p_CWVCSVersionData, **h_CWVCSVersionData;typedef struct CWVCSVersion{	CWVCSVersionForm	eVersionForm;	// version form	CWVCSVersionData	sVersionData;	// version data} CWVCSVersion, *p_CWVCSVersion, **h_CWVCSVersion;typedef struct CWVCSItem{	CWFileSpec				fsItem;				// item file specification	CWVCSItemStatus			eItemStatus;		// item status code	CWVCSVersion			version;			// item version	CWVCSCheckoutState		eCheckoutState;		// item checkout state} CWVCSItem, *p_CWVCSItem, **h_CWVCSItem;typedef struct CWVCSDatabaseConnection{	CWFileSpec		sDatabasePath;			// path to the database directory	CWFileSpec		sProjectRoot;			// path to the local database directory		char*			pUsername;				// user name	char*			pPassword;				// user password} CWVCSDatabaseConnection, *p_CWVCSDatabaseConnection, **h_CWVCSDatabaseConnection;	/* The following callback mechanisms are available for VCS plugins for VCS performing VCS specific * functions and retrieving VCS specific data from the context passed to the main entry point by the * IDE.  You may also use any of the callbacks for generic plugins. * * These callbacks are available only to plugins using version 2 of the API or greater. */  	/* Call this function as the first thing you do in your main entry point.  Check its result.  If you pass in 	 * true, then if the v2 plugin is running under a pre-Pro4 IDE it will set up the compatibillity libraries and  	 * return cwNoErr.  If you pass in false and your v2 plugin is running uner a pre-Pro4 IDE it will return 	 * cwCommandStatusFailed, at which point you should return this error to the IDE and not process the request 	 * sent to you.  	 * 	 * Note that if you allow v1 compatibility and the result of isV1 is true, your plugin will not receive the V2 	 * idle requests or preferences changed requests and you must work around accordingly. */CW_CALLBACK CWAllowV1Compatibility(CWPluginContext context, Boolean canHandleV1Mode, Boolean *isV1);	/* Get a comment from the user */CW_CALLBACK CWGetComment(CWPluginContext context, const char* pPrompt, char* pComment, const long lBufferSize);	/* Notify IDE if any changes occur to a file's information or checkout state */CW_CALLBACK CWVCSStateChanged(CWPluginContext context, const CWFileSpec* file, 	CWVCSCheckoutState eCheckoutState, const CWVCSVersion* version);		/* Display a IDE visual difference window for the passed files.  The first file passed in	 * should be an unchangable file and the second file should be the local file.  Instead of passing	 * a CWFileSpec it is possible to pass in a pointer to text (null terminated) and a title.	 * If the file spec is used, set both the title and text pointers to NULL */CW_CALLBACK CWDoVisualDifference(CWPluginContext context,	const CWFileSpec* file1, const char* pTitle1, const char* pText1, unsigned long lengthText1, 	const CWFileSpec* file2, const char* pTitle2, const char* pText2, unsigned long lengthText2);		/* Tell the IDE the current ratio of how many items are completed.  If you are able to correctly	 * give a completion ratio, the IDE will display a progress bar indicating how far along the	 * VCS action has progressed instead of displaying a busy indicator.  If you pass -1 as the	 * total number of items, the busy indicator will replace any progress bar that you have	 * displayed with a prior call to completion ratio during the handling of a single request */CW_CALLBACK CWCompletionRatio(CWPluginContext context, int totalItems, int completedItems);	/* Get the project file specifier */CW_CALLBACK CWGetProjectFileSpecifier(CWPluginContext context, CWFileSpec* projectFileSpec);	/* Is the command passed an advanced command? */CW_CALLBACK CWIsAdvancedRequest(CWPluginContext context, Boolean* isAdvanced);	/* Is the command passed a recursive command? */CW_CALLBACK CWIsRecursiveRequest(CWPluginContext context, Boolean* isRecursive);	/* Is the command passed simply to check if it is supported? */CW_CALLBACK CWIsCommandSupportedRequest(CWPluginContext context, Boolean* isCommandSupported);	/* Set the pointer to a new overriding menu title string */CW_CALLBACK CWSetCommandDescription(CWPluginContext context, CWVCSCommandDescription* descr);	/* Get the pointer to the database connection structure */CW_CALLBACK CWGetDatabaseConnectionInfo(CWPluginContext context, CWVCSDatabaseConnection* dbConnection);	/* Get the command status code */CW_CALLBACK CWGetCommandStatus(CWPluginContext context, CWVCSCommandStatus* status);	/* Set the command status code */CW_CALLBACK CWSetCommandStatus(CWPluginContext context, CWVCSCommandStatus status);	/* Get the number of VCS items passed to the plugin */CW_CALLBACK CWGetVCSItemCount(CWPluginContext context, unsigned long* count);	/* Get a pointer to the ith entry of the item array, 0 indexed */CW_CALLBACK CWGetVCSItem(CWPluginContext context, long index, CWVCSItem* item);	/* Change the data for a VCS Item in the item array */CW_CALLBACK CWSetVCSItem(CWPluginContext context, long index, CWVCSItem* item);	/* Get what's stored in the VCS pointer storage area */CW_CALLBACK CWGetVCSPointerStorage(CWPluginContext context, void** storage);	/* Store a pointer that will be maintained across calls to the main entry point */CW_CALLBACK CWSetVCSPointerStorage(CWPluginContext context, void* storage);#if CW_USE_PRAGMA_IMPORT#pragma import reset#endif#ifdef __cplusplus	}#endif#ifdef	_MSC_VER#pragma	pack(pop,2)#endif#ifdef	__MWERKS__#pragma options align=reset#endif#endif	/* __DROPINVCS_H__ */