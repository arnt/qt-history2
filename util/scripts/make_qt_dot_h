#!/usr/bin/perl -w

use File::Find;

@IGNORE = qw {
    qfiledefs_p.h
    qaccessible.h
    qinputcontext_p.h
    ucom.h
    mwerks_mac.h
    qthread_p.h
    qmodules.h
    moc_yacc.h
    y.tab.h
    qconfig.h
    qgfxlinuxfb_qws.h
    qvfbhdr_qws.h
    qwsdisplay_qws.h
    qxt.h
    qgl.h
    qnp.h
    jri.h
    jri_md.h
    jritypes.h
    npapi.h
    npupp.h
    qimageio.h
    qjpegio.h
    qt.h
    allmoc.h
    qfeatures.h
    q1xcompatibility.h
    qt_mac.h
    qt_mac9.h
    qt_x11.h
    qt_windows.h
    qgfxmach64defs_qws.h
    qmutex.h
    qgeneric.h
    qpaintdevicedefs.h
    qwindow.h
    qtranslatordialog.h
    qsmartptr.h
};

@IGNORE_RE = qw {
    qconfig.*\.h
};

$IGNORE=join "|", (@IGNORE_RE, map { "\Q$_" } @IGNORE);

$verbose = 0;

#$HEADMARK='Q[A-Z][A-Z][A-Z]*_H';
$STARTMARK='#ifndef QT_H';
$ENDMARK='#endif // QT_H';
$TAIL="#endif // QT_H";
$QTDIR="$ENV{QTDIR}";

if ( defined($ARGV[0]) && $ARGV[0] eq "--fix" ) {
    $fix++;
    shift;
}

@QT_HEADERS = ();
@QWS_HEADERS = ();

opendir SRC, "$QTDIR/src"
    || die "Reading QTDIR/src/";
map {
    $dir="$QTDIR/src/$_";
    opendir SUBSRC, "$dir";
    map {
	if ( m/\.h$/ &&
	    !m/^$IGNORE$/ &&
	    ! -f "$ENV{QTDIR}/src/compat/$_"  &&
	    ! -f "$ENV{QTDIR}/src/attic/$_" )
	{
	    $p="$dir/$_";
	    if ( /_qws\./ ) {
		push @QWS_HEADERS, "$p";
	    } elsif ( /_p\./ ) {
		push @QT_HEADERS_P, "$p";
	    } else {
		push @QT_HEADERS, "$p";
	    }
	}
    } readdir SUBSRC;
} readdir SRC;

open QT_H, ">$QTDIR/src/kernel/qt.h" or die "Cannot open $QTDIR/src/kernel/qt.h\n";

print QT_H
'/****************************************************************************
**
** Qt GUI Toolkit
**
** This header file efficiently includes all Qt GUI Toolkit functionality.
**
** Generated : '.`date`.'
**
** Copyright (C) 1995-2000 Trolltech AS.  All rights reserved.
**
** This file is part of the Qt GUI Toolkit.
**
*****************************************************************************/

#ifndef QT_H
#define QT_H
';



$include = '#include\s*(["<])([^\n]*?)[">]';

sub do_headers
{
    my @HEADERS = @_;
    my %FILE;
    my %LOCAL = map { ($_ => 1) } @HEADERS;
    my %DEP;
    my %HEADERS;
    H: for $file ( @HEADERS ) {
	($dir,$h) = $file =~ m{(.*)/(.*)};
	$dir{$h}=$dir;
	open HEADER, $file
	 or die "Cannot read $file";
	$content = "" if $fix;
	$found = 0;
	while (<HEADER>) {
	    $content .= $_ if $fix;
	    if ( /$STARTMARK/ ) {
		$incscan=1;
	    } elsif ( /$ENDMARK/ ) {
		$incscan=0;
		$found++; # next H;
	    } elsif ( /$include/ ) {
		if ($incscan) {
		    $inc=$2;
		    if ( !$IGNORE_HEADERS{$inc} ) {
			$DEP{"$h $inc"}=1;
			$LOCAL{$inc}=($1 eq '"');
			$FILE{$h}++;
			$FILE{$inc}++;
		    }
		}
	    }
	}
	if ( !$found ) {
	    if ( $fix ) {
		#$include = '#include\s*["<][^\n]*?[">]';
		$content =~ s/(($include\s)+)/$STARTMARK\n$1$ENDMARK\n/s
		    || $content =~ s/\n/\n$STARTMARK\n$ENDMARK\n/s;
		if ( ! -w "$file" ) {
		    system("p4 edit $file");
		}
		open OUT, ">$file";
		print OUT $content;
	    } else {
		die "No QT_H segment in $h ($file) - rerun with --fix to fix ALL headers\n";
	    }
	}
    }
    @FILE=sort keys %FILE;

    $N=$#FILE;
    $done=0;

    # Bubble sort by dependency... (qsort can't do this)
    while (!$done) {
	$done=1;
	for $i (1..$N) {
	    for $j (0..$i) {
		if ($DEP{"$FILE[$j] $FILE[$i]"}) {
		    # j depends on i, swap
		    if ( $i == $j ) {
			die "Error: $FILE[$j] depends on itself";
		    }
		    $t=$FILE[$i];
		    $FILE[$i]=$FILE[$j];
		    $FILE[$j]=$t;
		    $done=0;
		}
	    }
	}
    }

    # Check for circularities
    for $f ( 0..$#FILE ) {
	for $o ( ($f+1)..$#FILE ) {
	    print STDERR "Circularity in $FILE[$f] .. $FILE[$o]\n" if ( $DEP{"$FILE[$f] $FILE[$o]"} )
	}
    }

    # Be sure qglobal.h preceeds qfeatures.h
    @FILE = ( "qglobal.h", @FILE );

    for $h ( @FILE ) {
	if (!$DONE{$h}) {
	    if ( $printpath ) {
		$path = $dir{$h};
		if ( $path ) {
		    $path =~ s{.*/}{../};
		    $path .= "/";
		} else {
		    $path = "";
		}
	    } else {
		$path = "";
	    }
	    if ($path || $LOCAL{$h}) {
		print QT_H qq{#include "$path$h"};
	    } else {
		print QT_H qq{#include <$h>};
	    }
	    if ( $verbose ) {
		@deps = grep { $DEP{"$h $_"} } @FILE;
		if ( @deps ) {
		    print QT_H " // Depends on ",join ", ",@deps;
		}
	    }
	    print QT_H "\n";
	    $DONE{$h}++;
	}
    }
}

map { $IGNORE_HEADERS{$_}=1; } @QWS_HEADERS;

$printpath=0;
do_headers @QT_HEADERS;
%IGNORE_HEADERS=();

$printpath=1;
print QT_H "\n#if defined( QT_MOC_CPP ) || defined( QT_H_CPP )\n";
do_headers @QT_HEADERS_P;
print QT_H "#endif // Private headers\n\n";

$printpath=0;
print QT_H "\n#ifdef Q_WS_QWS\n";
do_headers @QWS_HEADERS;
print QT_H "#endif // Q_WS_QWS\n\n";

print QT_H "$TAIL\n";
