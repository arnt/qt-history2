#!/usr/bin/perl

if ( ! $ENV{"HOSTTYPE"} ) {
    $platform = "win";			# Windows 95 or NT
} else {
    $platform = "x11";			# X11
}

while ( @ARGV ) {			# parse command line args
    $_ = shift @ARGV;
    if ( s/^-// ) {
	if ( /^(win|x11)$/ ) {
	    $platform = $1;
	} elsif ( /^nobeta$/ ) {
	    $nobeta = 1;
	} elsif ( /^o(.*)/ ) {
	    $outfile = ($1 eq "") ? shift @ARGV : $1;
	    $outfile eq "" || open(STDOUT,">" . $outfile) ||
		die "Can't redirect stdout to \"$outfile\"";

	} else {
	    die "Unrecognized option";
	}
    } else {
	push (@makefiles, $_ );
    }
}

if ( ! @makefiles ) {
    chdir( $ENV{"QTDIR"} . "/src" );
    @makefiles = ("tools/Makefile","kernel/Makefile",
		  "widgets/Makefile","dialogs/Makefile" );
}

foreach $m ( @makefiles ) {
    if ( $m =~ /(^.*\/)/ ) {
	$dirpre = $1;
    } else {
	$dirpre = "";
    }
    %v = &scan_makefile($m);
    if ( $nobeta ) {
	$v{"SOURCES"} = &subtract_array( $v{"SOURCES"}, $v{"BETA"} );
	$v{"HEADERS"} = &subtract_array( $v{"HEADERS"}, $v{"BETA"} );
    }
    @s = sort split(/\s+/,$v{"SOURCES"});
    @h = sort split(/\s+/,$v{"HEADERS"});
    foreach $f ( @s ) { $f = $dirpre . $f; }
    foreach $f ( @h ) { $f = $dirpre . $f; }
    push(@src,@s);
    push(@hdr,@h);
    $src = $dirpre . join(" $dirpre",@s);
    $hdr = $dirpre . join(" $dirpre",@h);
}

$qglobal_cpp = $ENV{"QTDIR"} . "/src/tools/qglobal.cpp";
open(F, $qglobal_cpp) || die "Cannot open $qglobal_cpp";
while ( <F> ) {
    if ( /^\#define\s+QT_VERSION\s+\"([^\"]*)\"/ ) {
	$qt_version = $1;
	last;
    }
}
close(F);
($qt_version eq "") && die "Can't find the Qt version in qglobal.cpp";

$headers  = "HEADERS     =\t" . join(" \\\n\t\t",sort @hdr);
$sources  = "SOURCES     =\t" . join(" \\\n\t\t",sort @src);
if ( $platform ne "x11" ) {
    $headers =~ s/_x11/_$platform/g;
    $sources =~ s/_x11/_$platform/g;
}
$template = "TEMPLATE    =\t" . "qtlib";
$target   = "TARGET      =\t" . "qt";
$version  = "VERSION     =\t" . $qt_version;

print $template . "\n\n";
print $headers  . "\n\n";
print $sources  . "\n\n";
print $target   . "\n\n";
print $version  . "\n";

#
# scan_makefile(file)
#
# Scans a project file and returns an associative array
# of project variables with lists of values.
#

sub scan_makefile {
    local($file) = @_;
    local(%vars,$tag,$varstr,@v);

    open(TMP,$file) || die("Can't open file \"$file\"");
    while ( <TMP> ) {
	s/\#.*//;				# strip comment
	if ( /^\s*(\w+)\s*=/ ) {
	    $tag = $1;
	    s/^.*=\s*//;
	}
	if ( $tag ne "" ) {
	    $more = ( $_ =~ s/\s*\\\s*$// );	# more if \ at end of line
	    s/^\s+//;
	    s/\s+$//;
	    push( @v, split( /\s+/, $_ ) );
	    if ( ! $more ) {
		$varstr = join(" ",@v);
		$vars{$tag} = $varstr;
		$tag = "";
		@v = ();
	    }
	}
    }
    close(TMP);
    return %vars;
}


#
# Finds files.
#
# Examples:
#   find_files("/usr","\.cpp$",1)   - finds .cpp files in /usr and below
#   find_files("/tmp","/^#/",0)	    - finds #* files in /tmp
#

sub find_files
{
    local($dir,$match,$descend) = @_;
    local(*D);
    local($file,@files);
    ($dir eq "") && ($dir = ".");
    $dir .= "/" if ( !($dir =~ /\/$/) );
    if ( opendir(D,$dir) ) {
	($dir eq "./") && ($dir = "");
	foreach $file ( readdir(D) ) {
	    next if ( $file  =~ /^\.\.?$/ );
	    ($file =~ /$match/) && (push @files, ($dir . $file));
	    if ( $descend && -d $file ) {
		push @files, &find_files($file,$match,$descend);
	    }
	}
	closedir(D);
    }
    return @files;
}


#
# From the Camel book, p.202
#
sub subtract_array {
    local($a,$b) = @_;
    local(%mark);
    local(@aa,@bb,@cc);
    @aa = split(/\s+/,$a);
    @bb = split(/\s+/,$b);
    grep($mark{$_}++,@bb);
    @cc = grep(!$mark{$_},@aa);
    return join(" ",@cc);
}
