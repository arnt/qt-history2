#!/usr/bin/perl -w
#
# Creates a new Qt source distribution
#
# Copyright 2000 Troll Tech AS.  All rights reserved.
#
# ----------------------------------------------------------------
#
# Usage:
#	mkdists [options] {version}
#
# Options:
#	-nodoc	Don't generate documentation
#	-nowin	Don't generate Windows
#	-nox11	Don't generate X11
#	-noqws	Don't generate Qt/Embedded
#

use File::Find;
use File::Copy;
$/ = undef;

($j,$j,$j,$j,$j,$year,$j,$j,$j) = localtime (time);

# option parsing.

$doc = 1;
$version = 0;

for $a ( @ARGV ) {
    if ( $a eq "-nodoc" ) {
	$doc = undef;
	print "Will not generate documentation.\n";
    } elsif ( $a =~ /^-no(x11|qws|win)$/ ) {
	$notplatform{$1}=1;
	print "Will not generate \"$1\" platform.\n";
    } else {
	$version = $a;
    }
}

# okay, figure out what version of Qt to look at, and make a directory

if ( $version =~ /(.*)\.\d+/ ) {
    $branch = $1;
} else {
    die "could not figure out what branch to use, stopped";
}
$label = "qt/$version";
$version_digits = $version;
$version_digits =~ s/\.//g;
$version_digits =~ s/(\d\d\d).*/$1/;

$name = getlogin() || getpwuid($<) || "sexybaby";

$distdir="/tmp/qt-$version-$name";
mkdir $distdir, 0755 unless ( -d $distdir );
sub deletefiles {
    unless ( -d $_ ) {
	unlink $_;
	$deleted++;
    } 
}
find( \&deletefiles, $distdir );
print "Deleted $deleted files from last time\n" if ( $deleted );

# at this point, we have a directory structure, possibly full of empty
# directories.  let's fill it.

print "Checking out Qt $version and tmake\n";

open( I, "p4 fstat //depot/qt/$branch/doc.conf |" ) ||
  die "could not run p4 fstat, stopped";
$_ = <I>;
close I;
die "//depot/qt/$branch/... is not in the depot, stopped"
  unless ( $_ =~ / depotFile /s );

open( I, "p4 labels |" ) || die "could not run p4 labels, stopped";
$_ = "\n" . <I>;
close I;
die "Label $label does not exist, stopped" unless ( $_ =~ /\nLabel $label /s );

print "Exporting the entire Qt and tmake depots\n";

$tmpclient="qt-release-tmp-$name-$$";
open( I, "p4 client -t qt-release -o $tmpclient |" ) ||
  die "could not run p4 client, stopped";
$client = <I>;
close I;
$client =~ s@\nRoot:[^\n]*@\nRoot: $distdir@s;
$client =~ s@/qt/X.Y/@/qt/$branch/@gs;
$client =~ s@(\nClient: )[^\n]*@$1qt-release-tmp-$$@s;
$client =~ s@\bnomodtime\b@modtime@s;

open O, "| p4 -s client -i | egrep -v '^(info|exit):'";
print O $client;
close O;
open( I1, "p4 -s -c $tmpclient sync $distdir/qt/...\@$label | grep -v '^info:' |" )
  || die "could not sync qt, stopped";
open( I2, "p4 -s -c $tmpclient sync $distdir/tmake/... | grep -v '^info:' |" )
  || die "could not sync tmake, stopped";
$_ = "\n" . <I1> . <I2>;
s/\nexit: [^\n]*//g;
close I1;
close I2;

open( I, "p4 -s client -d $tmpclient |" )
  || die "could not run p4 client -d $tmpclient, stopped";
$_ = "\n" . <I>;
close I;
s/\ninfo: [^\n]*//g;
s/\nexit: [^\n]*//g;

$qtdir = "$distdir/qt";
$ENV{ "QTDIR" } = $qtdir;

# fixify qglobal's version number

$qglobal = "$distdir/qt/src/tools/qglobal.h";
open( I, "< $qglobal" ) || die "cannot open $qglobal, stopped";
$_ = <I>;
close I;
s/(\n\#define\s+QT_VERSION\s+)\d+/$1$version_digits/;
s/(\n\#define\s+QT_VERSION_STR\s+\")([\d\.]+)/$1$version/;
open( O, "> $qglobal.new" ) || die "cannot open $qglobal, stopped";
print O $_;
close O;
unlink( $qglobal );
rename( "$qglobal.new", $qglobal );
# and fetch the remainder of QT_VERSION_STR
if ( /\n\#define\s+QT_VERSION_STR\s+\"[\d\.]+(-[^\"]+)/ ) {
    $type = $1;
    if ( $type ne "-snapshot" && $type !~ /^-beta\d*$/ ) {
	die "The qt version is $version$type, which confuses me terribly";
    }
} else {
    $type = "";
}

print "Marking \$", "Id...\$\n";

sub idify {
    if ( -f $_ && ! -l $_ && -T $_ && open( I, "< $_" ) ) {
	my $f = <I>;
	my $o;
	close I;
	if ( defined( $f ) && $f =~ /\$Id(?::[^\$\n]*)?\$/s ) {
	    my ( $mday, $mon, $year, $d );
	    ($j,$j,$j,$mday,$mon,$year,$j,$j,$j) = localtime ( (stat($_))[9] );
	    $d = $File::Find::dir;
	    $d =~ s/^$qtdir/qt/;
	    $d = sprintf( "%s/%s   %s%s   edited %04d-%02d-%02d",
			  $d, $_, $version, $type, $year+1900, $mon+1, $mday );
	    $o = $f;
	    $f =~ s@\$Id(?::[^\$\n]*)?\$@\$Id\: $d \$@gsi;
	    if ( $f ne $o ) {
		my $x = ( -x $_ );
		chmod 0644, $_;
		open( O, "> $_" ) || die "could not write $File::Find::dir/$_";
		print O $f;
		close O;
		if ( $x ) {
		    chmod 0555, $_;
		} else {
		    chmod 0444, $_;
		}
	    }
	}
    }
}

find( \&idify, "$qtdir" );

print "Making temporary include files\n";

mkdir "$qtdir/include", 0777;
open( I, "$qtdir/bin/syncqt -show |" ) || die "could not run syncqt, stopped";
@includefiles = split( /\n/, <I> );
close I;

foreach $fullname ( @includefiles ) {
    $_ = $fullname;
    s-.*/--;
    symlink( "../$fullname", "$qtdir/include/$_" );
}

# time to run qdoc.  maybe.

mkdir( "$distdir/qt/doc/html", 0777 );
mkdir( "$distdir/qt/doc/man", 0777 );
mkdir( "$distdir/qt/doc/man/man1", 0777 );
mkdir( "$distdir/qt/doc/man/man3", 0777 );
# and do the moc.1 hack here
rename( "$distdir/qt/src/moc/moc.1", "$distdir/qt/doc/man/man1" );

if ( $doc ) {
    print "Running qdoc\n";
    open( I, "$distdir/qt/util/qdoc/qdoc $distdir/qt |" )
      || die "could not run qdoc, stopped";
    $_ = <I>;
    close I;
    open( I, "$distdir/qt/util/qdoc/man $distdir/qt |" )
      || die "could not run util/qdoc/man, stopped";
    $_ = <I>;
    close I;

    sub moveimages {
	if ( -f $_ && ( /\.png$/ || /\.jpg$/ ) ) {
	    move( $_, "$distdir/qt/doc/html/$_" );
	}
    }

    find( \&moveimages, "$qtdir/gif" );
}

print "Transmogrifying various files\n";

# Replace Netscape-owned code with dummies (direct user to PluginSDK)

sub fixnetscape {
    if ( /^(np|jri)/ ) {
	unlink $_;
	open( O, "> $_" );
	print O "#error \"$_ must be provided by Netscape.\n
#error \"This file just a placeholder.  Please see the documentation\"
#error \"to learn how to obtain the real file.\"
";
	close O;
    }
}
find( \&fixnetscape, "$distdir/qt/extensions/nsplugin/src" );

# changelogs?

print "Warning: qt/dist/changes-$version does not exist\n"
  unless ( -f "$distdir/qt/dist/changes-$version" );

# qt.h

unlink "$distdir/qt/include/qt.h";
if ( 0 ) { ### left out for now
    open( I, "$distdir/qt/util/scripts/make_qt_dot_h |" )
      || die "could not run make_qt_dot_h, stopped";
    $_ = <I>;
    close I;
    open( O, "> $distdir/qt/include/qt.h" )
      || die "could not write to include/qt.h, stopped";
    print O $_;
    close O;
}

# qt/src/moc stuff

open( I, "make -C $distdir/qt/src/moc -o moc.pro -o GNUmakefile mocgen.cpp |" )
  || die "could not run make, stopped";
$_ = <I>; # do anything with the input?  no?
close I;
open( I, "< $distdir/qt/src/moc/lex.yy.c" )
  || die "could not read lex.yy.c, stopped";
$_ = "/* Automatically generated at Troll Tech by mkdists, Qt $version */\n"
  . <I>;
close I;
s/\n\#include\s+\<unistd\.h\>[^\n]*/\n\#if !defined(_OS_WIN32_)$&\n\#endif/g;
open( O, "> $distdir/qt/src/moc/lex.yy.c" )
  || die "could not write lex.yy.c, stopped";
print O $_;
close O;
sleep 2; # Make very certain that mocgen.cpp has later timestamp than lex.yy.c
open( I, "< $distdir/qt/src/moc/mocgen.cpp" )
  || die "could not read mocgen.cpp, stopped";
$_ = "/* Automatically generated at Troll Tech by mkdists, Qt $version */\n"
  . <I>;
close I;
open( O, "> $distdir/qt/src/moc/mocgen.cpp" )
  || die "could not write mocgen.cpp, stopped";
print O $_;
close O;

#  qgif.h

$qgif = "$qtdir/src/kernel/qgif.h";

open( I, "< $qgif" )
    || die "could not read $qgif, stopped";
$_ = <I>;
close I;
s/(\n\#define QT_BUILTIN_GIF_READER\s+)\S+/$1 0/g;
open( O, "> $qgif.new" ) || die "could not write $qgif.new, stopped";
print O $_;
close O;
unlink( $qgif );
rename( "$qgif.new", $qgif );

# changes files

$major = $version;
$major =~ s/^(\d+\.\d+).*/$1/;
opendir( D, "$distdir/qt/dist" );
foreach ( readdir( D ) ) {
    move( "$distdir/qt/dist/$_", "$distdir/qt/$_" ) if ( /^changes-$major\./ ||
						         0 );
}
closedir( D );

# doc -> src/doc

&rmrf( "$qtdir/src/doc" );
rename( "$qtdir/doc", "$qtdir/src/doc" );

# tmake common stuff

$ENV{"TMAKEDIR"}="$distdir/tmake";
$ENV{"PATH"}="$ENV{TMAKEDIR}/bin:$ENV{PATH}";

# copy the tree to new platform-specific trees

for $platform ( "x11", "windows", "qws" ) {
    next if $notplatform{$platform};
    print "Making $distdir/$platform\n";
    mkdir "$distdir/$platform", 0777;
    if ( $platform eq "win" ) {
	$newdir = "$distdir/$platform/qt";
    } else {
	$newdir = "$distdir/$platform/qt-$version$type"
    }
    mkdir $newdir, 0777;
    $files = 0;
    sub populate {
	$outfile = "$File::Find::dir/$_";
	$outfile =~ s@^$qtdir/@@;
	$outfile =~ s-/\./-/-g;
	if ( -l $_ ) {
	    # skip all symlinks
	} elsif ( -f $_ && public( $outfile ) ) {
	    my $d;
	    $d = "$newdir/$outfile";
	    $d =~ s-/[^/]*$--;
	    &mkdir_steroids( $d );
	    $files++;
	    link( $_, "$newdir/$outfile" );
	}
    }
    find( \&populate, "$distdir/qt" );
    print "  ($files files)\n";
    if ( $undecideds ) {
	print "Could not decide whether to kill or keep$undecideds\n";
	die;
    }
}

# X11 and QWS stuff.

for $platform ( "x11", "qws" ) {
    next if $notplatform{$platform};

    $platformname = $platform eq "qws" ? "embedded" : $platform;

    print "Processing \U$platform\E ($distdir/$platform)\n";

    $qtdir = "$distdir/$platform/qt-$version$type";

    $ENV{ "TMAKEPATH" } = $ENV{"TMAKEDIR" } . "/lib/linux-g++";
    $ENV{ "QTDIR" } = $qtdir;

    find(
	sub {
	    unlink $_ if ( ( /_[a-z][a-z1]+.cpp$/ && !/_$platform.cpp$/ && !/_unix.cpp$/ ) ||
		   ( /_[a-z][a-z1]+.h$/ && !/_$platform.h$/ ) );
	}, $qtdir
    );

    # copy the dist things into a supplemental directory
    for $freedom ( "free", "commercial" ) {
	next if $freedom eq "free" && $platform ne "x11";

	mkdir "$distdir/$platform-$freedom/", 0777;
	mkdir "$distdir/$platform-$freedom/qt-$version$type", 0777;

	opendir( D, "$distdir/qt/dist/$freedom" );
	foreach ( readdir( D ) ) {
	    &copy_version( "$distdir/qt/dist/$freedom/$_",
			   "$distdir/$platform-$freedom/qt-$version$type/$_" );
	}
	closedir( D );

	opendir( D, "$distdir/qt/dist/$platformname" );
	for $file ( readdir( D ) ) {
	    next if $file =~ /^\./;
	    $d = "$distdir/qt/dist/$platformname/$file";
	    if ( -f $d ) {
		&copy_version( $d,
			   "$distdir/$platform-$freedom/qt-$version$type/$file" );
	    } else {
		# Copy it verbatim
		system("cp -a $d $distdir/$platform-$freedom/qt-$version$type");
	    }
	}
	closedir( D );

	# Remove unifont.bdf - it's too big to both shipping, and the
	# fontdir points to the source.
	unlink "$distdir/$platform-$freedom/qt-$version$type/etc/fonts/unifont.bdf";
	unlink "$distdir/$platform-$freedom/qt-$version$type/etc/fonts/verdana.ttf";
    }

    link( "$distdir/qt/util/scripts/configure", "$qtdir/configure" );

    # move the doc back

    mkdir "$qtdir/doc", 0777;
    rename( "$qtdir/src/doc/html", "$qtdir/doc/html" );
    rename( "$qtdir/src/doc/man", "$qtdir/doc/man" );

    # Generate makefiles

    open( I, "$qtdir/util/scripts/makeunixmake -v $platform 2>&1 |" )
      || die "could not run makeunixmake, stopped";
    $_ = <I>; # what do we do with it? nothing for now...
    close I;

    # copy the templates into configs, and lose tmake
    opendir( D, "$qtdir/tmake" );
    foreach ( readdir( D ) ) {
	move( $_, "$qtdir/configs" ) if ( /\.t$/ &&
					  $_ ne "propagate.t" &&
					  $_ ne "subdirs.t" );
    }
    closedir( D );
    rmrf( "$qtdir/tmake" );
    rmrf( "$qtdir/makefiles" );

    # make symlinks

    mkdir "$qtdir/include", 0777;
    foreach $fullname ( @includefiles ) {
	$_ = $fullname;
	s-.*/--;
	symlink( "../$fullname", "$qtdir/include/$_" );
    }

    # lose util well and truly

    &rmrf( "$qtdir/util" );

    # delete some examples

    &rmrf( "$qtdir/examples/kiosk" );
    &rmrf( "$qtdir/examples/biff" ) unless $platform eq "x11";
    &rmrf( "$qtdir/examples/desktop" ) unless $platform eq "x11";
    &rmrf( "$qtdir/examples/sound" ) unless $platform eq "x11";
    &rmrf( "$qtdir/examples/winmanager" ); # unless $platform eq "qws";
    &rmrf( "$qtdir/extensions/opengl" ) unless $platform eq "x11";
    &rmrf( "$qtdir/extensions/xembed" ) unless $platform eq "x11";
    &rmrf( "$qtdir/extensions/imageio" ) unless $platform eq "x11";
    &rmrf( "$qtdir/extensions/nsplugin" ) unless $platform eq "x11";
    &rmrf( "$qtdir/extensions/sound" ) unless $platform eq "x11";
    &rmrf( "$qtdir/extensions/xt" ) unless $platform eq "x11";

    # lose empty directories

    &prune( "qtdir" );

    # tar up the two supplementals

    chdir( "$distdir/$platform-free" ) if $platform eq "x11";
    system( "tar cf ../qt-$platformname-$version$type.tar qt-$version$type" ) if $platform eq "x11";
    chdir( "$distdir/$platform-commercial" );
    system( "tar cf ../qt-$platformname-$version$type-commercial.tar qt-$version$type" );

    # then run tar for real, on the unix tree.
    chdir( "$distdir/$platform" );
    open( "TAR1$platformname", "tar rf ../qt-$platformname-$version$type.tar qt-$version$type |" ) if $platform eq "x11";
    open( "TAR2$platformname", "tar rf ../qt-$platformname-$version$type-commercial.tar qt-$version$type |" );
    # those will run in the background, accessing the same files at the
    # same time, mostly.  later, we'll compress.

}

# windows stuff

if (!$notplatform{win}) {
    print "Processing Windows ($distdir/windows)\n";

    $qtdir = "$distdir/windows/qt";
    $ENV{ "QTDIR" } = $qtdir;

    sub justwinfiles {
	unlink $_ if ( ( /_[a-z][a-z1]+.cpp$/ && !/_win.cpp$/ ) ||
		       ( /_[a-z][a-z1]+.h$/ && !/^qt_windows.h$/ ) );
    }
    find( \&justwinfiles, $qtdir );

    # move the files into include

    mkdir "$qtdir/include", 0777 unless ( -d "$qtdir/include" );
    foreach $fullname ( @includefiles ) {
	$_ = $fullname;
	s-.*/--;
	move( "$qtdir/$fullname", "$qtdir/include/$_" );
    }

    # delete the xt estension

    &rmrf( "$qtdir/extensions/xt" );

    # Generate makefiles

    mkdir "$qtdir/lib",0777 unless ( -d "$qtdir/lib" );
    mkdir "$qtdir/mkfiles",0777 unless ( -d "$qtdir/mkfiles" );

    $ENV{ "TMAKEPATH" } = $ENV{"TMAKEDIR" } . "/lib/linux-g++";

    mkdir "$qtdir/lib", 0777 unless( -d "$qtdir/lib" );
    #foreach $buildtype ( "" ) {
    #    foreach $compiler ( "msvc" ) {
    #}}
    foreach $buildtype ( "", "-dll" ) {
	foreach $compiler ( "borland", "msvc" ) {
	    print "  Building $compiler$buildtype Makefiles\n";
	    open( O, "> $qtdir/lib/qt$version_digits.lib" ) || die;
	    close O;
	    copy( "$distdir/qt/src/Makefile.win32-dll", "$qtdir/src/Makefile" )
	      if ( $buildtype eq "-dll" );
	    $ENV{"TMAKEPATH"} = $ENV{"TMAKEDIR"} . "/lib/win32-$compiler";
	    open( I, "$qtdir/util/scripts/buildmakefiles -win32 $buildtype 2>&1|" )
	      || die "could not run buildmakefiles, stopped";
	    $_ = <I>;
	    close I;

	    chdir $qtdir;
	    open( I, "find . -name Makefile -o -name \"qt*.mak\" | xargs zip -rml9 $qtdir/mkfiles/$compiler$buildtype.zip |" )
	      || die "could not run zip, stopped";
	    $_ = <I>;
	    close I;

	    foreach ( "lib/qt$version_digits.lib", "src/Makefile", "src/qtdll.mak",
		      "src/qtmain.mak", "src/Makefile.win32-dll" ) {
		unlink $_ if ( -f $_ );
	    }
	}
    }

    # copy Windows dist/* stuff

    opendir( D, "$distdir/qt/dist/commercial" );
    foreach ( readdir( D ) ) {
	&copy_version( "$distdir/qt/dist/commercial/$_", "$qtdir/$_" );
    }
    closedir( D );

    opendir( D, "$distdir/qt/dist/win/" );
    foreach ( readdir( D ) ) {
	&copy_version( "$distdir/qt/dist/win/$_", "$qtdir/$_" );
    }
    closedir( D );

    mkdir "$qtdir/bin", 0777 unless( -d "$qtdir/bin" );
    opendir( D, "$distdir/qt/dist/win/bin" );
    foreach ( readdir( D ) ) {
	copy( "$distdir/qt/dist/win/bin/$_", "$qtdir/bin/$_" );
    }
    closedir( D );

    # lose the man pages and util

    &rmrf( "$qtdir/src/doc/man" );
    &rmrf( "$qtdir/util" );
    &rmrf( "$qtdir/tmake" );
    unlink( "$qtdir/src/qtinternal.pro" );

    # move the doc from doc/html/* to doc/*

    mkdir "$qtdir/doc", 0777;
    rename( "$qtdir/src/doc/html", "$qtdir/doc/html" );

    # make a lib/dummy
    mkdir "$qtdir/lib", 0777 unless( -d "$qtdir/lib" );
    open( O, "> $qtdir/lib/README" ) || die;
    print O "If this directory is empty, you forgot to build the Qt library\n";
    close O;

    # install one set of makefiles, and zip up the thing

    open( I, "unzip -aq -d $qtdir $qtdir/mkfiles/msvc.zip |" )
      || die "could not unzip msvc makefiles, stopped";
    $_ = <I>;
    close I;

    print "unzip said:\n$_\n" if ( defined( $_ ) && $_ ne "" );

    # lose empty directories

    &prune( "qtdir" );

    @binaryfiles = undef;
    @textfiles = undef;

    sub addfile {
	my $s = $_;
	$s =~ s/.*\.//;
	my $f = "$File::Find::dir/$_";
	$f =~ s@^$qtdir/@qt/@;
	if ( $s eq "dll" || $s eq "gif" || $s eq "png" || $s eq "jpg" ||
	     $s eq "bmp" || $s eq "any" || $s eq "pic" || $s eq "ppm" || 
	     $s eq "exe" || $s eq "zip" || $s eq "qm" ) {
	    push @binaryfiles, "$f";
	    #print "$f is binary\n";
	} else {
	    push @textfiles, "$f";
	}
    }

    find( \&addfile, $qtdir );

    chdir( "$distdir/windows" );
    open( O, "| zip -r9q@ $distdir/qtwin$version_digits$type.zip" )
      || die "could not zip up $distdir/qtwin$version_digits$type.zip, stopped";
    foreach $_ ( @binaryfiles ) {
	print O "$_\n" if ( defined( $_ ) && -f $_ );
    }
    close O;
    open( O, "| zip -r9ql@ $distdir/qtwin$version_digits$type.zip" )
      || die "could not zip up $distdir/qtwin$version_digits$type.zip, stopped";
    foreach $_ ( @textfiles ) {
	print O "$_\n" if ( defined( $_ ) && -f $_ );
    }
    close O;
}

# back to unix - close the tars, and compress the results after the
# thing is done

for $platform ( "x11", "embedded" ) {
    next if $notplatform{$platform};

    close "TAR1$platform" if $platform eq "x11";
    close "TAR2$platform";

    system( "gzip -9 $distdir/qt-$platform-$version$type.tar" ) if $platform eq "x11";
    system( "gzip -9 $distdir/qt-$platform-$version$type-commercial.tar" );
}


sub rmrfhelper {
    if ( -d $_ ) {
	rmdir $_;
    } else {
	unlink $_;
    }
}

sub rmrf {
    finddepth( \&rmrfhelper, $_[0] ) if ( -d $_[0] );
}


sub mkdir_steroids {
    my $d = $_[0];
    if ( ! -d $d ) {
	my $p;
	$p = $d;
	$p =~ s-/[^/]+$--;
	mkdir_steroids( $p ) if ( $p ne $d );
	mkdir $d, 0777;
    }
}


# Function killInternalFiles
# Identifies and kills internal files and folders.
#
# Usage: killInternalFiles( path )
#

sub public {
    my $file  = $_[0];

    my ( $keep, $kill );

    my $basename;
    $basename = $file;
    $basename =~ s-.*/--;

    $keep = (
	     # the scripts, for now
	     $file =~ /^util\/scripts\//

	     # everything in the subdirectories of src/doc/
	     || ( $file =~ /^src\/doc\// && $basename ne "Makefile" )

	     # all c++ files under .../src/
	     || $file =~ /(^|\/)src\/.*\.((cpp)|h|c|(pro))$/
	     || $file =~ /(^|\/)src\/qt\.t$/

	     # include (empty)
	     || $file eq "include"

	     # all doc files
	     || $basename =~ /.*\.doc$/

	     # the changes files
	     || $file =~ /^changes-/

	     # /configure
	     || $file eq "configure"

	     # the tutorials
	     ||  $file =~ /^tutorial\/t[0-9]*\/$/
	     # all c++ and pro files under tutorial
	     || $file =~ /^tutorial\/.*\.((cpp)|h|(pro))$/
	     # the examples
	     || $file =~ /^examples\/.*\/$/
	     # all c++, pro, qm, po and xpm files under examples
	     || $file =~ /^examples\/.*\.((cpp)|h|(pro)|(qm)|(po)|(xpm)|(map)|(txt)|(bmp)|(gif)|(pic)|(ppm)|(png)|(wav)|(any))$/
	     # all the junk from mpegplay in the kiosk example
	     || $file =~ /^examples\/kiosk\/.+\..+$/
	     || $file =~ /^examples\/kiosk\/README.*$/
	     || $file =~ /^examples\/kiosk\/tags$/
	     # all the launcher files
	     || $file =~ /^examples\/launcher\/.*(\.im|\.pl|perpetual_launch|start_demo)$/

	     # the extensions
	     || $file =~ /^extensions\/.*\/$/
	     # all c++, pro, qm, po and xpm files under extensions
	     || $file =~ /^extensions\/.*\.((cpp)|h|(pro)|(qm)|(po)|(xpm)|(map)|(txt)|(bmp)|(gif)|(pic)|(ppm)|(png)|(wav)|(any)|c)$/
	     || $file =~ /^extensions\/.*\/isdninfo$/

	     # READMEs, NOTICE and such
	     || $file =~ /^src\/((.*\/)|)[A-Z]+$/
	     || $file =~ /^src\/((.*\/)|)[A-Z]+$/
	     || $file =~ /^examples\/((.*\/)|)[A-Z]+$/
	     || $file =~ /^tutorial\/((.*\/)|)[A-Z]+$/
	     || $file =~ /^extensions\/((.*\/)|)[A-Z]+$/
	     || $file =~ /^extensions\/.*\/README\..*$/

	     # the moc
	     || $file =~ /^src\/moc\/.*\.(1|l|t|y)$/

	     # All of tmake
	     || $file =~/^tmake\//

	     # 3rdparty
	     || $file =~/src\/3rdparty\/$/
	     || $file =~/src\/3rdparty\/.*README$/
	     || $file =~/src\/3rdparty\/libpng\//
	     || $file =~/src\/3rdparty\/freetype2\//
	     || ( $file =~/src\/3rdparty\/zlib\// &&
		  not $basename eq "Makefile" )
	     # More  of nsplugin example
	     || $file =~/extensions\/nsplugin\/examples\/.*\.((def)|(rc)|(cgi)|(g1n))$/

	     # some bins
	     || $file =~/bin\/$/
	     || $file =~/bin\/findtr$/
	     || $file =~/bin\/qt20fix$/
	     || $file =~/bin\/qtrename140$/

	    );

    $kill = (
	     # no qdoc conf
	     $basename eq "doc.conf"

	     # no make.help
	     || $basename eq "make.help"

	     # Everything under dist
	     || $file =~/^dist\//

	     # no tests conf
	     || $file =~/.*\/tests\//

	     # no tests
	     || $file =~ /^tests\//

	     # utils, except scripts
	     || ( $file =~ /^util\// && $file !~ /^util\/scripts\// )

	     # no ~ files
	     || $basename =~/.*~$/

	     # no gif
	     || $file =~/gif\//

	     # no configs
	     || $file =~/configs\//

	     # no makefiles, except freetype2
	     || $basename eq "GNUmakefile" && $file !~ /src\/3rdparty\/freetype2\//
	     || $basename eq "Makefile" && $file !~ /src\/3rdparty\/freetype2\//
	     || $file =~ /src\/Makefile\..*/

	     # no mak files
	     || ( $basename =~/.*\.mak$/  && not $file =~ /.*\/libpng\// )

	     # no *.inc files
	     || $basename =~/.*\.inc$/

	     # some bins
	     || $file =~ /bin\/.*_make_.*$/
	     || $file =~ /bin\/syncqt.*$/

	    );
    if ( $keep == $kill ) {
	$undecideds .= "\n  $file ($keep)";
	$keep = undef;
    }
    $keep;
}


sub copy_version {
    my( $in, $out ) = @_;
    local $_;

    unlink $out if ( -f $out );
    if ( -f $in && ! -e $out ) {
	open( I, "< $in" ) || die "could not open $in, stopped";
	$_ = <I>;
	close I;
	s/%YEAR%/$year/g;
	s/%VERSION%/$version$type/g;
	s/%VERSIONWIN%/$version_digits/g;
	if ( $type eq "-snapshot" ) {
	    s/%SNAPSHOTONLY([^%]*)%/$1/g; 
	    s/%STABLEONLY[^%]*%//g;
	} else {
	    s/%SNAPSHOTONLY[^%]*%//g; 
	    s/%STABLEONLY([^%]*)%/$1/g;
	}
	open( O, "> $out" ) || die "could not open $out, stopped";
	print O $_;
	close O;
    }
}


sub prunehelp {
    rmdir $_ if ( -d $_ );
}

sub prune {
    finddepth( \&prunehelp, $_[0] ) if ( -d $_[0] );
}
