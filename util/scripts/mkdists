#!/usr/bin/perl -w
#
# Creates a new Qt source distribution
#
# Copyright 1996-2000 Troll Tech AS.  All rights reserved.
#
# ----------------------------------------------------------------
#
# Usage:
#	mkdist.generic [options] {version}
#
# Options:
#	-nodoc	Don't generate documentation
#	-local	Copy local distribution from $QTDIR, don't use p4
#	-LOCAL	Copy local distribution from $QTDIR, don't use p4, don't check
#	-noch	Ignore the fact that the changes file doesn't exist
#       -msonly Build Microsoft Visual C++ makefiles only (in win-mode)
#

#
# Yes, this code used to be a shell script.
#

use File::Find;

while ( defined($ARGV[0]) && $ARGV[0] =~ /^-/ ) {
    if ( $ARGV[0] eq "-nodoc" ) {
        $nodoc=1; shift;
    } elsif ( $ARGV[0] eq "-noch" ) {
        $noch=1; shift;
    } elsif ( $ARGV[0] eq "-local" ) {
        $local=1; shift;
    } elsif ( $ARGV[0] eq "-LOCAL" ) {
        $local=2; shift;
    } elsif ( $ARGV[0] eq "-msonly" ) {
        $msonly=1; shift;
    } else {
        last;
    }
}

$VERSION=$ARGV[0] || 0;
($BRANCH)=$VERSION =~ /(.*)\.\d+/;
$LABEL="qt/$VERSION";


$DISTDIR="/tmp/qt-$VERSION-".`whoami`;
chomp $DISTDIR;
$scriptdir="$DISTDIR/qt/util/scripts";

print "\nCreating new Qt distributions:\n";

if ( !$VERSION ) {
  print STDERR "Usage: mkdist.generic version\n";
  exit 1;
}

$T=`p4 fstat //depot/qt/$BRANCH/doc.conf | awk '/ depotFile / { print \$3 }'`;
if ( $T eq "" ) {
    print STDERR qq{"//depot/qt/$BRANCH/..." is not in the depot.\n"};
    print STDERR "Branch it, then restart:\n";
    print STDERR "      p4 integrate //depot/qt/main/... //depot/qt/$BRANCH/...\n";
    print STDERR "      p4 submit\n";
    exit 1;
}
if ( !`p4 labels | grep "^Label $LABEL "` ) {
    print STDERR "Label $LABEL does not exist. Create it, using the previous\n";
    print STDERR "label as a template.  Current labels can be listed with 'p4 laberls'\n";
    exit 1;
}

print "Deleting current $DISTDIR ...\n";
system("rm -rf $DISTDIR");

if ( $local ) {
    $localqt=`p4 fstat //depot/qt/$BRANCH/doc.conf`;
    $localtmake=`p4 fstat //depot/tmake/main/README`;
    if ( $localqt=~ s{.*clientFile ([^\n]*)/doc.conf.*}{$1}s
      && $localtmake=~ s{.*clientFile ([^\n]*)/README.*}{$1}s )
    {
	print "Duplicating your local depots...\n";
	print "  Qt:    ($localqt)\n";
	print "  tmake: ($localtmake)\n";
	print "WARNING: this will not exclude all appropriate files!\n";
	if ( $local < 2 ) {
	    $p4sync=`p4 sync -n //depot/qt/$BRANCH/... //depot/tmake/main/... 2>&1`;
	    $p4sync=~ s/.*up-to-date.\n//g;
	    $p4opened=`p4 opened //depot/qt/$BRANCH/... //depot/tmake/main/... 2>&1`;
	    $p4opened=~ s/.*not opened on this client.\n//g;
	    if ( $p4sync || $p4opened ) {
		print STDERR "You must submit and sync your changes first (or run with -LOCAL)\n";
		exit 1;
	    }
	}
	mkdir $DISTDIR,0777;
	system("cp -r $localqt $DISTDIR/qt");
	system("cp -r $localtmake $DISTDIR/tmake");
    } else {
	print STDERR "Cannot find qt/$BRANCH and/or tmake/main in your workspace\n";
	exit 1;
    }
} else {
    print "Exporting the entire Qt and tmake depots...\n";

    $TMPCLIENT="qt-release-tmp-$$";
    $client = `p4 client -t qt-release -o $TMPCLIENT`;
    $client =~ s{(\nRoot:).*}{$1 $DISTDIR};
    $client =~ s{/qt/X.Y/}{/qt/$BRANCH/}g;
    open P4CLIENT, "| p4 -s client -i | egrep -v '^(info|exit):'";
    print P4CLIENT $client;
    close P4CLIENT;
    system("p4 -s -c $TMPCLIENT sync $DISTDIR/...\@$LABEL 2>\&1 |
	    egrep -v '^(info|exit):'");
    system("p4 -s client -d $TMPCLIENT  2>\&1 | egrep -v '^(info|exit):'");
}

$ENV{TMAKEDIR}="$DISTDIR/tmake";
$ENV{TMAKEPATH}="$ENV{TMAKEDIR}/lib/linux-g++";
$ENV{PATH}="$ENV{TMAKEDIR}/bin:$ENV{PATH}";


# At this point, $DISTDIR is a clean checkout

chdir "$DISTDIR/qt/src";

# Replace Netscape-owned code with dummies (direct user to PluginSDK)
$NSDIR="$DISTDIR/qt/extensions/nsplugin/src";
opendir NSPLUGIN, $NSDIR;
for $i ( readdir NSPLUGIN ) {
    next unless $i =~ /^(np|jri)/;
    unlink "$NSDIR/$i";
    open NSFILE, ">$NSDIR/$i";
    print NSFILE qq{#error "This file is provided by Netscape.  Please see documentation."\n};
    close NSFILE;
}

#
# We should just insert the version parameter into the qglobal.h, and have
# qglobal.h use $Id: //depot/qt/main/util/scripts/mkdists#4 $ or something for purely internal use.
#
$qglobalfile="$DISTDIR/qt/src/tools/qglobal.h";
open QGLOBAL, $qglobalfile;
$qglobal=join "",<QGLOBAL>;
if ( $qglobal =~ /#define\s+QT_VERSION_STR\s+"([^"]*)"/ ) {
    $SRC_VERSION=$1;
} else {
    die "Cannot extract version from qglobal.h";
}
close QGLOBAL;

($VERSIONMAJOR)=$SRC_VERSION=~ /(.*)\.\d+/;
die "qglobal.h does not match branch $BRANCH" if $VERSIONMAJOR != $BRANCH;

if ( $SRC_VERSION =~ /(.*)-(snapshot)/ ) {
    $SRC_VERSION_N=$1;
    $SPECIAL=$2;
    $N="${SRC_VERSION_N}-".`date +\%Y\%m\%d`;
    chomp $N;
    $qglobal =~ s/$SRC_VERSION/$N/;
    open QGLOBAL, ">$qglobalfile";
    print QGLOBAL "$qglobal";
    close QGLOBAL;
} elsif ( $SRC_VERSION =~ /(.*)-(beta)/ ) {
    $SRC_VERSION_N=$1;
    $SPECIAL=$2;
} else {
    $SPECIAL="stable";
    $SRC_VERSION_N=$SRC_VERSION;
}
if ( "$VERSION" ne "$SRC_VERSION_N" ) {
    print STDERR "Version mismatch:   qglobal.h: $SRC_VERSION   argument: $VERSION\n";
    exit 1;
}
$VERSIONWIN=$SRC_VERSION; $VERSIONWIN =~ s/[-.]//g;

if ( !$noch && ! -f "$DISTDIR/qt/dist/changes-$VERSION" ) {
    print STDERR "You must create qt/dist/changes-$VERSION first (or run with -noch)\n";
    print STDERR "Find the logs:    p4 ???? ???? # ./changelog dd/mm/yyyy-previous-release-date >changes-$VERSION\n";
    print STDERR "Print the logs:   p4 ???? ???? # aprint -w80 -4 changes-$VERSION\n";
    exit 1;
}

$QTDIR="$DISTDIR/qt";
$ENV{QTDIR}=$QTDIR;

print "Create symlinks for Qt header files...\n";
mkdir "$QTDIR/include",0777;
system("$QTDIR/bin/syncqt | grep -v '^symlink created'");
###${scriptdir}/make_qt_dot_h > ${QTDIR}/include/qt.h
unlink "$QTDIR/include/qt.h";

if ( $nodoc ) {
    print "Documentation NOT generated...\n";
    system("mv -f $DISTDIR/qt/doc $DISTDIR/qt/src");
} else {
    print "Generating documentation...\n";
    mkdir "$DISTDIR/qt/doc", 0777;
    mkdir "$DISTDIR/qt/doc/html", 0777;
    system("$DISTDIR/qt/util/qdoc/qdoc $DISTDIR/qt");
    mkdir "$DISTDIR/qt/doc/man", 0777;
    mkdir "$DISTDIR/qt/doc/man/man1", 0777;
    mkdir "$DISTDIR/qt/doc/man/man3", 0777;
    system("$DISTDIR/qt/util/qdoc/man");
    system("mv $DISTDIR/qt/doc/man $DISTDIR/qt");
    system("mv $DISTDIR/qt/src/moc/moc.1 $DISTDIR/qt/man/man1");
    system("mv $DISTDIR/qt/doc/html $DISTDIR/qt");
    chdir $DISTDIR;
    system("mv -f $DISTDIR/qt/gif/*.png $DISTDIR/qt/html");
    system("mv -f $DISTDIR/qt/gif/*.jpg $DISTDIR/qt/html");
  #   system("mv -f $DISTDIR/qt/doc/.qdoc-links $DISTDIR");
    system("mv -f $DISTDIR/qt/doc $DISTDIR/qt/src");
    system("mv -f $DISTDIR/qt/html $DISTDIR/qt/doc");
}

print "Removing local files...\n";
chdir "$DISTDIR/qt/src";
map { $x11only{"src/$_"}++ } split " ",`tmake qtinternal.pro -e "Expand('X11ONLY')"`;
chdir $DISTDIR;
chdir "qt/examples";
system("rm -rf sheet");

sub not_plat {
    my ($f,$p) = @_;
    return 0 if $f =~ /_$p\.c[pc]*$/;
    return ($p ne "X11" && $x11only{$f})
        || $f eq "bugs"
        || $f eq "etc"
        || $f eq "gif"
        || $f eq "tests"
        || $f eq "make.help"
        || $f eq "variables"
        || $f eq ".cvsignore"
        || $f eq "doc.conf"
        || $f eq "src/qtinternal.pro"
        || $f eq "dist"
        || $f eq "util"
        || $f =~ /^bin\/syncqt/
        || $f =~ /\/doc.conf$/
	|| $f =~ /(_fb|_os2|_qws|_win|_x11|_mac)\.c[pc]*$/;
}

sub not_x11 {
    my ($f) = @_;
    if ( !defined($not_x11{$f}) ) {
	$not_x11{$f}=
	    $f =~ m{^src/mkfiles\b}
	 || $f =~ m{^src/tmp\b}
	 || $f =~ m{/qtmain.pro$}
	 || $f =~ m{/Makefile.win32-dll$}
	 || $f =~ m{\.bat$}
	 || not_plat($f,"x11");
    }
    return $not_x11{$f};
}

sub not_win {
    my ($f) = @_;
    if ( !defined($not_win{$f}) ) {
	$not_win{$f}=
	    $f =~ m{^extensions/xt$}
	 || $f =~ m{/qtmain.pro$}
	 || $f =~ m{^configs$}
	 || $f =~ m{/Makefile.in$}
	 || not_plat($f,"win");
    }
    return $not_win{$f};
}

print "Generate lex and yacc files for moc...\n";
chdir "$DISTDIR/qt/src/moc";
chmod 0644,"GNUmakefile";
system("make mocgen.cpp");

print "Removing internal makefiles\n";
chdir "$DISTDIR/qt";
system("find . -name GNUmakefile -o -name Makefile | xargs rm -f");
system("rm -f GNUmakefile.inc Makefile.inc");

chdir "$DISTDIR/qt/src/moc";
$lexyyc=`cat lex.yy.c`;
$lexyyc=~ s{^(#include \<unistd\.h\>)$}{#if !defined(_OS_WIN32_)\n$1\n#endif};
open T, ">lex.yy.c";
print T $lexyyc;
close T;

chdir "$DISTDIR/qt";
mkdir "mkfiles",0777;

# Convince tmake to use the right DLL library and set right DLL lib Makefile
mkdir "lib",0777 if ! -d "lib";
$DLLVER=`tmake src/qt.pro -e "Expand('VERSION')"`;
chomp $DLLVER;
$DLLVER =~ 's/\.//g';
open T, ">lib/qt$DLLVER.lib";
close T;
system("mv src/Makefile.win32-dll src/Makefile");

if (0) {
if ( !$msonly ) {
    print "Build DLL Makefiles for Borland C++...\n";
    $ENV{TMAKEPATH}="$ENV{TMAKEDIR}/lib/win32-borland";
    system("$scriptdir/buildmakefiles -win32 -dll");
    system(qq{find . -name Makefile -o -name "qt*.mak" | xargs ${scriptdir}/unix_to_dos});
    system(qq{find . -name Makefile -o -name "qt*.mak" | xargs zip -r mkfiles/borland_dll.zip});
}

print "Build DLL Makefiles for Microsoft Visual C++...\n";
$ENV{TMAKEPATH}="$ENV{TMAKEDIR}/lib/win32-msvc";
system("$scriptdir/buildmakefiles -win32 -dll");
system(qq{find . -name Makefile -o -name "qt*.mak" | xargs ${scriptdir}/unix_to_dos});
system(qq{find . -name Makefile -o -name "qt*.mak" | xargs zip -r mkfiles/msvc_dll.zip});

# Clean up after DLL library makefiles have been created
unlink "lib/qt$DLLVER.lib";
unlink "src/Makefile";
unlink "src/qtdll.mak";
unlink "src/qtmain.mak";

if ( !$msonly ) {
    print "Build Makefiles for Borland C++...\n";
    $ENV{TMAKEPATH}="$ENV{TMAKEDIR}/lib/win32-borland";
    system("$scriptdir/buildmakefiles -win32");
    system(qq{find . -name Makefile -o -name "qt*.mak" | xargs ${scriptdir}/unix_to_dos});
    system(qq{find . -name Makefile -o -name "qt*.mak" | xargs zip -r mkfiles/borland.zip});
}

print "Build Makefiles for Microsoft Visual C++...\n";
$ENV{TMAKEPATH}="$ENV{TMAKEDIR}/lib/win32-msvc";
system("$scriptdir/buildmakefiles -win32");
system(qq{find . -name Makefile -o -name "qt*.mak" | xargs ${scriptdir}/unix_to_dos});
system(qq{find . -name Makefile -o -name "qt*.mak" | xargs zip -r mkfiles/msvc.zip});

# Generate makefiles
system("$QTDIR/util/scripts/makeunixmake -v");
# Copy template files into qt/configs
system("cp $QTDIR/tmake/*.t $QTDIR/configs");
chdir "$QTDIR/configs";
system("rm -f propagate.t subdirs.t");
}

print "Copying the README, LICENSE etc. files...\n";
chdir "$DISTDIR/qt/dist";
system("cp [A-Z]* .. 2> /dev/null");
system("cp -f changes-${VERSIONMAJOR}[.0-9]* ..") unless $noch;

print "Removing distribution-building files...\n";
system("rm -rf qt/tmake qt/makefiles tmake");

print "Finally packing the distributions ...\n";


sub cpdist {
    my ($disttype,$platform) = @_;
    my @files = ();
    opendir DIR, "dist/$disttype";
    my @dfiles =

    # Silly hack for README required because commercial/README is x11
    # while win/README is Windows.
    grep { !/^\./ && ($platform ne "win" || $_ ne "README") } readdir DIR;

    for (@dfiles) { push(@files, "dist/$disttype/$_") }
    opendir DIR, "dist/$platform";
    my @pfiles = grep { !/^\./ } readdir DIR;
    for (@pfiles) { push(@files, "dist/$platform/$_") }
    system("cp -a ".(join " ",@files)." .");
    system("util/scripts/versionize $SRC_VERSION $VERSIONWIN $SPECIAL [A-Z]*");
    return (@dfiles,@pfiles);
}

print "X11...\n";

$qt="qt-${SRC_VERSION}";
rename "$DISTDIR/qt", "$DISTDIR/$qt";

for $free ( 0,1 ) {
    print $free ? "  Free...\n" : "  Commercial...\n";

    chdir $DISTDIR;
    open X11, "| tar cfz $qt".($free?"":"-commercial").".tar.gz --files-from - $qt";
    chdir $qt;
    @files=cpdist($free ? "free" : "commercial", "x11");

    # $File::Find::dir=""; $File::Find::prune=0; # Shut up perl

    find ( sub {
	my $f = "$File::Find::dir/$_";
	#$f =~ s{^\./}{};
	$f =~ s/^\.\///;
	if ( -d $_ ) {
	    $File::Find::prune=1 if not_x11($f);
	} else {
	    print X11 "$qt/$f\n" unless not_x11($f);
	}
    }, "." );
    close X11;

    system "rm -rf ".join(" ",@files);
}
chdir $DISTDIR;

system("tar cfz $qt-doconly.tar.gz $qt/doc");

rename "qt-${SRC_VERSION}", "qt";


# Now we move stuff around...
print "Windows...\n";

# Replace symlinks with real files
chdir "$DISTDIR/qt/src";
print "  Moving header files...\n";
system("mv ../include/qt.h .") if -f "../include/qt.h";
system("rm -f ../include/*.h");
system("mv */q*.h ../include");
system("mv qt.h ../include") if -f "qt.h";
chdir "$DISTDIR/qt";
system("mv extensions/opengl/src/q*.h include");
system("mv extensions/nsplugin/src/q*.h include");

cpdist("commercial", "win");

print "  Converting Unix text files to DOS...\n";
chdir $DISTDIR;
unlink "qt/MANIFEST";
system(q{find qt -type f -print | fmt -1 | \
	egrep -v '\.(dll|gif|png|jpg|bmp|any|pic|ppm|exe|zip|qm)$'}
	." | xargs ${scriptdir}/unix_to_dos");

print "  Packing...\n";
open WINCOMM, "| zip -\@ -q -9 qtwin${VERSIONWIN}.zip";
chdir "$DISTDIR/qt";
find ( sub {
    my $f = "$File::Find::dir/$_";
    $f =~ s/^\.\///;
    if ( -d $_ ) {
	$File::Find::prune=1 if not_win($f);
    } else {
	print WINCOMM "qt/$f\n" unless not_win($f);
    }
}, "." );
close WINCOMM;

chdir "$DISTDIR";
system("zip -r -q -9 qt${VERSIONWIN}-doconly.zip qt/doc");

print "Cleaning up...\n";

system("rm -rf $DISTDIR/qt $DISTDIR/tmake"); # It's full of junk, remove it.

print "Done, see ${DISTDIR}\n";
