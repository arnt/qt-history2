#!/bin/bash

#tmp places
TMP_DIR=
if [ -d "$HOME/tmp" ]; then
   TMP_DIR="$HOME/tmp"
elif [ -d "/tmp" ]; then
   TMP_DIR="/tmp"
else
   die "Cannot find a suitable temporary directory!"
fi
echo "Temporary directory: $TMP_DIR"
TMP_FILE=${TMP_DIR}/qt-tmpf-$$

#customizing
P4=                     #p4 location
if which p4 >/dev/null 2>&1; then
    P4=`which p4`
else
    P4=/usr/local/bin/p4
fi
P4PORT=p4.troll.no:866	#point p4 to the correct server

#internal variables
YEAR=`date +%Y`
CREATED_MANIFEST=no
MYNAME=`whoami`
[ -z $MYNAME ] && MYNAME="shellssuck"

#version info
REL_VERSION=0.0.0
BRANCH=auto
#paths
OUT_TREE=`pwd`
LOCAL_TREE=
LOG=/dev/null #by default we do not log
QDOC_PATH=$QTDIR/util/qdoc/qdoc
QPKG_PATH=$QTDIR/util/install/package/package
EXPORTS_PATH=$QTDIR/util/scripts/exports.sh
QMAKE_PATH=$QTDIR/bin/qmake
MANIFEST_FILE=${TMP_FILE}-manifest
#editions
DO_COMMERCIAL=yes
DO_FREE=yes
DO_REVIEW=no
DO_ACADEMIC=yes
#platforms
DO_WIN=yes
DO_X11=yes
DO_MAC=yes
DO_QNX6=no
DO_EMBEDDED=yes
DO_PKG=no
#other
DO_QMAKE=no
DO_GZIP=auto
DO_BZIP=auto
DO_STUFF=auto
DO_ID=auto
DO_DOC=auto
DO_EXPORTS=auto
TYPE=auto

die()
{
    echo $1
    exit 666
}

STATUS_DEPTH=0
status() {
    [ "$#" = 2 ] && [ "$2" = "-1" ] && STATUS_DEPTH=$((STATUS_DEPTH-5))
    blah=0
    [ ! -z "$1" ] && while [ "$blah" -lt "$STATUS_DEPTH" ]; do echo -n " "; blah=$((blah+1)); done
    [ "$#" = 2 ] && [ "$2" = "1" ] && STATUS_DEPTH=$((STATUS_DEPTH+5))
    [ ! -z "$1" ] && echo "$1"
    return 0
}

#parse commandline
showhelp()
{
    [ "$#" != 0 ] && [ ! -z "$1" ] && echo "******** Unknown Option: $@ ********"
    echo "$0 [options]"
    echo
    echo "Options can be any of:"
    echo

    echo "P4 Versions:"
    echo "  -type <type>       : Specify a type to override with (eg snapshot)"
    echo "  -local <directory> : Specify path to pre-p4'd depot"
    echo "  -version <version> : What version to retrieve from p4"
    echo "  -branch  <branch>  : What branch to retrieve from. If this"
    echo "                       option is ommited, it will be deduced from"
    echo "                       -version"
    echo "  :   -version and -local are mutually exclusive, if you :"
    echo "  :   specify -version you may also specify -branch      :"
    echo "  :   do not use -branch with -local                     :"
    echo "  :   Additionally you may use -branch by itself, and    :"
    echo "  :   will check out the HEAD of the given -branch       :"
    echo

    echo "Paths:"
    echo "  -manifest <file>     : Specify path and filename of manifest file (will create)"
    echo "  -outdir <directory>  : Where to put all things (default $OUT_TREE)"
    echo "  -p4 <executable>     : Where p4 lives (default $P4)"
    echo "  -qdoc <executable>   : Where qdoc lives (default $QDOC_PATH)"
    echo "  -qmake <executable>  : Where qmake lives (default $QMAKE_PATH)"
    echo "  -qpkg <executable>   : Where qpkg lives (default $QPKG_PATH)"
    echo "  -exports <executable>: Where the exports.sh script lives (default $EXPORTS_PATH)"
    echo

    echo "Editions:"
    echo "  -no-pkg          / -do-pkg           : Toggle pkg build for CD"
    echo "  -no-commercial   / -do-commercial    : Toggle commercial build"
    echo "  -no-academic     / -do-academic      : Toggle academic build"
    echo "  -no-free         / -do-free          : Toggle free build"
    echo "  -no-review       / -do-review        : Toggle product review build"
    echo

    echo "Platforms:"
    echo "  -no-mac / -do-mac             (default $DO_MAC)"
    echo "  -no-win / -do-win             (default $DO_WIN)"
    echo "  -no-x11 / -do-x11             (default $DO_X11)"
    echo "  -no-qnx6 / -do-qnx6           (default $DO_QNX6)"
    echo "  -no-embedded / -do-embedded   (default $DO_EMBEDDED)"
    echo

    echo "Various:"
    echo "  -no-id      / -do-id      : Toggle whether to generate \$Id tag"
    echo "  -no-doc     / -do-doc     : Toggle whether to generate documentation"
    echo "  -no-gzip    / -do-gzip    : Toggle whether to add a gzip package"
    echo "  -no-bzip    / -do-bzip    : Toggle whether to add a bzip package"
    echo "  -no-stuff   / -do-stuff   : Toggle whether to add a stuffit package"
    echo "  -no-exports / -do-exports : Toggle whether to generate libqt.map"

    echo "=-________________________________________________________________-="
    echo "All options can be in long form --option=value as well (where value "
    echo "is no for -no-* options and yes for -do-* options)"
    exit 666
}

while [ -n "$1" ]; do
   case $1 in
   -log)
        shift
	VAR=log
	VAL=$1
	;;
   -manifest)
	shift
	VAR=manifest
	VAL=$1
	;;
   -p4)
	shift
	VAR=p4
	VAL=$1
	;;
   -version)
       shift
       VAR=version
       VAL=$1
       ;;
   -branch)
       shift
       VAR=branch
       VAL=$1
       ;;
   -help)
       showhelp
       ;;
   -outdir)
	shift
	VAR=outdir
	VAL=$1
	;;
   -local)
	shift
	VAR=local
	VAL=$1
	;;
   -qmake)
	shift
	VAR=qmake_path
	VAL=$1
	;;
   -qpkg)
        shift
	VAR=qpkg_path
	VAL=$1
	;;
   -exports)
        shift
	VAR=exports_path
	VAL=$1
	;;
   -qdoc)
	shift
	VAR=qdoc_path
	VAL=$1
	;;
   -type)
	shift
	VAR=type
	VAL=$1
	;;
   -no*)
	VAR=`echo $1 | sed "s,^-no-*,,g"`
	VAL=no
	;;
   -do*)
	VAR=`echo $1 | sed "s,^-do-*,,g"`
	VAL=yes
	;;
   --*=*)
	VAR=`echo $1 | sed "s,^--\(.*\)=.*$,\1,"`
	VAL=`echo $1 | sed "s,^--.*=\(.*\)$,\1,"`
	;;
   *)
	showhelp "$1"
	;;
   esac
   shift

   case $VAR in
   #editions
   academic) DO_ACADEMIC=$VAL ;;
   commercial) DO_COMMERCIAL=$VAL ;;
   free)DO_FREE=$VAL;;
   review) DO_REVIEW=$VAL ;;
   #platforms
   pkg)  DO_PKG=$VAL  ;;
   win) DO_WIN=$VAL ;;
   x11) DO_X11=$VAL ;;
   mac) DO_MAC=$VAL ;;
   qnx6) DO_QNX6=$VAL ;;
   embedded) DO_EMBEDDED=$VAL ;;
   #paths
   exports_path) EXPORTS_PATH=$VAL ;;
   log) LOG=$VAL; rm -f $LOG ;;
   qpkg_path)  QPKG_PATH=$VAL  ;;
   qmake_path) QMAKE_PATH=$VAL ;;
   qdoc_path) QDOC_PATH=$VAL;;
   outdir) OUT_TREE=$VAL;;
   p4) P4=$VAL;;
   manifest) MANIFEST_FILE=$VAL;;
   local)
       [ -d "$VAL" ] || die "Unknown directory: $VAL"
       LOCAL_TREE=$VAL
       ;;
   #versioning
   type) TYPE=$VAL ;;
   branch) BRANCH=$VAL ;;
   version)
       expr "$VAL" : ".*\.\d*" >>$LOG 2>&1 || die "Can't figure out version from $VAL"
       LABEL="qt/$VAL"
       TMP_TYPE=`echo $VAL | sed "s,\([0-9\.]*\)\(-*.*\),\2," | sed "s,^-*,,"`
       if [ -z "$TMP_TYPE" ]; then
	   REL_VERSION="$VAL"
       else
	   [ "$TYPE" = "auto" ] && TYPE="$TMP_TYPE"
	   REL_VERSION=`echo $VAL | sed "s,\([0-9\.]*\)\(-*.*\),\1,"`
       fi
       ;;
   #other
   exports) DO_EXPORTS=$VAL ;;
   qmake) DO_QMAKE=$VAL ;;
   stuff) DO_STUFF=$VAL ;;
   doc) DO_DOC=$VAL ;;
   gzip)DO_GZIP=$VAL;;
   bzip)DO_BZIP=$VAL;;
   id) DO_ID=$VAL   ;;
   *) showhelp "--${VAR}=$VAL" ;;
   esac
done

#now decide some default value..
if [ "$DO_DOC" = "auto" ]; then
    if [ -z "$LOCAL_TREE" ]; then
	DO_DOC=yes
    else
	DO_DOC=no
    fi
fi
if [ "$DO_ID" = "auto" ]; then
    if [ -z "$LOCAL_TREE" ]; then
	DO_ID=yes
    else
	DO_ID=no
    fi
fi
if [ "$DO_GZIP" = "auto" ]; then
    if which gzip >>$LOG 2>&1; then
	DO_GZIP=yes
    else
	DO_GZIP=no
    fi
fi
if [ "$DO_BZIP" = "auto" ]; then
    if which bzip2 >>$LOG 2>&1; then
	DO_BZIP=yes
    else
	DO_BZIP=no
    fi
fi
if [ "$DO_STUFF" = "auto" ]; then
    if which stuff >>$LOG 2>&1; then
	DO_STUFF=yes
    else
	DO_STUFF=no
    fi
fi
if [ "$DO_EXPORTS" = "auto" ]; then
    if [ -x "$EXPORTS_PATH" ]; then
        DO_EXPORTS=yes
    else
        DO_EXPORTS=no
    fi
fi
if [ "$BRANCH" = "auto" ]; then
    if [ ! -z "$LOCAL_TREE" ]; then
       BRANCH="0.0.0"
    else
       BRANCH=`echo "$REL_VERSION" | sed "s,\([0-9.]*\).*,\1,"`
    fi
fi

#make sure everything is in order before bothering..
[ ! -x "$QMAKE_PATH" ] && die "qmake not found, failed (${QMAKE_PATH})"
if [ "x$DO_DOC" = "xyes" ]; then
    QDOC_SRC="`dirname $QDOC_PATH`"
    if [ -d  "$QDOC_SRC" ]; then
	status "Building qdoc.."
    	(cd "$QDOC_SRC"; "$QMAKE_PATH" qdoc.pro; make >>$LOG ) || die "Cannot build qdoc (${QDOC_SRC})"
    else
	echo "Cannot find qdoc source, hopefully you have made sure it is up-to-date"
    fi
    [ ! -x "$QDOC_PATH" ] && die "qdoc not found, failed (${QDOC_PATH})"
fi

if [ "x$DO_PKG" = "xyes" ]; then
    QPKG_SRC="`dirname $QPKG_PATH`"
    QPKG_SRC=`dirname $QPKG_SRC`
    if [ -d  "$QPKG_SRC" ]; then
	status "Building qpkg.."
    	(cd "$QPKG_SRC"; make qmake; make >>$LOG ) || die "Cannot build qpkg (${QPKG_SRC})"
    else
	echo "Cannot find qpkg source, hopefully you have made sure it is up-to-date"
    fi
    [ ! -x "$QPKG_PATH" ] && die "qpkg not found, failed (${QPKG_PATH})"
fi
[ -z "$LOCAL_TREE" ] && [ ! -x "$P4" ] && die "Coult not find P4!"
rm -f "$TMP_FILE" && { [ -e "$TMP_FILE" ] && die "Could not remove tmp file, failed (${TMP_FILE})" ; }
[ ! -d "$OUT_TREE" ] && { mkdir -p $OUT_TREE >>$LOG 2>&1 || die "Could not create outdir, failed (${OUT_TREE})" ; }

DISTDIR="${TMP_DIR}/qt-$BRANCH-$MYNAME-$$"

#Checkout P4
if [ -z "$LOCAL_TREE" ]; then
    export P4PORT
    checkoutlabel=""
    if ! $P4 fstat //depot/qt/$BRANCH/util/qdoc/qdoc.conf 2>/dev/null | grep " depotFile " >>$LOG 2>&1 ; then
	die "//depot/qt/$BRANCH/... is not in the depot, stopped"
    fi
    if [ ! -z $LABEL ]; then
	if ! $P4 labels 2>&1 | grep "^Label $LABEL" >>$LOG 2>&1 ; then
	    die "Label $LABEL does not exist, stopped"
	fi

	if $P4 label -o $LABEL | grep '^Options:.*locked' >>$LOG 2>&1; then
	    checkoutlabel="@${LABEL}"
	fi
    fi
    status "Exporting the entire Qt depot $checkoutlabel..";

    tmpclient="qt-release-tmp-$MYNAME";
    $P4 client -t qt-release-3x -o $tmpclient >${TMP_FILE}
    sed ${TMP_FILE} -e "s,^Root:.*,Root: $DISTDIR," -e "s,/qt/X.Y/,/qt/$BRANCH/,g" \
	    -e "s,^\(Client: \).*,\1qt-release-tmp-$$," -e "s,\bnomodtime\b,modtime," | \
      $P4 -s client -i >>$LOG 2>&1

    $P4 -s -c $tmpclient sync -f $DISTDIR/qt/...${checkoutlabel} >>$LOG 2>&1
else
    status "Copying Qt depot.."
    [ ! -d $DISTDIR/qt ] && mkdir -p $DISTDIR/qt
    cp -ar $LOCAL_TREE/* $DISTDIR/qt
fi

#setup branch correctly..
if [ "$REL_VERSION" = "0.0.0" ]; then
    V=`grep VERSION $DISTDIR/qt/src/qt.pro | awk '{print $3;}'`
    if [ ! -z $V ]; then
	BRANCH=$V
	REL_VERSION=$V
    fi
fi
BRANCH_DIGITS=`echo $REL_VERSION | sed "s,\.,,g" | sed "s,\([0-9]*[0-9]*[0-9]*\).*,\1,g"`
[ -z "$BRANCH_DIGITS" ] && BRANCH_DIGITS="000"

#get include files
includefiles=`QTDIR=$DISTDIR/qt $DISTDIR/qt/bin/syncqt -show`
privincludefiles=`QTDIR=$DISTDIR/qt $DISTDIR/qt/bin/syncqt -showpriv`
[ ! -d $DISTDIR/qt/include ] && mkdir -p "$DISTDIR/qt/include"
[ ! -d $DISTDIR/qt/include/private ] && mkdir -p "$DISTDIR/qt/include/private"
for fullname in $includefiles; do
    ln -sf "../$fullname" "$DISTDIR/qt/include/`basename $fullname`"
done
for fullname in $privincludefiles; do
    ln -sf "../../$fullname" "$DISTDIR/qt/include/private/`basename $fullname`"
done

#pregenerate moc files
status "Creating moc files.."
pushd $DISTDIR/qt/src/moc >>$LOG 2>&1
$QMAKE_PATH -spec $QTDIR/mkspecs/linux-g++ moc.pro -o Makefile

status "make moc_lex.cpp"
make moc_lex.cpp >>$LOG
status "make moc_yacc.cpp"
make moc_yacc.cpp >>$LOG

rm -f Makefile
popd >>$LOG 2>&1

#generate libqt.map
if [ "$DO_EXPORTS" = "yes" ]; then
  status "Creating libqt.map.."
  pushd $DISTDIR/qt/src >>$LOG 2>&1
  $EXPORTS_PATH $DISTDIR/qt/src
  popd >>$LOG 2>&1
fi

#cleanup documentation directories
mkdir -p "$DISTDIR/qt/doc"
mkdir -p "$DISTDIR/qt/doc/html"
mkdir -p "$DISTDIR/qt/doc/man"
mkdir -p "$DISTDIR/qt/doc/html/designer"
mkdir -p "$DISTDIR/qt/doc/html/designer/images"
mkdir -p "$DISTDIR/qt/doc/man/man3"
# and do the moc.1 hack here
mkdir -p "$DISTDIR/qt/doc/man/man1"
mv "$DISTDIR/qt/src/moc/moc.1" "$DISTDIR/qt/doc/man/man1"
# linguist
mv "$DISTDIR/qt/tools/linguist/lrelease/lrelease.1" "$DISTDIR/qt/doc/man/man1"
mv "$DISTDIR/qt/tools/linguist/lupdate/lupdate.1" "$DISTDIR/qt/doc/man/man1"
#uic
mv "$DISTDIR/qt/tools/designer/uic/uic.1" "$DISTDIR/qt/doc/man/man1"
#designer
cp -f $DISTDIR/qt/gif/* $DISTDIR/qt/doc/html/
rm -rf $DISTDIR/qt/tools/designer/manual
rm -rf $DISTDIR/qt/tools/designer/doc
# clean designer
rm -rf $DISTDIR/qt/tools/designer/plugins/designer_interface_roadmap
rm -rf $DISTDIR/qt/tools/designer/plugins/extrawidgets
rm -rf $DISTDIR/qt/tools/designer/plugins/p4
rm -rf $DISTDIR/qt/tools/designer/plugins/qvim
rm -rf $DISTDIR/qt/tools/designer/plugins/designer_interface_roadmap
#rm -rf $DISTDIR/qt/tools/designer/plugins/glade
# clean tools
rm -rf $DISTDIR/qt/tools/inspector

# Replace Netscape-owned code with dummies (direct user to PluginSDK)
for a in `find $DISTDIR/qt/extensions/nsplugin/src -name 'np*' -o -name 'jri*'`; do
    rm -f $a
    echo "#error \"$a must be provided by Netscape\"" > $a
    echo "#error \"This file is just a placeholder. Please see the documentation\"" >>$a
    echo "#error \"to learn how to obtain the real file\"" >>$a
done

# qt.h
if [ "x$DO_EMBEDDED" != "xyes" ] && [ "x$DO_QNX6" != "xyes" ]; then
   rm -f "$DISTDIR/qt/include/qt.h"
fi

# changes files
[ ! -f "$DISTDIR/qt/dist/changes-$REL_VERSION" ] && status "!! Warning: qt/dist/changes-$REL_VERSION does not exist !!"
for a in `find $DISTDIR/qt/dist/ -name "changes-$REL_VERSION*"`; do
    mv $a $DISTDIR/qt/`basename $a`
done

myexpr () {
    echo "$1" | egrep "$3" >>$LOG 2>&1
    return
}

binary_file() {
    file="$1"
    [ -x "$file" ] && return 0

    extn=`echo $file | sed "s,.*\.,,"`
    case "$extn" in
	msi|dll|gif|png|mng|jpg|bmp|any|pic|ppm|exe|zip|qm|ico) return 0 ;;
    esac
    return 1
}

# fixify qglobal's version number
qglobal="$DISTDIR/qt/src/tools/qglobal.h"
if [ "$TYPE" = "auto" ]; then
    TYPE=`grep QT_VERSION_STR $DISTDIR/qt/src/tools/qglobal.h | awk '{ print $3 }' | sed 's,["0-9.]*-*\(.*\)",\1,'`
    if [ ! -z "$TYPE" ] && [ "$TYPE" != "snapshot" ] && ! myexpr "$TYPE" : "^(alpha|beta)[0-9]*$" && ! myexpr "$TYPE" : "^[ab][0-9]*$"; then
	die "The TYPE is ${TYPE}, which confuses me terribly";
    fi
fi
if echo "$TYPE" | grep "^beta" >>$LOG 2>&1; then
    TYPE=`echo $TYPE | sed 's,^beta\([0-9]\)$,b\1,'`
elif echo "$TYPE" | grep "^alpha" >>$LOG 2>&1; then
    TYPE=`echo $TYPE | sed 's,^alpha\([0-9]\)$,a\1,'`
fi
VERSION_STR="$REL_VERSION"
if [ ! -z "$TYPE" ] && ! myexpr "$REL_VERSION" : "${TYPE}$"; then
    if myexpr "$TYPE" : "^[ab][0-9]*$"; then
	VERSION_STR=${VERSION_STR}${TYPE}
    else
	VERSION_STR=${VERSION_STR}-${TYPE}
    fi
fi

[ "$TYPE" = "snapshot" ] && VERSION_STR=`date "+${VERSION_STR}-%Y%m%d"`
[ "$DO_WIN" = "yes" ] && ! strings $DISTDIR/qt/dist/win/bin/moc.exe | grep "$VERSION_STR" >>$LOG 2>&1 && status "!! Warning: qt/dist/win/bin/moc.exe might not match !!"
sed -e "s,^\(\#define  *QT_VERSION  *\)[0-9]*$,\1${BRANCH_DIGITS},g" \
    -e "s,^\(\#define  *QT_VERSION_STR  *\)\".*\"$,\1\"${VERSION_STR}\",g" $qglobal >${TMP_FILE}
mv ${TMP_FILE} $qglobal

#fix $Id
if [ "x$DO_ID" = "xyes" ]; then
    status "Marking \$Id\$..."
    for a in `find $DISTDIR/qt/`; do
        if [ -f $a ] && ! binary_file "$a" && [ ! -L $a ] && grep '\$Id.*\$' $a >>$LOG 2>&1; then
	    execut=444
	    [ -x $a ] && execut=555
	    mtime=`ls -l $a | awk '{ print $6,$7,$8 }'` #mtime is pretty bogus, but a quick hack..
	    tag_ID="`echo $a | sed "s,^.*/,qt/,"`   ${VERSION_STR}   edited $mtime"
	    sed "s,\$Id[^\\$]*\\$,\$Id: ${tag_ID} \$,g" $a >${TMP_FILE}
	    rm -f $a
	    mv ${TMP_FILE} $a
	    chmod $execut $a
	fi
    done
fi

public_file () {
    { [ ! -e "$1" ] || [ -d "$1" ] ; } && return 1

    file_WHOLE=$1
    file_BASE=`basename $file_WHOLE`
    file=`echo $file_WHOLE | sed "s,^$DISTDIR/qt/,,"`

    { [ -z $file ] || [ $file = "/" ] ; } && return 1
    KEEP=

    if
	 # no qdoc conf
	 [ "$file_BASE" = "doc.conf" ] ||

	 # internal docs
	 [ "$file_BASE" = "TODO.txt" ] ||
	 [ "$file_BASE" = "BUGS.txt" ] ||

	 # no make.help
	 [ "$file_BASE" = "make.help" ] ||

	 # internal .pro file
	 [ "$file_BASE" = "qmake.pro" ] ||

	 # utils, except scripts
	 { myexpr "$file" : '^util\/' && ! myexpr "$file" : '^util\/scripts\/' ; } ||

	 # no ~ files
	 myexpr "$file_BASE" : '.*~$' ||

	 # no gif
	 myexpr "$file" : 'gif\/' ||

	 # no configs
	 myexpr "$file" : 'configs\/' ||
	 [ "$file" = "LICENSE.TROLL" ] ||

	 # no makefiles, except freetype2
	 { [ "$file_BASE" = "GNUmakefile" ] && myexpr "$file" : 'src\/3rdparty\/freetype2\/' ; }   ||
	 { [ "$file_BASE" = "GNUmakefile-kde" ] && myexpr "$file" : 'src\/3rdparty\/freetype2\/' ; } ||
	 { [ "$file_BASE" = "Makefile" ] && myexpr "$file" : 'src\/3rdparty\/freetype2\/' ; } ||
	 myexpr "$file" : 'src\/Makefile\..*' ||

	 # no mak files
	 { myexpr "$file_BASE" : '.*\.mak$' && ! myexpr "$file_BASE" : '.*\/libpng\/' ; } ||

	 # no *.inc files
	 myexpr "$file_BASE" : '.*\.inc$' ||

	 # some bins
	 myexpr "$file_BASE" : 'bin\/.*_make_.*$' ||
	 myexpr "$file" : 'bin\/syncqt.*$' ||

	 # Everything under dist
	 myexpr "$file" : '^dist\/' ||

	 # no tests
	 myexpr "$file" : '.*\/tests\/.*' || myexpr "$file" : '^tests\/.*'
     then
	    KEEP=no
     elif
	 # for the love of god! keep qmake! all hail qmake!
	 myexpr "$file" : "^qmake\/" ||

	 # the scripts, for now
	 myexpr "$file" : "^util\/scripts\/" ||

	 # everything in the subdirectories of src/doc/
	 { myexpr "$file" : "^src\/doc\/" && [ ! "$file_BASE" = "Makefile" ] ; } ||

	 # all c++ files under .../src/
	 myexpr "$file" : "\(^|\/\)src\/.*\.\(\(cpp\)|h|c|\(pro\)\)$" ||
	 myexpr "$file" : "\(^|\/\)src\/qt\.t$" ||

	 # include (empty)
	 [ "$file" = "include" ] ||

	 # all doc files except in tests
	 myexpr "$file_BASE" : ".*\.doc$" ||

	 # the changes files
	 myexpr "$file" : "^changes-" ||

	 # /configure
	 [ "$file" = "configure" ] ||

	 # the tools files
	 myexpr "$file" : "^tools\/.*\.\(\(cpp\)|h|\(pro\)|\(qm\)|\(po\)|\(xpm\)|\(xbm\)|\(png\)|\(bmp\)|\(gif\)|\(ui\)|1|\(txt\)|\(html\)|\(css\)\)$" ||
	 myexpr "$file" : "^tools\/designer\/integration\/.*\.\(\(clw\)|\(def\)|\(odl\)|\(rc\)|\(dsp\)|\(rc2\)|\(el\)|t\)" ||
	 myexpr "$file" : "^tools\/.*\/README" ||
	 myexpr "$file" : "^tools\/.*\/COPYING" ||
	 myexpr "$file" : "^tools\/.*\/HTML.manifest$" ||
	 myexpr "$file" : "^tools\/.*\/mkimages$" ||
	 myexpr "$file" : "^tools\/.*\/makeall$" ||
	 myexpr "$file" : "^tools\/designer\/designer\/.*\.\(\(rc\)|\(ico\)\)$" ||
	 myexpr "$file" : "^tools\/.*\/mksplash$" ||

	 # the tutorials
	 myexpr "$file" : "^tutorial\/t[0-9]*\/$" ||
	 # all c++ and pro files under tutorial
	 myexpr "$file" : "^tutorial\/.*\.\(\(cpp\)|h|\(pro\)\)$" ||

	 # the examples
	 myexpr "$file" : "^examples\/.*\/$" ||
	 # all c++, pro, qm, po and xpm files under examples
	 myexpr "$file" : "^examples\/.*\.\(\(cpp\)|h|\(pro\)|\(qm\)|\(po\)|\(xpm\)|\(map\)|\(txt\)|\(bmp\)|\(gif\)|\(pic\)|\(ppm\)|\(png\)|\(wav\)|\(any\)|\(xml\)\)$" ||
	 # all the junk from mpegplay in the kiosk example
	 myexpr "$file" : "^examples\/kiosk\/.+\..+$" ||
	 myexpr "$file" : "^examples\/kiosk\/README.*$" ||
	 myexpr "$file" : "^examples\/kiosk\/tags$" ||
	 # all the launcher files
	 myexpr "$file" : "^examples\/launcher\/.*\(\(\.im\)|\(\.pl\)|\(perpetual_launch\)|\(start_demo\)\)$" ||
	 # misc
	 [ "$file" = "examples/load/isdninfo" ] ||
	 myexpr "$file" : "examples/overlay_x11/README" ||
	 myexpr "$file" : "examples\/.*\.c$" ||

	 # the extensions
	 myexpr "$file" : "^extensions\/.*\/$" ||
	 # all c++, pro, qm, po and xpm files under extensions
	 myexpr "$file" : "^extensions\/.*\.\(\(cpp\)|h|\(pro\)|\(qm\)|\(po\)|\(xpm\)|\(map\)|\(txt\)|\(bmp\)|\(gif\)|\(pic\)|\(ppm\)|\(png\)|\(wav\)|\(any\)|c\)$" ||
	 myexpr "$file" : "^extensions\/.*\/isdninfo$" ||

	 # READMEs, NOTICE and such
	 myexpr "$file" : "^src\/\(\(.*\/\)|\)[A-Z]+$" ||
	 myexpr "$file" : "^src\/\(\(.*\/\)|\)[A-Z]+$" ||
	 myexpr "$file" : "^examples\/\(\(.*\/\)|\)[A-Z]+$" ||
	 myexpr "$file" : "^tutorial\/\(\(.*\/\)|\)[A-Z]+$" ||
	 myexpr "$file" : "^extensions\/\(\(.*\/\)|\)[A-Z]+$" ||
	 myexpr "$file" : "^extensions\/.*\/README\..*$" ||

	 # the moc
	 myexpr "$file" : "^src\/moc\/.*\.\(1|l|t|y\)$" ||

	 # All of tmake
	 myexpr "$file" : "^tmake\/" ||

	 # 3rdparty
	 myexpr "$file" : "src\/3rdparty\/$" ||
	 myexpr "$file" : "src\/3rdparty\/.*README$" ||
	 myexpr "$file" : "src\/3rdparty\/libmng\/" ||
	 myexpr "$file" : "src\/3rdparty\/libpng\/" ||
	 myexpr "$file" : "src\/3rdparty\/freetype2\/" ||
	 { myexpr "$file" : 'src\/3rdparty\/zlib\/' && [ ! "$file_BASE" = "Makefile" ] ; } ||
	 # More  of nsplugin example
	 myexpr "$file" : "extensions\/nsplugin\/examples\/.*\.\(\(mng\)|\(def\)|\(rc\)|\(cgi\)|\(g1n\)\)$" ||

	 # some bins
	 myexpr "$file" : "bin\/$" ||
	 myexpr "$file" : "bin\/findtr$" ||
	 myexpr "$file" : "bin\/qt20fix$" ||
	 myexpr "$file" : 'bin\/qmake$' ||
	 myexpr "$file" : "bin\/qtrename140$"
     then
	 KEEP=yes
     fi

     #fall back to asking..
     if [ -z "$KEEP" ]; then
	 echo -n "I've no idea what to do with $file, keep it? (yes or no): "
	 read KEEP
     fi
     [ "$KEEP" = "yes" ] && return 0
     return 1
}

copy_dist_file()
{
   in_file=$1
   out_file=$2
   edition=$3
   platform=$4
   platname=$5
   if [ -f "$in_file" ] && ! binary_file "$in_file"; then
	sed -e "s/%YEAR%/$YEAR/g" -e "s/%VERSION%/${VERSION_STR}/g" \
	    -e "s/%VERSION_NUMBER%/${REL_VERSION}/g" -e "s,%DISTNAME%,$platname,g" \
	    -e "s/%VERSIONWIN%/${BRANCH_DIGITS}/g" $in_file >${TMP_FILE}
	if [ "$TYPE" = "snapshot" ]; then
	    cat ${TMP_FILE} | perl -e '$crap.=<STDIN> until(eof(STDIN)); $crap =~ s/%SNAPSHOTONLY([^%]*)%/$1/g; $crap =~ s/%STABLEONLY[^%]*%//g; print $crap' >$out_file
	else
	   cat ${TMP_FILE} | perl -e '$crap.=<STDIN> until(eof(STDIN)); $crap =~ s/%SNAPSHOTONLY([^%]*)%//g; $crap =~ s/%STABLEONLY[^%]*%/$1/g; print $crap' >$out_file
	fi
	if [ "$edition" = "free" ]; then
	   cat ${out_file} | perl -e '$crap.=<STDIN> until(eof(STDIN)); $crap =~ s/%FREEONLY([^%]*)%/$1/g; $crap =~ s/%COMMERCIALONLY[^%]*%//g; print $crap' >${TMP_FILE}
	else
	   cat ${out_file} | perl -e '$crap.=<STDIN> until(eof(STDIN)); $crap =~ s/%FREEONLY[^%]*%//g; $crap =~ s/%COMMERCIALONLY([^%]*)%/$1/g; print $crap' >${TMP_FILE}
	fi
	mv "${TMP_FILE}" "$out_file"
   else
        cp -ar "$in_file" "$out_file"
   fi
}

copy_platform_files() {
    dir="$DISTDIR/qt/dist/$1"
    edition=$2
    platform=$3
    o_dir=$4
    platname=$5
    [ ! -e "$o_dir/README" ] && copy_dist_file "$DISTDIR/qt/dist/README" "$o_dir/README" "$edition" "$platform" "$platname"
    [ ! -d $dir ] && return 1
    for a in `find $dir`; do
	a_file=`echo $a | sed "s,$dir,,"`
	o_file=$a_file
	{ [ -z $a_file ] || [ -d $a ] ; } && continue
	[ "$platform" = "mac" ] && [ `basename $a_file` = "README.outside" ] && continue
	if [ "$platform" = "embedded" ] || [ "$platform" = "qnx6" ]; then
	    case `basename $a` in
	    *.qws) o_file=`basename $a | sed "s,\.qws,,"` ;;
	    *) [ -e "${a}.qws" ] && continue ;;
	    esac
	    if [ "$edition" = "commercial" ] || [ "$edition" = "review" ] || [ "$edition" = "academic" ]; then
		[ $o_file = "LICENSE" ] && o_file=".LICENSE"
		[ $o_file = "LICENSE-US" ] && o_file=".LICENSE-US"
	    fi
	else
	    echo $o_file | grep '.qws$' >>/dev/null 2>&1 && continue
	fi
	if [ "$platform" = "embedded" ] || [ "$platform" = "mac" ]; then
	   [ `basename $a_file` = "LICENSE.QPL" ] && continue
        fi
	case $edition in
	commercial|review|academic)
	    if [ "$platform" = "win" ]; then
		[ `basename $a` = "LICENSE" ] && continue
		[ `basename $a` = "LICENSE-US" ] && continue
	    else
		[ `basename $a` = "LICENSE" ] && o_file=".LICENSE"
		[ `basename $a` = "LICENSE-US" ] && o_file=".LICENSE-US"
	    fi
	    ;;
	*) [ `basename $a` = "LICENSE-US" ] && continue ;;
	esac

	#do copy
	final_dir=`dirname $o_dir/$o_file`
	[ ! -d $final_dir ] && mkdir -p $final_dir
	[ -f $o_dir/$o_file ] && rm -f $o_dir/$o_file
        copy_dist_file "$dir/$a_file" "$o_dir/$o_file" "$edition" "$platform" "$platname"
    done
    return 0
}

remove_file_and_includes()
{
    for a in $@; do
	file="$PLATDIR/$a"
	[ ! -e "$file" ] && continue
	HEADER_FILES="$file"
	[ -d "$file" ] && HEADER_FILES=`find $file -name *.h`
	for include_dir in "$PLATDIR/include" "$PLATDIR/include/private"; do
	    for a in $HEADER_FILES; do
		base=`basename $a`
		[ -e "$include_dir/$base" ] && rm -f "$include_dir/$base"
	    done
	done
	rm -rf $file
    done
}

for plat in mac win x11 qnx6 embedded; do
    #handle commandline options
    platformname=$plat
    plat2=$plat
    plat3=$plat
    case $plat in
    mac)
	[ "x$DO_MAC" = "xyes" ] || continue
	plat2=unix
	plat3=mac9
	;;
    qnx6)
	[ "x$DO_QNX6" = "xyes" ] || continue
	platformname="embedded"
	plat2=unix
	plat3=qws
	;;
    embedded)
	[ "x$DO_EMBEDDED" = "xyes" ] || continue
	plat2=unix
	plat3=qws
	;;
    x11)
	[ "x$DO_X11" = "xyes" ] || continue
	plat2=unix
	;;
    win)
	[ "x$DO_WIN" = "xyes" ] || continue
	;;
    *) die "Will probably need more info to package: $plat!" ;;
    esac
    status "****** Packing for platform: $plat ****" "1"

    PLAT_RM_FILE=${TMP_FILE}-plat-${plat}
    for edition in commercial free review academic; do
	case $edition in
	commercial)
	    [ "x$DO_COMMERCIAL" = "xyes" ] || continue
	    ;;
	free)
	    [ "x$DO_FREE" = "xyes" ] || continue
	    [ "$plat" != "embedded" ] && [ "$plat" != "x11" ] && [ "$plat" != "mac" ] && continue
	    ;;
	review)
	    [ "x$DO_REVIEW" = "xyes" ] || continue
	    ;;
        academic)
	    [ "x$DO_ACADEMIC" = "xyes" ] || continue
	    ;;
	esac

	#find the header/source license
	edition_plat_license=
	for lic in "${plat}-${edition}" "${edition}"; do
	    if [ -f "$DISTDIR/qt/dist/licenses/$lic" ]; then
		edition_plat_license="$DISTDIR/qt/dist/licenses/$lic"
		break;
	    fi
	done
	if [ -z "$edition_plat_license" ]; then
	    die "Package [${plat}-${edition}] does not have a valid source license!"
	fi

	#generate the manifest file
	if [ ! -e "$MANIFEST_FILE" ]; then
	    CREATED_MANIFEST=yes
	    status "Creating manifest file.."
	    OLDIFS=$IFS
	    export IFS='
' #looks ugly.. so is mike...
	    for a in `find $DISTDIR/qt`; do
		[ -d "$a" ] && continue
		if public_file "$a"; then
		    echo "$a" | sed "s,^${DISTDIR}/qt,," >>${MANIFEST_FILE} 2>>$LOG || \
			    die "Could not write to manifest file";
		fi
	    done
	    export IFS=$OLDIFS
	fi

	status "*** Packing $edition... *****" "1"
	PLATNAME=qt-${plat}-${edition}-${VERSION_STR}
	PLATDIR=$DISTDIR/$PLATNAME

	#copy the tree
	status "Copying the tree.."
	for a in `cat ${MANIFEST_FILE}`; do
	    d=${PLATDIR}/`dirname "$a"`
	    [ ! -d $d ] && mkdir -p $d
	    if [ -e "$DISTDIR/qt/$a" ]; then
	      ln "$DISTDIR/qt/$a" "$d/`basename $a`" && [ ! -L "$d/`basename $a`" ] && chmod ug+w "$d/`basename $a`"
	    fi
	done
	#clean the tree a little
	status "First cleanup.."
	case $edition in
	free)
	    #remove non-GPL sql stuff
	    rm -rf $PLATDIR/src/sql/drivers/oci
	    rm -rf $PLATDIR/src/sql/drivers/tds
	    rm -rf $PLATDIR/src/sql/drivers/shared
	    rm -rf $PLATDIR/src/sql/drivers/db2
	    rm -rf $PLATDIR/plugins/src/sqldrivers/oci
	    rm -rf $PLATDIR/plugins/src/sqldrivers/tds
	    rm -rf $PLATDIR/plugins/src/sqldrivers/db2
	    rm -rf $PLATDIR/extensions/motif
	    ;;
        commercial)
	    #remove .GPL files for assistant, designer and linguist in commercial
	    rm -f $PLATDIR/tools/assistant/LICENSE.GPL
	    rm -f $PLATDIR/tools/designer/LICENSE.GPL
	    rm -f $PLATDIR/tools/linguist/LICENSE.GPL
	    ;;
	esac
	remove_file_and_includes "extensions/xt" #we don't distribute these anymore

        # until a licensing question is answered, don't distribute the walkthrough code
	rm -rf "$PLATDIR/extensions/motif/examples/walkthrough"

	if [ "$plat" != "embedded" ] && [ "$plat" != "qnx6" ]; then
	    #Remove embedded from mkspec so that configure does not think we are running embedded
	    rm -rf "$PLATDIR/mkspecs/qws"
	    rm -rf "$PLATDIR/plugins/src/gfxdrivers"
	    rm -rf "$PLATDIR/plugins/gfxdrivers"
	    rm -rf "$PLATDIR/examples/directpainter"
	fi
	rm -f "$PLATDIR/mkspecs/README"
	rm -rf "$PLATDIR/examples/kiosk"
	rm -f "$PLATDIR/lib/fonts/unifont.bdf"
	rm -rf "$PLATDIR/tmake"
	rm -rf "$PLATDIR/util"
	rm -rf "$PLATDIR/tests"
	if [ "$plat" != "mac" ]; then
	    remove_file_and_includes "src/styles/qaquastyle.h" "src/styles/qaquastyle_p.h"
	    remove_file_and_includes "src/styles/qaquastyle.cpp"
	    remove_file_and_includes "src/styles/qaquastylepix_p.h" "src/styles/qaquastyle_p.cpp"
	    rm -rf "$PLATDIR/plugins/src/styles/aqua" "$PLATDIR/plugins/src/styles/mac"
        fi
	if [ "$plat" = "mac" ] && [ "$edition" = "free" ]; then
	    remove_file_and_includes "src/styles/qaquastyle.h" "src/styles/qaquastyle.cpp"
	    remove_file_and_includes "src/styles/qaquastylepix_p.h"
	    rm -rf "$PLATDIR/plugins/src/styles/aqua"
        fi
	if [ "$plat" != "win" ]; then
	    remove_file_and_includes "src/styles/qwindowsxpstyle.h" "src/styles/qwindowsxpstyle.cpp"
	    rm -rf "$PLATDIR/plugins/src/styles/windowsxp"
	fi

	mkdir -p $PLATDIR/lib
	echo "If this directory is empty, you forgot to build the Qt library" >$PLATDIR/lib/README
	if [ "$plat" = "x11" ] || [ "$plat" = "qnx6" ] || [ "$plat" = "embedded" ] || [ "$plat" = "mac" ]; then
	    ### Windows build system things
	    #configure.bat is for windows only
	    rm -f "$PLATDIR/configure.bat"
	    rm -f "$PLATDIR/bin/configure.exe"
	    #fix makefile mess
	    rm -f "$PLATDIR/Makefile" "$PLATDIR/qmake/Makefile" "$PLATDIR/qmake/GNUmakefile"
	    mv "$PLATDIR/GNUmakefile" "$PLATDIR/Makefile"
	    #Some code is specific to platform though..
	    rm -rf "$PLATDIR/tools/designer/integration/QMsDev"
	    rm -rf "$PLATDIR/tools/designer/integration/QMsNet"
	    rm -rf "$PLATDIR/src/3rdparty/gsos"
	    remove_file_and_includes "src/kernel/qt_windows.h"
	    if [ "$plat" = "embedded" ] || [ "$plat" = "qnx6" ]; then
		rm -rf "$PLATDIR/examples/biff" "$PLATDIR/examples/desktop" "$PLATDIR/examples/overlay_x11"
	    elif [ "$plat" = "x11" ]; then
		rm -rf "$PLATDIR/examples/winmanager" "$PLATDIR/examples/compact"
		rm -rf "$PLATDIR/examples/notepad" "$PLATDIR/examples/launcher"
		rm -rf "$PLATDIR/examples/trayicon"
		rm -rf "$PLATDIR/extensions/imageio"
		rm -rf "$PLATDIR/src/3rdparty/freetype2" "$PLATDIR/src/3rdparty/freetype"
		rm -f "$PLATDIR/src/widgets/qcompactstyle.h" "$PLATDIR/src/widgets/qcompactstyle.cpp"
	    elif [ "$plat" = "mac" ]; then
		rm -rf "$PLATDIR/examples/biff" "$PLATDIR/examples/desktop" "$PLATDIR/examples/overlay_x11"
		rm -rf "$PLATDIR/examples/winmanager" "$PLATDIR/examples/compact"
		rm -rf "$PLATDIR/examples/notepad" "$PLATDIR/examples/launcher"
		rm -rf "$PLATDIR/examples/trayicon"
		rm -rf "$PLATDIR/src/3rdparty/freetype2" "$PLATDIR/src/3rdparty/freetype"
		rm -f "$PLATDIR/src/widgets/qcompactstyle.h" "$PLATDIR/src/widgets/qcompactstyle.cpp"
	    fi
	elif [ "$plat" = "win" ]; then
	    ### Unix build system things
	    #configure is for unix only
	    rm -f "$PLATDIR/configure"
	    #GNUmakefile is for unix only
	    rm -f "$PLATDIR/GNUmakefile" $PLATDIR/qmake/GNUmakefile* "$PLATDIR/qmake/Makefile.unix"
	    # don't need config.tests
	    rm -rf "$PLATDIR/config.tests"

	    #Unix only code
	    rm -rf "$PLATDIR/src/3rdparty/gsos"
	    rm -rf "$PLATDIR/examples/biff" "$PLATDIR/examples/desktop" "$PLATDIR/examples/overlay_x11"
	    rm -rf "$PLATDIR/examples/winmanager" "$PLATDIR/examples/compact"
	    rm -rf "$PLATDIR/examples/notepad" "$PLATDIR/examples/launcher"
	    rm -rf "$PLATDIR/src/3rdparty/freetype2" "$PLATDIR/src/3rdparty/freetype"
	    rm -f "$PLATDIR/src/widgets/qcompactstyle.h" "$PLATDIR/src/widgets/qcompactstyle.cpp"

	    # move the files into include
	    status "Moving header files.."
	    [ ! -d "$PLATDIR/include" ] && mkdir -p "$PLATDIR/include"
	    [ ! -d "$PLATDIR/include/private" ] && mkdir -p "$PLATDIR/include/private"
	    cp "$PLATDIR/src/tools/qconfig-dist.h" "$PLATDIR/xxx"
	    for a in $includefiles; do
		FILE=$PLATDIR/include/`basename $a`
		rm -f $FILE
		[ -e $PLATDIR/$a ] && mv $PLATDIR/$a $FILE >>$LOG 2>&1
	    done
	    for a in $privincludefiles; do
		FILE=$PLATDIR/include/private/`basename $a`
		rm -f $FILE
		[ -e $PLATDIR/$a ] && cp $PLATDIR/$a $FILE >>$LOG 2>&1
	    done
	    mv "$PLATDIR/xxx" "$PLATDIR/src/tools/qconfig-dist.h"
	fi
	#don't need empty directories
	status "Pruning empty directories.."
	find $PLATDIR/ -type d -exec rmdir {} \; >>$LOG 2>&1

	#do the documentation
	if [ "x$DO_DOC" = "xyes" ]; then
	    for tdir in $DISTDIR/qt/tutorial/t*; do
	        tutorial=`basename $a`
		if [ -d "$tdir" ] && [ -e "${tdir}/${tutorial}.pro" ]; then
		    (cd "$tdir" && $QMAKE_PATH)
		fi
            done
	    status "Running qdoc.."
	    QTDIR=$PLATDIR $QDOC_PATH $DISTDIR/qt/util/qdoc/qdoc.conf --warning-level=0 >>$LOG 2>&1 || die "could not run qdoc, stopped"
	    find $PLATDIR/gif -exec mv {} $PLATDIR/doc/html/ \; >>$LOG 2>&1
	    if [ "$plat" = "x11" ] || [ "$plat" = "embedded" ] || [ "$plat" = "qnx6" ]; then
		QTDIR=$PLATDIR/ $DISTDIR/qt/util/qdoc/man  $PLATDIR/ >>$LOG 2>&1 || die "could not run man, stopped"
	    fi
	    for tdir in $DISTDIR/qt/tutorial/t*; do
	        tutorial=`basename $a`
		if [ -d "$tdir" ] && [ -e "${tdir}/${tutorial}.pro" ] && [ -e "${tdir}/Makefile" ]; then
		    rm -f $tdir/Makefile
		fi
            done
	rm -rf $PLATDIR/tools/designer/book

	fi
	if [ "$plat" = "win" ]; then
	    rm -rf "$PLATDIR/doc/man"
	    #since there is no man pages, move all docs to doc/
	    #mv $PLATDIR/doc/html/* $PLATDIR/doc
	    #rm -rf $PLATDIR/doc/html
	fi

	#remove excess files needed to generate documentation, but no longer needed for package
	#find $PLATDIR/tools/designer/manual/sgml/eg/book -name book.h | xargs rm -f
	#find $PLATDIR/tools/designer/manual/sgml/eg/book -name book.cpp | xargs rm -f
	#find $PLATDIR/tools/designer/manual/sgml/eg/book -name editbook.h | xargs rm -f
	#find $PLATDIR/tools/designer/manual/sgml/eg/book -name editbook.cpp | xargs rm -f

	#copy the platform dist stuff
	copy_platform_files "$platformname" $edition $plat $PLATDIR $PLATNAME #platform specific
	copy_platform_files "$edition" $edition $plat $PLATDIR $PLATNAME #edition specific

	status "Final cleanup.."
	#remove directories only used for documentation on some platforms
	if [ "$plat" != "win" ]; then
	    remove_file_and_includes "extensions/activeqt" #activeqt is windows only
	fi
	if [ "$plat" != "x11" ]; then
	    remove_file_and_includes "extensions/xt" "extensions/motif" #x11 only
	fi
	#remove platform specific files that don't belong
	if [ ! -e "$PLAT_RM_FILE" ]; then
	    for file in `find $PLATDIR -name '*_[a-z0-9]*\.*'`
	    do
		[ -d $file ] && continue
		match=`basename $file | sed "s,.*_,," | cut -d'.' -f1`
		case $match in
		unix|win|mac|x11|qws|mac9|wce|qnx6|qnx4)
		    if [ "$match" != "$plat" ] && [ "$match" != "$plat2" ] && [ "$match" != "$plat3" ]; then
			rm -f $file
			echo $file | sed "s,^${PLATDIR},,g" >>$PLAT_RM_FILE
		    fi
		    ;;
		*) ;;
		esac
	    done
	else
	    for f in `cat $PLAT_RM_FILE`; do
		rm -f $PLATDIR/$f
	    done
	fi

	#insert license headers
	status "Licensing.." "1"
	for a in `find $PLATDIR`; do
           if [ -f $a ] && ! binary_file "$a" && [ ! -L $a ] && grep '^** EDITIONS: ' $a >>$LOG 2>&1; then
	      allowed_editions=`grep '^** EDITIONS: ' $a | cut -d ':' -f2- | sed -e "s/, */ /g" -e "s/^ *//g" -e "s/ *$//g"`
	      if [ "$allowed_editions" = "UNKNOWN" ]; then
	          status "!! Warning: $a has unknown license [$allowed_editions] !!"
	      elif [ "$allowed_editions" != "NOLIMITS" ]; then
	        if [ "$edition" = "free" ] && ! echo "$allowed_editions" | grep "FREE" >/dev/null 2>&1; then
	          status "!! Warning: $a is not licensed for $edition package [$allowed_editions] !!"
		  continue
	        elif [ "$edition" = "commercial" ] && 
                     ! echo "$allowed_editions" | grep "\(PROFESSIONAL\|ENTERPRISE\)" >/dev/null 2>&1; then
	          status "!! Warning: $a is not licensed for $edition package [$allowed_editions] !!"
		  continue
                fi
	      fi
	      execut=444
	      [ -x $a ] && execut=555
	      sed "/EDITIONS/r $edition_plat_license" $a >${TMP_FILE}
	      rm -f $a
	      mv ${TMP_FILE} $a
	      chmod $execut $a
	   fi
        done
	status "" "-1"

	#actually package
	status "Packaging.." "1"
	(cd "$DISTDIR"
	if [ "$plat" = "x11" ] || [ "$plat" = "embedded" ] || [ "$plat" = "qnx6" ] || [ "$plat" = "mac" ]; then
	    status "Tar.."
	    tar cf "$OUT_TREE/${PLATNAME}.tar" "${PLATNAME}"
	    [ "$DO_GZIP" = "yes" ] && status "Gzip.." && gzip -c "$OUT_TREE/${PLATNAME}.tar" >"$OUT_TREE/${PLATNAME}.tar.gz"
	    [ "$DO_BZIP" = "yes" ] && status "Bzip2.." && bzip2 -z -c "$OUT_TREE/${PLATNAME}.tar" >"$OUT_TREE/${PLATNAME}.tar.bz2"
            if [ "$plat" = "mac" ] && [ "$DO_STUFF" = "yes" ]; then
               status "Stuffit.."
	       create_dir="QtMac-${VERSION_STR}"
	       mkdir -p "$create_dir"

	       pack_cmd="gnutar xfv"
	       pack_name="$OUT_TREE/${PLATNAME}.tar"
	       if [ "$DO_GZIP" = "yes" ]; then
		   pack_name="${pack_name}.gz"
		   pack_cmd="${pack_cmd}z"
	       fi
	       sed -e "s,%UNPACK_NAME%,$(basename $pack_name),g" -e "s/%UNPACK_CMD%/$pack_cmd/g" \
		   "$DISTDIR/qt/dist/mac/README.outside" >${TMP_FILE}-mac-outside
	       copy_dist_file "${TMP_FILE}-mac-outside" "${create_dir}/README" "$edition" "$plat" "$PLATNAME"
	       rm -f "${TMP_FILE}-mac-outside"
	       cp "$pack_name" "$create_dir"
               stuff -q "-n=${OUT_TREE}/${PLATNAME}.sit" "$create_dir"
	       rm -rf "$create_dir"
            fi
	elif [ "$plat" = "win" ]; then
	    txtfiles=""
	    binfiles=""
	    for fl in `find "${PLATNAME}"`; do
	        if binary_file $fl; then
		  binfiles="$fl $binfiles"
		else
		  txtfiles="$fl $txtfiles"
		fi
	    done
	    status "Text files..."
	    { for a in $txtfiles; do echo $a; done ; } | zip -l9q $OUT_TREE/${PLATNAME}.zip -@
	    status "Binary files..."
	    { for a in $binfiles; do echo $a; done ; } | zip -9q $OUT_TREE/${PLATNAME}.zip -@
	fi
	if [ "x$DO_PKG" = "xyes" ]; then
	   status "CD Package..."
	   if [ $plat = "win" ]; then
	       # do the unix->dos translation of text files
	       for a in $txtfiles; do perl -pi -e 's/\n/\r\n/' $a; done ;
	   fi
	   case $plat in
	   win) opts="-win -n" ;;
	   x11) opts="-unix" ;;
	   *) opts="-${plat}" ;;
	   esac
	   $QPKG_PATH $opts -desc $VERSION_STR -o "$OUT_TREE/${PLATNAME}.arq" ${PLATNAME}/* >& /dev/null
	   if [ $plat = "win" ]; then
	       # create a batch file to build the self-extracting archive for Windows
	       pushd $OUT_TREE
	       echo "install.exe -add-archive $PLATNAME.arq" > build-selfextractor.bat
	       zip -l9q $OUT_TREE/win-selfextractor.zip build-selfextractor.bat
	       zip -9q $OUT_TREE/win-selfextractor.zip "${PLATNAME}.arq"
	       rm build-selfextractor.bat
	       popd
	       pushd qt/dist/win
	       zip -9q $OUT_TREE/win-selfextractor.zip install.exe
	       if [ -x $QTDIR/util/packageclient/packageclient ]; then
		status "Build windows exe on utsikt.troll.no"
		$QTDIR/util/packageclient/packageclient $OUT_TREE/win-selfextractor.zip $OUT_TREE/${PLATNAME}.exe utsikt.troll.no
	       fi
	       popd
	   fi
	fi
	)
	status "" "-1"

	#cleanup
	status "($edition cleanup)"
	rm -rf $PLATDIR
	status "** Done Packing $edition.. **" "-1"
    done
    [ -e "$PLAT_RM_FILE" ] && rm -f $PLAT_RM_FILE
    status "******** Done Packaging $plat *********" "-1"
done

if [ "$DO_QMAKE" = "yes" ]; then
    status "Packaging qmake.." "1"
    for plat in unix win; do
      case $plat in
      win) [ "x$DO_WIN"  = "xyes" ] || continue ;;
      unix) [ "x$DO_X11" = "xno" ] && [ "x$DO_MAC" = "xno" ] && [ "x$DO_EMBEDDED" = "xno" ] [ "x$DO_QNX6" = "xno" ] && continue ;;
      esac
      status "** Packing for $plat **" "1"

      status "Copying files.."
      #qmake stuff
      QMAKE_VERSION=`grep 'QMAKE_VERSION "' "$DISTDIR/qt/qmake/option.h" | cut -d ' ' -f3 | sed 's,",,g'`
      PLATNAME=qmake-${plat}-${QMAKE_VERSION}
      [ "$TYPE" = "snapshot" ] && PLATNAME=`date "+${PLATNAME}-snapshot-%Y%m%d"`
      PLATDIR=$DISTDIR/qmake/$PLATNAME
      [ -d "$PLATDIR" ] || mkdir -p $PLATDIR
      #copy qmake stuff now
      cp -r "$DISTDIR/qt/mkspecs" "$PLATDIR"
      mkdir "$PLATDIR/src"
      cp -r $DISTDIR/qt/qmake/* "$PLATDIR/src"
      if [ "$DO_DOC" = "yes" ]; then
	mkdir "$PLATDIR/doc"
	cp $DISTDIR/qt/doc/qmake* "$PLATDIR/doc"
      fi

      #qt stuff
      QTPLATNAME=qt-${plat}-${REL_VERSION}
      [ "$TYPE" = "snapshot" ] && QTPLATNAME=`date "+${QTPLATNAME}-snapshot-%Y%m%d"`
      QTPLATDIR=$PLATDIR/$QTPLATNAME
      mkdir -p "$QTPLATDIR/include"
      mkdir -p "$QTPLATDIR/src/tools"
      for a in qstring qtextstream qiodevice qglobal qgdict qcstring qdatastream qgarray qbuffer qglist \
	qptrcollection qfile qregexp qgvector qgcache qbitarray qdir qfileinfo qdatetime qstringlist qmap qfeatures; do
	  H_FILE="$DISTDIR/qt/src/tools/${a}.h"
	  [ -e "$H_FILE" ] && cp "$H_FILE" "$QTPLATDIR/include"
	  CPP_FILE="$DISTDIR/qt/src/tools/${a}.cpp"
	  [ -e "$CPP_FILE" ] && cp "$CPP_FILE" "$QTPLATDIR/src/tools"
	  PLAT_CPP_FILE="$DISTDIR/qt/src/tools/${a}_${plat}.cpp"
	  [ -e "$PLAT_CPP_FILE" ] && cp "$PLAT_CPP_FILE" "$QTPLATDIR/src/tools"
      done

      #makefile stuff
      if [ "$plat" = "unix" ]; then
         rm -f "$PLATDIR/src/Makefile" #windows stuff
	 sed -e "s,@REL_QTDIR@,../$QTPLATNAME,g" -e "s,@OUT_QTDIR@,../$QTPLATNAME,g" \
	    $PLATDIR/src/Makefile.unix >$PLATDIR/src/Makefile
	 sed -e "s,@REL_QTDIR@,../$QTPLATNAME,g" -e "s,@OUT_QTDIR@,../$QTPLATNAME,g" \
	    $PLATDIR/src/GNUmakefile.in >$PLATDIR/src/GNUmakefile
	 rm -f "$PLATDIR/src/Makefile.unix" "$PLATDIR/src/GNUmakefile.in" #don't need them
      elif [ "$plat" = "win" ]; then
         rm -f "$PLATDIR/src/Makefile.unix" "$PLATDIR/src/GNUmakefile.in" #unix stuff
         sed "s,\$(QTDIR),../$QTPLATNAME,g" $PLATDIR/src/Makefile >$TMP_FILE
	 mv "$TMP_FILE" "$PLATDIR/src/Makefile"
      fi

      status "Packaging.." "1"
      (cd "$DISTDIR/qmake"
      if [ "$plat" = "unix" ]; then
	status "Tar.."
	tar cf "$OUT_TREE/${PLATNAME}.tar" "${PLATNAME}"
	[ "$DO_GZIP" = "yes" ] && status "Gzip.." && gzip -c "$OUT_TREE/${PLATNAME}.tar" >"$OUT_TREE/${PLATNAME}.tar.gz"
	[ "$DO_BZIP" = "yes" ] && status "Bzip2.." && bzip2 -z -c "$OUT_TREE/${PLATNAME}.tar" >"$OUT_TREE/${PLATNAME}.tar.bz2"
        if [ "$plat" = "mac" ] && [ "$DO_STUFF" = "yes" ]; then
           status "Stuffit.."
           stuff -q "-n=${OUT_TREE}/${PLATNAME}.sit" "${PLATNAME}"
        fi
      elif [ "$plat" = "win" ]; then
	txtfiles=""
	binfiles=""
	for fl in `find "${PLATNAME}"`; do
	  if binary_file $fl; then
	     binfiles="$fl $binfiles"
	  else
	     txtfiles="$fl $txtfiles"
	  fi
	done
	if [ ! -z "$txtfiles" ]; then
	    status "Text files..."
	    { for a in $txtfiles; do echo $a; done ; } | zip -l9q $OUT_TREE/${PLATNAME}.zip -@
	fi
	if [ ! -z "$binfiles" ]; then
	    status "Binary files..."
	    { for a in $binfiles; do echo $a; done ; } | zip -9q $OUT_TREE/${PLATNAME}.zip -@
	fi
      fi
      )
      status "" "-1"
      status "** Done with $plat **" "-1"
   done
   status "Done with qmake" "-1"
fi

status "(mkdists cleanup..)"
rm -rf $DISTDIR
rm -f ${TMP_FILE}
cp -a $MANIFEST_FILE $OUT_TREE/manifest >>$LOG 2>&1
[ "x$CREATED_MANIFEST" = "xyes" ] && rm -f ${MANIFEST_FILE}
status "mkdists done"
exit 0
