#!/usr/bin/perl
#
# $Id: //depot/qt/main/util/qdoc/qdoc#5 $
#
# this is a massive hack, written very quickly
#
# usage: gendoc *.cpp
#        (or just some C++ files)
#
# gendoc looks for comments that start with /*! and look for these
# escapes:
#
# "\e word" emphasises that word
#
# \arg, \capt, \name, \return and \todo all use the text until the next
# blank line to do, respectively, describe an argument, set a caption
# for the documented unit, set the name which triggers links to the unit,
# describe the return value, and finally add an item to the todo list
#
# "\fn line" uses the rest of the line as a function specification
# (most commonly an inline or virtual = NULL function). It must be the
# first escape
#
# "\class name header" documents the class "name" which is defined in
# header file "<header>".  It too must be the first escape

sub urlencode {
    local($_) = @_;

    s-\!|\%|\/|\<|\=|\>|\[|\]|\^|\||\~|\+-sprintf("+%02x", ord($&))-eg;
    $_;
}

sub html {
    local($_) = @_;

    s/\&/&amp;/gs;
    s/</&lt;/gs;
    s/>/&gt;/gs;
# "

    $_;
}


sub processcode {
    local ($_) = @_;

    $_ = &html($_);
    s/\n/\n\t/gs;
    s/^\s*\n//s;
    s/\s+$/\n/s;
    s/\n\s*\n/\n<br>\n/gs;
    s!\\/(.*?\n)!//$1!gs;

    join($_, "<pre>\n", "</pre>\n");
}



sub findlink {
    local ($_, $class, $url, $ismethod) = @_;

    if (defined($anchor{$_}) && $anchor{$_} ne $url) {
	sprintf("<a href=%s>%s</a>", $anchor{$_}, $_);
    } elsif (($ismethod eq "(") && 
	     defined($anchor{$class . $_}) && $anchor{$class . $_} ne $url) {
	sprintf("<a href=%s>%s</a>", $anchor{$class . $_}, $_);
    } else {
	sprintf("%s", $_);
    }
}




sub processdocs {
    local ($url, $doc, $class, %word, $idoc);

    foreach $url ( sort keys %type ) {
	$class = $name{$url};
	$class =~ s/::.*/::/;

	$doc = $doc{$url};

	$capt{$url} = $1 
	    if ($doc =~ s/\\capt\s+(.*?)
		(?:(?:\n\s*\n\s*)|(?:$ ))/\n\n/sx);
	$name{$url} = $1
	    if ($doc =~ s/\s*\\name\s+(.*?)
		(?:(?:\n\s*?\n\s*)|(?:$ ))/\n/sx);
	$doc =~ s/\s*$/\n/s;
	$doc =~ s/^\s*//s;

	$doc =~ s/\\internal\s.*//s if (!$internal);

	$doc .= "<p><strong>Returns:</strong> " . $1
	    if ($doc =~ s/\s*\\returns?\s+(.*?)
		(?:(?:\n\s*?\n\s*)|(?:$ ))/\n\n/sx);

	$_ = "<p><strong>Arguments:</strong>\n<ul>\n";
	$_ .= "<li>" . $1 . "\n" 
	    while ($doc =~ s/\s*\\arg\s+(.*?)
		   (?:(?:\n\s*?\n\s*)|(?:$ ))/\n\n/sx);
	$_ .= "</ul>\n";
	$doc .= $_ if (/<li>/s);

	$_ = "<strong>To do:</strong>\n<ul>\n";
	$_ .= "<li>" . $1 . "\n" 
	    while ($doc =~ s/\s*\\todo\s+(.*?)
		   (?:(?:\n\s*?\n\s*)|(?:$ ))/\n\n/sx);
	$_ .= "</ul>\n";
	$doc .= $_ if (/<li>/s);

	$doc =~ s-\\internal\s-<p><strong>Internal comments:</strong><p>\n-s;

	$doc =~ s!\\code\s\{\{(.*?)\}\}!&processcode($1)!es;

	$doc =~ s!\\e\s+(\S+)!<em>$1</em>!gs;

	$doc =~ s-\s*\n\s*\n\s*-\n<p>-gs;

	undef %word;
	$_ = $class;
	s/:://;
	$word{$_}++;

	$doc =~ s-(?:(?:(\s+)((?:(?:operator\S{1,3})|(?:\w+)))(\(?))|(<.*?>))-
	    if ($4 eq "") {
		if (!defined($word{$2})) {
		    $word{$2}++;
		    sprintf("%s%s", $1, &findlink($2, $class, $url, $3));
		} else {
		    sprintf("%s%s", $1, $2, $3);
		}
	    } else {
		sprintf("%s", $4);
	    }
	-egsx;

	$doc{$url} = $doc;
    }
}


sub mangleclass {
    local($class) = @_;

    $class =~ s/[:\s].*//;
    $class =~ tr/A-Z/a-z/;
    $class = "globals" if ($class eq "");
    $class .= ".html";

    $class;
}




sub manglefn {
    local($type, $class, $name, $sig, $const) = @_;
    local($url, $d);

    $type =~ s/\s+/-/g;
    $type =~ s/^-*(.*?)-*$/$1/;
    $type =~ s/-*([\*\&])-*/$1/g;
    $type = "-" . $type if ($type ne "");
    $const = "-" . $const if ($const ne "");
    $url = join("", &mangleclass($class), "#", $name);
    $d = "(";
    foreach (split(/\s*,\s*/, $sig)) {
# kill argument name
	s/^\s*((?:
		(?:const\s+)|
		(?:volatile\s+)|
		(?:signed\s+)|
		(?:unsigned\s+)|
		(?:long\s+)|
		(?:short\s+)|
		(?:struct\s+)|
		(?:union\s+)|
		(?:class\s+)|
		(?:enum\s+)
		)*\w+[\s\*\&]*?)\s*\b\w+\s*(?:=.*?\s*)?$/$1/gsx;
# strip spaces around & and *
	s/\s*([\*\&])\s*/$1/;
# kill default and change spaces into -
	s/=.*//g;
	s/\s+/-/g;
	s/-+$//;
	s/^-+//;
# finally add it to the url
	$url = join($d, $url, $_);
	$d = ",";
    }
    if ($d eq ",") {
	$url .= ")" . $type . $const;
    } else {
	$url .= "()" . $type . $const;
    }

    $url = &urlencode($url);
}




sub storeclass {
    local($filename, $sig, $def) = @_;
    local($url, $name, $inh);

    ($name, $inh) = split(/\s*:\s*/, $sig);

    $url = &mangleclass($sig);
    $type{$url} = "class";
    $name{$url} = $name;

    $inheritance{$url} = $inh if (defined($inh) && $inh ne "");

    $def =~ s/\s+/ /g;

    $members{$url} = $def;
}




sub getfile {
    local($filename) = @_;
    local($ifdef);

    open(F, "< $filename") || die "can't open $filename for reading";
    $ifdef = 0;
    while(<F>) {
	$dates{$1} = $2 if (/\$Id\:\s+(.*?),v\s+[0-9\.]+\s+(\S+)\s/);
	$ifdef++ if (/^\#if/ && ($ifdef || !/_H$/)); # medium awful
	if ($ifdef) {
	    print $filename, ":", $., ": ignoring ", $_ if ($debug);
	} else {
	    s-//.*--;
	    push @_,$_;
	}
	$ifdef-- if ($ifdef && /^\#endif\b/); # hm, hm, *_H
    }
    close(F);
    join("", @_);
}



sub readh {
    local ($filename) = @_;

    $h = getfile($filename);
    print "header file: ", $filename, "\n" if ($debug);
    $h =~ s/\x22([^\\\x22]|\\.)*\x22//g; # \x22 is "

# { is \x7b and } is \x7d
    while ($h =~ m-\nclass\s+
	   (\w*?)\s+
	   \x7b\s+(.*?)\n\x7d-xsg
	   ) {
	&storeclass($filename, $1, $2);
    }
}

    


sub readc {
    local ($filename) = @_;

    $c = getfile($filename);
    print "code file: ", $filename, "\n" if ($debug);

# eliminate all the string constants
    $c =~ s/\x22([^\\\x22]|\\.)*\x22//g; # \x22 is "

    study $c;

# find all the defined functions
    while ($c =~ m-
	   (?:/\*\!\s*	      (?# documentation prologue 
			       )
	   ((?:[^\*]|(?:\*[^/]))*) (?# documentation
			       )
           \*/)\s*            (?# comment end 
			       )
	   \n\s*((?:\w+\b\s*)*[\*\&\s])*(?# return type 
			       )
	   (?:(\w+)\s*::\s*)? (?# class name and :: 
			       )
	   ((?:\~?\w+)|       (?# function name, or *gasp* operator
			       )
            (?:operator(?:
	     (?:\=)|
	     (?:\-)|
	     (?:\*)|
	     (?:\/)|
	     (?:\%)|
	     (?:\^)|
	     (?:\&)|
	     (?:\|)|
	     (?:\~)|
	     (?:\!)|
	     (?:\<)|
	     (?:\>)|
	     (?:\+\=)|
	     (?:\-\=)|
	     (?:\*\=)|
	     (?:\/\=)|
	     (?:\%\=)|
	     (?:\^\=)|
	     (?:\&\=)|
	     (?:\|\=)|
	     (?:\<\<)|
	     (?:\>\>)|
	     (?:\<\<\=)|
	     (?:\>\>\=)|
	     (?:\!\=)|
	     (?:\<\=)|
	     (?:\>\=)|
	     (?:\&\&)|
	     (?:\|\|)|
	     (?:\+\+)|
	     (?:\-\-)|
	     (?:\-\>)|
	     (?:\(\))|
	     (?:\[\])|
	     (?:\,)|
	     (?:\-\>\*)|
	     (?:\s+new)|
	     (?:\s+delete))))\s*
	   \(\s*([^\)]*?)\s*\) (?# arg list
			       )
           \s*(const)?\s*\x7b-gsx) { # const, opening brace
        my ($doc, $type, $class, $name, $args, $const);
	$doc = $1;
	$type = $2;
	$class = $3;
	$name = $4;
	$args = $5;
	$const = $6;
	$all = $&;
	if (!($type =~ /\bstatic\b/)) {
	    if ($args =~ /[()]/) {
		print STDERR "function prototype in argument\n", $all;
	    } else {
		my ($url);
		$url = &manglefn($type, $class, $name, $args, $const);
		$name{$url} = $class . "::" . $name;
		$type{$url} = "fn";
		print "url: ", $url, "\n" if ($debug);
		$doc{$url} = $doc;
		$class .= "::" if ($class ne "");
		$def{$url} = $type." ".$class.$name."(".$args.")";
	    }
	}
    }

# find all class documentation entries
    while ($c =~ m-
	   /\*\!\s*	      (?# documentation prologue
			       )
	   \\class\s+         (?# class keyword
			       )
           (\w+)\s+([\.\w]+)  (?# class name and header file
			       )
           (.*?)              (?# actual documentation
			       )
           \*/-gsx) {           # comment end
	my ($class, $hfile, $doc);
	my ($url);
	$class = $1;
	$hfile = $2;
	$doc = $3;
	if (!defined($cfiles{$hfile})) {
	    readh($hfile);
	}
	$cfiles{$hfile} .= " " . $filename;
	$url = &mangleclass($class);
	print $class, " not in ", $hfile, "\n" 
	    unless (defined($members{$url}));
	$doc{$url} = $doc;
	$includefile{$url} = $hfile;
    }

# and function documentation
    while ($c =~ m-
	   /\*\!\s*	      (?# documentation prologue
			       )
	   \\fn\s+         (?# fn keyword
			       )
           ((?:[^\(:]*[\s\&\*]+)?)
	   (?:(\w+)::)?
	   ((?:(?:operator[^\(\s]{1,3})|(?:\~?\w+)))
	   (?:\s*\(([^\(\)]*)\)\s*(const)?)?;?\n (?# function signature
						)
           (.*?)              (?# actual documentation
			       )
           \*/-gsx) {           # comment end
	my ($type, $class, $name, $args, $const, $doc);
	my ($url);
	$type = $1;
	$class = $2;
	$name = $3;
	$args = $4;
	$const = $5;
	$doc = $6;
	$all = $&;
	$url = &manglefn($type, $class, $name, $args, $const);
	$name{$url} = $class . "::" . $name;
	$type{$url} = "fn";
	print "url: ", $url, "\n" if ($debug);
	$doc{$url} = $doc;
	$class .= "::" if ($class ne "");
	$def{$url} = $type." ".$class.$name."(".$args.")";
    }
}

sub makenames {
    foreach ( sort keys %name ) {
	$anchor{$name{$_}} = $_ unless (defined($anchor{$name{$_}}));
    }
#    foreach (sort keys %anchor) { print $_, ": ", $anchor{$_}, "\n"; }
}

#
# add links and escapes to a string
#
sub al {
    local (@o, $_,);

    @o = split(/\b/, $_[0]);
    foreach ( 0..$#o ) {
	if (defined($anchor{$o[$_]})) {
	    $o[$_] = join ("", "<a href=", $anchor{$o[$_]}, ">", 
			   &html($o[$_]), "</a>");
	} else {
	    $o[$_] = &html($o[$_]);
	}
    }
    join("", @o);
}

#
# add <a href> to args where appropriate and html-encode
#
sub makearglinks {
    local($_, $pre, $name, $post, $class, $anchor);

    foreach (sort keys %type) {
	if ($type{$_} eq "fn" &&
	    $def{$_} =~ /^([^\~\(:]*)\s+
	    ((?:\w+::)?(?:(?:operator[^\(\s]{1,3})|(?:(?:\~?\w+))))\s*
	    (\(.*)/sx) {
	    $pre = $1;
	    $name = $2;
	    $post = $3;
	    $class = $name;
	    $class =~ s/::.*//;
	    if (defined($anchor{$class})) {
		$anchor = $anchor{$class};
		undef $anchor{$class};
		$def{$_} = join(" ", &al($pre), &html($name), &al($post));
		$anchor{$class} = $anchor;
	    } else {
		$def{$_} = join(" ", &al($pre), &html($name), &al($post));
	    }
	}
    }
}




sub printout {
    local($url, $tail, $fnheader, $fntail);

    open(O, "> /dev/null") || die "cant open /dev/null";
    $tail = "";
    $fntail = "";

    foreach $url ( sort keys %type ) {
	my($file);

	$file = $url;
	$file =~ s/#.*//;
	if ($file ne $cfile) {
	    $fnheader = "<h2>Member function documentation</h2>\n<dl>\n";
	    print O $fntail, $tail;
	    close(O);
	    open(O, "> $file") || die "can't open $file for writing";
	    $cfile = $file;

	    $tail = "<hr><p>\nThis file is part of the <a href=qt.html>Qt toolkit</a>,\n<a href=licence.html>copyright</a> 1995\n<a href=troll.html>Troll Tech AS</a>, all rights reserved.";
	    if (defined ($cfiles{$includefile{$url}})) {
		my(%files);
		$files{$includefile{$url}}++;
		$tail = join("\n", $tail,
			      "<p>",
			     "It was generated from the following files:",
			     "<ul>",
			     "<li>" . $includefile{$url} .
			     (defined($dates{$includefile{$url}}) ? 
			      (": " . $dates{$includefile{$url}}) :
			      ("")),
			     "");
		foreach (sort split(/\s+/, $cfiles{$includefile{$url}})) {
		    if ($_ ne "" && !defined($files{$_})) {
			$files{$_}++;
			if (defined($dates{$_})) {
			    $tail = join("", $tail, "<li>", $_, ": ", $dates{$_}, "\n");
			} else {
			    $tail = join("", $tail, "<li>", $_);
			}
		    }
		}
		$tail .= "</ul>\n";
	    }
	    $tail .= "<address>\n<a href=mailto:agulbra\@troll.no>Arnt Gulbrandsen</a>, <a href=mailto:all\@troll.no>Troll Tech AS</a>\n</address>\n</body></html>";

	    print O "<html><head>\n<title>Qt toolkit - ", 
	    $name{$url}, 
	    " class</title>\n</head><body>\n",
	    "<h1>Documentation for the ", $name{$url}, " class</h1>\n<hr>\n";
	}
	if ($type{$url} eq "class") {
	    my ($i);
	    print O "<p>\n<code>#include &lt;", $includefile{$url}, "&gt;</code>\n"
		if (defined($includefile{$url}));
	    $i = "";
	    foreach ( sort split(/\s*\,\s*/, $inheritance{$url}) ) {
		my ($im, $ic);
		if (/(\w+)\s+(\w+)/) {
		    $im = $1;
		    $ic = $2;
		} else {
		    $ic = $_;
		    $im = "public";
		}
		if ($ic ne "" && im eq "public") {
		    $i = join ("", $i, " <li>", $ic, " (", $capt{$ic}, ")");
		}
	    }
	    if ($i eq "") {
		print O "<p>\nDoes not inherit anything.\n";
	    } else {
		print O "<p>\nInherits:\n<ul>\n", &al($i), "</ul>\n";
	    }

	    print O "<p>\n<h2>Description</h2>\n", $doc{$url}, "\n";
	    if (defined($members{$url})) {
		my (%m, $mode);
		undef %m;
		$mode = "private";
		foreach (split(/;/, $members{$url})) {
		    $mode = $1 if (s/^\s*((?:
					   (?:private\b\s*?)|
					   (?:protected\b\s*?)|
					   (?:public\b\s*?)|
					   (?:signals\b\s*?)|
					   (?:slots\b\s*?))+):\s*//sx);
		    next if (/^\s*friend\b/);
		    if (/((^)|([^\(]*\b))static\b/) {
			s/(\s*)static\s*/$1/;
			$m{"static ".$mode} .= $_ . ";";
		    } else {
			$m{$mode} .= $_ . ";";
		    }
		}
		foreach $mode ('public', 'static public',
			       'signals', 'slots',
			       'protected', 'static protected',
			       'private', 'static private') {
		    my ($e1, $e2);
		    next unless (defined($m{$mode}));
		    $_ = $mode;
		    $_ .= " members" if (!/s$/);
		    print O "<h2>", ucfirst $_, "</h2>\n<ul>\n";
		    foreach (split (/;/, $m{$mode})) {
			s/\s*([\(\)]+\s*)/ $1 /g;
			s/\s*([,\*\&]+\s*)/$1 /g;
			s-\s*//.*?\n\s*--;
			s/^\s+//;
			s/\s+$//;
			s/\s+/ /g;

			if (/^\s*(?:\}\s*)?((?:[^\(\~]*[\s\&\*]+)?)(?=[\w~]) (?# prelude
							       )
			    ((?:(?:operator[^\(\s]{1,3})|(?:\~?\w+))) (?# name
								   )
			    \s*\(([^\(\)]*)\)\s*(const)?\s*(?:[\{=].*)?$/x) {
			    my ($u,$t,$f,$a,$c);
			    $t = $1;
			    $f = $2;
			    $a = $3;
			    $c = $4;
			    $u = &manglefn($t, $name{$url}, $f, $a, $c);
			    next unless ($internal || 
					 ($mode =~ /public/) ||
					 ($doc{$u} ne ""));
			    if ($type{$u} eq "fn") {
				$_ = join("", &html($t), "<a href=", $u,
					  "><strong>", &html($f), 
					  "</strong></a> ( ", &html($a), 
					  " ) ", $c);
			    } else {
				$_ = join("", &html($t), "<strong>", 
					  &html($f), "</strong> ( ", 
					  &html($a), " ) ", $c);
			    }
			    $_ = join ("", $_, " - <em>", $capt{$u}, "</em>")
				if (defined($capt{$u}));
			} else {
			    $_ = &html($_);
			    s;(\w+[^:\(\{]*)\b(\w+);$1<strong>$2</strong>;s;
			}
			print O "<li>", $_, "\n";
		    }
		    print O "</ul>\n";
		}
	    }
	} elsif ($type{$url} eq "fn") {
	    my ($name);
	    print O $fnheader;
	    $fnheader = "";
	    $fntail = "</dl>\n";
	    $_ = $def{$url};
	    $name = $url;
	    $name =~ s/^[^\#]*\#//;
	    s;([^\(]*)\b(\w+);$1<strong>$2</strong>;s;
	    s%\(%<a name=$name>\(</a>%s;
	    print O "<p><dt>", $_, "\n<dd>", $doc{$url};
	}
    }
    print O $fntail, $tail;
    close(O);
}


$cfile = "VOLD";
#$debug = 1;
$internal = 1;

foreach $arg ( 0..$#ARGV ) {
    &readc($ARGV[$arg]);
}

&makenames();
&makearglinks();
&processdocs();

chdir("/local/qt/doc/html") || die "can't cd to /local/qt/doc/html";

&printout();


