#!/usr/bin/perl
#
# $Id: //depot/qt/main/util/qdoc/qdoc#92 $
#
# this is a massive hack, written very quickly
#
# usage: gendoc *.cpp
#        (or just some C++ files)
#
# gendoc looks for comments that start with /*! and does stuff with these
# escapes:
#
# "\e word" emphasises that word
#
# "\c word" outputs the word in code style
#
# "\warning" outputs "Warning:" in boldface or equivalent
#
# \< -> <
# \> -> >
# \& -> &
# in code examples, \/ becomes //
#
# \arg, \capt, \name, \return and \todo all use the text until the next
# blank line to do, respectively, describe an argument, set a caption
# for the documented unit, set the name which triggers links to the unit,
# describe the return value, and finally add an item to the todo list
#
# "\fn line" uses the rest of the line as a function specification
# (most commonly an inline or virtual = NULL function). It must be the
# first escape
#
# "\overload line" defines line to be an inline function which differs
# from some other version only by the argument types.  qdoc will do the
# appropriate magic
#
# "\class name header" documents the class "name" which is defined in
# header file "<header>".  It too must be the first escape
#
# "\code ... \endcode" makes a code example.  If the first two characters
# on a line in the block are space characters (not white space, ascii 32)
# they will be removed.
#   Variables declared as "class name" or "class * name" (any amount of
# white space) and used as "name.member" or "name->member" will be linked
# to the correct class::member
#
# "\link name text text text \endlink" makes "text text text" into a link
# to "name" which must be a member of this class or fully qualified
#
# "\page filename.html" directs the rest of the file to that filename
#
# "\sa" outputs "See also: " and clears the has-shown-link table
#
# "\header filename.h" adds filename.h to the list of header files that
# are to be included in the documentation.
#
# "\relates classname" directs the documentation for the item to the
# sensible file (one assumes that you choose a sensible class).
#
# "\ingroup groupname" makes this class a member of that class group, and
# "\makegroup groupname caption" creates a group index page.

sub html {
    local($_) = @_;

    s/&/&amp;/gs;
    s/</&lt;/gs;
    s/>/&gt;/gs;

    $_;
}


sub processcode {
    local ($_) = @_;
    local (%types);

    $_ = &html($_);
    s/^\s*\n//s;
    s/\s+$/\n/s;
    s!\\/(.*?\n)!//$1!gs;

    while ( m@(?:(?:^)|(?:[;\{\(]))(?:\s*//[^\n]*\n)*\s*([A-Za-z0-9_:]+)(?=\s*\*?\s*([A-Za-z0-9_]+))@gs ) {
	if ($type{$anchor{$1}} eq "class") {
	    if (defined($types{$2})) {
		print "confusion: ", $2, " seems to refer to both ", $1, 
		" and ", $types{$2}, "\n" if ($1 ne $types{$2});
	    } else {
		$types{$2} = $1;
	    }
	}
    }

    s@([A-Za-z0-9_]+)(\s*(?:(?:\.)|(?:-&gt;))\s*)([A-Za-z0-9_]+)@
	if (defined($anchor{$types{$1} . "::" . $3})) {
	    sprintf("%s%s<a href=%s>%s</a>", $1, $2,
		    $anchor{$types{$1} . "::" . $3}, $3);
	} else {
	    sprintf("%s%s%s", $1, $2, $3);
	}
    @egsx;

    s@\b([A-Za-z0-9_]+::[A-Za-z0-9_]+)\b@
	if (defined($anchor{$1})) {
	    sprintf("<a href=%s>%s</a>", $anchor{$1}, $1);
	} else {
	    sprintf("%s", $1);
	}
    @egsx;

    s@(\s)([A-Za-z0-9_]+)(?!::)@
	if ((defined($anchor{$2})) && ($type{$anchor{$2}} eq "class")) {
	    sprintf("%s<a href=%s>%s</a>", $1, $anchor{$2}, $2);
	} else {
	    sprintf("%s%s", $1, $2);
	}
    @egsx;

    s/\n\s*\n/\n<linebreak>\n/gs;

    join($_, "<pre>\n", "</pre>\n");
}


sub findlink {
    local ($_, $class, $url, $ismethod) = @_;

    if (defined($anchor{$_}) && $anchor{$_} ne $url && $_ ne $class) {
	sprintf("<a href=%s>%s</a>", $anchor{$_}, &html($_));
    } elsif ((($ismethod eq "(") || (/^[A-Z]/)) && 
	     defined($anchor{$class . $_}) && $anchor{$class . $_} ne $url) {
	sprintf("<a href=%s>%s</a>", $anchor{$class . $_}, &html($_));
    } elsif ((($ismethod eq "(") || (/^[A-Z]/)) && 
	     defined($anchor{"::" . $_}) && $anchor{"::" . $_} ne $url) {
	sprintf("<a href=%s>%s</a>", $anchor{"::" . $_}, &html($_));
    } else {
	sprintf("%s", $_);
    }
}

sub preprocessdocs {
    local ($url, $_);

    foreach $url ( sort keys %type ) {
	$doc{$url} =~ s@\\header\s+([a-z0-9\.]+)@
	    my ($h1, $h2);
	    $h1 = $1;
	    $h2 = $h1;
	    $h2 =~ s/\.h$/-h.html/;
	    $headerfiles{$h1} = $h2;
	    sprintf("");
	@egsx;
    }

    foreach $url ( sort keys %type ) {
	$doc{$url} =~ s@\\relate[ds]\s+(\w+)@
	    $relations{$1} .= " " . $url;
	    $home{$url} = $1;
	    sprintf("");
	@egsx;
    }

    # not actually url's... too tired to do it right :(
    foreach $url ( sort keys %relations ) {
	my (%tmp);
	$relations{$url} =~ s/^\s*//;
	foreach ( split(/\s+/, $relations{$url}) ) {
	    $tmp{$_}++ if ($_ ne "");
	}
	$relations{url} = join(" ", sort keys %tmp);
    }
}



sub processdocs {
    local ($url, $doc, $class, %word, $idoc);

    foreach $url ( sort keys %type ) {
#print "processing url: ", $url, "\n";
	if (defined($home{$url})) {
	    $class = $home{$url};
	} else {
	    $class = $name{$url};
	    $class =~ s/::.*/::/;
	}
	$class .= "::" unless ($class =~ /::/);

	$doc = $doc{$url};

	unless ($doc =~ /(?:(?:^)|(?:\n))(?:  )/s) {
	    $doc =~ s/\n  /\n/gs;
	    $doc =~ s/^  //s;
	}

	$doc =~ s/\\\&/&amp;/gs;
	$doc =~ s/\\</&lt;/gs;
	$doc =~ s/\\>/&gt;/gs;

	$doc =~ s/\s*\\ingroup\s+([^\\\s]*)/
	    {
	    $classes{$1.".html"} .= $class;
	    "\n";
	}
	/egsx;
	$capt{$url} = $1 
	    if ($doc =~ s/\s*\\capt\s+(.*?)
		(?:(?:\n\s*\n\s*)|(?:$ ))/\n\n/sx);
	$name{$url} = $1
	    if ($doc =~ s/\s*\\name\s+(.*?)
		(?:(?:\n\s*?\n\s*)|(?:$ ))/\n/sx);
	$doc =~ s/\s*$/\n/s;
	$doc =~ s/^\s*//s;
	$doc =~ s-\s*\\warning\s+-<p><strong>Warning:</strong> -gs;
	if (!$internal) {
	    $doc =~ s/^\s*\\internal\s/For internal use only.\\internal /s;
	    $doc =~ s/\\internal\s.*//s;
	}

	# this code is _really_ hard to follow... sorry
	$doc =~ s@\\sa\s+(.*)?\n@
	{
	    my ($seealso);
	    $seealso = $1;

	    $seealso =~ s/\s+/ sex /gs;
	    $seealso =~ s/\\link(.*?)\\endlink/
	    {
		my($evilhack);
		$evilhack = $1;
		$evilhack =~ s- sex - -gs;
		sprintf("\\link %s \\endlink", $evilhack);
	    }/esg;

	    $seealso =~ s/,? sex and sex / sex /;
	    $seealso =~ s/\.?\s*(?:sex\s*)?$//;
	    $seealso =~ s/,?\s+sex\s+/ sex and sex /gs;
	    $seealso =~ s/ sex and sex (?=.* sex and sex )/, sex /gs;
	    $seealso =~ s/ sex / /gs;
	    sprintf( "\n\nmagicwordthatyoushouldavoid %s.\n", $seealso );
	}@es;

	$doc =~ s-\\link\s+((?:(?:\w+)\s+)*[\*\&]?\s*)(\w+)::(\w+)\s*\((.*?)\)(?:\s*(const))?\s+(.+?)\s*\\endlink-
	{
#print $1, " ", $2, " ", $3, " (", $4, ") ", $5, " <=> ", $6, "\n";
	    $string = $6;
	    $tryagain = $&;
	    $_ = &manglefn( $1, $2, $3, $4, $5);
	    if ($type{$_} eq "fn") {
		sprintf("<a href=%s>%s</a>", $_, $string);
	    } else {
		sprintf("%s", $tryagain);
	    }
	}
	-egsx;

	$doc =~ s-\\link\s+([\w:\.]+)(?:[\(\)]*)\s*(.*?)\s*\\endlink-
	    if (defined($anchor{$1})) {
		sprintf("<a href=%s>%s</a>", $anchor{$1}, &html($2));
	    } else {
		if (defined($anchor{$class . $1})) {
		    sprintf("<a href=%s>%s</a>", 
			    $anchor{$class . $1}, &html($2));
		} else {
		    print "No link to '", $1, "' for '", $2, "'\n";
		    sprintf("%s", $2);
		}
	    }
	-egsx;

	$doc .= "<p>Returns: " . $1
	    if ($doc =~ s/\s*\\returns?\s+(.*?)
		(?:(?:\n\s*?\n\s*)|(?:$ ))/\n\n/sx);

	if ($doc =~ /\s+\\arg\s+/s) {
	    $doc =~ s-\s+\\arg\s+-
		\n\nArguments:\n<ul>\n<li>-sx;
	    $doc =~ s-\s+\\arg\s+(.*?)(?=\s+\\arg\s+)-\n<li>$1-gs;
	    $doc =~ s-\s+\\arg\s+(.*?)
		(?:(?:\n\s*?\n)|(?:$ ))-\n<li>$1\n</ul>\n-sx;
	}

	$_ = "<p>To do:\n<ul>\n";
	$_ .= "<li>" . $1 . "\n"
	    while ($doc =~ s/\s*\\todo\s+(.*?)
		   (?:(?:\n\s*?\n\s*)|(?=\\todo\s)|(?:$ ))/\n\n/sx);
	$_ .= "</ul>\n";
	$doc .= $_ if (/<li>/s);

	$_ = "<p>Bugs and limitations:\n<ul>\n";
	$_ .= "<li>" . $1 . "\n" 
	    while ($doc =~ s/\s*\\bug\s+(.*?)
		   (?:(?:\n\s*?\n\s*)|(?:$ ))/\n\n/sx);
	$_ .= "</ul>\n";
	$doc .= $_ if (/<li>/s);

	$doc =~ s-\\internal\s-<p>Internal comments:<p>\n-s;

	$doc =~ s!\\code\b(.*?)\\endcode!&processcode($1)!esg;

	$doc =~ s!\\e\s+(\S+)!<em>$1</em>!gs;
	$doc =~ s!\\c\s+(\S+)!<code>$1</code>!gs;

	$doc =~ s/\.?\s*$/.\n/s;
	$doc =~ s/^\s*\n//s;
	$doc =~ s/>\.\n$/>\n/s;

	$doc =~ s-\s*\n\s*\n(?:\s|(?:<p>))*-\n<p>-gs;
	$doc =~ s-^(?:<p>)+--s;
	$doc =~ s/<linebreak>//gs;

	undef %word;
	$_ = $class;
	s/:://;
	$word{$_}++;

	$doc =~ s-(?:(?:\b((?:(?:operator[^\s\(]{1,3})
			    |(?:[\w:]+(?:\.(?:h)|(?:cpp))?)))(\()?(?!</a>))
		   |((?:(?:<pre>.*?</pre>)|(?:<a [^>]+>[^<]*</a>)|(?:<.*?>))))-
	    if ($3 eq "") {
		if (!defined($word{$1})) {
		    if ($1 eq "magicwordthatyoushouldavoid") {
			undef %word;
			sprintf("See also: ");
		    } else {
			my ($tmp);
			$tmp = &findlink($1, $class, $url, $2);
			$word{$1}++ if ($tmp ne $1);
			sprintf("%s%s", $tmp, $2);
		    }
		} else {
		    sprintf("%s%s", $1, $2);
		}
	    } else {
		sprintf("%s", $3);
	    }
	-egsx;

	$doc =~ s@(?:(?:(<pre>.*?</pre>)\n?)|(?:\n *))@$1\n@gs;

	$doc =~ s@</em>\s+<em>@ @gs;
	$doc =~ s@</code>\s+<code>@ @gs;
	$doc =~ s@</strong>\s+<strong>@ @gs;

	$brief{$url} = $1
	    if ($doc =~ s/\s*\\brief\s+(.*?)(?:(?:\n<p>\s*)|(?:$))//s);

	$brief{$url} =~ s/\s*\n\s*/ /g;

	if ((defined($brief{$url})) && !(defined($capt{$url})) &&
	    ($type{$url} eq "class" )) {
	    $capt{$url} = $brief{$url};
	    $capt{$url} =~ s/^the\s+\w+\s+(?:(?:class)|(?:widget))\s+(?:(?:is)|(?:provides)|(?:contains)|(?:specifies))?\s*(?:\ban?\b)?\s*//si;
	    $capt{$url} =~ s/\.\s*$//s;
	    $capt{$url} = ucfirst $capt{$url};
	}

	$doc{$url} = $doc;
    }
}



sub writepages {
    local($doc, $p, $e, $f);

    foreach $file ( keys %pages ) {
	$doc = $pages{$file};
	$doc =~ s-\\link\s+([\w:\.]+)(?:[\(\)]*)\s*(.*?)\s*\\endlink-
	    if (defined($anchor{$1})) {
		sprintf("<a href=%s>%s</a>", $anchor{$1}, $2);
	    } else {
		print "No link to '", $1, "' for '", $2, "'\n";
		sprintf("%s", $2);
	    }
	-egsx;

	$doc =~ s-\\internal\s-<p>Internal comments:<p>\n-s;

	$doc =~ s!\\code\b(.*?)\\endcode!&processcode($1)!esg;

	$doc =~ s!\\e\s+(\S+)!<em>$1</em>!gs;
	$doc =~ s!\\c\s+(\S+)!<code>$1</code>!gs;

	$doc =~ s/\n\s*\n/\n<p>\n/gs;
	$doc =~ s/<linebreak>//gs;
	$doc =~ s/<p>\s*<p>/<p>/gs;

	open(O, "> $outputdir/$file") ||
	    die "can't open $outputdir/$file";
	print O $doctype, "<html><head>", $doc, "\n";
	if (defined($classes{$file})) {
	    $p = "<p>Classes:<ul plain>\n";
	    $e = "";
	    foreach ( sort split(/:+/, $classes{$file}) ) {
		if (defined($anchor{$_})) {
		    print O $p, "<li><a href=", $anchor{$_}, ">", $_, "</a>\n";
		    $p = "";
		    print O "    (", $capt{$anchor{$_}}, ")\n" 
			if (defined($capt{$anchor{$_}}));
		    $e = "</ul>\n";
		} else {
		    print "no such group: ", $_, "\n";
		}
	    }
	    print O $e;
	}
	print O $address;
	close(O);
    }
}



sub mangleclass {
    local($class) = @_;

    $class =~ s/[:\s].*//;
    $class =~ tr/A-Z/a-z/;
    $class = "globals" if ($class eq "");
    $class .= ".html";

    die "produced null url" if ($class eq "");

    $class;
}



#
# now, now
#
# %urls is the list of url's, indexed by mangled function
#
# $uniq is just an unique number, starts at 0
#
sub manglefn {
    local($type, $class, $name, $sig, $const, $home) = @_;
    local($url, $d);

    $type =~ s/\s+/-/g;
    $type =~ s/^-*(.*?)-*$/$1/;
    $type =~ s/-*([\*\&])-*/$1/g;
    $type =~ s/^-?virtual-?//;
    $type = "-" . $type if ($type ne "");
    $const = "-" . $const if ($const ne "");
    $url = $class . "::" . $name;
    $sig =~ s/\(.*?\)//gs;
    $d = "(";
    foreach (split(/\s*,\s*/, $sig)) {
# kill argument name
	s/\s*=.*//s;
	if ( !(s/([\&\*]).*/$1/) && (/((?:\w+\s+)*?)\s*([\w<>]*)\s+(\w+)$/s)) {
	    if (($2 ne "class") && ($2 ne "enum") && ($2 ne "union") &&
		($2 ne "struct") && ($2 ne "const") && ($2 ne "volatile") &&
		($3 ne "int") && ($3 ne "float") && ($3 ne "char") &&
		($3 ne "short") && ($3 ne "long") && ($3 ne "unsigned") &&
		($3 ne "signed") && ($2 ne "")) {
		s/\s*\w+$//;
	    }
	}
# strip spaces around & and *
	s/\s*([\*\&])\s*/$1/;
# kill default and change spaces into -
	s/=.*//g;
	s/\s+/-/g;
	s/-+$//;
	s/^-+//;
# finally add it to the url
	$url = join($d, $url, $_);
	$d = ",";
    }
    if ($d eq ",") {
	$url .= ")" . $type . $const;
    } else {
	$url .= "()" . $type . $const;
    }

    unless (defined($urls{$url})) {
	$home = &mangleclass($class) unless ($home =~ /\S/);
	$urls{ $url } = join("", $home, "#", ++$uniq);
    }

    $url = $urls{$url}; #cool!
}




sub storeclass {
    local($filename, $sig, $def) = @_;
    local($url, $name, $inh, $enum);

    ($name, $inh) = split(/\s*:\s*/, $sig);

    $url = &mangleclass($sig);
    $type{$url} = "class";
    $name{$url} = $name;

    $inheritance{$url} = $inh if (defined($inh) && $inh ne "");

    $def =~ s/\s+/ /g;
    $def =~ s/Q_OBJECT//;
    $def =~ s/(\)\s*(?:const\s*)?)\{.*?\}/$1;/gs;
    $def =~ s/struct[^\;\{]*\{.*?\}\s*\w*\s*\;\s*//gs;
    $def =~ s/;\s*$//s;

    while ($def =~ /(?:\b|^)enum\s+(\w+)\b/gs) {
	$enum = $url . "#" . $1;
	$type{$enum} = "enum";
	$name{$enum} = $name . "::" . $1;
	$anchor{$name{$enum}} = $enum unless (defined($anchor{$name{$enum}}));
    }

    $def =~ s/\)\s*\{.*?\}\s*/\);\n/gs;
    $members{$url} = $def;
}




sub getfile {
    local($filename) = @_;
    local($ifdef, @defines);

    open(F, "expand < $filename |") || die "can't open $filename for reading";
    $ifdef = 0;
    while(<F>) {
	$dates{$1} = $2 if (/\$Id\:\s+(.*?),v\s+[0-9\.]+\s+(\S+)\s/);
	if ( /^#if/ ) {
	    push @defines, $ifdef;
	    $ifdef = 1 if ( !/_H$/ && !/\bUSE_TEMPLATECLASS\)?$/ );
	}
	push @_,$_ unless ($ifdef);
	$ifdef = pop @defines if ( /^\#endif\b/ );
    }
    close(F);
    join("", @_);
}



sub readfiles {
    local($/, $_, $h, $w, $filename, $htmlfilename);

    undef $/;
    foreach $filename ( keys %headerfiles ) {
	if (defined($hdir)) {
	    $_ = $hdir . "/" . $filename;
	} else {
	    $_ = $filename;
	}
	open(F, "expand < $_ |") || die "can't open $_ for reading";
	$_ = $filename;
	s/\./-/;
	s/$/.html/;
	open(H, "> $outputdir/$_") 
	    || die "can't open $outputdir/$_ for writing";
	$h = <F>;
	close(F);
	$h = &html($h);
	$h =~ s@\nclass\s+\w+(?:\s*:(\s*(?:public\s+)?\w+\s*,?)*)?@
	    $_ = "";
	    foreach $w (split(/\b/, $&)) {
		if (defined($anchor{$w})) {
		    $_ = join("", $_, "<a href=", $anchor{$w}, ">", $w, "</a>");
		} else {
		    $_ = join("", $_, $w);
		}
	    }
	    $_;
	@egsx;
	$h =~ s@(\n#include\s+[\<\x22])([\w\.]+)([\>\x22])@
	    if (defined($headerfiles{$2})) {
		sprintf("%s<a href=%s>%s</a>%s", $1, $headerfiles{$2}, $2, $3);
	    } else {
		sprintf("%s%s%s", $1, $2, $3);
	    }
	@egsx;
	print H $doctype, "
<html><head><title>
Qt Toolkit - ", $filename, " include file
</title></head><body>
<p>This is the verbatim text of the ", $filename," include file.  It is is
provided only for illustration; the <a href=license.html>copyright</a>
remains with Troll Tech.
<hr>
<pre>
", $h, "\n</pre>\n", $address;
	close H;
     }

    foreach $filename ( keys %examples ) {
	my (%a, $a);

	open(F, "expand < /local/qt/examples/$filename |")
	    || die "can't open $filename for reading";
	$htmlfilename = $filename;
	$htmlfilename =~ s@.*/@@;
	$htmlfilename =~ s/\.cpp/-cpp.html/;
	open(H, "> $outputdir/$htmlfilename") 
	    || die "can't open $outputdir/$htmlfilename for writing";
	$h = <F>;
	close F;
	$h = &processcode($h);
	$h =~ s/<linebreak>//gs;

	while ( $h =~ m@<a href=(.*?)>(.*?)</a>@gs ) {
	    $a{$1} = $2;
	}

	foreach ( keys %a ) {
	    $a = $a{$_};
	    $doc{$_} .= "<p>Examples:\n" unless ($doc{$_} =~ /\bExamples:\s/);
	    $doc{$_} .= " <a href=$htmlfilename>$filename</a>\n";
	    $doc{$_} =~ s/<a href=$htmlfilename>/<a href=$htmlfilename\#$a>/gs;
	}
	foreach ( keys %a ) {
	    $a = $a{$_};
	    $h =~ s@<a href=$_>@<a name=$a></a><a href=$_>@s;
	}

	$h =~ s@(\n#include\s+\&lt;)([\w\.]+)(\&gt;)@
	    if (defined($headerfiles{$2})) {
		sprintf("%s<a href=%s>%s</a>%s", $1, $headerfiles{$2}, $2, $3);
	    } else {
		sprintf("%s%s%s", $1, $2, $3);
	    }
	@egsx;
	print H $doctype, "
<html><head><title>
Qt Toolkit - ", $filename, " example file
</title></head><body>

The example program on this page may be used, distributed and modified
without limitation.

", $examples{$filename}, "
<hr>
", $h, $address;
	close H;
    }
}



sub readh {
    local ($filename) = @_;

    if (defined($hdir)) {
	$h = getfile($hdir . "/" . $filename);
    } else {
	$h = getfile($filename);
    }
    print "header file: ", $filename, "\n" if ($debug);

    $h =~ s-(?:(?:(/\*.*?\*/))|(?://[^\n]*))-$1-gs;

# { is \x7b and } is \x7d
    while ($h =~ m-\n(?:template\s*<\s*class\s+(.+?)\s*>\s*)?
	   class\s+([^\n]*?)\s+
	   \x7b\s+(.*?)\n\x7d-xsg
	   ) {
	if ( $1 eq "" ) {
	    &storeclass($filename, $2, $3);
	} else {
	    my ($sig, $def, $cookie);
	    $cookie = $1;
	    $sig = $2;
	    $def = $3;
	    $sig =~ s/^(\w+)T\b/$1/s;
	    $_ = $sig;
	    s/[:\s].*//;
	    $def =~ s/\b$_(?:)T\b/$_/gs;
	    $templatecookie{&mangleclass($sig)} = $cookie;
	    &storeclass( $filename, $sig, $def );
	}
    }

    while ($h =~ /\bdeclare\s*\(\s*(\S+?)\s*,\s*(\S+?)\s*\)\s*;
	   \s+\#define\s+(\S+)\s+(\S+)\s*\(\s*(\S+)\s*\)\s/gsx ) {
	   next if ( ($1 ne $4) || ($2 ne $5) );
	   $declared{$3} = $1 . " " . $2 . " " . $filename;
	   #print $3, " -> ", $declared{$3}, "\n";
       }

    while ($h =~ /\bdeclare\s*\(\s*(\S+?)\s*,\s*(\S+?)\s*\)\s*;
	   \s+\typedef\s+(\S+)\s*\(\s*(\S+)\s*\)\s+(\S+)\s;/gsx ) {
	   next if ( ($1 ne $3) || ($2 ne $4) );
	   $declared{$5} = $1 . " " . $2 . " " . $filename;
       }
    
    $headerfiles{$filename} = $filename;
    $headerfiles{$filename} =~ s/\./-/;
    $headerfiles{$filename} =~ s/$/.html/;
}



sub templates {
    local ($url, $_, $n, $t, $f, $i, $c, $m, $mm, $url);

    foreach $n ( sort keys %declared ) {
	($t, $i, $f) = split(/\s+/, $declared{$n});
	$t =~ s/M$//; # oh no... oh well
	$url = &mangleclass($t);
	if (defined($templatecookie{$url}) && defined($members{$url})) {
	    $c = $templatecookie{$url};
	    $_ = $members{$url};
	    s/\b$t\s*<\s*$c\s*>/$n/gs;
	    s/\b$t(\s*\()/$n$1/gs;
	    s/\b$c\b/$i/gs;
#print "making up ", $n, " in ", $f, " from ", $t, "<", $c, ">:\n", $_, "\n";
	    &storeclass( $f, $n, $_ );
	    # This is O(toomany) but was easy to write
	    foreach $m ( keys %name ) {
		# icky hack here, :. should be :: but perl5 doesn't like that
		if (($name{$m} =~ /^$t:/s) && ($type{$m} eq "fn") ) {
		    $mm = $name{$m};
		    $mm =~ s/.*:+//;
		    if ( $mm eq $t ) {
			$mm = $n;
		    } elsif ( $mm eq "~".$t ) {
			$mm = "~".$n;
		    }
		    unless ( defined( $type{$n . "::" . $mm } ) ) {
#print "B: ", $name{$m}, "-> ", $n, "::", $mm, "\n";
			# okie, now set $url to the new url and copy it across
#			$u = &manglefn($t, $name{$url}, $f, $a, $c);
#			$url = &mangleclass($n) . "#" . ++$uniq;
			if ( $mm eq "_cast" ) {
			    my ($type, $const);
			    if ( $def{$m} =~ /\s+operator\s+(.*?)\s*\(\)\s*((?:const)?)$/ ) {
				$type = $1;
				$const = $2;
				$url = &manglefn($type, $n, $mm,"",
						 $const, &mangleclass($n));
			    } else {
				die "unparsable definition: ", $n, "::", $mm,
				" cannot be instantiated from ", $def{$m};
			    }
			} else {
			    my ($type, $args, $const);
			    if ( $def{$m} =~ /^\s(.*?)\b\s*[A-Za-z_]+::[A-Za-z_]+\s*\(\s*(.*?)\s*\)\s*((?:const)?)$/ ) {
				$type = $1;
				$class = $2;
				$args = $3;
				$const = $4;
				$url = &manglefn($type, $n, $mm, $args,
						 $const, &mangleclass($n));
			    } else {
				die "unparsable definition: ", $n, "::", $mm,
				"cannot be instantiated from ", $def{$m};
			    }
			}
#print "C: ", $m, " -> ", $url, "\n";
			$def{$url} = $def{$m};
			$def{$url} =~ s/\b$t\b/$n/g;
			$name{$url} = $n . "::" . $mm;
			$doc{$url} = $doc{$m};
			$overload{$url} = $overload{$m};
			$type{$url} = "fn";
#print "D: def: ", $def{$url}, " name: ", $name{$url}, "\n";
		    }
		}
	    }
	} else {
	    print "declared $n as $t<$i> but $t is unknown\n";
	}
    }
}


sub readc {
    local ($filename) = @_;
    local ($overload);

    $c = getfile($filename);
    print "code file: ", $filename, "\n" if ($debug);

    $c =~ s-(?:(?:(/\*.*?\*/))|(?://[^\n]*))-$1-gs;

    while ($c =~ m@
	   (?:/\*[-\!][-\s]*
	    ((?:[^\*]|(?:\*[^/]))*?)
	    -*\*/)\s*
	   (?:([A-Za-z_](?:[^\{;\*]|(?:\*[^/]))+)\s*\x7b)?@gsx) {
	my ($doc, $def, $type, $class, $name, $args, $const, $skip);
	$skip = 0;

	$doc = $1;
	$def = $2;

	if ($doc =~ m@^\\class\s+(\w+)\s+([\.\w]+)\s+(.*?)\s*$@s) {
	    # it's a \class
	    my ($class, $hfile, $doc);
	    my ($url);
	    $class = $1;
	    $hfile = $2;
	    $doc = $3;
	    if (!defined($cfiles{$hfile})) {
		readh($hfile);
	    }
	    $filename =~ s-^.*/--;
	    $cfiles{$hfile} .= " " . $filename;
	    $url = &mangleclass($class);
	    print $class, " not in ", $hfile, "\n" 
		unless (defined($members{$url}) || defined($declared{$class}));
	    $doc{$url} = $doc;
	    $includefile{$url} = $hfile;
	    $includefile{$url} =~ s/\.doc/.h/;
	} elsif ($doc =~ m@^\\defgroup\s+([\w\.]+)\s+(.*?)\s*$@s) {
	    # it's a \defgroup
	    $pages{$1} = 
		"<title>Qt toolkit - group index</title></head><body>\n"
		    . $2;
	    $classes{$1} = "";
	} elsif ($doc =~ m@^\\page\s+([\w\.]+)\s+(.*?)\s*$@s) {
            # it's a \page
	    $pages{$1} = $2;
	    $anchor{$1} = $1;
	} elsif ($doc =~ m@^\\example\s+([\w\./]+)\s+(.*?)\s*$@s) {
	    # it's an example file
	    $examples{$1} = $2;
	} else {
	    # it's a function, \fn or real?
	    print "";
	    $overload = 0; # defeat too-cool switch optimizer
	    if ($doc =~ /^\\overload\s+([^;\n]+);?\s+(.*?)\s*$/s) {
		$def = $1;
		$doc = "This is an overloaded member function, provided for convenience.  It differs from the above function only in what argument(s) it takes.\n\n" . $2;
		$overload = 1;
	    } elsif ($doc =~ /^\\fn\s+([^;\n]+);?\s+(.*?)\s*$/s) {
		$def = $1;
		$doc = $2;
	    }
	    ($name, $args) = split(/\s*\(\s*/, $def);
	    if ($name =~ /^\s*(.*?[ \*\&])\s*((?:\w+::)?)(\w+[^\(\s\w]{0,3})$/s) {
		$type = $1;
		$class = $2;
		$name = $3;
		$class =~ s/:://;
		$type =~ s/^\s+//;
		$type =~ s/\s+$//;
	    } elsif ($name =~ /^\s*(?:virtual\s+)?(\w+)\s*::\s*(\~?\w+)$/s) {
		$type = "";
		$class = $1;
		$name = $2;
	    } elsif ($name =~ /^\s*(\w+)\s*::operator\s*([\s\w\*\&]+)$/s) {
		$type = $2;
		$class = $1;
		$name = "_cast";
	    } else {
		print "skipped: ", $filename, ": ", $def, "\n", $doc, "\n";
		$skip = 1;
	    }
	    $args =~ s/([^:]):[^:].*/$1/s;
	    if ($args =~ /^(.*?)\s*\)\s*((?:const)?)\s*?$/s) {
		$args = $1;
		$const = $2;
	    } else {
		$skip = 1;
	    }

	    if (($skip == 0)) {
		if (!($type =~ /\bstatic\b/)) {
		    if ($args =~ /[()]/) {
			print STDERR "function prototype in argument\n", $def;
		    } else {
			my ($url, $home);

			if ($doc =~ /\\relate[ds]\s+(\w+)/s) {
			    $home = &mangleclass($1);
			} else {
			    $home = &mangleclass($class);
			}
			$url = &manglefn($type, $class, $name, 
					 $args, $const, $home);
			if (defined($name{$url})) {
			    print "$filename: $def documented twice\n";
			} else {
			    $name{$url} = $class . "::" . $name;
			    $type{$url} = "fn";
			    $doc{$url} = $doc;
			    $overload{$url} = 1 if ($overload);
			    $class .= "::" if ($class ne "");
			    $const = " " . const if ($const ne "");
			    if ($name eq "_cast") {
				$def{$url} = join("", $class, "operator ", 
						  $type, " ()", $const);
			    } else {
				$args =~ s/\s\s+/ /gs;
				$def{$url} = join("", $type, " ", $class,
						  $name, "(", $args, ")",
						  $const);
			    }
#			    print "url: ", $url, " is ", $def{$url}, "\n";
			}
		    }
		}
	    }
	}
    }
}

sub makenames {
    local($_, $dum, %total);

    foreach ( sort keys %name ) {
	$anchor{$name{$_}} = $_ unless 
	    (defined($anchor{$name{$_}}) ||
	     defined($overload{$_}) ||
	     ($doc{$_} =~ /^\s$/s));
    }

    # next, we do a good imitation of c++ inheritance... subclasses:
    foreach ( keys %inheritance ) {
	my ($c, $i);
	$i = $inheritance{$_};
	$i =~ s/((?:(?:^)|(?:,)))\s*\w+\s+(?=\w)/$1/sg;
	foreach $c ( split ( /\s*,\s*/, $i ) ) {
	    if (defined($subclasses{$c})) {
		$subclasses{$c} .= " " . $name{$_};
	    } else {
		$subclasses{$c} = $name{$_};
	    }
	}
    } # and members
    $dum = 1;
    while ($dum) {
	my ($url, $class, $member);
	$dum = 0;
	foreach ( keys %anchor ) {
	    next unless (($type{$anchor{$_}} eq "fn") || 
			 ($type{$anchor{$_}} eq "enum"));
	    $url = $anchor{$_};
	    $class = $_;
	    $member = $_;
	    $class =~ s/::.*//;
	    $member =~ s/.*:://;
	    next if (($member eq $class) || (("~" . $class) eq $member));
	    foreach ( split( /\s+/, $subclasses{$class} ) ) {
		unless (defined($anchor{$_ . "::" . $member})) {
		    $dum = 1;
		    $anchor{$_ . "::" . $member} = $url;
#print $_, " inherited ", $member, " from ", $class, "\n";
		}
	    }
	}
    }

    foreach ( keys %headerfiles ) {
	$anchor{$_} = $headerfiles{$_} unless (defined($anchor{$_}));
    }

    foreach ( keys %examples ) {
	next if (defined($anchor{$_}));
	$dum = $_;
	s@.*/@@;
	s/\.cpp$/-cpp.html/;
	$anchor{$_} = $dum;
    }

#   foreach ( sort keys %anchor ) { print $_, ": ", $anchor{$_}, "\n"; }
}

#
# add links and escapes to a string
#
sub al {
    local ($_, $class) = @_;

    s-[\w:]+-
	if (defined($anchor{$class . "::" . $&}) &&
	    $type{$anchor{$class."::".$&}} ne "fn") {
	    sprintf("<a href=%s>%s</a>", $anchor{$class."::".$&}, &html($&));
	} elsif (defined($anchor{$&}) &&
		 $type{$anchor{$&}}) {
	    sprintf("<a href=%s>%s</a>", $anchor{$&}, &html($&));
	} else {
	    &html($&);
	}
    -egs;
    $_;
}

#
# add <a href> to args where appropriate and html-encode
#
sub makearglinks {
    local($_, $pre, $name, $post, $class, $anchor);

    foreach (sort keys %type) {
	if ($type{$_} eq "fn" &&
	    $def{$_} =~ /^([^\~\(:]*)\s+
	    ((?:\w+::)?(?:(?:operator[^\(\s]{1,3})|(?:(?:\~?\w+))))\s*
	    (\(.*)/sx) {
	    $pre = $1;
	    $name = $2;
	    $post = $3;
	    if (defined($home{$_})) {
		$class = $home{$_};
	    } else {
		$class = $name;
		$class =~ s/::.*//;
	    }
	    if (defined($anchor{$class})) {
		$anchor = $anchor{$class};
		undef $anchor{$class};
		$def{$_} = join(" ", &al($pre, $class), &html($name), 
				&al($post, $class));
		$anchor{$class} = $anchor;
	    } else {
		$def{$_} = join(" ", &al($pre, $class), &html($name), 
				&al($post, $class));
	    }
	}
    }
}




#
# add default values to arguments, from .h argument list
#
# note that argument names aren't touched, just default values
sub fixdefvalues {
    local ($url, $args) = @_;
    local (@ha, @ca, $_, $changed);

    if (defined($def{$url})) {
	@ha = split(/\,/, $args);
	$_ = $def{$url};
	s/.*\(//s;
	s/\).*//s;
	@ca = split(/\,/, $_);
	die ("argument mismatch:\n" . $args . "\n" . $_ . "\n")
	    if ($#ha != $#ca);

	$changed = 0;
	foreach ( 0 .. $#ha ) {
	    if ( $ha[$_] =~ /\s*=.*$/ ) {
		$ca[$_] .= $&;
		$changed++;
	    }
	}
	if ($changed > 0) {
#print "changed ", $def{$url};
	    $_ = join(",", @ca);
	    $def{$url} =~ s/\(.*?\)/($_)/s;
#print " to ", $def{$url}, "\n";
	} else {
#print "unchanged: ", $def{$url}, "\n";
	}
    }
}


#
# allow word breaks only after commas
# does not work (html)
#
sub clever {
    local ($in) = @_;

    $in =~ s/\s+/&nbsp;/g;
    $in =~ s/,&nbsp;/, /g;
    $in;
}




#
# as in 'sort weirdly keys %type'
#
sub weirdly {
    local ($aa, $bb);

    $aa = $name{$a};
    $aa =~ s/::~/::_/;
    $bb = $name{$b};
    $bb =~ s/::~/::_/;
    if ($aa eq $bb) {
	if (defined($overload{$b})) {
	    if (defined($overload{$a})) {
		return ($def{$a} cmp $def{$b});
	    } else {
		return (-1);
	    }
	} else {
	    if (defined($overload{$a})) {
		return (1);
	    } else {
		return ($def{$a} cmp $def{$b});
	    }
	}
    } else {
	return ($aa cmp $bb);
    }
}


sub printclass {
    local ( $url ) = @_;
    local ( $class, $file, $tail, $fnheader, $fntail, %fndocs );

    $class = $name{$url};

#print "0: ", $class, "\n";

    if (!$internal && ($doc{$url} =~ /^\s*$/)) {
	print "skipping internal class ", $class, "\n";
	next;
    }

    die "$class ($url) is not a class" if ( $type{$url} ne "class" );

    $file = $url;
    $file =~ s/#.*//;
    open(O, "> $outputdir/$file") 
		|| die "can't open $outputdir/$file for writing,";

    $documented{$url}++;

    $fnheader = "<hr><h2>Member Function Documentation</h2>\n";
    $tail = "<hr><p>\nThis file is part of the <a href=qt.html>Qt toolkit</a>,\n<a href=license.html>copyright &copy;</a> 1995\n<a href=troll.html>Troll Tech</a>, all rights reserved.\n";
    if (defined ($cfiles{$includefile{$url}})) {
	my(%files);
	$files{$includefile{$url}}++;
	$tail = join("\n", $tail,
		     "<p>",
		     "It was generated from the following files:",
		     "<ul>",
		     "<li>" . $includefile{$url} .
		     (defined($dates{$includefile{$url}}) ? 
		      (": " . $dates{$includefile{$url}}) :
		      ("")),
		     "");
	foreach (sort split(/\s+/, $cfiles{$includefile{$url}})) {
	    if ($_ ne "" && !defined($files{$_})) {
		$files{$_}++;
		if (defined($dates{$_})) {
		    $tail = join("", $tail, "<li>", $_, ": ", $dates{$_}, "\n");
		} else {
		    $tail = join("", $tail, "<li>", $_);
		}
	    }
	}
	$tail .= "</ul>\n";
    }
    $tail .= $address;

    print O $doctype, "<html><head>\n<title>Qt Toolkit - ", 
    $class, 
    " Class</title>\n</head><body>\n",
    "<h1>", $name{$url}, " Class Reference</h1>\n<hr>\n";

    my ($i, $family);
    if (defined($brief{$url})) {
	print O "<p>\n", $brief{$url}, "\n";
	print O "<a href=#details>(details)</a>\n"
	    if ($doc{$url} ne "");
	$_ = $file;
	s/\.html/-members.html/;
	print O "<a href=", $_, ">", " (complete member list)</a>\n";
    }
    print O "<p>\n<code>#include &lt;<a href=", $headerfiles{$includefile{$url}}, ">", $includefile{$url}, "</a>&gt;</code>\n" if (defined($includefile{$url}));
    if ($relations{$name{$url}} =~ /\S/s) {
	my($relatives, $name, $header);
	$relatives = "<hr><p><h2>Related Functions</h2>\n";
	$family = "<h2>Related Functions</h2>\n(Note that these are not member functions.)\n<ul>";
	foreach ( split( /\s+/, $relations{$name{$url}} ) ) {
	    $name = $_;
	    $documented{$_}++;
	    $name =~ s/^[^\#]*\#//;
	    $header = $def{$_};
	    $header =~ s;([^\(]*\s)\b(\S+);$1<a name=$name>$2</a>;s;
	    $relatives = join ("", $relatives, "<p><h3>", $header,
			       "</h3>\n<p>", $doc{$_}, "\n");
	    $header = $def{$_};
	    $header =~ s@</?a.*?>@@gs; #okok, so it is stupid
	    $header =~ 
		s;([^\(]*\s)\b(\S+);$1<a href=$url#$name><strong>$2</strong></a>;s;
	    $family = join( "\n<li>", $family, $header);
	}
	$tail = join("", $relatives, $tail);
	$family = join ("", $family, "\n</ul>\n");
    }

    $i = "";
    foreach ( sort split(/\s*\,\s*/, $inheritance{$url}) ) {
	my ($im, $ic);
	if (/(\w+)\s+(\w+)/) {
	    $im = $1;
	    $ic = $2;
	} else {
	    $ic = $_;
	    $im = "public";
	}
	if (($ic ne "") && ($im eq "public")) {
	    if (defined($capt{$ic})) {
		$i = join ("", $i, ", ", &al($ic), " (", $capt{$ic}, ")");
	    } else {
		$i = join ("", $i, ", ", &al($ic));
	    }
	}
    }
    if ($i ne "") {
	$i =~ s/^\,\s*//;
	$i =~ s/\,([^,]+)$/ and$1/;
	print O "<p>\nInherits ", $i, ".\n";
    }

    if ($subclasses{$name{$url}} =~ /\S/) {
	my ($ic);
	$i = "";
	foreach $ic ( sort split(/\s+/, $subclasses{$name{$url}}) ) {
	    if (defined($capt{$ic})) {
		$i = join ("", $i, ", ", &al($ic), " (", $capt{$ic}, ")");
	    } else {
		$i = join ("", $i, ", ", &al($ic));
	    }
	}
	$i =~ s/^\,\s*//;
	$i =~ s/\,([^,]+)$/ and$1/;
	print O "<p>Inherited by ", $i, ".\n";
    }

    die "no members in class $class" unless (defined($members{$url}));

    my (%m, $mode, $foreplay, $afterglow);
    undef %m;
    $mode = "Private";
    foreach (split(/;/, $members{$url})) {
	$mode = ucfirst($1)
	    while (s/^\s*((?:
			   (?:private\b\s*?)|
			   (?:protected\b\s*?)|
			   (?:public\b\s*?)|
			   (?:signals\b\s*?)|
			   (?:slots\b\s*?))+):\s*//sx);
	next if (/^\s*friend\b/);
	$mode =~ s/slots/Slots/;
	if (/((^)|([^\(]*\b))static\b/) {
	    s/(\s*)static\s*/$1/;
	    $m{"Static ".$mode} .= $_ . ";";
	} else {
	    $m{$mode} .= $_ . ";";
	}
    }
    foreach $mode ('Public', 'Public Slots', 'Signals',
		   'Static Public', 'Protected', 
		   'Protected Slots', 'Static Protected',
		   'Private', 'Private Slots', 'Static Private') {
	my ($e1, $e2);
	next unless (defined($m{$mode}));
	$_ = $mode;
	$_ .= " Members" if (!/s$/);
	$foreplay = join("", "<h2>", $_, "</h2>\n<ul>\n");
	$afterglow = "";
	foreach (split (/;/, $m{$mode})) {
	    next if ($mode =~ /rivate/ && !$internal);

	    $countall++;

	    s/\s*([\(\)]+\s*)/ $1 /g;
	    s/\s*([,\*\&]+\s*(?!=))/$1 /g;
	    s-\s*//.*?\n\s*--;
	    s/^\s+//;
	    s/\s+$//;
	    s/\s+/ /g;
	    s/\)\s*:\s*[A-Q].*/\)/;
	    if (/^\s*((?:[^\(\~]*[\s\&\*]+)?)(?=[\w~]) (?# prelude
							)
		((?:(?:operator[^\(\s]{1,3})|(?:\~?\w+))) (?# name
							   )
		\s*\((.*?)\)\s*(const)?\s*$/x) {
		my ($u,$t,$mt,$f,$a,$ma,$c);
		$t = $1;
		$f = $2;
		$a = $3;
		$c = $4;

		$a =~ s/^\s+//s;
		$a =~ s/\s+$//s;

		$u = &manglefn($t, $name{$url}, $f, $a, $c);
#print "1: $u\n";
		&fixdefvalues($u, $a) if ($type{$u} eq "fn");
		if ($type{$u} eq "fn") {
		    $_ = join("", &html($t), "<a href=", $u,
			      "><strong>", &html($f), 
			      "</strong></a> (", &html($a), 
			      ") ", $c);
		    $fndocs{$u} = $mode;
		} else {
		    print "undocumented: ", $t," ", $name{$url}, "::", $f,
		        " (",$a,") ", $c, "\n" if ($errmsg++<$maxerr);
		    $_ = join("", &html($t), "<strong>", 
			      &html($f), "</strong> (", 
			      &html($a), ") ", $c);
		}
		$_ = join ("", $_, " - <em>", $capt{$u}, "</em>")
		    if (defined($capt{$u}));
	    } elsif (/^\s*enum\s+(\w+)/s &&
		     defined($anchor{$name{$url} . "::" . $1})) {
		my($name);
		$name = $1;
		$_ = &html($_);
		s;(\w+[^\=:\(\{]*)\b(\w+);$1<strong><a name=$name>$2</a></strong>;s;
	    } elsif (/^\s*enum\s*\{/s) {
		$_ = &html($_); # don't do anything, but it's legal
	    } elsif (/^operator\s+([\w\s\*\&]+?)\s*\(\s*\)\s*((?:const)?)\s*$/s) {
		my($u, $r, $c);
		$r = $1;
		$c = $2;
		$u = &manglefn($r, $name{$url}, 
			       "_cast", "", $c);
		if ($type{$u} eq "fn") {
		    $_ = join("", "operator <a href=", $u, "><strong>",
			      &html($r), "</strong></a> ()", $c);
		    $fndocs{$u} = $mode;
#print "2: $_\n";
		} else {
		    print "undocumented: ", $name{$url}, "::operator ", $r,
		        " () ", $c, "\n" if ($errmsg++<$maxerr);
		    $_ = join("", "operator <strong>", &html($r),
			      "</strong> ()", $c);
		}
		$_ = join ("", $_, " - <em>", $capt{$u}, "</em>")
		    if (defined($capt{$u}));
	    } else {
		$_ = "";
	    }
	    if (/\S/s) {
		print O $foreplay, "<li>", $_, "\n";
		$foreplay = "";
		$afterglow = "</ul>\n";
	    }
	}
	print O $afterglow;
    }
    if ($family =~ /\S/s) {
	print O $family;
    }

    if ($brief{$url} =~ /\S/s) {
	print O "<hr><p><h2><a name=details>Detailed Description</a></h2>\n", $brief{$url}, "\n<p>\n", $doc{$url}, "\n";
    } else {
	print O "<hr><p><h2>Detailed Description</h2>\n", $doc{$url}, "\n";
    }

    foreach $url ( sort weirdly keys %fndocs ) {
	next unless ($doc{$url} =~ /\S/s);

	$documented{$url}++;
	$countdoc++;

	my ($name, $class, $reimp, $protection);
	$class = $url;
	$class =~ s/\#.*//;
	$class = $name{$class} . "::";
	$protection = lc $fndocs{$url};
	$protection =~ s/s$//;
	$protection =~ s/\s*public\s*//;
	if ($protection ne "") {
	    $protection = " <code>[" . $protection . "]</code>";
	}
	$_ = $def{$url};
	if ( /$class/ ) {
	    $name = $url;
	    $name =~ s/^[^\#]*\#//;
	    print O $fnheader;
	    $fnheader = "";
	    $fntail = "\n";
	    s;([^\(]*\s)\b(\S+);$1<a name=$name>$2</a>;s;
	    print O "<p><h3>", $_, $protection, "</h3>\n<p>", $doc{$url};

	    $name = $name{$url};
	    $class = $name;
	    $name =~ s/.*:://;
	    $class =~ s/::.*//;
	    $reimp = "";
	    foreach $class ( sort split(/\s+/, $subclasses{$class})) {
		$_ = join("::", $class, $name);
		$reimp .= ", <a href=" . $anchor{$_} . ">" . $class . "</a>"
		    if (defined($anchor{$_}) &&
			$anchor{$_} ne $anchor{$name{$url}});
	    }
	    if ($reimp ne "") {
		$reimp =~ s/^\,\s*/<p>Reimplemented in /;
		$reimp =~ s/\,([^,]+)$/ and$1/;
		print O $reimp, ".\n";
	    }
	}
    }

    print O $fntail, $tail;
    close(O);
}


sub classindex {
    open(O, "> $outputdir/classes.html")
	|| die "can't open $outputdir/classes.html for writing";
    print O $doctype, "
<html>
<head><title>Qt Toolkit - Class List</title></head>
<body>
<h1>Semi-Complete Qt Class List</h1>
<ul compact>
";
    open(P, "> $outputdir/classes69.html")
	|| die "can't open $outputdir/classes69.html for writing";
    print P $doctype, "
<html>
<head><title>Qt Toolkit - Class List</title></head>
<body>
<h1>Annotated Qt Class Index</h1>
<p>Here are the classes that make up Qt, with brief descriptions:
<ul compact>
";
    foreach $url ( sort keys %type ) {
	if (($type{$url} eq "class") && defined($documented{$url})) {
	    print O "<li><a href=", $url, ">", $name{$url}, "</a>\n";
	    print P "<li><strong><a href=", $url, ">", $name{$url}, "</a></strong> (" 
		, $capt{$url}, ")\n" if ( $capt{$url} =~ /\S/ );
	}
    }
    print O "</ul>\n", $address;
    print P "</ul>\n", $address;
    close(O);
    close(P);
}


sub enumindex {
    open(O, "> $outputdir/enums.html")
	|| die "can't open $outputdir/enums.html for writing";
    print O $doctype, "<html><head><title>Qt toolkit, enum type indexe</title></head><body>\n<h1>Qt enum type index</h1>\n<p>Here are the enums defined in the Qt toolkit:\n<ul compact>";
    foreach $url ( sort keys %type ) {
	print O "<li><a href=", $url, ">", $name{$url}, "</a>\n"
	    if ($type{$url} eq "enum");
    }
    print O "</ul>\n", $address;
    close(O);
}



sub headerindex {
    local($filename);
    open(O, "> $outputdir/headers.html")
	|| die "can't open $outputdir/headers.html for writing";
    print O $doctype, "<html><head><title>Qt toolkit - header file index</title></head><body>\n<h1>Qt header file index</h1>\n<p>Here are the header files that make up the Qt API:\n<ul compact>";
    foreach $filename ( sort keys %headerfiles ) {
	$_ = $filename;
	s/\./-/;
	s/$/.html/;
	print O "<li><a href=", $_, ">", $filename, "</a>\n";
    }
    print O "</ul>\n", $address;

    close(O);
}



sub exampleindex {
    local($filename);
    open(O, "> $outputdir/examples.html")
	|| die "can't open $outputdir/examples.html for writing";
    print O $doctype, "<html><head><title>Qt toolkit - Example Index</title></head><body>\n<h1>Qt Example Index</h1>\n<p>Here are some of the examples that are included with Qt:\n<ul compact>";
    foreach $filename ( sort keys %examples ) {
	$_ = $filename;
	s@.*/@@;
	s/\.cpp$/-cpp.html/;
	print O "<li><a href=", $_, ">", $filename, "</a>\n";
    }
    print O 
"</ul>
<p>
These paths are relative to the examples subdirectory in the Qt
distribution. You will find Makefiles, header files and so on there.
Only the most relevant code is here.
", $address;

    close(O);
}



#
# make a semi-graphical inheritance tree
#
sub inheritanceindex {
    open(O, "> $outputdir/hierarchy.html")
	|| die "can't open $outputdir/hierarchy.html for writing";
    print O $doctype, "
<html>
<head><title>Qt Toolkit - Class Hierarchy</title></head>
<body>
<h1>Qt Class Hierarchy</h1>

<p>This inheritance list is sorted roughly, but not completely,
alphabetically.

<ul plain>
";
    foreach ( sort keys %members ) {
	&doclassinheritance( $name{$_} ) if (($type{$_} eq "class") && 
					     (defined($documented{$_})) &&
					     !($inheritance{$_} =~ /\S/s));
    }
    foreach ( sort keys %members ) {
	print "Not in hierarchy index page: ", $name{$_}, "\n"
	    if (($type{$_} eq "class") &&
		(defined($documented{$_})) &&
		!defined($classtree{$name{$_}}));
    }
    print O "</ul>", $address;
    close O;
}

sub doclassinheritance {
    local($class) = @_;
    local($_);

    if ($inheritance{$_} =~ /\S/s) {
	$_ = $inheritance{$_};
	s/,.*//s;
	s/^\s*\w+\s+//s;
	&doclassinheritance($_) unless (defined($classtree{$_}));
    }

    unless (defined($classtree{$class}) || $doc{$anchor{$class}} =~ /^\s*$/s) {
	$classtree{$class}++;
	print O "<li><a href=", $anchor{$class}, ">", $class, "</a>\n";
	if ($subclasses{$class} =~ /\S/s) {
	    print O "<ul plain>\n";
	    foreach ( sort split(/\s+/, $subclasses{$class} ) ) {
		if ($inheritance{$anchor{$_}} =~ /,.*$class/s) {
		    print O "<li><a href=", $anchor{$_}, 
			    ">", $_, "</a>\n";
		} else {
		    &doclassinheritance( $_ );
		}
	    }
	    print O "</ul>\n";
	}
    }
}


#
# make a complete list of member for each class
sub memberlists {
    local($class, $member, $file, $tail);

    $file = "/dev/null";
    open(O, "> /dev/null") || die "cant open /dev/null";
    $tail = "";
    $fntail = "";

    foreach ( sort keys %anchor ) {
	if ( $type{$anchor{$_}} eq "class" ) {
	    print O $tail;
	    $file = $anchor{$_};
	    $file =~ s/\.html/-members.html/;
	    open(O, "> $outputdir/$file")
		|| die "can't open $outputdir/$file for writing";
	    $tail = "</ul>\n" . $address;
	    print O $doctype, "
<html><head><title>
Qt toolkit - ", $_, " member list
</title></head><body>
<h1>Complete Member List for ", $_, "</h1>
<p>This is the complete list of member functions and enum types for 
<a href=", $anchor{$_}, ">", $_, "</a>, including all inherited members.

<p>

The document generator doesn't understand all the C++ inheritance and
scope rules, so this list may not be completely accurate.  It's a
problem, and we'll fix it before 1.0.

<ul>
";
	} elsif ( $type{$anchor{$_}} eq "fn" && !($_ =~ /::_cast/)) {
	    $member = $_;
	    $member =~ s/.*:://;
	    print O "<li><a href=", $anchor{$_}, ">", &html($member), "</a>\n";
	} elsif ( $type{$anchor{$_}} eq "enum" ) {
	    $member = $_;
	    $member =~ s/.*:://;
	    print O "<li>enum <a href=", $anchor{$_}, ">", &html($member), "</a>\n";
	}
    }
    print O $tail;
    close O;
}





umask 0111;
$cfile = "VOLD";
$maxerr = 20;
#$debug = 1;
if ($0 =~ /gendoc/) {
    $internal = 1;
    print "generating internal docs\n";
    $outputdir = "/tmp/qdoc";
} else {
    $internal = 0;
    $outputdir = "/local/qt/doc/html";
}

($j, $min, $hour, $mday, $mon, $year) = localtime(time);
$address = sprintf("<hr><address>\nGenerated at %02d:%02d, %4d/%02d/%02d by the <a href=mailto:www\@troll.no>webmaster</a> at <a href=http://www.troll.no/>Troll Tech</a>\n</address>\n</body></html>\n", $hour, $min, 1900+$year, 1+$mon, $mday );
$doctype = "<!doctype HTML public \"-//IETF//DTD HTML 2.0 Level 2//EN\">\n";

if ($#ARGV > -1) {
    $hdir = ".";
    foreach $arg ( 0..$#ARGV ) {
	&readc($ARGV[$arg]);
    }
} else {
    my($sources, $dirs);
    chdir($ENV{"QTDIR"} . "/src") || die "can't cd to QTDIR/src";
    $hdir = $ENV{"QTDIR"} . "/include";
    foreach $dirs ( "tools", "kernel", "widgets", "dialogs", "doc" ) {
	chdir( $dirs ) || die "can't cd to $dirs";
	open(F, "make showsources |") || die "can't make showsources";
	$sources = <F>;
	close F;
	foreach $d ( split(/\s+/, $sources) ) {
	    $_ = $d;
	    &readc( $_ );
	}
	chdir( ".." ) || die "can't cd back to QTDIR";
    }
}

&templates();
&preprocessdocs();
&makenames();
&makearglinks();
&processdocs();
&writepages();
&readfiles();

foreach $c ( keys %doc ) {
    if (($type{$c} eq "class") && ($anchor{$name{$c}} eq $c) ) {
	&printclass($c);
    }
}

if ($#ARGV > 4 || $#ARGV < 0) {
    &inheritanceindex();
    &classindex();
    &enumindex();
    &headerindex();
    &exampleindex();
    &memberlists();
}

if ( $internal ) {
    foreach $c ( keys %doc ) {
	if (!defined($documented{$c}) && ($def{$c} =~ /\S/)) {
	    $_ = $def{$c};
	    s/<.*?>//gs;
	    print "unreferenced: ", $_, "\n";
	}
    }
}

print "Documented ", $countdoc, " member functions, left out ",
    $errmsg, " undocumented member functions and ", 
    $countall-$countdoc-$errmsg, " private or non-function members\n";
