#!/usr/bin/perl
#
# $Id: //depot/qt/main/util/qdoc/qdoc#231 $
#
# this is a massive hack, written very quickly
#
# usage: qdoc base-qt-directory
#

use File::Find;
use Cwd;

sub html {
    local($_) = @_;

    s/&/&amp;/gs;
    s/</&lt;/gs;
    s/>/&gt;/gs;
    s/\$I\x64:/&\#36;Id&\#58;/gs; # protect cvs markers

    $_;
}

#
# HTMLize and add links to code, returns the result
#
sub processcode {
    local ($_, $basefile) = @_;
    local (%types, %inheritedtypes, %myfunctions, $myclass);

    $_ = &html($_);
    s/^\s*?(?= *\S)?/\n\n/s;
    s/\s+$/\n\n/s;

    # allow escaping of comments
    s!\*\\/(.*?\n)!*/$1!gs;
    s!\\/(.*?\n)!//$1!gs;

    # pick up any local include files
    if ( $basefile ne "" ) {
	$basefile =~ s-/[^/]*$-/-;
	my ( $fn, $f, $h );
	while ( /\n\043include\s+\042([^\s\042]+\.h)\042\n/gs ) {
	    $h = $basefile . $1;
	    $fn = join( "\n", $fn, $h ) if ( -f $h );
	}
	foreach $h ( split( /\s+/, $fn ) ) { # most icky
	    next unless ( -f $h );
	    #print "reading include file $h\n";
	    $f = join( "\n", $f, &getfile( $h ) );
	}
	while ( $f =~ /(?:^|[\n\{])\s*class\s+(?:\w+\s+)?(\w+)\s*:\s*public\s+(\w[\w\d+]*)\b/gs ) {
	    if (!defined( $anchor{$1} ) &&
		defined( $anchor{$2} ) &&
		!defined($inheritedtypes{$1})) {
		$inheritedtypes{$1}=$2;
		#print "$1 inherits $2\n";
	    }
	}
    }

    # look for own class definitions that inherit documented classes
    while ( /(?:^|[\n\{])\s*(?:(?:class)|(?:struct))\s+(?:\w+\s+)?(\w+)\s*:\s*public\s+(\w[\w\d+]*)\b/gs ) {
	if (!defined( $anchor{$1} ) &&
	    defined( $anchor{$2} ) &&
	    !defined( $inheritedtypes{$1} ) ) {
	    $inheritedtypes{$1} = $2;
	}
    }

    # pick up functions
    foreach $myclass ( keys %inheritedtypes ) {
	while ( /\n\S[^\n]*(\b$myclass\b::[a-z][\w\d_]+)\b/g ) {
	    $myfunctions{$1} = ++$uniq;
	    #print "example member: $1\n";
	}
    }

    # label include files
    s@(\n\043include\s+(?:\042|(?:&lt;)))(.*?.h)((?:\042|(?:&gt;)))@
       if ( defined( $anchor{$2} ) ) {
	   sprintf("%s<a href=\"%s\">%s</a>%s", $1, $anchor{$2}, $2, $3);
       } else {
	   sprintf("%s%s%s", $1, $2, $3);
       }
    @egsx;

    # look for variables
    while ( m@(?:(?:^)|(?:[\n:;\{\(]))(?:\s*//[^\n]*\n)*\s*([A-Za-z0-9_]+)(?:\s*&lt;[^;]*?&gt;)?\s*\*?\s*([A-Za-z0-9_]+)@gs ) {
	if ($type{$anchor{$1}} eq "class") {
#	    print "Changing type of $2 from ", $types{$2}, " to $1\n"
#		if (defined($types{$2}) && ($1 ne $types{$2}));
	    $types{$2} = $1;
	} elsif (defined($inheritedtypes{$1}) &&
		 $type{$anchor{$inheritedtypes{$1}}} eq "class") {
	    print "Changing type of $2 from ", $types{$2}, " to $1\n"
		if (defined($types{$2}) &&
		    ($inheritedtypes{$1} ne $types{$2}));
	    $types{$2} = $inheritedtypes{$1};
	}
    }

    # look for var.method() and var->method()
    s@\b([A-Za-z0-9_]+)(\s*(?:(?:\.)|(?:-&gt;))\s*)([A-Za-z0-9_]+)@
    {
	if (defined($anchor{$types{$1} . "::" . $3})) {
	    sprintf("%s%s<a href=\"%s\">%s</a>", $1, $2,
		    $anchor{$types{$1} . "::" . $3}, $3);
	} elsif (defined($myfunctions{$1."::".$3})) {
	    sprintf("%s%s<a href=\043%s>%s</a>", $1, $2,
		    $myfunctions{$1."::".$3}, $3);
	} elsif (defined($inheritedtypes{$1}) &&
		 defined($anchor{$types{$inheritedtypes{$1}} . "::" . $3})) {
	    sprintf("%s%s<a href=\"%s\">%s</a>", $1, $2,
		    $anchor{$types{$inheritedtypes{$1}} . "::" . $3}, $3);
	} else {
	    sprintf("%s%s%s", $1, $2, $3);
	}
    }
    @egsx;

    # look for class::method()
    # statics in templates are not recognized
    s@((?:(?:^)|(?:[\n;\{\(]))\s*)\b([A-Za-z0-9_]+::[A-Za-z0-9_]+)\b@
    {
	if (defined($anchor{$2})) {
	    sprintf("%s<a href=\"%s\">%s</a>", $1, $anchor{$2}, $2);
	} elsif (defined($myfunctions{$2})) {
	    sprintf("%s<a href=\043%s>%s</a>", $1, $myfunctions{$2}, $2);
	} else {
	    sprintf("%s%s", $1, $2);
	}
    }
    @egsx;

    # look for class names
    s@((?:(?:^)|(?:[:\n;\{\(])|(?:\bnew))\s*)([A-Za-z0-9_]+)\b(?!::)@
    {
	if ((defined($anchor{$2})) && ($type{$anchor{$2}} eq "class")) {
	    sprintf("%s<a href=\"%s\">%s</a>", $1, $anchor{$2}, $2);
	} else {
	    sprintf("%s%s", $1, $2);
	}
    }
    @egs;

    # add links to own or inherited member functions, and to globals
    $myclass = "";
    s@(?:(?:\n[\w\s]*?[\*\s]*\b(\w+)\s*::\s*\w+\s*\([^\)\;\{]*\)\s*(?:const\s*)?(?=[\{:]))|(?:((?:(?:^)|(?:[\n\{\(\,]))\s*)([a-z][A-Za-z0-9_]+)(\s*\()))@
    {
	# $1 is class name _or_
	# $2 is before function use, $3 is function name, $4 is " ("
	if ( $1 ne "" ) {
#	    print "SEX: ", $1, "\n";
	    $myclass = $1;
	    $&;
	} elsif ( $myclass ne "" &&
		 defined( $myfunctions{$myclass . "::" . $3} ) ) {
#	    printf( "1: <a href=#%s>%s</a>%s\n",
#		    $myfunctions{$myclass . "::" . $3}, $3, $4 );
	    sprintf( "%s<a href=#%s>%s</a>%s",
		    $2, $myfunctions{$myclass . "::" . $3}, $3, $4 );
	} elsif ( $myclass ne "" &&
		 $type{$anchor{$inheritedtypes{$myclass}."::".$3}} eq "fn" ) {
#	    printf( "2: <a href=\"%s\">%s</a>%s\n",
#		    $anchor{$inheritedtypes{$myclass}."::".$3}, $3, $4 );
	    sprintf( "%s<a href=\"%s\">%s</a>%s",
		    $2, $anchor{$inheritedtypes{$myclass}."::".$3}, $3, $4 );
	} elsif ( $type{$anchor{"::".$3}} eq "fn" ) {
#	    printf( "3: <a href=\"%s\">%s</a>%s\n", $anchor{"::".$3}, $3, $4 );
	    sprintf( "%s<a href=\"%s\">%s</a>%s", $2, $anchor{"::".$3}, $3, $4 );
	} else {
#	    print "VOLD: ",$myclass," ",$inheritedtypes{$myclass},"::",$3,
#	          " ", $anchor{$inheritedtypes{$myclass}."::".$3}, "\n";
	    $&;
	}
    }
    @egs;
	
    # add anchors to locally defined functions
    foreach $myclass ( keys %myfunctions ) {
	s@(\b$myclass\b)@
	    sprintf("<a name=\"%s\"></a>%s", $myfunctions{$myclass}, $1);
	@esg;
	s@<a href=\".*?\"><a name=.*?></a>$myclass</a>@
	    sprintf("<a name=\"%s\"></a>%s", $myfunctions{$myclass}, $1);
	@esg;
    }

    s/^\s*\n//s;
    s/\s+$/\n/s;

    s/\n\s*\n/\n<linebreak>\n/gs;

    join($_, "<pre>", "</pre>\n");
}


sub findlink {
    local ($_, $class, $url, $ismethod) = @_;

    if ($type{$anchor{$_}} eq "example") {
	sprintf("<a href=\"%s\">%s</a>", $anchor{$_}, &html($_));
    } elsif (defined($anchor{$_}) && $anchor{$_} ne $url && $_ ne $class) {
	sprintf("<a href=\"%s\">%s</a>", $anchor{$_}, &html($_));
    } elsif ( (($ismethod eq "(") || (/^[A-Z]/)) &&
	      defined($anchor{$class . $_}) &&
	      $anchor{$class . $_} ne $url &&
	      !defined($internal{$class . $_}) ) {
	sprintf("<a href=\"%s\">%s</a>", $anchor{$class . $_}, &html($_));
    } elsif ((($ismethod eq "(") || (/^[A-Z]/)) &&
	     defined($anchor{"::" . $_}) && $anchor{"::" . $_} ne $url) {
	sprintf("<a href=\"%s\">%s</a>", $anchor{"::" . $_}, &html($_));
    } elsif ( (/^[A-Z]/) &&
	      defined($anchor{"Qt::" . $_}) && $anchor{"Qt::" . $_} ne $url) {
	sprintf("<a href=\"%s\">%s</a>", $anchor{"Qt::" . $_}, &html($_));
    } else {
	sprintf("%s", $_);
    }
}

sub preprocessdocs {
    local ($url, $_);

    foreach $url ( sort keys %type ) {
	$doc{$url} =~ s@\\header\s+([a-z0-9\.]+)@
	    my ($h1, $h2);
	    $h1 = $1;
	    $h2 = $h1;
	    $h2 =~ s/\.h$/-h.html/;
	    $headerfiles{$h1} = $h2;
	    sprintf("");
	@egsx;
    }

    foreach $url ( sort keys %type ) {
	$doc{$url} =~ s@\\relate[ds]\s+(\w+)@
	    $relations{$1} .= " " . $url;
	    $home{$url} = $1;
	    sprintf("");
	@egsx;
    }

    foreach $url ( sort keys %type ) {
	$internal{$url} = 1 if ( $doc{$url} =~ /^\s*\\internal\s/ );
    }

    foreach $url ( sort keys %type ) {
	$doc{$url} =~ s@\\define\s+(\S+)@
	    #$anchor{$1} = $url unless defined($anchor{$1});
	    sprintf("");
	@egsx;
    }

    # not actually url's... too tired to do it right :(
    foreach $url ( sort keys %relations ) {
	my (%tmp);
	$relations{$url} =~ s/^\s*//;
	foreach ( split(/\s+/, $relations{$url}) ) {
	    $tmp{$_}++ if ($_ ne "");
	}
	$relations{url} = join(" ", sort keys %tmp);
    }
}



sub handlecodeincludes {
    local( $cmd, $arg ) = @_;
    local ( $res, $slash, $basefile );

    #print "Arg: ", $cmd, " - ", $arg, "\n";
    $res = "<blink>error</blink>";

    while( $#code >= 0 && $code[0] eq "    <linebreak>" ) {
	shift @code;
    }

    if ( $cmd eq "include" || $cmd eq "dontinclude" ) {
	undef $basefile;
	foreach $edir ( @exampledirs ) {
	    $basefile = $edir . "/" . $arg
		if ( !defined($basefile) && -f ($edir . "/" . $arg) )
	}
	die "unable to find $arg, stopped. (searched ".join(", ",@exampledirs).")" if ( !defined( $basefile ) );
	open(IF, "expand < $basefile |") ||
	    die "cannot read $basefile";
	#print "including code from $basefile\n";
	$slash = $/;
	undef $/;
	$arg = <IF>;
	close IF;
	$/ = $slash;
	$res = &processcode( $arg, $basefile );
	$arg = $res; # icky
	$arg =~ s-^<pre>-\n-;
	$arg =~ s-</pre>$--;
	$arg =~ s-\n-\n    -g;
	if ( $cmd eq "dontinclude" ) {
	    $arg =~ s-<a href=\"?#[\d\w]+\"?>(.*?)</a>-$1-gs;
	    $arg =~ s-<a name=\"?[\d\w]+\"?>(.*?)</a>-$1-gs;
	    $res = "";
	}
	@code = split( /\n+/, $arg );
    } elsif ( $cmd eq "line" ) {
	$res = shift @code;
	print "line ", $res, "does not contain ", $arg, "\n"
	    unless ( $res =~ /\Q$arg\E/ );
	$res = "<pre>\n" . $res . "\n</pre>\n";
    } elsif ( $cmd eq "skipline" || $cmd eq "skip" ) {
	while ( $#code>-1 && !( $code[0] =~ /\Q$arg\E/ ) ) {
	    #print $#code, " - ", $code[0], " (", $arg, ")\n";
	    shift @code;
	}
	print "no such line: ", $arg, "\n" if ( $#code == -1 );
	$res = "";
	$res = join( shift @code, "<pre>\n", "</pre>\n" )
	    if ( $cmd eq "skipline" );
    } elsif ( $cmd eq "until" ) {
	$res = "<pre>";
	while ( $#code > -1 && !( $code[0] =~ /\Q$arg\E/ ) ) {
	    #print $#code, " - ", $code[0], " sex\n";
	    $res = join( "\n", $res, shift @code );
	}
	print "no such line: ", $arg, "\n" if ( $#code == -1 );
	$res = join( "\n", $res, shift @code, "</pre>\n" );
    } else {
	die "internal error regarding $cmd $arg";
    }

    #print "Result: $res\n";

    $res;
}


#
# handle code includes, common to pages and item docs
#
sub codeincludes {
    local ($doc) = @_;

    $doc =~ s/\s+\\((?:
		  (?:include)|
		  (?:dontinclude)|
		  (?:line)|
		  (?:skipline)|
		  (?:skip)|
		  (?:until)))\b\s*(\S+)/
		      " " . &handlecodeincludes($1,$2)
    /esgx;
    $doc =~ s-</pre>\s*<pre>\n--gs;
    $doc;
}
			



sub processdocs {
    local ($url, $doc, $class, %word);

    foreach $url ( sort keys %type ) {
#print "processing url: ", $url, "\n";
	if (defined($home{$url})) {
	    $class = $home{$url};
	} else {
	    $class = $name{$url};
	    $class =~ s/::.*/::/;
	}
	$class .= "::" unless ($class =~ /::/);

	$doc = $doc{$url};

	unless ($doc =~ /(?:(?:^)|(?:\n))(?:  )/s) {
	    $doc =~ s/\n  /\n/gs;
	    $doc =~ s/^  //s;
	}

	$doc =~ s/\\\&/&amp;/gs;
	$doc =~ s/\\</&lt;/gs;
	$doc =~ s/\\>/&gt;/gs;

	$doc =~ s/\s*\\ingroup\s+([^\\\s]*)/
	    {
	    $classes{$1.".html"} .= $class;
	    "\n";
	    }
	/egsx;
	$doc =~ s/\s*\\extension\s+([^\\\s]*)/
	    {
	     $extension{$url} = $1;
	    "\n";
	    }
	/egsx;
	$name{$url} = $1
	    if ($doc =~ s/\s*\\name\s+(.*?)
		(?:(?:\n\s*?\n\s*)|(?:$ ))/\n/sx);
	$doc =~ s/\s*$/\n/s;
	$doc =~ s/^\s*//s;
	$doc =~ s-\s*\\warning\s+-<p><b>Warning:</b> -gs;
	if (!$internal) {
	    $doc =~ s/^\s*\\internal\s/For internal use only.\\internal /s;
	    $doc =~ s/\\internal\s.*//s;
	}
	if ( $doc =~ s/(^|\s)\\obsolete\b//gs ) {
	    if ( $type{$url} eq "fn" ) {
		$what = "function";
	    } elsif ( $type eq "enum" ) {
		$what = "type";
	    } elsif ( $type eq "class" ) {
		$what = "class";
	    } else {
		$what = "member";
	    }
	    # uglehack.  look for this text elsewhere...
	    $doc = "<b>This ". $what . " is obsolete.</b> It is provided to "
	      . "keep old source working, and will probably be removed in a "
		. "future version of Qt.  We strongly advise against using it "
		. "in new code.<p>" . $doc;
	}

	if ($doc =~ s/\s*\\credit\s+([^\n]*?)\s*/\n\n/s) {
	    $credit{$1}{$url}++;
	}

	if ($doc =~ s/\s*\\important\s+(.*?)(?:(?:\n\s*\n\s*)|(?:$ ))/\n\n/s) {
	    #print "$url has important stuff: $1\n";
	    $important{$url} = $1;
	    $important{$url} =~ s/,?\s+/ /gs;
	}

	if ( $doc =~ m/(^|\s)\\mustquote\b/s ) {
	    my $mq = $doc;
	    $mq =~ s/.*\\mustquote\s*//s;

	    $mq =~ s/\\sa.*//;

	    $mq =~ s/\.*\s*$/.\n/s;
	    $mq =~ s/>\.\n$/>\n/s;

	    $mq =~ s-\s*\n\s*\n(?:\s|(?:<p>))*-\n<p>-gs;
	    $mq =~ s-^(?:<p>)+--s;
	    $mq =~ s/<linebreak>//gs;

	    $mustquote{$mq}{$url}++;

	    $doc =~ s/\\mustquote\s*//s;
	}

	# this code is _really_ hard to follow... sorry
	$doc =~ s@\\sa\s+(.*)?\n@
	{
	    my ($seealso);
	    $seealso = $1;

	    $seealso =~ s/\s+/ sex /gs;

	    $seealso =~ s/\\link(.*?)\\endlink/
	    {
		my($evilhack);
		$evilhack = $1;
		$evilhack =~ s- sex - -gs;
		sprintf("\\link %s \\endlink", $evilhack);
	    }/esg;

	    $seealso =~ s!<a\b(.*?)</a?>!
	    {
		my($evilhack);
		$evilhack = $1;
		$evilhack =~ s- sex - -gs;
		sprintf("<a%s</a>", $evilhack);
	    }!esgi;

	    $seealso =~ s/,? sex and sex / sex /;
	    $seealso =~ s/\.?\s*(?:sex\s*)?$//;
	    $seealso =~ s/,?\s+sex\s+/ sex and sex /gs;
	    $seealso =~ s/ sex and sex (?=.* sex and sex )/, sex /gs;
	    $seealso =~ s/ sex / /gs;
	    sprintf( "\n\nmagicwordthatyoushouldavoid %s.\n", $seealso );
	}@es;

	# try full function qualification
	$doc =~ s-\\link\s+((?:(?:\w+)\s+)*[\*\&]?\s*)(\w+)::(\w+)\s*\((.*?)\)(?:\s*(const))?\s+(.+?)\s*\\endlink-
	{
#print $1, " ", $2, " ", $3, " (", $4, ") ", $5, " <=> ", $6, "\n";
	    $string = $6;
	    $tryagain = $&;
	    $_ = &manglefn( $1, $2, $3, $4, $5);
	    if ($type{$_} eq "fn") {
		sprintf("<a href=\"%s\">%s</a>", $_, $string);
	    } else {
		sprintf("%s", $tryagain);
	    }
	}
	-egsx;

	# refer to function or class by name
	$doc =~ s-\\l\s+([^\s\(\.\,\)]+(?:\.h)?)((?:[\(\)]*))-
	    if (defined($anchor{$1})) {
		sprintf("<a href=\"%s\">%s</a>", $anchor{$1}, &html($1 . $2));
	    } else {
		if (defined($anchor{$class . $1})) {
		    sprintf("<a href=\"%s\">%s</a>",
			    $anchor{$class . $1}, &html($1 . $2));
		} elsif (defined($anchor{"::".$1})) {
		    sprintf("<a href=\"%s\">%s</a>",
			    $anchor{"::" . $1}, &html($1 . $2));
		} else {
		    print "No link to '$1' (processing $name{$url})\n";
		    sprintf("%s", $1 . $2);
		}
	    }
	-egsx;

	# try normal class::member, just class or member
	$doc =~ s-\\link\s+([^\s\(]+)(?:[\(\)]*)\s*(.*?)\s*\\endlink-
	    if (defined($anchor{$1})) {
		sprintf("<a href=\"%s\">%s</a>", $anchor{$1}, &html($2));
	    } else {
		if (defined($anchor{$class . $1})) {
		    sprintf("<a href=\"%s\">%s</a>",
			    $anchor{$class . $1}, &html($2));
		} elsif (defined($anchor{"::".$1})) {
		    sprintf("<a href=\"%s\">%s</a>",
			    $anchor{"::" . $1}, &html($2));
		} else {
		    my ( $target, $string ) = ( $1, $2 );
		    $string =~ s/\s+/ /gs;
		    print "No link to '$target' for '$string' (processing $name{$url})\n";
		    sprintf("%s", $2);
		}
	    }
	-egsx;

	$doc .= "<p>Returns: " . $1
	    if ($doc =~ s/\s*\\returns?\s+(.*?)
		(?:(?:\n\s*?\n\s*)|(?:$ ))/\n\n/sx);

	if ($doc =~ /\s+\\arg\s+/s) {
	    $doc =~ s-\s+\\arg\s+-
		\n\nArguments:\n<ul>\n<li>-sx;
	    $doc =~ s-\s+\\arg\s+(.*?)(?=\s+\\arg\s+)-\n<li>$1-gs;
	    $doc =~ s-\s+\\arg\s+(.*?)
		(?:(?:\n\s*?\n)|(?:$ ))-\n<li>$1\n</ul>\n-sx;
	}

	$_ = "<p>To do:\n<ul>\n";
	$_ .= "<li>" . $1 . "\n"
	    while ($doc =~ s/\s*\\todo\s+(.*?)
		   (?:(?:\n\s*?\n\s*)|(?=\\todo\s)|(?:$ ))/\n\n/sx);
	$_ .= "</ul>\n";
	$doc .= $_ if (/<li>/s);

	$_ = "<p>Bugs and limitations:\n<ul>\n";
	$_ .= "<li>" . $1 . "\n"
	    while ($doc =~ s/\s*\\bug\s+(.*?)
		   (?:(?:\n\s*?\n\s*)|(?:$ ))/\n\n/sx);
	$_ .= "</ul>\n";
	$doc .= $_ if (/<li>/s);

	$doc =~ s-\\internal\s-<p>Internal comments:<p>\n-s;

	$doc =~ s@\\version\b@$version@gs;
	if ( $doc =~ /\\reimp\b/s ) {
	    $doc =~ s@\\reimp\b@Reimplemented for internal reasons; the API is not affected.@s;
	    $doc =~ s@\\reimp\b@@gs;
	    $reimp{$url}++;
	}

	$doc =~ s!\\e\s+(\S+)!<em>$1</em>!gs;
	
	$doc =~ s!\\a\s+(\S+)!<em>$1</em>!gs;
	$doc =~ s!\\c\s+(\S+)!<code>$1</code>!gs;

	$doc =~ s!\\code\b(.*?)\\endcode!&processcode("\n" . $1)!esg;

	$doc = &codeincludes($doc);

	$doc =~ s/\.*\s*$/.\n/s;
	$doc =~ s/^\s*\n//s;
	$doc =~ s/>\.\n$/>\n/s;

	$doc =~ s-\s*\n\s*\n(?:\s|(?:<p>))*-\n<p>-gs;
	$doc =~ s-^(?:<p>)+--s;
	$doc =~ s/<linebreak>//gs;

	undef %word;
	$_ = $class;
	s/:://;
	$word{$_}++;
	$word{"Qt"}++;

# used to be  s-(?:(?:\b((?:(?:operator[^\s\(]{1,3})
# ...

	$doc =~ s-(?:(?:\b((?:(?:operator(?:(?:\(\s*\))|(?:[^\s\(]{1,3})))
			    |(?:[\w:/]+(?:\.(?:h|(?:cpp)))?)))(\()?(?!</a>))
		   |((?:(?:<pre>.*?</pre>)|(?:<a [^>]+>[^<]*</a>)|(?:<.*?>))))-
	    if ($3 eq "") {
		if (!defined($word{$1})) {
		    if ($1 eq "magicwordthatyoushouldavoid") {
			undef %word;
			sprintf("See also: ");
		    } else {
			my ($tmp);
			$tmp = &findlink($1, $class, $url, $2);
			$word{$1}++ if ($tmp ne $1);
			sprintf("%s%s", $tmp, $2);
		    }
		} else {
		    sprintf("%s%s", $1, $2);
		}
	    } else {
		sprintf("%s", $3);
	    }
	-egsx;

	$doc =~ s@(?:(?:(<pre>.*?</pre>)\n?)|(?:\n *))@$1\n@gs;

	$doc =~ s@</em>\s+<em>@ @gs;
	$doc =~ s@</code>\s+<code>@ @gs;
	$doc =~ s@</b>\s+<b>@ @gs;
	$doc =~ s@<p>\s*(<(?:li)|(?:/ol)|(?:/ul)|>)@$1@gs;

	$brief{$url} = $1
	    if ($doc =~ s/\s*\\brief\s+(.*?)(?:(?:\n<p>\s*)|(?:$))//s);

	$brief{$url} =~ s/\s*\n\s*/ /g;

	if ((defined($brief{$url})) && !(defined($capt{$url})) &&
	    ($type{$url} eq "class" )) {
	    $capt{$url} = $brief{$url};
	    $capt{$url} =~ s/^the\s+\w+\s+(?:(?:class)|(?:widget))\s+(?:(?:is)|(?:provides)|(?:contains)|(?:specifies))?\s*(?:\ban?\b)?\s*//si;
	    $capt{$url} =~ s/\.\s*$//s;
	    $capt{$url} = ucfirst $capt{$url};
	}

	$doc{$url} = $doc;
    }
}



sub writepages {
    local($doc, $p, $e, $f, $file);

    foreach $file ( sort keys %pages ) { # MUST be alphabetical
	$doc = $pages{$file};
	open(O, "> $outputdir/$file") ||
	    die "can't open $outputdir/$file";
	if ( $file =~ /\.html$/ ) {
	    $doc =~ s-\\link\s+([^\s\(]+)(?:[\(\)]*)\s*(.*?)\s*\\endlink-
		if (defined($anchor{$1})) {
		    sprintf("<a href=\"%s\">%s</a>", $anchor{$1}, $2);
		} else {
		    print "No link to '", $1, "' for '", $2, "'\n";
		    sprintf("%s", $2);
		}
	    -egsx;
	
	    # refer to function or class by name
	    $doc =~ s-\\l\s+([^\s\(\.\,\)]+(?:\.h)?)((?:[\(\)]*))-
		if (defined($anchor{$1})) {
		    sprintf("<a href=\"%s\">%s</a>", $anchor{$1}, &html($1 . $2));
		} else {
		    if (defined($anchor{$class . $1})) {
			sprintf("<a href=\"%s\">%s</a>",
				$anchor{$class . $1}, &html($1 . $2));
		    } elsif (defined($anchor{"::".$1})) {
			sprintf("<a href=\"%s\">%s</a>",
				$anchor{"::" . $1}, &html($1 . $2));
		    } else {
			print "No link to '$1' (during write of $file)\n";
			sprintf("%s", $1 . $2);
		    }
		}
	    -egsx;
	
	    $doc =~ s/\\internal\s.*//s if (!$internal);
	    $doc =~ s-\\internal\s-<p>Internal comments:<p>\n-s;
	
	    $doc =~ s/\\\&/&amp;/gs;
	    $doc =~ s/\\</&lt;/gs;
	    $doc =~ s/\\>/&gt;/gs;
	
	    $doc =~ s!\\code\b(.*?)\\endcode!&processcode($1)!esg;
	
	    $doc = &codeincludes($doc);
	
	    if ( $doc =~ m/(^|\s)\\mustquote\b/s ) {
		my $mq = $doc;
		$mq =~ s/.*\\mustquote\s*//s;

		$mq =~ s/\\sa.*//;

		$mq =~ s/\.*\s*$/.\n/s;
		$mq =~ s/>\.\n$/>\n/s;

		$mq =~ s-\s*\n\s*\n(?:\s|(?:<p>))*-\n<p>-gs;
		$mq =~ s-^(?:<p>)+--s;
		$mq =~ s/<linebreak>//gs;

		$mustquote{$mq}{$file}++;

		$doc =~ s/\\mustquote\s*//s;

		die "Cannot process \\quotelist before \\mustquote.  Stopped"
		  if ( defined( $haveprocessedquotelist ) );
	    }
	
	    $doc =~ s!\\classhierarchy!&classhierarchy()!es;
	    $doc =~ s!\\classlist!&classlist()!es;
	    $doc =~ s!\\extensionlist!&extensionlist()!es;
	    $doc =~ s!\\annotatedclasslist\(([^,)]*),([^,)]*),([^,)]*),([^,)]*),([^,)]*)\)!&annotatedclasslist($1,$2,$3,$4,$5)!es;
	    $doc =~ s!\\annotatedclasslist!&annotatedclasslist("<ul>\n","<li>"," (", ")\n","</ul>")!es;
	    $doc =~ s!\\headerfilelist!&headerfilelist()!es;
	    $doc =~ s!\\functionindex!&functionindex()!es;
	    $doc =~ s!\\quotelist!&quotelist()!es;
	
	    $doc =~ s@\\version\b@$version@gs;

	    $doc =~ s@\\postheader\b@$postheader@gs;
	    $doc =~ s@\\style\b@$style@gs;
	    $doc =~ s@\\title([^\n]*)\n@<title>$module_long - $1</title>$style</head><body bgcolor=\"#ffffff\">\n$postheader<h1 align=center>$1</h1><br clear="all">@gs;
	
	    $doc =~ s!\\e\s+(\S+)!<em>$1</em>!gs;
	    $doc =~ s!\\c\s+(\S+)!<code>$1</code>!gs;
	
	    $doc =~ s/\n\s*\n/\n<p>\n/gs;
	    $doc =~ s/<linebreak>//gs;
	    $doc =~ s/<p>\s*<p>/<p>/gs;
	    $doc =~ s@<p>\s*(<(?:li)|(?:/ol)|(?:/ul)|>)@$1@gs;
	
	    print O $doctype, "<html><head>", $doc, "\n";

	    $types = undef;
	} else {
	    print O $doc;
	}
	if (defined($classes{$file})) {
	    $p = "<p>Classes:<ul plain>\n";
	    $e = "";
	    foreach ( sort split(/:+/, $classes{$file}) ) {
		if (defined($anchor{$_})) {
		    print O $p, "<li><a href=\"",$anchor{$_},"\">",$_,"</a>\n";
		    $p = "";
		    print O "    (", $capt{$anchor{$_}}, ")\n"
			if (defined($capt{$anchor{$_}}));
		    $e = "</ul>\n";
		} else {
		    print "no such group: ", $_, "\n";
		}
	    }
	    print O $e;
	}
	if ( $file =~ /\.html$/ ) {
	    print O $address;
	}
	close(O);
    }
}



sub mangleclass {
    local($class) = @_;

    $class =~ s/[:\s].*//;
    $class =~ tr/A-Z/a-z/;
    $class = "globals" if ($class eq "");
    $class .= ".html";

    die "produced null url" if ($class eq "");

    $class;
}



#
# now, now
#
# %urls is the list of url's, indexed by mangled function
#
# $uniq is just an unique number, starts at 0
#
sub manglefn {
    local($type, $class, $name, $sig, $const, $home) = @_;
    local($url, $d, $mc);
    local($names);

    $type =~ s/\s+/-/g;
    $type =~ s/^-*(.*?)-*$/$1/;
    $type =~ s/-*([\*\&]+)-*/$1/g;
    $type =~ s/^-?virtual-?//;
    if ( ($type =~ /^[A-Z][^:]*$/ ) # class-local enum
	&& defined( $type{&mangleclass( $class ) . "#" . $type} ) ) {
	$type = $name{&mangleclass( $class ) . "#" . $type};
    } elsif ( ($type =~ /^[A-Z][^:]*$/ ) # Qt-local enum
	&& defined( $type{"qt.html#" . $type} ) ) {
	$type = $name{"qt.html#" . $type};
    }
    $type = "-" . $type if ($type ne "");
    $const = "-" . $const if ($const ne "");
    $url = $class . "::" . $name;
    $sig =~ s/\(.*?\)//gs;
    $d = "(";
    $names = "";
    foreach (split(/\s*,\s*/, $sig)) {
# kill argument name
	s/\s*=.*//s;
	if ( !(s/([\&\*]+).*/$1/) &&
	    (/((?:\w+\s+)*?)\s*([\w<>]*)\s+(\w+)$/s)) {
	    if (($2 ne "class") && ($2 ne "enum") && ($2 ne "union") &&
		($2 ne "struct") && ($2 ne "const") && ($2 ne "volatile") &&
		($3 ne "int") && ($3 ne "float") && ($3 ne "char") &&
		($3 ne "short") && ($3 ne "long") && ($3 ne "unsigned") &&
		($3 ne "signed") && ($2 ne "")) {
		s/\s*(\w+)$//;
		$names .= $1 . " ";
	    }
	}
	# qualify enums (third uglest hack in qdoc, methinks)
	if ( /^[A-Z][^:]*$/ # class-local enum
	     && defined( $type{&mangleclass( $class ) . "#" . $_} ) ) {
	    $_ = $name{&mangleclass( $class ) . "#" . $_};
	} elsif ( /^[A-Z][^:]*$/  # Qt-local enum
		  && defined( $type{"qt.html#" . $_} ) ) {
	    $_ = $name{"qt.html#" . $_};
	}
# strip spaces around & and *
	s/\s*([\*\&]+)\s*/$1/g;
# kill default and change spaces into -
	s/=.*//g;
	s/\s+/-/g;
	s/-+$//;
	s/^-+//;
# finally add it to the url
	$url = join($d, $url, $_);
	$d = ",";
    }
    if ($d eq ",") {
	$url .= ")" . $type . $const;
    } else {
	$url .= "()" . $type . $const;
    }

    if (!defined(%urls) && open( I, "< " . $ENV{"HOME"} . "/.qdoc-cache" ) ) {
	while( <I> ) {
	    if ( /(\S+)\s+(\S+)/ ) {
		$cachable{$1} = $2;
		$urls{$1} = $2;
	    }
	}
	close I;
    }

    unless (defined($urls{$url})) {
	$home = &mangleclass($class) unless ($home =~ /\S/);
	$uniqkeys{$home} ||= "a0";
	open( MD5, "md5sum --string='" . $url . "' |" );
	$md5sum = <MD5>;
	close MD5;
	$md5sum =~ s/\s.*//;
	$urls{ $url } = join("", $home, "#", substr($md5sum, 0, 6 ) );
	$cachable{$url} = $url;
    }

    $argnames{$urls{$url}} = " " . $names;
    $url = $urls{$url}; #cool!
}




sub storeclass {
    local($filename, $sig, $def) = @_;
    local($url, $name, $inh, $enum);

    ($name, $inh) = split(/\s*:\s*/, $sig);

    $url = &mangleclass($sig);
    $type{$url} = "class";
    $name{$url} = $name;

    $inheritance{$url} = $inh if (defined($inh) && $inh ne "");

    while ( $def =~ /\{[^\{\}]*\{[^\{\}]*\}[^\{\}]*\}/s ) {
	$def =~ s/\{[^\{\}]*(\{[^\{\}]*\})[^\{\}]*\}/\1/gs;
    }

    $def =~ s/\s+/ /g;
    $def =~ s/Q_OBJECT//;
    $def =~ s/(\)\s*(?:const\s*)?)(?::[^;:\}\{]*)?\{.*?\}/$1;/gs;
    $def =~ s/struct[^\;\{]*\{.*?\}\s*\w*\s*\;\s*//gs;
    $def =~ s/;\s*$//s;

    my $p = undef;
    # (((( matches
    while ( $def =~ /Q_PROPERTY\s*\(\s*([^)]+?)\s*\)/g ) {
	$p .= "\n" if defined($p);
	$p .= "$1";
    }
    $properties{$url} = $p;
    $def =~ s/Q_PROPERTY\s*\([^)]*\)//g;
    $def =~ s/Q_OVERRIDE\s*\([^)]*\)//g;
    $def =~ s/Q_ENUMS\s*\([^)]*\)//g;

    $def =~ s/\)\s*\{.*?\}\s*/\);\n/gs;
    $members{$url} = $def;

    # minor hack: set $virtual{$url} for all urls representing a virtual
    # function
    foreach (split(/;/, $def)) {
	s/^(?:[\w\s]+:(?!:))*\s*//s;
	if (/^((?:[^\(\~]*[\s\&\*]+)?)(?=[\w~]) (?# prelude
						 )
	    ((?:(?:operator(?:(?:\(\s*\))|(?:[^\s\(]{1,3})))
	      |(?:\~?\w+)))                        (?# name
						    )
	    \s*\((.*?)\)\s*(const)?\s*(?:=\s*0\s*)?$/x) {
	    my ($u,$t,$mt,$f,$a,$ma,$c);
	    $t = $1;
	    $f = $2;
	    $a = $3;
	    $c = $4;

	    $a =~ s/^\s+//s;
	    $a =~ s/\s+$//s;

	    $u = &manglefn($t, $name, $f, $a, $c);
	    $virtual{$u} = $u if ( $t =~ /^virtual\b/s );
	}
    }
}




sub getfile {
    local($filename) = @_;
    local($_, $ifdef, @defines, @lines);

    open(F, "expand < $filename |") || die "can't open $filename for reading";
    $ifdef = 0;
    while(<F>) {
	$dates{$1} = $2 if (/\$Id\:\s+(.*?),v\s+[0-9\.]+\s+(\S+)\s/);
	if ( /^#if/ ) {
	    push @defines, $ifdef;
	    $ifdef = 1 if ( !/_H_?$/ && !/QT_FEATURE/ && !/QT_MOC_CPP/ &&
			    !/QT_NO_CODECS/ );
	}
	if ( !$ifdef ) {
	    if ( defined( $preprocess ) ) {
		&$preprocess;
	    }
	    push @lines,$_;
	}
	$ifdef = pop @defines if ( /^\#endif\b/ );
    }
    close(F);
    $_ = join("", @lines);
    s/\n\#[^\n]*//gsi;
    $_;
}



sub readfiles {
    local($/, $_, $h, $w, $filename, $htmlfilename);

    undef $/;
    foreach $filename ( keys %headerfiles ) {
	$_ = $filename;
	$_ = "$includedir/$filename" unless ( -f $_ );
	next unless -f $_;
	open(F, "expand < $_ |") || die "can't open $_ for reading";
	$_ = $filename;
	s/\./-/;
	s/$/.html/;
	open(H, "> $outputdir/$_")
	    || die "can't open $outputdir/$_ for writing";
	$h = <F>;
	close(F);
	$h = &html($h);
	$h =~ s@\n(?:(?:class)|(?:struct))\s+(?:[\w_]+\s+)?[\w:]+(?:\s*:(\s*(?:public\s+)?\w+\s*,?)*)?@
	    $_ = "";
	    foreach $w (split(/\b/, $&)) { # ARNTHER
		if ( $w =~ /\w/ && $doc{$anchor{$w}} =~ /\S/) {
		    $_ = join("", $_, "<a href=\"", $anchor{$w}, "\">", $w, "</a>");
		} else {
		    $_ = join("", $_, $w);
		}
	    }
	    $_;
	@egsx;
	$h =~ s@(\n\x023include\s+[\<\x22])([\w\.]+)([\>\x22])@
	    if (defined($headerfiles{$2})) {
		sprintf("%s<a href=\"%s\">%s</a>%s", $1, $headerfiles{$2}, $2, $3);
	    } else {
		sprintf("%s%s%s", $1, $2, $3);
	    }
	@egsx;
	print H $doctype, "
<html><head><title>
", $module_long, " - ", $filename, " include file
</title>", $style, "
</head><body bgcolor=\"#ffffff\">\n", $postheader, "
<h1 align=center>", $filename, "</h1><br clear=\"all\">
This is the verbatim text of the ", $filename," include file.  It is
provided only for illustration; the copyright
remains with ", $company, ".
<hr>
<pre>
", $h, "\n</pre>\n", $address;
	close H;
     }

    foreach $filename ( keys %examples ) {
	my (%a, $a, $doc, $fqfilename);

	$doc = &codeincludes($examples{$filename});
	$doc =~ s/<linebreak>//gs;
	
	undef $fqfilename;
	foreach $edir ( @exampledirs ) {
	    $fqfilename = $edir . "/" . $filename
		if ( !defined($fqfilename) && -f ($edir . "/" . $filename) )
	}

	die "unable to find $filename, stopped" if ( !defined( $fqfilename ) );
	open(F, "expand < $fqfilename |")
	    || die "can't open $filename for reading";
	$htmlfilename = $filename;
	$htmlfilename =~ s@/@-@;
	$htmlfilename =~ s/\.cpp/-cpp.html/;
	open(H, "> $outputdir/$htmlfilename")
	    || die "can't open $outputdir/$htmlfilename for writing";
	$h = <F>;
	close F;
	$h = &processcode($h, $fqfilename );
	$h =~ s/<linebreak>//gs;

	while ( $h =~ m@<a href=\"?(.*?)\"?>(.*?)</a>@gs ) {
	    $a{$1} = $2;
	}

	foreach ( keys %a ) {
	    $a = $a{$_};
	    $doc{$_} .= "<p>Examples:\n" unless ($doc{$_} =~ /\bExamples:\s/);
	    $doc{$_} .= " <a href=\"$htmlfilename\">$filename</a>\n";
	    $doc{$_} =~ s/<a href=\"$htmlfilename\">/<a href=\"$htmlfilename\#$a\">/gs;
	}
	foreach ( keys %a ) {
	    $a = $a{$_};
	    $h =~ s@<a href=\"?$_\"?>@<a name=\"$a\"></a><a href=\"$_\">@s;
	}

	$h =~ s@(\n\x23include\s+\&lt;)([\w\.]+)(\&gt;)@
	    if (defined($headerfiles{$2})) {
		sprintf("%s<a href=\"%s\">%s</a>%s",
			$1, $headerfiles{$2}, $2, $3);
	    } else {
		sprintf("%s%s%s", $1, $2, $3);
	    }
	@egsx;

	print H $doctype, "
<html><head><title>
", $module_long, " - ", $filename, " example file
</title>", $style, "
</head><body bgcolor=\"#ffffff\">\n", $postheader, "\n", $doc, "\n", $h, $address;
	close H;
    }
}



sub readh {
    local ($filename) = @_;

    local( $h );

    $h = getfile( ( -f $filename ) ? $filename : "$includedir/$filename" );

    print "header file: ", $filename, "\n" if ($debug);

    $h =~ s-(?:(?:(/\*[\-!].*?\*/))|(?:/\*.*?\*/)|(?://[^\n]*))-$1-gs;

# { is \x7b and } is \x7d
    while ($h =~ m-\n(?:template\s*<\s*class\s+(.+?)\s*>\s*)?
	   (?:(?:class)|(?:struct))\s+([^\n]*?)\s+
	   \x7b\s+(.*?)\n\x7d-xsg
	   ) {
	my ($cookie, $sig, $def) = ($1,$2,$3);
	$sig =~ s/\w+\s+(\w+)/$1/;
	#print "class $sig\n";
	if ( $cookie eq "" ) {
	    # Not a template
	    &storeclass($filename, $sig, $def);
	} else {
	    $templatecookie{&mangleclass($sig)} = $cookie;
	    &storeclass( $filename, $sig, $def );
	}
    }

    while( $h =~ /\ntypedef (\w+)\s*<([a-zA-Z]+?)\s*>\s*(\w+);/g ) {
	$declared{$3} = $1 . " " . $2 . " " . $filename;
	#print "saw $3: ", $declared{$3}, "\n";
    }

    $headerfiles{$filename} = $filename;
    $headerfiles{$filename} =~ s/\./-/;
    $headerfiles{$filename} =~ s/$/.html/;
}



sub templates {
    local ($url, $_, $n, $t, $f, $i, $c, $m, $mm, $url);

    foreach $n ( sort keys %declared ) {
	($t, $i, $f) = split(/\s+/, $declared{$n});
	# $t is the template, $i is the instantiated type, $f is header file
	$t =~ s/M$//; # oh no... oh well
	$url = &mangleclass($t);
	if (defined($templatecookie{$url}) && defined($members{$url})) {
	    $c = $templatecookie{$url};
	    $_ = $members{$url};
	    s/\b$t\s*?<\s*$c\s*?>/$n/gs;
	    s/\b$t(\s*\()/$n$1/gs;
	    s/\b$c\b/$i/gs;
#print "making up ", $n, " in ", $f, " from ", $t, "<", $c, ">:\n", $_, "\n";
	    &storeclass( $f, $n, $_ );
	    # This is O(toomany) but was easy to write
	    foreach $m ( keys %name ) {
		# icky hack here, :. should be :: but perl5 doesn't like that
		if (($name{$m} =~ /^$t:/s) && ($type{$m} eq "fn") ) {
		    $mm = $name{$m};
		    $mm =~ s/.*:+//;
		    if ( $mm eq $t ) {
			$mm = $n;
		    } elsif ( $mm eq "~".$t ) {
			$mm = "~".$n;
		    }

		    $url = "";
		    #print "B: ", $name{$m}, "-> ", $n, "::", $mm, "\n";
		    # okie, now set $url to the new url and copy it across
		    if ( $mm eq "_cast" ) {
			my ($type, $const);
			if ( $def{$m} =~ /^.*?\b\s*[A-Za-z_]+::operator\s+(.*?)\s*\(\)\s*((?:const)?)$/ ) {
			    $type = $1;
			    $const = $2;

			    $type =~ s/\b$t\s*?<\s*$c\s*?>/$n/gs;
			    $type =~ s/\b$c\b/$i/g;

			    $url = &manglefn($type, $n, $mm,"",
					     $const, &mangleclass($n));
			}
		    } else {
			my ($type, $args, $const);
			if ( $def{$m} =~ /^\s*(.*?)\b\s*[A-Za-z_]+::(?:(?:~?[A-Za-z_]+)|(?:operator\s*\S+))\s*\(\s*(.*?)\s*\)\s*((?:const)?)$/ ) {
			    $type = $1;
			    $args = $2;
			    $const = $3;

			    $type =~ s/\b$t\s*?<\s*$c\s*?>/$n/gs;
			    $type =~ s/\b$c\b/$i/g;

			    # instantiate argument type
			    $args =~ s/\b$t\s*?<\s*$c\s*?>/$n/gs;
			    $args =~ s/\b$t(\s*\()/$n$1/gs;
			    $args =~ s/\b$c\b/$i/gs;

			    $url = &manglefn($type, $n, $mm, $args,
					     $const, &mangleclass($n));
			} else {
			    #print "1: ", $def{$m}, "\n";
			}
		    }

		    if ( $url ne "" ) {
			#print "C: ", $m, " -> ", $url, "\n";
			$def{$url} = $def{$m};
			$def{$url} =~ s/\b$t\s*?<\s*$c\s*?>/$n/gs;
			$def{$url} =~ s/\b$t(\s*\()/$n$1/gs;
			$def{$url} =~ s/\b$c\b/$i/gs;
			$def{$url} =~ s/\b$t\b/$n/g;
			$name{$url} = $n . "::" . $mm;
			$doc{$url} = $doc{$m};
			$overload{$url} = $overload{$m};
			$type{$url} = "fn";
			#print"D: def: ",$def{$url}," name: ",$name{$url},"\n";
		    }
		}
	    }
	} else {
	    print "declared $n as $t<$i> but $t is unknown\n";
	}
    }
}


sub readcpp {
    &readc if ( ( /\.cpp$/ || /\.cc$/ ) && $File::Find::dir !~ /\.p4ebak$/ );
}


sub readdoc {
    &readc if ( /\.doc$/ && $File::Find::dir !~ /\.p4ebak$/ );
}


sub readc {
    my ($filename) = $_;
    my ($overload, $c);

    $c = getfile($filename);
    print "code file: ", $filename, "\n" if ($debug);

#    $c =~ s-(?:(?:(/\*.*?\*/))|(?://[^\n]*))-$1-gs;
    $c =~ s-(?:(?:(/\*[\-!].*?\*/))|(?:/\*.*?\*/)|(?://[^\n]*))-$1-gs;

    while ($c =~ m@/\*\!\s*
	   ([^\*]*\*+(?:[^\*/][^\*]+\*+)*)/\s*
	   (?:([A-Za-z_](?:[^\{;\*]|(?:\*[^/]))+)\s*\x7b)?@gsx) {
	my ($doc, $def, $type, $class, $name, $args, $const, $skip);
	$skip = 0;

	$doc = $1;
	$def = $2;
	$doc =~ s/\s*\*$//;
	$def =~ s/\):/\) :/gs; # add a space so next s/// works
	$def =~ s/\s:\s*\b.*//s; # strip away constructor inheritance
	$def =~ s/\s+/ /gs;

	if ($doc =~ m@^\\class\s+(\w+) *([\.\w/]+)\s+(.*?)\s*$@s) {
	    # it's a \class
	    my ($class, $hfile, $rfile, $doc);
	    my ($url);
	    $class = $1;
	    $hfile = $2;
	    $doc = $3;
	    if ( $hfile eq "" ) {
		$hfile = $filename;
		s/\..*/.h/;
	    }
	    $rfile = $hfile;
	    $hfile =~ s/\.doc/.h/;
	    die if ( $hfile eq "" );
	    readh($rfile) if (!defined($cfiles{$hfile}));
	    $filename =~ s-^.*/--;
	    $cfiles{$hfile} .= " " . $filename;
	    $url = &mangleclass($class);
#	    print $class, " not in ", $rfile, "\n"
#		unless (defined($members{$url}) || defined($declared{$class}));
	    # override inheritance after storeclass has done its job
	    $inheritance{$url} = "public ".$1
		if ( $doc =~ s/\s*\\inherit\s*(\w+)\s+/\n\n/ );
	    $doc{$url} = $doc;
	    $includefile{$url} = $hfile;
	} elsif ($doc =~ m@^\\fodder$@s) {
	    $perlbuginversion5003fodder++;
	} elsif ($doc =~ m@^\\page\s+([\w\.-]+)\s+(.*?)\s*$@s) {
            # it's a \page
	    $pages{$1} = $2 . "\n";
	    $anchor{$1} = $1;
	    $skip = 1;
	} elsif ($doc =~ m@^\\base64\s+([\w\.-]+)\s+(.*?)\s*$@s) {
            # it's a \base64
	    my ( $warwick, $sharon );
	    $warwick = $1;
	    $sharon = $2;
	    $#_ = -1;
	    foreach ( split( /\n/, $sharon ) ) {
		s/\s//g;
		tr|A-Za-z0-9+/| -_|;
		push @_, pack( "c", 32 + 0.75 * length $_ ) . $_;
	    }
	    $pages{$warwick} = unpack( "u", join( "\n", @_, "" ) );
	    $anchor{$warwick} = $warwick;
	    $skip = 1;
	} elsif ( $doc =~ m@^\\defgroup\s+([\w\.-]+)\s+(.*?)\s*$@s ) {
	    # it's a \defgroup
	    $pages{$1} = "<title>" . $module_long .
		" - group index</title>" . $style . "
</head><body bgcolor=\"#ffffff\">\n" . $postheader . "\n"
		    . $2;
	    $classes{$1} = "";
	    $skip = 1;
	} elsif ( $doc =~ m@^\\enum\s+(\w+)::([\w_]+)\s+(.*?)\s*$@s ) {
	    # it's a \enum
	    my( $class, $member, $enumdoc ) = ( $1, $2, $3 );
	    $skip = 1;
	    my $globalname = $class . "::" . $member;
	    my $url = &mangleclass( $globalname ) . "#" . $member;
	    $urls{$globalname} = $url;
	    $name{$url} = $class . "::" . $member;;
	    $type{$url} = "enum";
	    $doc{$url} = $enumdoc;
	    $urls{$url} = $url;
	} elsif ($doc =~ m@^\\example\s+([\w\./]+)\s+(.*?)\s*$@s) {
	    # it's an example file
	    $examples{$1} = $2;
	    $skip = 1;
	} else {
	    # it's a function, \fn or real?
	    $doc .= "\n";
	    $overload = 0;
	    if ($doc =~ /^\\overload\s+([^;\n\(\)]+(?:\(\s*\)\s*)?\([^\);]*\)\s*(?:const)?);?\s+(.*?)\s*$/s) {
		$def = $1;
		$doc = "This is an overloaded member function, provided for convenience.  It differs from the above function only in what argument(s) it accepts.\n\n" . $2;
		$overload = 1;
	    } elsif ($doc =~ /^\\overload\s*\n\s*(.*?)\s*$/s) {
		$doc = "This is an overloaded member function, provided for convenience.  It differs from the above function only in what argument(s) it accepts.\n\n" . $1;
		$overload = 1;
	    } elsif ($doc =~ /^\\fn\s+([^;\n\(\)]+(?:\(\s*\)\s*)?\([^\);]*\)\s*(?:const)?);?\s+(.*?)\s*$/s) {
		$def = $1;
		$doc = $2;
	    }

	    print $def, "\n" if ( $def =~ /newTypeEntry/ );
	    $def =~ s/\s+throw\b.*$//;
	    print $def, "\n" if ( $def =~ /newTypeEntry/ );
	    ($name, $args) = split(/\s*\((?=[^\(]+\s*$ )/x, $def);
	    if ($name =~ /^\s*(\w+)\s*::operator\s*([\s\w\*\&]+)$/s) {
		$type = $2;
		$class = $1;
		$name = "_cast";
	    } elsif ($name =~ /^\s*(.*?[ \*\&])
		\s*((?:\w+::)?)
		((?:(?:operator\s*(?:(?:\(\s*\))|(?:[^\s\(]{1,3})))
		  |(?:(?:\~?\w+))))$/sx) {
		$type = $1;
		$class = $2;
		$name = $3;
		$class =~ s/:://;
		$type =~ s/^\s+//;
		$type =~ s/\s+$//;
	    } elsif ($name =~ /^\s*(?:virtual\s+)?(\w+)\s*::\s*(\~?\w+)$/s) {
		$type = "";
		$class = $1;
		$name = $2;
	    } else {
		print "skipped: ", &cwd(), "/", $filename, ": ", $def, "\n", $doc, "\n";
		$skip = 1;
	    }
	    $args =~ s/([^:]):[^:].*/$1/s;
	    $args =~ s/\s*([\*\&]+)\s*/ $1 /sg;
	    $args =~ s/\s+,/,/sg;
	    if ($args =~ /^\s*(.*?)\s*\)\s*((?:const)?)\s*?$/s) {
		$args = $1;
		$const = $2;
	    } else {
		$skip = 1;
	    }

	    if (($skip == 0)) {
		if (!($type =~ /\bstatic\b/)) {
		    if ($args =~ /[()]/) {
			print STDERR "function prototype in argument\n", $def;
		    } else {
			my ($url, $home);

			if ($doc =~ /\\relate[ds]\s+(\w+)/s) {
			    $home = &mangleclass($1);
			} else {
			    $home = &mangleclass($class);
			}
			$url = &manglefn($type, $class, $name,
					 $args, $const, $home);
			if (defined($name{$url})) {
			    print "$filename: $def ($url - $name{$url}) documented twice\n";
			} else {
			    $name{$url} = $class . "::" . $name;
			    $type{$url} = "fn";
			    $doc{$url} = $doc;
			    $overload{$url} = 1 if ($overload);
			    $class .= "::" if ($class ne "");
			    $const = " " . const if ($const ne "");
			    if ($name eq "_cast") {
				$def{$url} = join("", $class, "operator ",
						  $type, " ()", $const);
			    } else {
				$args =~ s/\s\s+/ /gs;
				$def{$url} = join("", $type, " ", $class,
						  $name, "(", $args, ")",
						  $const);
			    }
#			    print "url: ", $url, " is ", $def{$url}, "\n";
			}
		    }
		}
	    }
	}
    }
}


sub makenames {
    local($_, $dum, $ferdig, $anchor);

    foreach ( sort keys %name ) {
	$anchor{$name{$_}} = $_ if ( (!/^globals.html/) &&
				     !defined($anchor{$name{$_}}) &&
				     !defined($overload{$_}) &&
				     $doc{$_} =~ /[A-Za-z]+/s );
    }

    # next, we do a good imitation of c++ inheritance... subclasses:
    foreach ( keys %inheritance ) {
	my ($c, $i);
	$i = $inheritance{$_};
	$i =~ s/((?:(?:^)|(?:,)))\s*\w+\s+(?=\w)/$1/sg;
	foreach $c ( split ( /\s*,\s*/, $i ) ) {
	    if (defined($subclasses{$c})) {
		$subclasses{$c} .= " " . $name{$_};
	    } else {
		$subclasses{$c} = $name{$_};
	    }
	}
    } # and members
    $ferdig = 0;
    while ($ferdig == 0) {
	my ($url, $class, $member, $possible);
	$ferdig = 1;
	foreach $url ( keys %urls ) {
	    next unless (($type{$urls{$url}} eq "fn") ||
			 ($type{$urls{$url}} eq "enum"));
	    $member = $class = $url;
	    $class =~ s/::.*//;
	    $member =~ s/\(.*//;
	    $member =~ s/^.*:://;
	    next if (($member eq $class) || ($member eq "~".$class));
	    foreach ( split( /\s+/, $subclasses{$class} ) ) {
		$possible = $url;
		$possible =~ s/^$class:/$_:/;
		$possible =~ s/~$class\b/~$_\b/
		    if (("~" . $class) eq $member);
		if ( defined( $virtual{$urls{$url}} ) &&
		    !defined( $virtual{$urls{$possible}} ) ) {
		    $virtual{$urls{$possible}} = $virtual{$urls{$url}};
		    $ferdig = 0;
		}
		unless (defined($anchor{$_ . "::" . $member})) {
		    $urls{$possible} = $urls{$url};
		    $anchor{$_ . "::" . $member} = $urls{$url};
		}
	    }
	}
    }

    foreach ( keys %headerfiles ) {
	unless (defined($anchor{$_})) {
	    $anchor{$_} = $headerfiles{$_};
	    $type{$anchor{$_}} = "header";
	}
    }

    foreach ( keys %examples ) {
	unless (defined($anchor{$_})) {
	    $dum = $_;
	    s@/@-@;
	    s/\.cpp$/-cpp.html/;
	    $anchor{$dum} = $_;
	    $type{$_} = "example";
	}
    }

#   foreach ( sort keys %anchor ) { print $_, ": ", $anchor{$_}, " - ", $name{$anchor{$_}}, "\n"; }
}







#
# add links and escapes to a string
#
sub al {
    local ($_, $class) = @_;

    s-(?:(?:[\w:]+)|(?:[&<>]))-
    {
	if (defined($anchor{$class . "::" . $&}) &&
	    $type{$anchor{$class."::".$&}} ne "fn") {
	    sprintf("<a href=\"%s\">%s</a>",
		    $anchor{$class."::".$&}, &html($&));
	} elsif (defined($anchor{"::" . $&}) &&
	    $type{$anchor{"::".$&}} ne "fn") {
	    sprintf("<a href=\"%s\">%s</a>", $anchor{"::".$&}, &html($&));
	} elsif (defined($anchor{$&}) &&
		 $type{$anchor{$&}}) {
	    sprintf("<a href=\"%s\">%s</a>", $anchor{$&}, &html($&));
	} else {
	    &html($&);
	}
    }
    -egs;
    $_;
}


#
# add <a href> to args where appropriate and html-encode
#
sub makearglinks {
    local($_, $pre, $name, $post, $class, $anchor);

    foreach (sort keys %type) {
	if ($type{$_} eq "fn" &&
	    $def{$_} =~ /^([^\~\(:]*)\s+
	    ((?:\w+::)?(?:(?:operator(?:(?:\(\s*\))|(?:[^\s\(]{1,3})))
			|(?:(?:\~?\w+))))\s*
	    (\(.*)/sx) {
	    $pre = $1;
	    $name = $2;
	    $post = $3;
	    if (defined($home{$_})) {
		$class = $home{$_};
	    } else {
		$class = $name;
		$class =~ s/::.*//;
	    }
	    if (defined($anchor{$class})) {
		$anchor = $anchor{$class};
		undef $anchor{$class};
		$def{$_} = join(" ", &al($pre, $class), &html($name),
				&al($post, $class));
		$anchor{$class} = $anchor;
	    } else {
		$def{$_} = join(" ", &al($pre, $class), &html($name),
				&al($post, $class));
	    }
	}
    }
}




#
# add default values to arguments, from .h argument list
#
# note that argument names aren't touched, just default values
sub fixdefvalues {
    local ($url, $args) = @_;
    local (@ha, @ca, $_, $changed);

    return if ( $args eq ")(" ); # operator()()

    if (defined($def{$url})) {
	@ha = split(/\,/, $args);
	$_ = $def{$url};
	s/.*\(//s;
	s/\).*//s;
	@ca = split(/\,/, $_);
#print "url: ", $def{$url}, "\n";
	die ("argument mismatch:\n" . $args . "\n" . $_ . "\n")
	    if ($#ha != $#ca);

	$changed = 0;
	foreach ( 0 .. $#ha ) {
	    if ( $ha[$_] =~ /\s*=.*$/ ) {
		$ca[$_] .= $&;
		$changed++;
	    }
	}
	if ($changed > 0) {
#print "changed ", $def{$url};
	    $args = join(",", @ca);
	    $def{$url} =~ s/\(.*?\)/($args)/s;
#print " to ", $def{$url}, "\n";
	} else {
#print "unchanged: ", $def{$url}, "\n";
	}
    }
    $args;
}


#
# as in 'sort weirdly keys %type'
#
sub weirdly {
    local ($aa, $bb);

    $aa = $name{$a};
    $aa =~ s/::~/::_/;
    $aa =~ s/[a-zA-Z]*::/::/;
    $bb = $name{$b};
    $bb =~ s/::~/::_/;
    $bb =~ s/[a-zA-Z]*::/::/;
    if ( defined($internal{$a}) && !defined($internal{$b}) ) {
	return 1;
    } elsif ( !defined($internal{$a}) && defined($internal{$b}) ) {
	return -1;
    } elsif ($aa eq $bb) {
	if (defined($overload{$b})) {
	    if (defined($overload{$a})) {
		return ($def{$a} cmp $def{$b});
	    } else {
		return (-1);
	    }
	} else {
	    if (defined($overload{$a})) {
		return (1);
	    } else {
		return ($def{$a} cmp $def{$b});
	    }
	}
    } else {
	return ($aa cmp $bb);
    }
}


sub simpler {
    my ($string, $file) = @_;

    $string =~ s/<a href=\"$file\#/<a href=\"\#/g;
    $string;
}


sub printclass {
    local ( $url ) = @_;
    local ( $class, $file, $tail, $fnheader );
    my %enumdocs;
    my %fndocs;

    $class = $name{$url};

    if (!$internal && ($doc{$url} =~ /^\s*$/)) {
	print "skipping internal class ", $class, " (no class documentation)\n";
	next;
    }

    die "$class ($url) is not a class" if ( $type{$url} ne "class" );

    $file = $url;
    $file =~ s/#.*//;
    open( O, "> $outputdir/$file")
		|| die "can't open $outputdir/$file for writing,";

    $documented{$url}++;

    $fnheader = "<hr><h2>Member Function Documentation</h2>\n";
    $tail = $footer;
    $tail .= $address;

    print O $doctype, "<html><head>\n<title>", $module_long, " - ",
    $class,
    " Class</title>", $style, "
</head><body bgcolor=\"#ffffff\">\n", $postheader, "\n",
    "<h1 align=center>", $name{$url}, " Class Reference</h1><br clear=\"all\">\n";

    my ($i, $family);
    if (defined($brief{$url})) {
	print O "<p>\n", &simpler( $brief{$url}, $file ), "\n";
	if ( defined( $extension{$url} ) ) {
	    print O "This class is part of the <b>Qt ", $extension{$url}, " Extension.</b>\n";
	}
	print O "<a href=\"#details\">More...</a>\n"
	    if ($doc{$url} ne "");
    }
    print O "<p>\n<code>#include &lt;<a href=\"", $headerfiles{$includefile{$url}}, "\">", $includefile{$url}, "</a>&gt;</code>\n" if (defined($includefile{$url}));
    if ($relations{$name{$url}} =~ /\S/s) {
	my($relatives, $name, $header);
	$relatives = "<hr><h2>Related Functions</h2>\n";
	$family = "<h2>Related Functions</h2>\n(Note that these are not member functions.)\n<ul>";
	foreach ( split( /\s+/, $relations{$name{$url}} ) ) {
	    $name = $_;
	    $documented{$_}++;
	    $name =~ s/^[^\#]*\#//;
	    $header = $def{$_};
	    $header =~ s;([^\(]*\s)\b(\S+);$1<a name=\"$name\"></a>$2;s;
	    $relatives = join ("", $relatives, "<h3>", $header,
			       "</h3>\n<p>", $doc{$_}, "\n");
	    $header = $def{$_};
	    $header =~ s@</?a.*?>@@gs; #okok, so it is stupid
	    $header =~
		s;([^\(]*\s)\b(\S+);$1<a href=\"$url#$name\"><b>$2</b></a>;s;
	    $family = join( "\n<li>", $family, $header);
	}
	$tail = join("", $relatives, $tail);
	$family = join ("", $family, "\n</ul>\n");
    }

    $i = "";
    foreach ( sort split(/\s*\,\s*/, $inheritance{$url}) ) {
	my ($im, $ic);
	if (/(\w+)\s+(\w+)/) {
	    $im = $1;
	    $ic = $2;
	} else {
	    $ic = $_;
	    $im = "public";
	}
	if (($ic ne "") && ($im eq "public")) {
	    if (defined($capt{$ic})) {
		$i = join ("", $i, ", ", &al($ic), " (", $capt{$ic}, ")");
	    } else {
		$i = join ("", $i, ", ", &al($ic));
	    }
	}
    }
    if ($i ne "") {
	$i =~ s/^\,\s*//;
	$i =~ s/\,([^,]+)$/ and$1/;
	print O "<p>\nInherits ", $i, ".\n";
    }

    if ($subclasses{$name{$url}} =~ /\S/) {
	my ($ic);
	$i = "";
	foreach $ic ( sort split(/\s+/, $subclasses{$name{$url}}) ) {
	    if (defined($capt{$ic})) {
		$i = join ("", $i, ", ", &al($ic), " (", $capt{$ic}, ")");
	    } else {
		$i = join ("", $i, ", ", &al($ic));
	    }
	}
	$i =~ s/^\,\s*//;
	$i =~ s/\,([^,]+)$/ and$1/;
	print O "<p>Inherited by ", $i, ".\n";
    }

    $_ = $file;
    s/\.html/-members.html/;
    print O "<p><a href=\"", $_, "\">List of all member functions.</a>\n";

    die "no members in class $class" unless (defined($members{$url}));

    my (%m, $mode, $foreplay, $afterglow);
    undef %m;
    $mode = "Private";
    foreach (split(/;/, $members{$url})) {
	$mode = ucfirst($1)
	    while (s/^\s*((?:
			   (?:private\b\s*?)|
			   (?:protected\b\s*?)|
			   (?:public\b\s*?)|
			   (?:signals\b\s*?)|
			   (?:slots\b\s*?))+):\s*//sx);
	next if (/^\s*friend\b/);
	$mode =~ s/slots/Slots/;
	$mode =~ s/Qp/P/;
	if (/((^)|([^\(]*\b))static\b/) {
	    s/(\s*)static\s*/$1/;
	    $m{"Static ".$mode} .= $_ . ";";
	} else {
	    $m{$mode} .= $_ . ";";
	}
    }

    $m{'Important Inherited'} = $importants{$url};

    foreach $mode ('Public', 'Public Slots', 'Signals',
		   'Static Public', 'Important Inherited', 'Protected',
		   'Protected Slots', 'Static Protected',
		   'Private', 'Private Slots', 'Static Private') {
	my ($e1, $e2);
	next unless (defined($m{$mode}));
	$_ = $mode;
	$_ .= " Members" if (!/s$/);
	$foreplay = join("", "<h2>", $_, "</h2>\n<ul>\n");
	$afterglow = "";
	foreach (split (/;/, $m{$mode})) {
	    next if ($mode =~ /rivate/ && !$internal);

	    $countall++;

	    s/\s*([\(\)]+\s*)/ $1 /g;
	    s/\s*([,\*\&]+\s*(?!=))/$1 /g;
	    s-\s*//.*?\n\s*--;
	    s/^\s+//;
	    s/\s+$//;
	    s/\s+/ /g;
	    s/\)\s*:\s*[A-Q].*/\)/;
	    s/\s+throw\b.*$//;

	    if (/^operator\s+([\w\s\*\&]+?)\s*\(\s*\)\s*((?:const)?)\s*$/s) {
		my($u, $r, $c);
		$r = $1;
		$c = $2;
		$u = &manglefn($r, $name{$url},
			       "_cast", "", $c);
		if ( $type{$u} eq "fn" && $doc{$u} =~ /[a-z]/si ) {
		    if ( defined($internal{$u}) ) {
			$_ = join("", "operator <b>", &html($r), "</b> ()",
				  $c, " (internal)");
		    } else {
			$_ = join("", "operator <a href=", $u, "><b>",
				  &html($r), "</b></a> ()", $c);
		    }
		    $fndocs{$u} = $mode;
		} else {
		    print "undocumented: ", $name{$url}, "::operator ", $r,
		        " () ", $c, "\n" if ($errmsg++<$maxerr);
		    $_ = join("", "operator <b>", &html($r),
			      "</b> ()", $c);
		}
	    } elsif (/^\s*((?:[^\(\~]*[\s\&\*]+)?)(?=[\w~]) (?# prelude
							     )
		     ((?:(?:operator(?:(?:\(\s*\))|(?:[^\s\(]{1,3})))
		       |(?:\~?\w+)))                        (?# name
							     )
		     \s*\((.*?)\)\s*(const)?\s*(?:=\s*0\s*)?$/x) {
		my ($u,$t,$mt,$f,$a,$ma,$c);
		$t = $1;
		$f = $2;
		$a = $3;
		$c = $4;

		$a =~ s/^\s+//s;
		$a =~ s/\s+$//s;
		$a =~ s/\s*([\*\&]+)\s*/ $1 /g;
		$a =~ s/\s+,/,/sg;

		if ( defined( $importantyuck{$name{$url} . "::" . $f} ) ) {
		    my $yuck = $importantyuck{$name{$url} . "::" . $f};
		    $u = &manglefn($t, $yuck, $f, $a, $c);
		} else {
		    $u = &manglefn($t, $class, $f, $a, $c);
		    $u = $url if ( !( $u =~ /^$url\#/ ) ); # any non-function
		}
		$t =~ s/^(?:virtual\s*)?/virtual /
		    if ( defined($virtual{$u}) );
		&fixdefvalues($u, $a) if ($type{$u} eq "fn");
		if ( $type{$u} eq "fn" && $doc{$u} =~ /[a-z]/si ) {
		    if ( defined( $internal{$u} ) ) {
			# maybe we should delete argument names and
			# values for these.  but I'm too lazy to do it
			# now.
			#$a =~ s/\s*=[^,]*(?=,)//g;
			#$a =~ s/\s*=[^\)]*\))/ /g;
			$_ = join("", &html($t), "<b>",
			      &html($f), "</b> (",
			      &html($a), ") ", $c, " (internal)" );
		    } elsif ( defined( $templatecookie{$url} ) ) {
			# only for templates: promote the .cpp variable names
			$a = $def{$u};
			$a =~ s/^.*?\((\)\()?\s*//s;
			$a =~ s/\s*\).*?$//s;
			$a =~ s-<a href=.*?>(.*?)</a>-$1-g;
			$_ = join("", &html($t), "<a href=\"", $u,
				  "\"><b>", &html($f),
				  "</b></a> (", $a,
				  ") ", $c);
		    } else {
			$_ = join("", &html($t), "<a href=\"", $u,
				  "\"><b>", &html($f),
				  "</b></a> (", &html($a),
				  ") ", $c);
		    }
		    $fndocs{$u} = $mode;
		    # second uglest hack in qdoc
		    if ($doc{$u} =~ /^<b>This function is obsolete./si ) {
			s/<[^>]*>//g;
			$_ .= " <em>(obsolete)</em>";
		    }
		} else {
		    print "undocumented: ", $t," ", $name{$url}, "::", $f,
		        " (",$a,") ", $c, "\n" if ($errmsg++<$maxerr);
		    $_ = join("", &html($t), "<b>",
			      &html($f), "</b> (",
			      &html($a), ") ", $c);
		}
		if ( defined( $reimp{$u} ) ) {
		    # for reimps, say nothing at all
		    $_ = "";
		}
	    } elsif ( /^\s*enum\s+(\w+)/s ) {
		my($name);
		$name = $1;
		$_ = &html($_);
		if ( defined( $anchor{$class . "::" . $name} ) ) {
		    my $url = $anchor{$class . "::" . $name};
		    s;\b$name\b;<a href=\"$url\"><b>$name</b></a>;s;
		    $enumdocs{$url} = $name;
		} else {
		    s;\b$name\b;<b>$name</b>;s;
		}
	    } elsif (/^\s*enum\s*\{/s) {
		$_ = &html($_); # don't do anything, but it's legal
	    } elsif ( /^\s*typedef\b.*\b([A-Z][a-zA-Z]*)$/s &&
		      defined( $anchor{$class . "::" . $1} ) ) {
		my $name = $1;
		$enumdocs{$file . "#" . $name} = $name;
		s;\b$name\b;<a href=\"\#$name\"><b>$name</b></a>;s;
	    } else {
		$_ = "";
	    }
	    if (/\S/s) {
		s/\(\s*/\( /s;
		s/\s*\)/ \)/s;
		s/\(\s+\)/\(\)/s;
		s/ +//gs; # to nbsp
		s/,/, /gs; # from nbsp
		s/<a/<a /gs;
		s/<a href=\"$file\#/<a href=\"\#/gs;
		print O $foreplay, "<li><span class=\"fn\">", $_, "</span>\n";
		$foreplay = "";
		$afterglow = "</ul>\n";
	    }
	}
	print O $afterglow;
    }
    if ($family =~ /\S/s) {
	print O $family;
    }

    if ($properties{$url}) {
	# Just a quick hack to show the properties. No links.
	print O "<h2>Properties</h2>\n";
	my $p;
	print O "<table border=1 cellpadding=3 cellspacing=0>\n";
	print O "<tr><th>Type<th>Name<th>READ<th>WRITE<th>Options\n";
	for $p ( split "\n", $properties{$url} ) {
	    my ($rtype, $name, $opt) =
		$p =~ m/^(\w+)\s+(\w+)\s+(.*)$/;
	    my $get = $opt =~ s/(.*?)\s*\bREAD\s+(\w+)(.*)/$1$3/ ? $2 : "&nbsp;";
	    my $set = $opt =~ s/(.*?)\s*\bWRITE\s+(\w+)(.*)/$1$3/ ? $2 : "&nbsp;";
	    if (!$opt) {
		$opt = "&nbsp;";
	    }
	    print O "<tr><td>$rtype<td>$name<td>$get<td>$set<td>$opt\n";
	}
	print O "</table>\n";
    }


    if ($brief{$url} =~ /\S/s) {
	print O "<hr><h2><a name=\"details\"></a>Detailed Description</h2>\n";
	if ( defined( $extension{$url} ) ) {
	    print O "This class is defined in the <b>Qt ", $extension{$url};
	    print O " Extension</b>, which can be found in the <tt>qt/extensions</tt> directory.\nIt is not included in the main Qt API.\n<p>\n";
	}
	print O &simpler( $brief{$url}, $file ), "\n<p>\n"
	  , &simpler( $doc{$url}, $file ), "\n";
    } else {
	print O "<hr><h2>Detailed Description</h2>\n"
	  , &simpler( $doc{$url}, $file ), "\n";
    }

    if ( keys %enumdocs ) {
	print O "<hr><h2>Member Type Documentation</h2>\n";
	foreach $url ( sort keys %enumdocs ) {
	    print O "<h3 class=\"fn\"><a name=\"", $enumdocs{$url}, "\">";
	    print O $class, "::", $enumdocs{$url}, "</a></h3>\n"
	      , &simpler( $doc{$url}, $file );
	}
    }

    foreach $url ( sort weirdly grep( /^$url\#/, keys %fndocs ) ) {
	next unless ($doc{$url} =~ /\S/s);

	$documented{$url}++;
	$countdoc++;

	my ($name, $class, $reimp, $protection);
	$class = $url;
	$class =~ s/\#.*//;
	$class = $name{$class} . "::";
	$protection = lc $fndocs{$url};
	$protection =~ s/\s*public\s*//;
	$protection = "virtual " . $protection
	    if ( defined($virtual{$url}) );
	$protection =~ s/s?\s*$//;
	$protection =~ s/ +//; # nbsp
	$protection = " <code>[" . $protection . "]</code>"
	    if ($protection ne "");
	$_ = $def{$url};
	if ( /$class/ ) {
	    my( $p, $r );
	    $name = $url;
	    $name =~ s/^[^\#]*\#//;
	    print O $fnheader;
	    $fnheader = "";
	    s/^\s*//;
	    s;([^\(]*)\b(\S+::\S+);$1<a name=\"$name\"></a>$2;s;
	    s/\(\s*/\( /s;
	    s/\s*\)/ \)/s;
	    s/\(\s+\)/\(\)/s;
	    s/ +//gs; # to nbsp
	    s/,/, /gs; # from nbsp
	    s/<a/<a /gs;
	    print O "<h3 class=\"fn\">",$_,$protection,"</h3>\n<p>"
	      ,&simpler( $doc{$url}, $file );

	    $p = "<p>";
	
	    if ( defined($virtual{$url}) ) {
		if ( $virtual{$url} ne $url ) {
		    $name = $name{$virtual{$url}};
		    $class = $name;
		    $class =~ s/::.*//;
		    print O $p, "Reimplemented from <a href=\""
			, $virtual{$url}, "\">", $class, ".</a>\n";
		    $p = "";
		}
		if ( defined($reimplementations{$url}) ) {
		    print O $p, $reimplementations{$url}, ".\n";
		}
	    }
	}
    }

    print O $tail;

    close(O);
}



sub reimplementations {
    my ($r, $n, $c);

    foreach $r ( keys %virtual ) {
	if ($r ne $virtual{$r} &&
	    $type{$r} eq "fn" &&
	    $doc{$r} =~ /\S/ ) {
	    $n = $name{$r};
	    $n =~ s/::.*//;
	    $reimplementations{$virtual{$r}} .=
		", <a href=\"" . $r . "\">" . $n . "</a>";
	}
    }

    foreach $r ( keys %reimplementations ) {
	$reimplementations{$r} =~ s/^\,\s*/Reimplemented in /;
	$reimplementations{$r} =~ s/\,([^,]+)$/ and$1/;
    }
}


sub importants {
    my $url;
    my $i;
    my $p;
    my $class;
    foreach $url ( keys %important ) {
	$class = $name{$url};
	foreach $i ( split( /\s+/s, $important{$url} ) ) {
	    $p = $class . "::" . $i;
	    if ( defined( $anchor{$p} ) && $type{$anchor{$p}} eq "fn" ) {
		my $y;
		next if ( $p eq $class );
		$y = $anchor{$p};
		$y =~ s/\#.*//;
		$y = $name{$y};
		$importantyuck{$p} = $y;
		$p = $y . "::" . $i;
		my $fn;
		foreach $fn ( sort { $def{$a} cmp $def{$b} } keys %doc ) {
		    next unless ( $type{$fn} eq "fn"  &&
				  $def{$fn} =~ /\b$p\b/ );
		    # uglest hack in qdoc.  possibly.
		    next if ($doc{$fn} =~ /^<b>This \S+ is obsolete./si );
		    my $f;
		    $f = $def{$fn};
		    $f =~ s/<[^>]*>//g;
		    $f =~ s/\&amp;/\&/g;
		    $f =~ s/\&lt;/</g;
		    $f =~ s/\&gt;/>/g;
		    $f =~ s/[a-zA-Z]+:://;
		    $f =~ s/\s+=[^,]+,/,/g;
		    $importants{$url} .= $f . ";";
		}
	    } else {
		print "did not find important function ", $p, " (", $anchor{$p}, ")\n";
	    }
	}
    }
}


sub classlist {
    my $result, @classurls, @colindex, $tmp, $i, $done, $url;

    @classurls = sort grep {
	(($type{$_} eq "class") && defined($documented{$_})) } keys %type;

    # Find longest common prefix (eg. "Q")
    $prefix = $classurls[$#classurls-1];
    $url = $classurls[0];
    # shorten the assumed prefix until it is an actual prefix
    $prefix =~ s/.$// while( $prefix ne substr( $url, 0, length $prefix ) );
    $prefix_length = length $prefix;




    # find out where each column starts

    $i = 0;
    $tmp = 0;
    $colindex[$i++] = 0;

    $tmp = sprintf("%d",$tmp+($#classurls-$tmp)/5-1); # end of first column - approximately
    $tmp++ while( substr( $classurls[$tmp  ], $prefix_length, 1 ) eq
		  substr( $classurls[$tmp+1], $prefix_length, 1 ) );
    $colindex[$i++] = $tmp+1;

    $tmp = sprintf("%d",$tmp+($#classurls-$tmp)/4-1); # end of next column
    $tmp++ while( substr( $classurls[$tmp  ], $prefix_length, 1 ) eq
		  substr( $classurls[$tmp+1], $prefix_length, 1 ) );
    $colindex[$i++] = $tmp+1;

    $tmp = sprintf("%d",$tmp+($#classurls-$tmp)/3-1); # end of next column
    $tmp++ while( substr( $classurls[$tmp  ], $prefix_length, 1 ) eq
		  substr( $classurls[$tmp+1], $prefix_length, 1 ) );
    $colindex[$i++] = $tmp+1;

    $tmp = sprintf( "%d", $tmp+($#classurls-$tmp)/2-1 ); # end of next column
    $tmp++ while( substr( $classurls[$tmp  ], $prefix_length, 1 ) eq
		  substr( $classurls[$tmp+1], $prefix_length, 1 ) );
    $colindex[$i++] = $tmp+1;

    $colindex[$i++] = $#classurls+1;

    # build the table
    $result = "<table>\n";
    $i = 0;
    $done = 0;
    while( !$done ) {
	my $col;
	$done = 1;
	$result = join( "", $result, "<tr>\n" );
	foreach $col ( 0 .. $#colindex-1 ) {
	    my $j;
	    $j = $colindex[$col] + $i;
	    $result = join( "", $result, "<td>" );
	    $result = join( "", $result, "<b>",
			    uc substr( $classurls[$j], $prefix_length, 1 ),
			    "</b>" )
	      if ( $j < $colindex[$col+1] &&
		   ( $j == 0 ||
		     ( substr( $classurls[$j-1], $prefix_length, 1 ) ne
		       substr( $classurls[$j], $prefix_length, 1 ) ) ) );
	    $result = join( "", $result, "</td>\n<td>" );
	    if ( $j < $colindex[$col+1] ) {
		my $ex, $n, $url;
		$url = $classurls[$j];
		$ex = defined( $extension{$url} ) ? "*" : "";
		$n = $name{$url};
		$result = join( "", $result, "<a href=\"", $url, "\">",
				$n, $ex, "</a>" );
		$done = 0;
	    }
	    $result = join( "", $result, "</td>\n" );
	}
	$result = join( "", $result, "</tr>\n" );
	$i++;
    }
    $result = join( "", $result, "</table>\n" );

    # strip it of unnecessary cells
    $result =~ s-(?:<td>\s*</td>\s*)+</tr>-</tr>-gs;
    $result =~ s-<tr>\s*</tr>\s*--gs;

    # and return it
    $result;
}


sub extensionlist {
    my $resulto,%x;
    %x = map { $_=>1 } values %extension;
    foreach $ext ( sort keys %x ) {
	$result .= ", " if $result;
	$result = "* Extensions classes of " if !$result;
	$result .= $ext;
    }
    $result;
}


sub annotatedclasslist {
    my $result;
    my ($pre, $preline, $sep, $postline, $post) = @_;
    $result = $pre;
    foreach $url ( sort keys %type ) {
	if (($type{$url} eq "class") && defined($documented{$url})) {
	    $ex = "";
	    if ( defined( $extension{ $url } ) ) {
		$ex = " <small><b>[Qt $extension{$url} Extension]</b></small>";
	    }
	    $result = join( "", $result,  "$preline<b><a href=\"",
			   $url, "\">", $name{$url}, "</a></b>$sep",
			   $capt{$url}, $ex, "$postline" )
		if ( $capt{$url} =~ /\S/ );
	}
    }
    $result .= $post;
    $result;
}


sub headerfilelist {
    my $result = "<ul>\n";
    foreach $filename ( sort keys %headerfiles ) {
	$_ = $filename;
	s/\./-/;
	s/$/.html/;
	$result = join( "", $result,
		       "<li><a href=\"", $_, "\">", $filename, "</a>\n" );
    }
    return $result . "</ul>\n";
}


sub headerindex {
    local($filename);
    open(O, "> $outputdir/headers.html")
	|| die "can't open $outputdir/headers.html for writing";
    print O $doctype, "<html><head><title>", $module_long, " - header file index</title>", $style, "
</head><body bgcolor=\"#ffffff\">\n", $postheader, "\n<h1 align=center>", $module, " header file index</h1><br clear=\"all\">\n<p>Here are the header files that make up the ", $module, " API:\n<ul compact>";
    foreach $filename ( sort keys %headerfiles ) {
	$_ = $filename;
	s/\./-/;
	s/$/.html/;
	print O "<li><a href=\"", $_, "\">", $filename, "</a>\n";
    }
    print O "</ul>\n", $address;

    close(O);
}



sub exampleindex {
    local($filename);
    open(O, "> $outputdir/examples.html")
	|| die "can't open $outputdir/examples.html for writing";
    print O $doctype, "<html><head><title>", $module_long, " - Example Programs</title>", $style, "
</head><body bgcolor=\"#ffffff\">\n", $postheader, "\n<h1 align=center>", $module, " Example Programs</h1><br clear=\"all\">\n<p>Here are some of the example programs that are included with ", $module, ":\n<ul compact>";
    foreach $filename ( sort keys %examples ) {
	$_ = $filename;
	$htmlfilename = $filename;
	$htmlfilename =~ s@/@-@;
	$htmlfilename =~ s/\.cpp/-cpp.html/;
	print O "<li><a href=\"", $htmlfilename, "\">", $filename, "</a>\n";
    }
    print O
"</ul>
<p>
These paths are relative to the <code>examples</code> subdirectory in the ", $module, "
distribution. You will find Makefiles, header files and so on there.
Only the most relevant code is here.
", $address;

    close(O);
}



#	$doc =~ s!\\classhierarchy!&classhierarchy()!es;

#
# make a semi-graphical inheritance tree
#
sub classhierarchy {
    my $result;
    $result = "<ul plain>\n";
    foreach ( sort keys %members ) {
	$result = join( "", $result, &classinheritance( $name{$_} ))
	    if (($type{$_} eq "class") &&
		(defined($documented{$_})) &&
		!($inheritance{$_} =~ /\S/s));
    }
    foreach ( sort keys %members ) {
	print "Not in hierarchy index page: ", $name{$_}, "\n"
	    if (($type{$_} eq "class") &&
		(defined($documented{$_})) &&
		!defined($classtree{$name{$_}}));
    }
    $result .= "</ul>";
    $result;
}

sub classinheritance {
    my($class) = @_;
    local($_);
    my $result;
    $result = "";

    if ($inheritance{$_} =~ /\S/s) {
	$_ = $inheritance{$_};
	s/,.*//s;
	s/^\s*\w+\s+//s;
	&classinheritance($_) unless (defined($classtree{$_}));
    }

    unless (defined($classtree{$class}) || $doc{$anchor{$class}} =~ /^\s*$/s) {
	$classtree{$class}++;
	$result = "<li><a href=\"$anchor{$class}\">$class</a>\n";
	if ($subclasses{$class} =~ /\S/s) {
	    $result .= "<ul plain>\n";
	    foreach ( sort split(/\s+/, $subclasses{$class} ) ) {
		if ($inheritance{$anchor{$_}} =~ /,.*$class/s) {
		    $result .= "<li><a href=\"$anchor{$_}\">$_</a>\n";
		} else {
		    $result .= &classinheritance( $_ );
		}
	    }
	    $result .= "</ul>\n";
	}
    }
    $result;
}


#
# make a semi-graphical inheritance tree
#
sub inheritanceindex {
    open(O, "> $outputdir/hierarchy.html")
	|| die "can't open $outputdir/hierarchy.html for writing";
    print O $doctype, "
<html>
<head><title>", $module_long, " - Class Hierarchy</title>", $style, "
</head>
<body bgcolor=\"#ffffff\">\n", $postheader, "
<h1 align=center>", $module, " Class Hierarchy</h1><br clear=\"all\">

<p>This inheritance list is sorted roughly, but not completely,
alphabetically.

<ul plain>
";
    foreach ( sort keys %members ) {
	&doclassinheritance( $name{$_} ) if (($type{$_} eq "class") &&
					     (defined($documented{$_})) &&
					     !($inheritance{$_} =~ /\S/s));
    }
    foreach ( sort keys %members ) {
	print "Not in hierarchy index page: ", $name{$_}, "\n"
	    if (($type{$_} eq "class") &&
		(defined($documented{$_})) &&
		!defined($classtree{$name{$_}}));
    }
    print O "</ul>", $address;
    close O;
}

sub doclassinheritance {
    local($class) = @_;
    local($_);

    if ($inheritance{$_} =~ /\S/s) {
	$_ = $inheritance{$_};
	s/,.*//s;
	s/^\s*\w+\s+//s;
	&doclassinheritance($_) unless (defined($classtree{$_}));
    }

    unless (defined($classtree{$class}) || $doc{$anchor{$class}} =~ /^\s*$/s) {
	$classtree{$class}++;
	print O "<li><a href=\"", $anchor{$class}, "\">", $class, "</a>\n";
	if ($subclasses{$class} =~ /\S/s) {
	    print O "<ul plain>\n";
	    foreach ( sort split(/\s+/, $subclasses{$class} ) ) {
		if ($inheritance{$anchor{$_}} =~ /,.*$class/s) {
		    print O "<li><a href=\"", $anchor{$_},
			    "\">", $_, "</a>\n";
		} else {
		    &doclassinheritance( $_ );
		}
	    }
	    print O "</ul>\n";
	}
    }
}


#
# make a complete list of member for each class
sub memberlists {
    local($class, $member, $file, $tail);

    $file = "/dev/null";
    open(O, "> /dev/null") || die "cant open /dev/null";
    $tail = "";

    foreach ( sort keys %anchor ) {
	if ( $type{$anchor{$_}} eq "class" && $name{$anchor{$_}} eq $_ ) {
	    print O $tail;
	    $file = $anchor{$_};
	    $file =~ s/\.html/-members.html/;
	    open(O, "> $outputdir/$file")
		|| die "can't open $outputdir/$file for writing";
	    $tail = "</ul>\n" . $address;
	    print O $doctype, "
<html><head><title>", $module_long, " - ", $_, " member list
</title>", $style, "
</head><body bgcolor=\"#ffffff\">\n", $postheader, "
<h1 align=center>Complete Member List for ", $_, "</h1><br clear=\"all\">
<p>This is the complete list of member functions and enum types for
<a href=\"", $anchor{$_}, "\">", $_, "</a>, including all inherited members.

<p>

<ul>
";
	} elsif ( $type{$anchor{$_}} eq "fn" && !($_ =~ /::_cast/)) {
	    $member = $_;
	    $member =~ s/.*:://;
	    print O "<li><a href=\"",$anchor{$_},"\">",&html($member),"</a>\n"
		if ( $documented{$anchor{$_}} );
	} elsif ( $type{$anchor{$_}} eq "enum" ) {
	    $member = $_;
	    $member =~ s/.*:://;
	    print O
	      "<li>enum <a href=\"",$anchor{$_},"\">",&html($member),"</a>\n"
		if ( $documented{$anchor{$_}} );
	}
    }
    print O $tail;
    close O;
}



sub byfunction {
    local ($aa, $bb);

    $aa = $a;
    $aa =~ s/.*:://;
    $bb = $b;
    $bb =~ s/.*:://;
    return $aa cmp $bb;
}



sub functionindex {
    my( $a, $b, $c );
    my $result = "<ul>";

    $a = "sex";

    foreach ( sort byfunction keys %anchor ) {
	if ( $type{$anchor{$_}} eq "fn" && $documented{$anchor{$_}} &&
	     $name{$anchor{$_}} eq $_ ) {
	    $b = $_;
	    $b =~ s/.*:://;
	    next if ( $b eq "_cast" || $b =~ /^~/ );
	    $c = $_;
	    $c =~ s/::.*//;
	    next if ( $b eq $c || $c eq "" );
	    if ( $a ne $b ) {
		$a = $b;
		$result = join("", $result, "\n<li>", &html($b), ":" );
	    } elsif ( $a eq "operator=" && $c eq "QGDictIterator" ) {
		$result .= "\n <a href=\"http://www.kbuxton.com/discordia/fnord.html\">fnord</a>"
	    }
	    $result = join( "", $result, "\n <a href=\"", $anchor{$_},
			    "\">", $c, "</a>" );
	}
    }
    $result .= "\n</ul>";
    $result;
}




sub quotelist {
    my( $a, $b, $c, $d );

    $haveprocessedquotelist++;
    my $result = "";
    foreach $a ( sort keys %mustquote ) {
	$result .= "<hr>\n$a\n<ul>\n";
	foreach $b ( sort keys %{$mustquote{$a}} ) {
	    my $link = $name{$b};
	    if ( !($link =~ /\S/) &&
		 $pages{$b} =~ /<title>(?:\s*qt\s+toolkit\s+(?:-\s+)?)?([^<]*)/si ) {
		$link = $1;
	    }
	    $link = "(Unknown title)" unless ($link =~ /\S/);
	    $result .= "<li><a href=\"$b\">$link</a>\n";
	}
	$result .= "</ul><p>\n";
    }
    $result;
}




($j, $min, $hour, $mday, $mon, $year) = localtime(time);

if ( $#ARGV == -1 ) {
    $d = ".";
} elsif ( $#ARGV == 0 ) {
    $d = $ARGV[0];
} else {
    die "too many arguments, stopped";
}

open( CONF, "< $d/doc.conf" ) || die "$d/doc.conf does not exist, stopped";
$slash = $/;
undef $/;
$_ = <CONF>;
$/ = $slash;
close CONF;
eval; die "$@(in $d/doc.conf)\nstopped" if $@;

print "using $d/doc.conf" if ( $debug );

die "sourcedir not defined, stopped"
  unless defined( $sourcedir ) ||defined( @sourcedir );
die "$sourcedir is not a directory, stopped" unless ( -d $sourcedir );
die "includedir not defined, stopped" unless defined( $includedir );
# die "$includedir is not a directory, stopped" unless ( -d $includedir );
die "outputdir not defined, stopped" unless defined( $outputdir );
mkdir ($outputdir, oct 777) unless ( -e $outputdir );
die "$outputdir is not a directory, stopped" unless ( -d $outputdir );

die "module not defined, stopped" unless defined( $module );
$module_long ||= $module;
die "footer not defined, stopped" unless defined( $footer );
die "address not defined, stopped" unless defined( $address );
die "company not defined, stopped" unless defined( $company );

$style ||= "";
$postheader ||= "";

@exampledirs = () if ( !defined( @exampledirs ) );

umask 0111;
$cfile = "VOLD";
$maxerr ||= 5;

$doctype ||= "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">";

if ( defined( @sourcedirs ) ) {
    foreach $sourcedir ( @sourcedirs ) {
	finddepth( \&readcpp, $sourcedir );
    }
} else {
    finddepth( \&readcpp, $sourcedir );
}

if ( defined( @docdirs ) ) {
    foreach $docdir ( @docdirs ) {
	finddepth( \&readdoc, $docdir );
    }
} else {
    finddepth( \&readdoc, $docdir );
}

chdir( "/tmp" );

&templates();
&preprocessdocs();
&makenames();
&makearglinks();
&processdocs();
&readfiles();
&reimplementations();
&importants();


foreach $c ( sort keys %doc ) {
    if ($type{$c} eq "class") {
	if ($anchor{$name{$c}} eq $c) {
	    $classpool{$c}++;
	} else {
	    print "not printing $c";
	    if ( defined( $name{$c} ) ) {
		print " (named ", $name{$c};
		print " -> ",$anchor{$name{$c}}, ""
		  if ( defined( $anchor{$name{$c}} ) );
		print ")";
	    }
	    print "\n";
	}
    } elsif ( $type{$c} eq "example" || $type{$c} eq "header" ) {
	# nothing
    } else {
#	print $c, " is a ", $type{$c}, "\n" unless ( $c =~ /\x23/ );
    }
}

$moreclassestoprint = 1;
while( $moreclassestoprint ) {
    $moreclassestoprint = 0;
    foreach $url ( keys %classpool ) {
	if ( $classpool{$url} > 0 ) {
	    my $okay = 1;
	    foreach $parent ( sort split( /\W+/, $inheritance{$url} ) ) {
		if (defined( $anchor{$parent} ) &&
		    $classpool{$anchor{$parent}} > 0 ) {
		    $moreclassestoprint = 1;
		    $okay = 0;
		}
	    }
	    if ( $okay ) {
		$classpool{$url} = 0;
		printclass( $url );
	    }
	}
    }
}

&writepages();
&exampleindex();
&memberlists();

if ( $internal ) {
    foreach $c ( keys %doc ) {
	if (!defined($documented{$c}) && ($def{$c} =~ /\S/)) {
	    $_ = $def{$c};
	    s/<.*?>//gs;
	    print "unreferenced: ", $_, "\n";
	}
    }
}

print "Documented ", $countdoc, " member functions, left out ",
    0+$errmsg, " undocumented member functions and ",
    $countall-$countdoc-$errmsg, " (", $countall,
    ") private or non-function members\n";

&post();

chdir( "$outputdir" );
print "Creating Index...\n";
system( "$ENV{'QTDIR'}/util/qdoc/mkindex index *.html" );
print "Creating Title Index...\n";
system( "$ENV{'QTDIR'}/util/qdoc/mktitleindex titleindex *.html" );
print "Creating Property Index...\n";
system( "$ENV{'QTDIR'}/util/qdoc/mkproperties propertyindex *.html" );
print "Creating Whatsthis Help...\n";
system( "$ENV{'QTDIR'}/util/qdoc/mkwhatsthis whatsthis *.html" );
print "Finished!\n";

if ( open( O, "> " . $ENV{"HOME"} . "/.qdoc-cache" ) ) {
    foreach ( keys %cachable ) {
	print O $_, " ", $urls{$_}, "\n";
    }
    close O;
}
