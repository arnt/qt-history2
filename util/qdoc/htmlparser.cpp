/*
  htmlparser.cpp
*/

#include <qfile.h>
#include <qstring.h>

#include <stdio.h>

#include "emitter.h"
#include "messages.h"

/*
  The HTML parser reads HTML files generated by qdoc and extracts HTML chunks
  that correspond to a doc comment (see class Doc and derivatives in doc.cpp).
  The parser is highly sensitive to the format of the generated HTML.

  HTML files are parsed to compare documentation from the previous run with the
  new documentation, in supervisor mode.
*/

/*
  The file is parsed directly from the characters its made of. There is no
  tokenizer. The lookahead character is yyCh. It is fairly fast.
*/
static QString yyFileName;
static FILE *yyIn;
static int yyCh;

/*
  Returns the string up to (and excluding) the terminator. Parsing will resume
  after the terminator.

  If the "<!-- eof -->" marker is reached, the result is the same as if EOF was
  really reached.
*/
static QString getBefore( const QString& terminator )
{
    int matchedLen = 0;
    QString t;

    while ( matchedLen < (int) terminator.length() && yyCh != EOF ) {
	t += QChar( yyCh );

	if ( terminator[matchedLen] == QChar(yyCh) )
	    matchedLen++;
	else
	    matchedLen = 0;

	yyCh = getc( yyIn );
    }
    t.truncate( t.length() - matchedLen );
    int k = t.find( QString("<!-- eof -->") );
    if ( k != -1 ) {
	t.truncate( k );
	yyCh = EOF;
    }
    return t;
}

/*
  Skips until the terminator is met. Parsing will resume after the terminator.
  This is essentially the equivalent of calling getBefore() and ignoring the
  result.
*/
static void skipUntil( const QString& terminator )
{
    int matchedLen = 0;

    while ( matchedLen < (int) terminator.length() && yyCh != EOF ) {
	if ( terminator[matchedLen] == QChar(yyCh) )
	    matchedLen++;
	else
	    matchedLen = 0;

	yyCh = getc( yyIn );
    }
}

/*
  Parses a class reference HTML file (e.g., qwidget.html). Such a file has a
  very peculiar structure, because it contains many Docs.
*/
static void parseClass( DocEmitter *emitter )
{
    skipUntil( QString("<h2>Detailed Description</h2>\n") );
    QString html = getBefore( QString("<hr><h") );
    if ( !html.isEmpty() )
	emitter->addHtmlChunk( yyFileName, HtmlChunk(html) );

    for (;;) {
	skipUntil( QString("3 class=fn>") );
	skipUntil( QString("<a name=\"") );
	QString anchor = getBefore( QString("\">") );
	skipUntil( QString("</h3>") );

	html = getBefore( QString("<h") );
	while ( yyCh != '3' && yyCh != 'r' && yyCh != EOF ) {
	    html += QString( "<h" );
	    html += getBefore( QString("<h") );
	}

	int k = html.find( QString("<p>Examples:") );
	if ( k == -1 )
	    k = html.find( QString("<p>Reimplemented from ") );
	if ( k == -1 )
	    k = html.find( QString("<p>Reimplemented in ") );

	if ( k != -1 )
	    html.truncate( k );

	if ( html.isEmpty() )
	    break;

	if ( !anchor.isEmpty() )
	    emitter->addHtmlChunk( yyFileName + QChar('#') + anchor,
				   HtmlChunk(html) );
    }
}

/*
  Parses a HTML file other than a class reference. These files correspond to at
  most one Doc.
*/
static void parseOther( DocEmitter *emitter )
{
    QString html = getBefore( QString("%magicwordthatyoushouldavoid") );
    if ( !html.isEmpty() )
	emitter->addHtmlChunk( yyFileName, HtmlChunk(html) );
}

/*
  Parses a HTML file. Passes control to parseClass() or parseOther() to do the
  real job, or to neither if the HTML file is a verbatim header file or member
  list.
*/
void parseHtmlFile( DocEmitter *emitter, const QString& filePath )
{
    yyFileName = filePath.mid( filePath.findRev(QChar('/')) + 1 );
    yyIn = fopen( QFile::encodeName(filePath), "r" );
    if ( yyIn == 0 ) {
	syswarning( "Cannot open HTML file '%s' for reading",
		    filePath.latin1() );
	return;
    }
    yyCh = getc( yyIn );

    skipUntil( QString("<h1 align=center>") );
    QString heading = getBefore( QString("</h1>\n\n") );

    if ( heading.find(QString("Class Reference")) != -1 ) {
	parseClass( emitter );
    } else if ( heading.right(2) != QString(".h") &&
		heading.find(QString("Member List")) == -1 ) {
	parseOther( emitter );
    }

    fclose( yyIn );
}
