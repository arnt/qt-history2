\chapter Creating a Main Window Application

In this chapter and in chapter two we will create a small but complete
Qt application. This chapter will cover the main window, and the next
chapter covers the dialogs.

The application is called \c colortool; it is used to associate names
with colors. The application is a standard main window application
with some custom dialogs to facilitate some of the user interaction.

\section1 The Color Tool Application

\img qd-colortool1.png The Color Tool application

The \c colortool application is a multiplatform application that
allows users to create, edit and save lists of colors. Each color has
a user defined name and an RGB (Red, Green Blue) value. 

This application presents the user with a view of a set of colors and
their names. We will provide two views (using a \Class QWidgetStack)
which the user can switch between. The tabular view will show each
color as a small square followed by its name and hex value. It will
also provide the option of an indicator to show whether or not the
color is one of the 216 standard web colors. The iconic view will show
each color as a circular color swatch with the name of the color
beneath.

The application will read and write files in the format used by the X
Consortium for the \File rgb.txt file. This will allow our users to
create their own color files and to load, edit and save \File rgb.txt
format files.

We will provide a simple search option so that users can quickly
locate a color: this is particularly useful when hundreds or thousands
of colors are shown. The search will be provided in a modeless dialog
so that the user can search and still interact with the main form. We
will also allow the user to add and delete colors, and to set some
user options; providing these will require us to create modal dialogs.

Finally we'll ensure that the application loads user options at start
up and saves user options at termination. We will also include the
view and the size and position of the main window with these options,
so that the application will always start with the size, position and
view it had when the user last used it.

\section1 Starting and Exiting \QD

\index Starting Qt Designer
\QD is controlled in the same way as any other modern
desktop application.
To start \QD under Windows click the \Menu Start
button and click \Menu {Programs|Qt X.x.x|Designer}.
(X.x.x is the Qt version number, e.g. 3.1.0.) If you're running a Unix
or Linux operating system you can either double click the \QD icon or enter
\c {designer &} in an xterm.

When \QD starts it shows the New/Open dialog. (If you prefer the old
behaviour, check the "Don't show this dialog in the future" checkbox.)
We'll just click \CANCEL to skip past it.

\img qd-newopen-dlg.png New/Open Dialog

\index Exiting Qt Designer
\index Getting Help
When you've finished using \QD click
\Menu File|Exit; you will be prompted to save any
unsaved changes. Help is available by pressing \Key F1 or
from the \Menu Help menu.

To get the most benefit from the tutorial chapters we recommend that you
start \QD now and create the example applications as you read. Most of
the work involves using \QD's menus, dialogs and editors. The code can
be entered directly using \QD's code editor; you can cut and paste it
from the on-line version of this manual or copy it from the example
source code.

When you start \QD, by default, you will see a menu bar and various
toolbars at the top.
\index Widgets and Source window!Object Explorer
\index Object Explorer
\index Pixmaps
On the left is the new Toolbox. This contains buttons which you click
to reveal a particular set of tools. On the right hand side are three
windows, the first is the Project Overview window, the second is the
Object Explorer and the third is the Properties/Editor Signal Handlers
window. The Project Overview window lists the files and images
associated with the project; to open any form (\File .ui file), or the
code associated with it (in its (\File .ui.h file), simply single
click it. The Object Explorer window lists the current form's widgets
and members. The Properties/Editor window is used to view and change
the properties of forms and widgets. We will cover the use of \QD's
windows, dialogs, menu options and tools as we create example
applications.

\section1 Creating the Project

Our \c colortool application is going to be a standard C++
application, so we need to create a C++ project and add our files and
code to this project.

\sidebar Creating a Project

\index Projects
\index Projects!Creating New
\index Creating Projects!Projects
\index Pixmaps!In Projects
\index Pixmaps!Adding to Forms
Whenever you create a new application we \e strongly recommend that
you create a project file and open the project rather than individual
\index .ui 
\File .ui files. Using a project has the advantage that
all the forms you create for the project are available via a single
mouse click rather than having to be loaded individually through file
open dialogs. An additional benefit of using project files is that
they allow you to store all your images in a single file rather than
duplicate them in each form in which they appear. See \l{The Designer
Approach} chapter's \l{Project management} section for detailed
information on the benefits of using project files.

Project files use the \File .pro suffix and are used by the \c qmake
tool to create makefiles for the relevant target platforms. 
\endsidebar

Create a new project as follows:
\list 1
\i Click \Menu File|New to invoke the \Widget{New File} dialog. 
\i Click "C++ Project" to create a C++ project, then click \OK to pop
up the \Widget{Project Settings} dialog. 
\i Click the ellipsis button to invoke the \Widget{Save As} dialog.
Use this dialog to navigate to where you want to create the new
project, ideally creating a new folder for it (e.g. called
"colortool"), using the \Button{Create New Folder} toolbar button. 
\i Enter a filename of "colortool.pro", then click \OK. The project's
name will now be "colortool"; click \OK to close the \Widget{Project
Settings} dialog.
\i Click \Menu File|Save to save the project.
\endlist

\img qd-chapdialogs-creatingnewprojects.png New File dialog

The \Widget{New File} dialog is used to create all the files that can
be used in a \QD project. This includes C++ source files, an
automatically generated \c main.cpp file, and a variety of forms based
on pre-defined templates. (You can create your own templates too.) 

For the \c colortool application we want to start with a main window
form. When we create this form, \QD will present a wizard which we can
use to automatically create menu and toolbar options and automatically
create the relevant signal/slot connections. For every menu option or
toolbar button, \QD will create a single \Class QAction (see the
\l{Actions and Action Groups} sidebar).

\sidebar Actions and Action Groups

An \e action is an operation that the user initiates through the user
interface, for example, saving a file or changing some text's font
weight to bold.

We often want the user to be able to perform an action using a variety
of means. For example, to save a file we might want the user to be able
to press \Key Ctrl+S, or to click the \Button Save toolbar button
or to click the \Menu File|Save menu option. Although the means of
invoking the action are all different, the underlying operation is the
same and we don't want to duplicate the code that performs the
operation. In Qt we can create an action (a \Class QAction object)
which will call the appropriate function when the action is invoked. We
can assign an accelerator, (e.g. \Key Ctrl+S), to an action. We
can also add an action to a menu item and to a toolbar button.

If the action has an on/off state, e.g. bold is on or off, when the user
changes the state, for example by clicking a toolbar button, the state
of everything associated with the action, e.g. menu items and toolbar
buttons, are updated.

Some actions should operate together like radio buttons. For example, if
we have left align, center align and right align actions, only one
should be 'on' at any one time. An \e {action group} (a
\Class QActionGroup object) is used to group a set of actions together.
If the action group's \c {exclusive} property is TRUE then only one of
the actions in the group can be on at any one time. If the user changes
the state of an action in an action group where \c {exclusive} is TRUE,
everything associated with the actions in the action group, e.g. menu
items and toolbar buttons, are updated.

\index Actions and Action Groups
\QD can create actions and action groups visually, can assign
accelerators to them, and can associate them with menu items and toolbar
buttons.

\endsidebar

\section1 Creating the Main Window

\index Main Window!Creating
\index Creating Main Windows
\index Main Window!Wizard
\index Wizards!Main Window
\index Creating Menus
\index Menus!Adding
\index Adding!Menus
\index Creating Toolbars
\index Toolbars, Creating
\index Toolbar Buttons!Adding
\index Adding!Toolbars
\index Adding!Actions and Action Groups
\index Adding!Toolbar Buttons

We will use the main window wizard to build a main window. The wizard
allows us to create actions and a menu bar and a toolbar through which
the user can invoke the actions. We will also create our own actions,
menus and toolbar. We will add some widgets to the toolbar and add a
main widget to the main window. 

Click \Menu File|New to invoke the \Widget{New File} dialog, click
"Main Window" to create a main window form, then click \OK. A new
\Class QMainWindow form will be created and the \Widget{Main Window
Wizard} will pop up.

\section2 Using the Main Window Wizard

\list 1

\i

The \e {Choose available menus and toolbars} wizard page appears
first. It presents three categories of default actions, File
Actions, Edit Actions and Help Actions. For each category you
can choose to have \QD create menu items, toolbar buttons and
signal/slots connections for the relevant actions. You can
always add or delete actions, menu items, toolbar buttons and
connections later.

\index Creating Menus
\index Menus!Adding
\index Creating Toolbars
\index Toolbars, Creating
\index Toolbar Buttons!Adding
\index Adding!Menus
\index Adding!Toolbars
\index Adding!Actions and Action Groups
\index Adding!Toolbar Buttons
\index Signals and Slots!Connecting Actions

We will accept the defaults for File Actions and for the Edit Actions,
i.e. have menu items, toolbar buttons and the relevant connections
created. In fact we'll be changing the Edit actions considerably later
on, but it is still convenient to create them now. We won't have any
Help Actions on the toolbar so uncheck the Help Action's Toolbar
checkbox. Click \Button Next to move on to the next wizard page.

\img qd-chapmainwin-mainwinwiz1.png
\caption Main Window Wizard- Choosing menus and toolbars

\i

\index Creating Toolbars
\index Toolbars, Creating
\index Toolbar Buttons!Adding
\index Adding!Toolbar Buttons
\index Separator!Menu item
\index Separator!Toolbar button

The \e {Setup Toolbar} wizard page is used to populate a toolbar with
actions from each of the default action categories. The Category
combobox is used to select which set of actions you wish to work on.
The Actions list box lists the actions available for the current
category. The Toolbar listbox lists the toolbar buttons you want to
create. The blue left and right arrow buttons are used to move actions
into or out of the Toolbar list box. The blue up and down arrow
buttons are used to move actions up and down within the Toolbar list
box. Note that the '\<Separator\>' item in the Actions list box may be
moved to the Toolbar list box as often as required and will cause a
separator to appear in the finished toolbar.

Copy the New, Open and Save Actions to the Toolbar list box. Copy a
\<Separator\> to the Toolbar list box. Change the Category to Edit and
copy the Cut Copy and Find actions to the Toolbar list box. Click
\Button Next and then click \Button Finish.

\img qd-chapmainwin-mainwinwiz2.png
\caption Main Window Wizard- Setting up the toolbar

\endlist

If you preview the form (\Key {Ctrl+T}) the File and Edit
menus will be available and you'll be able to drag the toolbar
either into an independent window of its own, or to dock it to
the left, right, bottom or top of the window. The menus and
toolbars are not yet functional, but we will rectify this as we
progress.

\img qd-chapmainwin-mainwinwiz3.png
\caption Previewing the Form

Now that we've created the form we will need to change some of its
properties. (See the \l{Using the Property Editor} sidebar.)

\sidebar Using the Property Editor

\index Using the Property Editor
\index Properties
The Property Editor has two columns, the Property column which lists
property names and the Value column which lists the values. Some
property names have a plus sign '+' in a square to their left; this
signifies that the property name is the collective name for a set of
related properties. Click a form or widget to make the Property Editor
show the form or widget's properties.

For example, click the \Property sizePolicy property's plus sign; you
will see four properties appear indented below sizePolicy: hSizeType,
vSizeType, horizontalStretch and verticalStretch. These properties are
edited in the same way as any other properties.

If you want to change the same property to the same value for a whole
set of widgets, (e.g. to give them all a common cursor, tooltip,
colors, etc.), \Key Click one of the widgets, then \Key Shift+Click
the others to select them all. (Alternatively, click the first
widget's name in Object Explorer, then \Key Shift+Click all the others
in Object Explorer: this technique is especially useful for forms with
lots of nested widgets and layouts.) The properties they have in
common will be shown in the property editor, and any change made to
one property will be made to that same property for all the selected
widgets.

\img qd-chapdialogs-propertyeditor.png
\caption Property Editor

Some properties have simple values, for example, the \Property name property
has a text value, the \Property width property (within \Property
minimumSize) has a numeric value. To change a text value click the
existing text and type in your new text. To change a numeric value click
the value and either type in a new number, or use the spin buttons to
increase or decrease the existing number until it reaches the value you
want. Some properties have a fixed list of values, for example the
\Property mouseTracking property is boolean and can take the values True or
False. The \Property cursor property also has a fixed list of values. If
you click the cursor property or the \Property mouseTracking property the
value will be shown in a drop down combobox; click the down arrow to see
what values are available. Some properties have complex sets of values
or special values; for example the \Property font property and the
\Property iconSet property. If you click the font property an ellipsis
button (\Button {...}) will appear; click this button and a
\Widget{Select Font} dialog will pop up which you can use to change
any of the font settings. Other properties have ellipsis buttons which
lead to different dialogs depending on what settings the property can
have. For example, if you have a lot of text to enter for a \Property
text property you could click the ellipsis button to invoke the
\Widget{Multi-line Edit} dialog.

\index Properties!Reverting changes
\index Properties!Initial values
The names of properties which have changed are shown in bold. If
you've changed a property but want to revert it to its default value
click the property's value and then click the red 'X' button to the
right of the value. Some properties have an \e initial value, e.g.
'TextEdit1', but no default value; if you revert a property that has
an initial value but no default value (by clicking the red 'X') the
value will become empty unless the property, e.g. name, is not allowed
to be empty.

\index Undo and Redo!Properties
\index Properties!Undo and Redo!Undo and Redo
\index Redo!Undo and Redo
The property editor fully supports Undo and Redo
(\Key Ctrl+Z and \Key Ctrl+Y, also available
from the \Menu Edit menu).

\endsidebar

\section2 Setting Properties

Click the form. This will make all the form's properties appear in the
Property Editor. Change the form's \Property name to "MainForm" and
its \Property caption to "Color Tool".

The main window wizard created a few slots and actions that are not relevant to
our application, so we'll delete them. 

\sidebar The Object Explorer

\index Object Explorer
View the Object Explorer window by clicking \Menu {Window|Views|Object
Explorer}. The Object Explorer has two tabs, the Objects tab which
shows the object hierarchy, and the Members tab which shows the
members you have added to the form. Clicking the name of a widget in
the Object tab will select the widget and show its properties in the
Property Editor. It is easy to see and select widgets in the Object
Explorer which is especially useful for forms that have many widgets
or which use layouts. Multiple widgets can be selected by
\Key{Click}ing the first one then \Key{Shift+Click}ing the others.

\img qd-chapdialogs-objectexplorer.png
\caption Object Explorer

\index Code Editing
\index Subclassing
\index Forward declarations
\index Includes
\index Adding!Code
\index Adding!Forward declarations
\index Adding!Includes
\index Adding!Class variables
\index Class variables
\index Deleting!Forward declarations
\index Deleting!Includes
\index Deleting!Class variables
\index Forms!Forward declarations
\index Forms!Class variables
\index Forms!Code editing
\index Forms!destructor
\index Forms!constructor
In the original version of \QD if you wanted to provide code for a
form you had to subclass the form and put your code in the
subclass. This version fully supports the subclassing
approach, but now provides an alternative: placing your code
directly into forms. Writing code in \QD is not quite the same
as subclassing, for example you cannot get direct access to the
form's constructor or destructor. If you need code to be executed
by the constructor create a slot called 
\index init()
\Func{void init()}; if it exists it will be called from the constructor.
Similarly, if you need to be executed before destruction create a
slot called
\index destroy()
\Func{void destroy()}.
You can also add your own class variables which
will be put in the generated constructor's code, and you can add
forward declarations and any includes you require. To add a variable
or declaration right click the appropriate item, e.g. Class
Variables, then click New then enter your text, e.g.
\c {QString m_filename}. If one or more items exist
right clicking will popup a menu that has New, Edit and Delete 
options. If you want to enter multiple items, e.g. multiple include
files or multiple data members, it is easiest to right click in the
relevant section, then click Edit to invoke an Edit dialog. To edit
code just click the name of a function to invoke the code editor. Code
editing and creating slots are covered later.

\index Subclassing
If you subclass the form you create your own
\index .cpp
\File .cpp files which can contain your own
constructor, destructor, functions, slots, declarations and variables
as your requirements dictate. (See \l {Subclassing} for more
information.)

\endsidebar

Click the Object Explorer's Members tab. Right click the filePrint()
slot, then click Delete from the popup menu. In the same way delete
the editUndo(), editRedo() and editPaste() slots. (Right click
editUndo(), then click Delete, etc.) Later we'll see how to create new
slots when we add further functionality to the application.

Right click the filePrintAction action in the Action Editor, then
click Delete Action from the popup menu. In the same way delete the
editUndoAction, editRedoAction and editPasteAction actions.

One side effect of these deletions is that the menus now have some
redundant separators.

Click the form's \Menu File menu. (Note, we're clicking our newly
created form's \Menu File menu, not \QD's \Menu File menu!) There are
\e two separators above the Exit menu option (the \Menu File|Print
option was in-between until we deleted it). Right click one of these
separators, then click Delete Separator. Don't worry if you miss and
delete a menu option by accident: if you delete the wrong thing click
\Menu Edit|Undo to undelete. The form's \Menu Edit menu has a
redundant separator at the top (the undo and redo options were there).
Delete this separator in the same way. (Click the form's \Menu Edit
menu, right click the separator, click Delete Separator.) Again, don't
worry if you delete a menu option by mistake, just press \Key Ctrl+Z
to undo.

Click \Menu{File|Save} to save the form as \File mainform.ui.

The form can now be previewed by clicking \Menu{Preview|Preview Form}
(or press \Key Ctrl+T).

\section2 Adding Custom Actions

We want to provide the user with actions that are specific to our
application. We want to provide the ability to switch between the two
views we will be offering, and allow the user to add colors and set
their preferred options. We'll prepare the way by creating a new menu
for the view options and by adding a separator to the toolbar. 

Right click the form's menu bar to pop up its context menu, then click
the \Menu{Add Menu Item} option. This creates a new menu item called
"Menu" to the right of the existing menu bar items. Click "Menu" and
drag it to the left of the "Help" menu and release it there. (A
vertical red line indicates its position.) Right click "Menu", the
click \Menu{Rename Menu Item}. Change its name to "\&View".

We could create a new toolbar for the view menu items, but instead
we'll put a separator at the end of the existing toolbar and add the
view options after the separator. (Alternatively we could have created
an entirely new toolbar. See \l{Creating and Populating Toolbars} for
more information on doing this.) Right click the right-most toolbar
button ("Find"), the click \Menu{Insert Separator}.

Now we'll create our form's custom actions.

\sidebar Creating and Populating Toolbars

\index Creating Toolbars
\index Adding!Toolbars
\index Toolbars, Creating
A new toolbar is created by right clicking on the menu bar (or to the
right of the existing toolbar(s)) then clicking \Menu{Add Toolbar}.
Toolbar. The new toolbar is empty and is visible only by its
\e{toolbar handle}. (Toolbar handle's are usually represented as a
gray area containing either two thick vertical lines or with many
small pits).

\img qd-chapmainwin-toolbarhandle.png
\caption Toolbar Handle

\index Actions and Action Groups!Adding to a Toolbar
\index Separator!Toolbar button
\index Adding!Actions and Action Groups to a Toolbar
\index Adding!Toolbar Separators
Actions are added to toolbars simply by dragging them from the Action
Editor to the toolbar, and dropping them on the toolbar in the
position we want them. (The position is indicated by a vertical red
line.)

\img qd-chapmainwin-toolbarhandle2.png
\caption Dragging the Action Group to the Toolbar

\img qd-chapmainwin-toolbaractiongroup1.png
\caption Populating the Toolbar with an Action Group

All the actions in an action group are added to a toolbar in one go,
simply by dragging the action group from the Action Editor and
dropping it on the toolbar.

Since toolbar buttons normally only show an image, all actions that
are to be used in toolbars should have their \Property{iconSet}
property set to a suitable image.

\index Separator!Toolbar button
\index Deleting!Toolbar Separators
\index Deleting!Toolbars
Toolbar buttons and separators (usually represented as indented
vertical gray lines), can be dragged and dropped into new positions in
the toolbar at any time. Separators can be inserted by right clicking
a toolbar button and clicking Insert Separator. Toolbar buttons and
separators can be deleted by right clicking them and clicking Delete
Item. Toolbars can be deleted by right clicking their toolbar handle
and clicking Delete Toolbar.

\index Previewing!Toolbars
If you preview an application you'll find that all the toolbars can be
dragged to different docking points (top, left, right and bottom of a
\Class QMainWindow or subclass), or dragged out of the application as
independent tool windows. 

\img qd-chapmainwin-previewing.png
\caption Toolbar with all the Actions Added

\section3 Adding Widgets to the Toolbar

\index Toolbars!Adding Widgets
\index Widgets!Adding to Toolbars
\index Adding!Widgets
Sometimes a simple button is insufficient for our needs. For example,
if we wanted the user to be able to choose a font name and font size
from the toolbar we might want to provide a direct means rather than
having a toolbar button launch a font dialog.

\index Widgets!ComboBox
\index Widgets!SpinBox
\index Separator!Toolbar button
It is perfectly feasible to add \Widget{ComboBox}es and
\Widget{SpinBox}es to toolbars. For example, a \Widget{ComboBox} could
be used to list the available font names and the \Widget{SpinBox} used
to select a font size.

\img qd-chapmainwin-addwidg.png
\caption Adding Widgets to the Toolbar

Although you can put any widget into a toolbar we recommend that
widgets which can be associated with an action should \e not be added
to the toolbar directly. For these widgets, i.e. menu items, toolbar
buttons and lists of items, you should create an action (drop down
action for a list of items), associate the action with the widget, and
add the action to the toolbar. Widgets that can sensibly be inserted
directly into a toolbar are \Widget {ComboBox}es, \Widget {SpinBox}es
and \Widget {Line Edit}s.

\endsidebar

\section3 Adding the Options Action

Right click the first action in the Action Editor, then click
\Menu{New Action}. The Property Editor now shows the new action's
properties. Change the action's name to "optionsAction". Click the
ellipsis button on the \Property{iconSet} property to pop up the
\Widget{Choose an Image} dialog. Click the \Button{Add...} button to pop
up the \Widget{Choose Images...} file selection dialog. Navigate to
\c{qt/tools/designer/pics/small}; click the \c{tabwidget.png} image,
then click \Button{Open}. The \c{tabwidget.png} image now appears
highlighted in the \Widget{Choose an Image} dialog; click \OK to use
it. Change the \Property{text} property to "Options" and change the
\Property{menuText} property to "\&Options...".

Click the optionsAction in the Action Editor and drag it to the Edit
menu. The Edit menu will pop up; drag the optionsAction down the menu
(a horizontal red line indicates its position), and drop it at the end
after the "Find" option.

The options action ought to be visually separated from the other Edit
menu options. Click the form's Edit menu, then right click the
"Find" option, then click \Menu{Insert Separator}.

We'll connect and code this action later.

\section3 Adding the Add Action

Right click the first action in the Action Editor, then click
\Menu{New Action}. Change the action's \Property{name} property to
"editAddAction". Change its \Property{iconSet} property to
\c{widgetstack.png}. (Click the \Property{iconSet} property's ellipsis
button, click \Button{Add...}, click \c{widgetstack.png}, then click
\Button{Open}, then click \OK.) Change the \Property{text} property to
"Add" and the \Property{menuText} property to "\&Add...". Change the
\Property{accel} property to "Ctrl+A".

Click the editAddAction and drag it to be the first item in the Edit
menu. (Drag it to the edit menu and drop it when the horizontal red
line is above the "Cut" menu option.)

Since we also want to make this option available from the toolbar,
click the editAddAction again, and this time drag it to the toolbar.
Drop it to the left of the scissors (Cut) toolbar button. (A
horizontal red line indicates its position during the drag.)

\section4 Tidying Up

We're going to use "Cut" for deleting colors, so we'll change the
user-visible name to "Delete" to make its meaning clearer. Click the
editCutAction in the Action Editor to make its properties appear in
the Property Editor. Change its \Property{text} property to "Delete"
and change its \Property{menuText} property to "\&Delete".

A side-effect of the above change is that \Key Alt+C (originally used
for "Cut") is now unused. Click the editCopyAction action in the
Action Editor, and change its \Property{menuText} property to "\&Copy".

We can always check to see if there are any accelerator conflicts by
clicking \Menu{Edit|Check Accelerators} (or \Key{Alt+R}).

\section3 Adding An Action Group

We want to provide the user with a choice of views, but since they can
only use one view at a time we need to ensure that the menu options
and toolbar buttons they use to switch between views always stay in
sync. We don't have to write any code to achieve this: we simply put
the relevant actions in an action group and let Qt take care of the
details.

Right click an action in the Action Editor, then click \Menu{New
Action Group}. The action group's properties are now showing in the
Property Editor. Change the action group's \Property{name} property to
"viewActionGroup", and change its \Property{text} property to "View".
We want the action group to be \e{exclusive}, i.e. for only one of its
actions to be "on" at any one time; but there's no need to set the
\Property{exclusive} property since it defaults to True which is what
we want.

We'll now create the view actions. The process is virtually the same
as for actions that are not in an action group; the only difference is
that when we right click to pop up the context menu, we \e must right
click the relevant action group, not just anything in the Action
Editor.

Right click the viewActionGroup, then click \Menu{New Action}. Change
this action's \Property{name} property to "viewTableAction". Set its
\Property{toggleAction} property to True and set its \Property{on}
property to True. We want it to be a toggle action because either the
user is using this view (it is "on") or another one (it is "off"). We
set this action to "on" because it will be the default view. Change
its \Property{iconSet} property to \c{table.png}. (Click the
\Property{iconSet} property's ellipsis button, click \Button{Add..},
click \c{table.png}, then click \Button{Open}, then click \OK.) Change
the \Property{text} property to "View Table" and the
\Property{menuText} property to "View \&Table". Change the
\Property{toolTip} property to "View Table (Ctrl+T)", and set the
\Property{accel} property to "Ctrl+T".

Right click the viewActionGroup, then click \Menu{New Action}. Change
this action's \Property{name} property to "viewIconsAction". Set its
\Property{toggleAction} property to True. Change its
\Property{iconSet} property to \c{iconview.png}. Change the
\Property{text} property to "View Icons" and the \Property{menuText}
property to "View \&Icons". Change the \Property{toolTip} property to
"View Icons (Ctrl+I)", and set the \Property{accel} property to
"Ctrl+I".

\section4 Using an Action Group

Now that we've created the view actions we need to make them available
to the user.

Click the viewActionGroup action group in the Action Editor, and drag
it to the View menu; drop it on this menu (when the horizontal red
line appears beneath the View menu). Because we dragged the action
group, \e all its actions (in our case the viewTableAction and
viewIconsAction) are added to the relevant menu. We'll also make the
view actions available on the toolbar. Click the viewActionGroup once
again, and drag it to the toolbar; drop it the right of the separator
at the far right of the toolbar, and drop it on the toolbar's edge.
(Again, a vertical red line will indicate the position.)

Don't forget that you can preview to see things in action with
\Key{Ctrl+T}, and to click \Menu{File|Save} (or press \Key{Ctrl+S})
regularly! If you preview now you will find that if you click the view
toolbar buttons and menu options that both the toolbar buttons and the
menu items automatically stay in sync.

\section1 Creating the Main Widget

Most main-window style applications consist of a menu bar, a toolbar,
a status bar and a central widget. We've already created a menu bar
and toolbar, and since we've created a \Class QMainWindow (via the
main window wizard), we also have a status bar. Widgets commonly used
as an application's main widget are \Class QListView (which provides a
tree view), \Class QTable and \Class QTextEdit. Since we want to
provide our users with two different views of the same data, we'll use
a \Class QWidgetStack as our main widget. The \Class QWidgetStack has
no visual representation of its own; you place one or more widgets on
each \Class QWidgetStack "page", as if each page was a form in its own
right, and then provide the user with some mechanism for switching
between pages. (This is similar in principle to using a \Class
QTabWidget.) We want to provide our users with two views: a tabular
view that lists colours and their names, and an icon-based view that
shows color swatches. In our example we only place a single widget on
each \Class QWidgetStack page; but this merely reflects the
application's design -- we could have placed any number of widgets on
each page.

Click the Toolbox's Containers item, then click WidgetStack. Click
roughly in the middle of the form to place the widget stack. Change
the WidgetStack's \Property{name} property to "WidgetStack".

\sidebar Widget Placement

When placing widgets on forms using \QD, you only need to place things
in \e approximately the right place. And there is no need to worry
about the size of the widgets placed. If, for example, you place a
label and then change its text so that the text doesn't fit, this
doesn't matter. The reason we don't have to care about precise
positions and sizes is that \QD uses Qt's layout classes to lay out
forms automatically: we just have to select sets of widgets and tell
\QD how they should be laid out in relation to each other, e.g. 
vertically, one above the other, or horizontally, side by side, or in
a grid, and \QD will lay them out and size them appropriately.

In this chapter we only make the most minimal use of \QD's layout
facilities, we make more use of them and provide more information
in chapter two, where we create several dialogs.
\endsidebar

Click the form itself, then click the \Button{Lay Out Vertically}
toolbar button. The WidgetStack now fills the entire form. We're now
ready to populate the WidgetStack's pages with widgets.

Click the Toolbox's Views item. Click Table, then click roughly in the
middle of the WidgetStack. Change the table's \Property{name} property
to "colorTable", change its \Property{numRows} property to "0", and
its \Property{readOnly} property to "True". 

If you right click a widget to pop up its context menu, in most cases
the first item will be an "Edit" option. The Table widget is no
different in this respect, and its "Edit" option leads to a dialog
through which columns and rows can have their titles changed, etc.

Right click the table, then click \Menu{Edit...} to invoke the
\Widget{Edit Table} dialog. Change the Label for column 1 to "Name".
Click "2" in the Columns list so that column 2's label is shown in the
Label line edit. Change column 2's label to "Hex". In the same way
change column 3's label to "Web". (The reference section provides full
information on this dialog.) Click \OK to close the dialog.

Click the WidgetStack, then click the \Button{Lay Out Vertically}
toolbar button. The table now fits inside the WidgetStack, and will
resize with the WidgetStack (which in turn will resize with the form:
try clicking \Key Ctrl+T to preview and resize the previewed form).

Click the "page" object in Object Explorer. Change its name to
"tablePage".

We're now ready to create the next page. Right click the WidgetStack,
then click \Menu{Add Page} on the context menu. The table has
"disappeared", or rather the new WidgetStack page obscures the
first WidgetStack page which contains the table. Click IconView in the
Toolbox, then click roughly in the middle of the WidgetStack. Change
the IconView's \Property{name} property to "colorIconView" and change
its \Property{resizeMode} property to "Adjust".

It is often useful to create IconView items during design, but it
isn't appropriate for our application. Right click the IconView to
popup its context menu, then click \Menu{Edit...} to invoke the
\Widget{Edit IconView} dialog. Click \Button{Delete Item} to delete
the default item, then click \OK. 

Click the WidgetStack, then click the \Button{Lay Out Vertically}
toolbar button. The icon view now fits inside the WidgetStack. 

Click the "page" object in Object Explorer. Change its name to
"iconsPage".

Right click the WidgetStack, then click \Menu{Previous Page}.

That completes the user interface design for our application's main
window. Note that if you preview the form clicking the "View" menu
options and toolbar buttons has no effect. Indeed, none of the menu
options and toolbar buttons does anything useful yet. We'll write the
underlying code in the next section.

\section1 Writing the Code

There are two approaches that can be taken when it comes to writing
code for forms designed with \QD. The original approach is to create a
subclass of every form you create and put all your code in the
subclass. Since Qt 3.0, \QD has provided an alternative: you can write
your code directly in \QD using the code editor. See \l{The Designer
Approach} for a comparative review. For this example we will write all
the code inside \QD; for an example of the subclassing approach see
\l{Subclassing and Dynamic Dialogs}.

Before we launch into writing code we need to create some form
variables. For example, we need to keep track of whether a view needs
updating (because the user loaded a new set of colors, or added or
deleted colors in the other view).

\section2 Adding Member Variables

Click Object Explorer's Members tab. Right click "Class Variables"
(towards the bottom), then click \Menu{Edit}. The \Widget{Edit Class
Variables} dialog appears. Click the \Button{Add} button, and type in
"QMap\<QString,QColor\> m_colors". We will use this map to relate
user color names to colors. Click the \Button{Add} button again, and
type in "bool m_changed". We'll use this variable to keep track of
whether the data has changed or not; this is useful for offering the
user a prompt to save unsaved changes when they exit or open a new
file, for example. 

In the same way add "QString m_filename;" so that we can keep track of
the file the user has open. Add "bool m_table_dirty" and "bool
m_icons_dirty". If the user adds a color when viewing the table we'll
mark the icons as 'dirty' so that the icon view will be updated if the
user changes to view the icons, and vice versa. Add "bool m_show_web;"
-- we'll use this to record whether or not the user wants a column in
the table to indicate which colors are web colors. Add "int
m_clip_as;" -- we'll use this to choose what to put on the clipboard
when the user clicks \Menu{File|Copy}. We'll keep a pointer to the
global clipboard, so add "QClipboard *clipboard;". Finally add
"QStringList m_comments;". This is used for loading and saving color
files and is explained later.

Press \Key Enter, to confirm the last variable, then click
\Button{Close} to close the dialog. All the variables now appear in
Object Explorer's Members tab.

\section3 Adding Forward Declarations

Some of the variables we've created are of classes that need forward
declarations. Right click Forward Declarations (in Object Explorer's
Members tab), then click \Menu{Edit}. This pops up the \Widget{Edit
Forward Declarations} dialog. This dialog works in exactly the same
way as the \Widget{Edit Class Variables} dialog that we've just used.
Add the following forward declarations: "class QString;" and "class
QColor;". Close the dialog and the forward declarations appear in
Object Explorer.

\section3 Adding Includes

Our form will also need some included files. Includes may be added in
the declaration, or (for preference) in the implementation. Right
click "Includes (in Implementation)", then click \Menu{Edit}. Use the
dialog that pops up to enter "qcolor.h" and "qstring.h". Since we're
going to use the clipboard we'll need access to the global clipboard
object via \Class QApplication, so also add "qapplication.h" and
"qclipboard.h". We'll also be doing some drawing (e.g. the color
swatches), so add "qpainter.h" too, then close the dialog. 

When entering include files you can include double quotes or angle
brackets if you wish; if you don't use either \QD will put in double
quotes automatically.

\section2 Signals and Slots Connections

Most of the signals and slots connections were created automatically
by the main window wizard when we created the main form. We have added
some new actions since then, and we need to ensure that they are
connected to slots so that we can code their behaviour.

\img qd-connections1-dlg.png View and Edit Connections dialog

\sidebar Creating Signals and Slots Connections

Click \Menu{Edit|Connections} to invoke the \Widget{View and Edit
Connections} dialog.

The use of this dialog usually follows the same pattern. We click
\Button{New} to create a new connection, then we select the Sender
widget, the sender's Signal and the Receiver (usually the form). If we
want to use a pre-defined slot, we select that slot; otherwise we
click \Button{Edit Slots...} create a new slot on-the-fly, and select
the newly created slot. (The old method of clicking and dragging to
create connections is still supported, but the new method is a lot
faster and easier, especially for creating lots of connections in one
go.)
\endsidebar

We want to update the status bar so that the user can see information
about the color they're on.

Click \Menu{Edit|Connections} to invoke the \Widget{View and Edit
Connections} dialog.

Click \Button{New} to create a new connection. Change the Sender to
"colorTable" and the Signal to "currentChanged(int,int)". Change the
Receiver to "MainForm". We want to connect to our own custom slot
which we haven't yet created. Click the \Button{Edit Slots...} button
to invoke the \Widget{Edit Functions} dialog. Change the slot name
(which defaults to "newSlot") to "changedTableColor(int,int)". Click
\OK to close the dialog. Now change the Slot in the \Widget{View and
Edit Connections} dialog to our newly created
"changedTableColor(int,int)" slot.

Click \Button{New} to create a new connection. Change the Sender to
"colorIconView" and the Signal to "currentChanged(QIconViewItem*)".
Change the Receiver to "MainForm". Click the \Button{Edit Slots...}
button to invoke the \Widget{Edit Functions} dialog. Change the slot
name to "changedIconColor(QIconViewItem*)". Click \OK to close the
dialog. Now change the Slot in the \Widget{View and Edit Connections}
dialog to "changedIconColor(QIconViewItem*)".

Now we can implement our \Func{changedTableColor()} and
\Func{changedIconColor()} slots to update the status bar with details
about the current color.

We also want to ensure that when the user changes view, the colors
shown in the view are correct. For example, if the user deleted a
color in the table view and changed to the icon view, we must ensure
that the icon view does not show the deleted color.

Click \Button{New} to create a new connection. Change the Sender to
"WidgetStack", the Signal to "aboutToShow(int)", and the Receiver to
"MainForm". Create a new slot called "aboutToShow()" and make this the
Slot that the WidgetStack's "aboutToShow(int)" signal connects to. The
signal includes the ID of the widget that is about to be shown; but we
don't need it so we create a slot that doesn't take any parameters.

Once crucial piece of functionality is to allow the user to switch
between views. We could connect each of the view actions separately,
but it is more convenient (and easier to extend) if we connect the
action group as a whole.

Create a new connection with the "viewActionGroup" as the Sender.
Change the Signal to "selected(QAction*)" and change the Receiver to
"MainForm". Create a slot called "changeView(QAction*)" and make this
the slot that the signal connects to.

Click \OK to close the \Widget{View and Edit Connections} dialog.
We are now ready to write the code.

\img qd-connections2-dlg.png View and Edit Connections dialog

\section2 Editing the Code

There is quite a lot of code to include in the application, but this
does not mean that a lot of typing is required! All the code is
reproduced here so, if you're reading an electronic copy, you can
simply cut and paste. If you're reading a print copy, all the code is
provided in \c{qt/tools/designer/examples/colortool}; simply open the
relevant \c{.ui.h} files and copy and paste from there into your own
version of the project. If you are comfortable with Qt programming and
simply want to use this manual to learn about designing with \QD, you
can skip to \l{Creating main.cpp}, and once you've created
\c{main.cpp} you can skip to the next section. Just copy
\c{mainform.ui.h} from the examples directory into the directory where
you've created your version of the \c{colortool} project and you'll
have all the code instantly.

Click \c{mainform.ui.h} in the Project Overview window. A code editor
window showing the empty slots appears.

Unfortunately all the slots are called "Form1::"... instead of
"MainForm::".... This is easily remedied. Click
\Menu{Search|Replace...}, to invoke the \Widget{Replace Text} dialog.
Enter "Form1" as the Find text and "MainForm" as the Replace text,
then click \Button{Replace All}. Click \Button{Close}.


\section3 Adding Constants

\quotefile colortool/mainform.ui.h
\skipto CLIP_AS_HEX
\printuntil ColorTool

We define some useful constants for our form since it's easier to
remember "CLIP_AS_RGB" than "2". The two \Class{QString}s are used by
\Class QSettings when we come to load and save user preferences;
they're explained when we cover \Func{loadOptions()} and
\Func{saveOptions()}. Note that we can insert any valid C++ into a
\c{.ui.h} file including constant declarations as we've done here and
\c{#include}s, etc.

Since we're not subclassing if we want to have code executed during
construction we must create an \Func{init()} function; this will be
called at the end of the form's constructor.

\section3 init() 

\quotefile colortool/mainform.ui.h
\skipto MainForm::init
\printuntil clearData
\printuntil }

The first thing we do is take a pointer to the global clipboard
object. The \Func{setSelectionMode()} call ensures that the clipboard
works as expected on all all platforms. The "findForm" and
"loadSettings()" lines will be covered later; if you're entering the
code, comment them out for now. We set the filename to be empty
because the user hasn't opened a file. We set changed to false since
no changes have taken place yet. But we mark both the table and the
icon view as dirty since we want these to be drawn straight away. We
call the \Func{clearData()} function that we'll write next; this
function clears all the color data, and if called with "TRUE", it
creates new colors with default values.

\section3 clearData() 

\quotefile colortool/mainform.ui.h
\skipto MainForm::clearData
\printuntil populate
\printuntil }

This function is used when we start the application and when the user
creates a new file or loads an existing file. It clears out the data
and optionally inserts default colors. We set the application's
caption because when we load and save files we add the filename to the
caption, so when we clear we need to remove any filename from the
caption. We clear the colors map and the comments string list, then
optionally fill the colors map with some standard colors. Finally we
call \Func{populate()} which is the function we'll create next to fill
the table and icon view with data.

\section3 populate() 

\quotefile colortool/mainform.ui.h
\skipto MainForm::populate
\printuntil icons_dirty = FALSE;
\printuntil }
\printuntil }

This function is at the heart of the application. It visually presents
the data to the user. If the table is "dirty" (e.g. if the user has
added or deleted colors in the icon view, or has opened a color file)
we will populate the table. We start by deleting the contents of every
cell. Next we change the number of rows to equal the number of colors
in the colors map. For each color we want to display a little square
that shows the color, so we create a pixmap of the required size. 

We now create a iterator for our color map, and iterate over every
color. The color map has the user's color names as its keys, and
\Class QColor instances as values. We retrieve the color and fill our
pixmap with that color. We then set the "Name" column (column
\c{COL_NAME}), to have the color's name (\c{it.key()}) and the pixmap
we've just filled with that color. \Class{QColor}'s \Func{name()}
function returns a string that is the hex representation of a color,
e.g. "#12AB2F"; we retrieve this and set the second ("Hex") column to
this value.

If the user wants to see if which colors are web colors we create a
\Class QCheckTableItem, and check it if it is a web color. (We'll
cover \Func{isWebColor()} shortly.) We then insert this \Class
QCheckTableItem into the "Web" column.

Having populated the table we call \Func{adjustColumn()} to ensure
that each column is just wide enough to show its widest entry, and
show or hide the "Web" column depending on the user's preference.

Finally we set \c{m_table_dirty} to "FALSE", since it is now
up-to-date.

If the icon view is "dirty" we \Func{clear()} it of any existing data.
We then iterate over each color in our color map. For each color we
create a new \Class QIconViewItem; we label the item with the user's
color name and provide a pixmap (generated by \Func{colorSwatch()},
covered shortly) in the relevant color. Finally we set
\c{m_icons_dirty} to "FALSE", since it is now up-to-date.

\section3 isWebColor()

\quotefile colortool/mainform.ui.h
\skipto MainForm::isWebColor
\printuntil }

The 216 web colors are those colors whose RGB (Red, Green, Blue)
values are all in the set (0, 51, 102, 153, 204, 255). 

\section3 colorSwatch()

\quotefile colortool/mainform.ui.h
\skipto MainForm::colorSwatch
\printuntil }

We create a pixmap of a suitable size and fill it with white. We then
create a \Class QPainter which we'll use to paint on the pixmap. We
don't want a pen because we don't want an outline around the shape we
draw. We draw an ellipse (which will be circular since we draw in an
80 x 80 pixel square). We return the resultant pixmap.

[[Create main.cpp and make and run the application]]


[[DON'T FORGET TO TELL 'EM TO UNCOMMENT findForm and loadSettings in init() WHEN THEY ARE READY]]
[[MAKE SURE I'VE COVERED EVERY FUNCTION]]


