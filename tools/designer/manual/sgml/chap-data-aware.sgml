<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook V3.1//EN"[
<!ENTITY qd "<emphasis>Qt Designer</>">
<!ENTITY st "<classname>QSqlTable</>">
<!ENTITY sd "<classname>QSqlDialog</>">
<!ENTITY ok "<guibutton>OK</>">
<!ENTITY i "<literal>INSERT</>">
<!ENTITY d "<literal>DELETE</>">
<!ENTITY u "<literal>UPDATE</>">
]>

<chapter id="using-data-aware-widgets">
<title>Using Data-Aware Widgets</>

<para>
This chapter shows you how to use Qt's data-aware widgets from within
&qd;. If you wish to run the examples or
create your own applications using these widgets you need access to
a SQL database and a Qt database driver that can connect to the
database. The current drivers that Qt supports are QODBC (Open Database
Connectivity), QOCI (Oracle), QPSQL6 (PostgreSQL 6), QPSQL7 (PostgreSQL
7) and QMYSQL (MySQL). 
</para>

<para>
Although you can use the Qt data-aware widgets to browse and edit data
in SQL databases without having to write any SQL, a basic understanding
of SQL is highly recommended. We assume some familiarity with
<literal>SELECT</>, &i;, &u; and &d; statements. We also assume a basic
understanding of the concepts of normalisation and of primary and
foreign keys. A standard text covering SQL databases is <citetitle
pubwork="book">An Introduction to Database Systems (7th ed.)</> by C. J.
Date, ISBN 0201385902. 
</para>

<para>
In the following text we describe the creation of the 'book'
application. The application demonstrates how to use &st;s including
in-place record editing and drilldown from one &st; to another. It also
demonstrates how to create &sd;s for data-aware forms. A great deal of
functionality is available from the classes directly in &qd;, but
where extra power is required, for example for foreign key handling,
we explain how to subclass to achieve finer control. 
<screenshot>
<graphic format="jpg" fileref="images/book.jpg"></graphic>
</screenshot>
</para>

<sidebar><title>The Example Schema</title>
<para>
Note that the examples in this chapter all use the tables, views and
records which are defined in the
<filename>qt/tools/designer/eg/book.sql</> file. This file has been
tested with PostgreSQL 6. You may need to modify the SQL in this file to
recreate the example database on your own system. 
<example><title>Schema <literal>CREATE TABLE</> Statements</><programlisting>
\scan eg/book.sql /CREATE TABLE\s*author/ /CREATE TABLE\s*format/
</programlisting></example>
The book table is simplified for the purposes of example. It can only
relate a book to a single author (authorid) and lacks an ISBN field.
The format table is used to store 'paperpack', 'hardback', etc.
<example><title>Schema <literal>CREATE VIEW</> Statements</><programlisting>
\scan eg/book.sql /CREATE VIEW/ /CREATE VIEW/
</programlisting></example>
The book_view is used to present the book's format as a textual value
rather than as a raw id. The author_view has a one-to-one correspondence
with the author table and allows us to select an author on the basis of
a single field, in a combobox for example.
</para>
</sidebar>

<sect1 id="setting-up-database-connections">
<title>Setting Up Database Connections</>

    <para>
    There are two aspects of database connections that we must consider.
    Firstly the connection we wish to use within &qd; itself, and
    secondly the connection we wish to use in the applications that we
    create.
    </para>

    <sect2 id="setting-up-qt-designers-connections">
	<title>Setting Up &qd;'s Connections</>

	<para>
	<screenshot>
	<graphic format="jpg" fileref="images/database-connections-dialog.jpg"></graphic>
	</screenshot>
	Choose <guimenuitem>Edit|Database Connections</> from the menu
	bar. The Database Connections dialog will appear. Click
	<guibutton>New Connection</>. For applications that use a single
	database it will probably be most convenient to use the default
	connection name of "(default)". If you use more than one
	database give each one a unique name. A driver must be chosen
	from the Driver combo box. The database name may be available in
	the Database Name combo box or may have to be typed in. The
	database name, username, password and hostname should be
	provided by your database systems administrator. When the
	Connection information has been completed click
	<guibutton>Connect</>. If the connection is made the connection
	name will appear in the list box on the left hand side of the
	dialog. You can now close the dialog; the connection settings
	will remain in force until you change or delete them or quit &qd;. 
	</para>

	<para>
	&qd; can remember database connection settings in
	<application>qmake</> project files. Create a new project, e.g.
	click <guimenuitem>File|New Project</> and complete the Project
	Settings dialog. (See <xref linkend="using-project-files">
	"Using Project Files".) Next time you start &qd; instead of
	opening individual <literal>.ui</> files open the
	<literal>.pro</> project file instead and &qd; will
	automatically reload the project's connection settings.  To
	activate the connection click <guimenuitem>Edit|Database
	Connections</>. The connections previously saved with the
	project will be listed in the left hand list box. Click the
	connection you wish to use and then click <guibutton>Connect</>.
	This connection will be used from now on, e.g. for previewing
	&st;s. Opening a project file also causes &qd; to load in the
	list of forms associated with the project into the Form List
	window. In most of the discussion that follows we will assume
	that you use project files and have clicked <guibutton>Connect</>
	so that there is always a connection available when you work in
	&qd;.
	</para>

    </sect2>

    <sect2 id="setting-up-connections-for-applications">
    <title>Setting Up Connections for Applications</>

	<para>
	The applications you create must make their own connections to
	the SQL database. 
<example><title>createConnections() function</><programlisting>
\scan eg/book1/main.cpp /bool createConnections..$/ /^}/
</programlisting></example>
	We call <function>addDatabase</> passing it the name of the
	driver we wish to use. We then set the connection information by
	calling the <literal>set...</> functions. Finally we attempt to
	open the connection. If we succeed we return TRUE, otherwise we
	output some error information and return FALSE. 
<example><title>From <filename>qt/tools/designer/eg/book1/main.cpp</></><programlisting>
\scan eg/book1/main.cpp /int main/ /^}/
</programlisting></example>
	All the examples presented in this chapter call
	<function>createConnections</> after creating the
	<classname>QApplication</> object in their <filename>main.cpp</>
	file and make use of the default connection. If you need to
	connect to multiple databases use the two-argument form of
	<function>addDatabase</>, passing it both the name of the driver
	and a unique identifier. This is explained in the <ulink
	url="http://doc.trolltech.com/sql.html">Qt SQL Module
	documentation</>.
	</para>
	
	<para>
	Note that we do not need to keep a reference to database
	connections. If you use a single database connection, the
	"default" connection, any database functions will use this
	connection automatically. We can always get a pointer to
	a connection by calling <function>QSqlDatabase::database()</>.
	</para>

    </sect2>
</sect1>

<sect1 id="using-qsqltable">
<title>Using &st;</>

    <para>
    &st;s may be placed on any form and provide browsing of database
    tables and views. &st;s can also be used to update or delete
    records in-place. Inserting records via a &st; usually requires some
    subclassing, so that we can generate primary keys for example, or
    provide default values. If we wish to present records using a form
    view (perhaps combining several tables and views) we would use a
    &sd;; see <xref linkend="using-qdialog-to-create-data-aware-forms">
    "Using &sd; to Create Data-Aware Forms". 
    </para>

    <sect2 id="quickly-viewing-a-database-table">
    <title>Quickly Viewing a Database Table</>

	<para>
	This example, along with all the other examples in this
	chapter, has the project name 'book' and uses the database
	created by the <filename>book.sql</> script. As we work through
	the chapter we will build the 'book' application. The project
	file for this first example is
	<filename>qt/tools/designer/eg/book1/book.pro</>. Start a new project by
	clicking <guimenuitem>File|New Project</>. Complete the dialog
	by entering a project name and a project file name.  Now click
	<guimenuitem>Edit|Database Connections</>. Fill in the
	connection information appropriate to your database then press
	<guibutton>Connect</>. The connection name should now appear in
	the left hand list box. (If this doesn't happen you'll need to
	contact your database systems administrator for help.) Close the
	dialog.
	</para>

	<para>
	Click <guimenuitem>File|New</>. The New Form dialog presents us
	with a number of form templates to choose from. Choose the
	'Dialog' form, <emphasis>not</> 'SQL Dialog', and click &ok;.
	Now click <guimenuitem>File|Save</>. You will be prompted for a
	filename, call it <filename>book.ui</>. 
	</para>

	<para>
	To place a &st; widget on the form either click
	<guimenuitem>Tools|Views|QSqlTable</> or click the &st; toolbar
	button. Click on the form and the SQL Table Wizard dialog will
	appear. 

	<orderedlist numeration="arabic">
	    <listitem>
		<para>
		The <emphasis>Database Connection and Table</>
		wizard page is used to set up a connection if one doesn't exist
		and to choose the table or view for the &st;. (See <xref
		linkend="setting-up-qt-designers-connections"> "Setting
		Up &qd;'s Connections".)
		</para>

		<para>
		Click the connection you wish to use, listed in the left hand
		list box, e.g. "(default)". The tables and views will appear in
		the right hand Table list box. Click the book_view view and then
		click the <guibutton>Next</> button. 
		</para>
	    </listitem>

	    <listitem>
		<para>
		The <emphasis>Displayed Fields</> wizard page
		provides a means of selecting which fields should be
		displayed in the &st; and in what order. By default all fields
		except the primary key (if there is one) are in the right hand
		Displayed Fields list box. The left and right blue arrow buttons
		can be used to move fields between the Displayed Fields and the
		Available Fields list boxes. The blue up and down arrow buttons
		are used to select the display order of the displayed fields. 
		</para>

		<para>
		Move the id and authorid fields to the Available Fields list
		box. Move the title field to the top of the Displayed Fields
		list box followed by the price field. Click <guibutton>Next</>.
		</para>
	    </listitem>

	    <listitem>
		<para>
		The <emphasis>Table Properties</> wizard page
		provides convenient access to the database-related properties of
		the &st;. 
		</para>

		<para>
		Click the Read-Only checkbox, then click <guibutton>Next</>.
		</para>
	    </listitem>

	    <listitem>
		<para>
		The <emphasis>SQL</> wizard page is used to set
		the &st;'s Filter and Sort properties. The Filter is an SQL
		<literal>WHERE</> clause (without the word 'WHERE'). For
		example, to only list books whose titles begin with 'T', we
		would enter <literal>title LIKE 'T%'</>. The Available Fields
		list box lists all the fields. The Sort By list box lists the
		fields that the &st; is to sort by and the direction of their
		sorting (ASCending or DESCending). The left and right blue
		arrows are used to move fields between the two list boxes. The
		up and down blue arrows move fields up and down within the Sort
		By list box. The ASC or DESC setting is changed with the sort
		order button.
		</para>

		<para>
		Move the title field into the Sort By list box and click
		<guibutton>Finish</>.
		</para>
	    </listitem>
	</orderedlist>
	</para>

	<para>
	The table will appear on the form with each column labelled with
	a default column name. If you wish to change the settings
	most of them are available in the property window. The display
	names, the fields they are based upon, and the order of
	appearance of the columns can be changed using the Edit Table
	dialog (explained later) by right clicking the &st; and left
	clicking Edit.
	</para>

	<para>
	Click on the form and click the <guibutton>Lay out Vertically</>
	toolbar button. Now click <guimenuitem>Preview|Preview Form</>;
	the form will run and the table will automatically display all
	the records.
	</para>

	<para>
	This example shows how quick and easy it is to use
	&st; to show the contents of a database table
	or view. However, in real applications we will need more
	functionality, for example making the table or view editable,
	displaying more than one table and relating the tables together.
	</para>

	<sidebar><title>A Note on Foreign Keys</title>
	<para>
	In most relational databases tables contain fields which are
	foreign keys into other tables. In our book database example the
	formatid in the book table is a foreign key into the format
	table, and the authorid in the book table is a foreign key into
	the author table. When we present a form to the end user we do
	not usually want the foreign key itself to be visible but rather
	the text associated with it. Thus, we would want the format name
	to appear rather than the format id when we show the book table.
	Whilst this can be achieved programmatically, e.g. using
	calculated fields, it is far easier to create a view that
	encompases the fields we wish to make visible to the user. A
	view also places the burden of work on the database rather than
	the client application. In the examples we have created the
	book_view view to demonstrate this approach.
	</para>
	</sidebar>

    </sect2>

    <sect2 id="relating-two-tables-together">
    <title>Relating Two Tables Together (Master-Detail)</>

	<para>
	Databases often have pairs of tables that are related. For
	example an invoice table might list the numbers, dates and
	customers for invoices, but not the actual invoice items which
	the invoiceitem table might store. In the book database we 
	wish to have a &st; that we can use to browse
	through the authors and a second &st; to show
	the books they've written. To achieve this using &qd; we will
	need to subclass. 
	</para>

	<para>
	Subclassing one of the &st;s would lead us up
	a blind alley. Subclassing the &st;s would
	allow us to connect the two tables together using Qt's
	signals/slots mechanism -- but to properly relate the tables we
	need to have access to their underlying database cursors and
	signals/slots are not appropriate for this. So we will need to
	subclass the form that holds the &st;s since
	the form has access to all its components.
	</para>

	<para>
	Open the book project if it isn't already in &qd;. We will
	modify this project to show two &st;s that
	relate the author table to the book_view view. 

	<orderedlist numeration="arabic">
	    <listitem>
		<para>
		Click the book_view &st; and then click the
		<guibutton>Break Layout</> toolbutton.
		</para>
	    </listitem>

	    <listitem>
		<para>
		Drag the top of the &st; down so that it only occupies
		the bottom half of the form.
		</para>
	    </listitem>

	    <listitem>
		<para>
		Since we're going to be subclassing it is a good
		idea to give our own names to the widgets we are going to use
		since we will be referring to them in code. Click the book_view
		&st; and change its name to "BookQSqlTable". Click the form and
		change its name to "BookFormBase". (Our subclass will be called
		"BookForm".) 
		</para>
	    </listitem>
		
	    <listitem>
		<para>
		Now click on the &st; toolbutton and click on the top
		half of the form. The SQL Table Wizard will appear.
		(This Wizard is explained in <xref
		linkend="quickly-viewing-a-database-table"> "Quickly
		Viewing a Database Table".) 
		<orderedlist numeration="arabic" inheritnum="inherit">
		    <listitem>
			<para>
			Click the connection you're using and click the
			author table. Click the <guibutton>Next</> button.
			</para>
		    </listitem>

		    <listitem>
			<para>
			The Displayed Fields page shows the id field in
			the Available Fields list box and the surname
			and forename fields in the Displayed Fields list
			box. Move the forename field to the top and then
			click the <guibutton>Next</> button.
			</para>
		    </listitem>

		    <listitem>
			<para>
			On the Table Properties page click Confirm
			Deletes then click the <guibutton>Next</>
			button.
			</para>
		    </listitem>

		    <listitem>
			<para>
			On the SQL page we will leave the Filter
			(<literal>WHERE</> clause) empty. Move the
			surname field to the Sort By list box and click
			<guibutton>Finish</>.
			</para>
		    </listitem>

		    <listitem>
			<para>
			Change this &st;'s name to "AuthorQSqlTable".
			</para>
		    </listitem>
		</orderedlist>
		</para>
	    </listitem>

	    <listitem>
		<para>
		Shift+Click the bottom &st; so that both &st;s
		are selected and then click the <guibutton>Lay out Vertically
		(in Splitter)</> toolbar button. 
		</para>
	    </listitem>

	    <listitem>
		<para>
		Click on the form and click the <guibutton>Lay
		out Vertically</> toolbar button. 
		</para>
	    </listitem>
	</orderedlist>
	</para>

	<para>
	Run the form by clicking <guimenuitem>Preview|Preview Form</>.
	All the authors are displayed in the top &st;
	and all the books are displayed in the bottom
	&st;. Unfortunately we only want the books of the currently
	selected author showing in the bottom &st;: we will achieve this
	through subclassing. 
	</para>

	<sidebar><title>Using the Table Editor</>
	<para>
	<screenshot>
	<graphic format="jpg" fileref="images/edit-table-dialog.jpg"></graphic>
	</screenshot>
	&st;s are created and set up using the SQL Table Wizard. Like
	any other &qd; widget their properties may be changed in the
	Properties window. Some of the column and row based properties
	can also be be changed using the Edit Table dialog. This
	dialog is invoked by right clicking the &st; and left
	clicking the <guimenuitem>Edit</> menu item. The right hand half
	of the Edit Table dialog is where we choose the fields we wish
	to display, their order and their labels. The procedure for
	creating columns is as follows:

	<orderedlist numeration="arabic">
	    <listitem>
		<para>
		Click the <guibutton>New Column</> button
		</para>
	    </listitem> 

	    <listitem>
		<para>
		Click the triangle at the right hand side of the
		Field combobox to drop down the list of available
		fields
		</para>
	    </listitem>

	    <listitem>
		<para>
		Click the field you wish to include at this point
		</para>
	    </listitem>

	    <listitem>
	    <para>
		<emphasis>Optionally</> edit the Label if the default
		isn't appropriate 
	    </para>
	    </listitem>

	    <listitem>
	    <para>
	    <emphasis>Optionally</> click the Pixmap <guibutton>...</>
	    button to choose a pixmap to be displayed to the left of the
	    column's label
	    </para>
	    </listitem>
	</orderedlist>

	Repeat the steps listed above for each column you wish to add.
	Once all the fields have been added you can change their
	ordering by using the blue up and down arrow buttons. At any
	point you can press <guibutton>Apply</> to see how the table
	will look. Finally click the &ok; button to save the
	properties you have set. You can always return to the table
	editor to change these settings later.
	</para>
	</sidebar>

	<para>
	Now that we have set up the visual design we need to create a
	slot on the form so that as the user navigates through the
	author table the book view can be updated to show only those
	books written by the current author. Run the application in
	preview mode: the author &st; will show all the authors and the
	book_view &st; will show all the books. &qd; has put most of the
	pieces in place but to make the new slot work we need to
	subclass the form so that we can set up a signal/slot connection
	between the author &st; and the book_view &st;. 
	</para>

    </sect2>

    <sect2 id="subclassing-to-link-qsqltable-widgets-together">
    <title>Subclassing to Link &st; Widgets Together</title>

	<para>
	We need to create a new header file for our subclass,
	<filename>bookform.h</filename>. The simplest approach is to run
	<application>uic</> on the command line to generate skeleton
	files and use those, e.g.
<programlisting>
uic -o bookform.h -subdecl BookForm book.h book.ui
uic -o bookform.cpp -subimpl BookForm book.cpp book.ui
</programlisting>
<example><title>From <filename>qt/tools/designer/eg/book2/bookform.h</></><programlisting>
\scan eg/book2/bookform.h /^#include/ /class QSqlRecord/

\scan eg/book2/bookform.h /class BookForm/ /^};/
</programlisting></example>
	We include <filename>book.h</filename> which is the header file
	automatically generated by &qd; and which contains the
	superclass. All we are concerned with here is making the slot we
	created in &qd; active. (Remember to add <filename>bookform.h</>
	and <filename>bookform.cpp</> to the <filename>book.pro</>
	project file and run <application>qmake</> to update the
	<filename>Makefile</>.)
	</para>

	<para>
<example><title>BookForm newAuthor from 
<filename>qt/tools/designer/eg/book2/bookform.cpp</></><programlisting>
\scan eg/book2/bookform.cpp /BookForm::newAuthor/ /^}/
</programlisting></example>
	Whenever the AuthorSqlTable's current author changes a signal is
	sent to the newAuthor slot with a reference to the new
	author's record. The BookSqlTable's filter is set to select only
	the book_view records whose authorid's are equal to the id of
	the current author in the author table. After changing the
	filter we call <function>refresh()</> on BookSqlTable to
	repopulate it with the new filter in force.
	</para>

	<para>
	When this example is run initially all the authors and
	<emphasis>all</> the books are shown. However once the user
	navigates through the author records only those books with a
	matching authorid are shown. We want to show only the relevant
	books, even when the form is initally run, but to achieve this
	we need control of the underlying cursor which subclassing the
	form alone does not provide. 
	</para>

	<para>
<example><title>AuthorCursor from <filename>qt/tools/designer/eg/book3/bookform.h</></><programlisting>
\scan eg/book3/bookform.h /class AuthorCursor/ /^};/
</programlisting></example>
	We create our own cursor subclass based on <classname>QSqlCursor</>. 
	</para>

	<para>
<example><title>BookForm class from <filename>qt/tools/designer/eg/book3/bookform.h</></><programlisting>
\scan eg/book3/bookform.h /class BookForm/ /^};/
</programlisting></example>
	The BookForm subclass now includes a BookForm constructor as
	well as an AuthorCursor.
	</para>

	<para>
<example><title>AuthorCursor from <filename>qt/tools/designer/eg/book3/bookform.cpp</></><programlisting>
\scan eg/book3/bookform.cpp /AuthorCursor::AuthorCursor/ /^}/
</programlisting></example>
	The AuthorCursor's constructor sets the table name to author and
	the display labels for the fields we wish to display.
	</para>

	<para>
<example><title>BookForm constructor from <filename>qt/tools/designer/eg/book3/bookform.cpp</></><programlisting>
\scan eg/book3/bookform.cpp /BookForm::BookForm/ /^}/
</programlisting></example>
	The BookForm constructor sets the AuthorSqlTable's cursor to the
	authorCursor that we created. At first glance this may seem no
	different from leaving &qd; to handle this, but what we have
	done is to force the construction of the cursor
	<emphasis>before</> the construction of the form so that when we
	call <function>refresh()</> on the AuthorSqlTable we will get a
	valid record. This small change ensures that when the example is
	run it correctly displays the books of only the first author
	rather than all the books. When the user navigates through the
	author records the correct books are displayed in the
	BookSqlTable as before.
	</para>

	<para>
	Note that further examples of subclassing QSqlCursors and
	QSqlTables are given in the <ulink
	url="http://doc.trolltech.com/sql.html">Qt SQL Module
	documentation</>, especially the Custom Editor Widgets and
	Subclassing QSqlCursor sections.
	</para>

    </sect2>

    <sect2 id="editing-records-in-a-qsqltable">
	<title>Editing Records in a &st;</>

	<para>
	Displaying database data is useful in itself but we often want
	to insert, update or delete the records that we are browsing.
	For database <emphasis>tables</> we can edit records in-place in
	the &st;. For database <emphasis>views</> we
	cannot edit records in-place. The reason that views are
	different from tables is that not all drivers support editable
	views. Whilst it is theoretically possible to emulate editable
	views by starting a transaction, performing the edits on each of
	the underlying tables concerned and completing and commiting the
	transaction, not all drivers support transactions: without
	editable views or transactions it may not be possible to
	guarantee consistent view updates so views displayed in
	&st;s should always be set to read only unless the underlying
	database you are using supports updateable views.
	</para>

	<sect3 id="editing-table-records">
	    <title>Editing Table Records</>

	<para>
	The author table's &st; already provides &u; and &d; operations.
	However, &i; will not work because the user cannot enter an
	author id. The author id is a unique primary key and should be
	generated by the database or in code to maintain the integrity
	of the database. The solution is a simple extension to our
	AuthorCursor subclass where we reimplement
	<classname>QSqlCursor</>'s <literal>primeInsert()</> virtual
	function.
<example><title>AuthorCursor from <filename>qt/tools/designer/eg/book4/bookform.h</></><programlisting>
\scan eg/book4/bookform.h /class AuthorCursor/ /^};/
</programlisting></example>
	We add a declaration for the <function>primeInsert</> function
	since we need to reimplement it.
<example><title>AuthorCursor from <filename>qt/tools/designer/eg/book4/bookform.cpp</></><programlisting>
\scan eg/book4/bookform.cpp /QSqlRecord \*AuthorCursor/ /^}/
</programlisting></example>
	The implementation of the function is straightforward: we
	acquire a pointer to the cursor's internal edit buffer, generate
	the next unique author id and set the edit buffer's value to the
	new id. (Note that not all databases support sequences or the
	<function>nextval</> function. Your database documentation
	should explain how to deal with auto-numbered fields in code.)
	</para>

	<para>
	We can now browse, &i;, &u; and
	&d; records in the author table. Browsing is
	supported by clicking records and by using the arrow keys. Once
	a record is active (highlighted) we can edit the database. Press
	the <keycap>Insert</> key to &i; a new record;
	press <keycap>F2</> to &u; the current record;
	press the <keycap>Delete</> key to &d; the
	current record. All these operations take place live and
	immediately. Users can be given the opportunity to confirm
	their edits by setting the &st;'s confirmEdits property to True.
	If the confirmEdits property is True user confirmation will
	be required for all insertions, updates and deletes. For finer
	control you can set the confirmInsert, confirmUpdate and
	confirmDelete properties individually.
	</para>

	</sect3>

	<sect3 id="editing-view-records">
	    <title>Editing View Records</>

	<para>
	Since we cannot edit views in-place we will need to create a
	pop-up dialog which contains the details of the book the user
	wishes to edit. To achieve this we need to make the book_view
	read only, set up some buttons which the user can press to
	invoke the dialog and finally create the dialog itself. 
	</para>

	<para>
	<orderedlist numeration="arabic">

	    <listitem>
		<para>
		Click on the book_view &st;; click on the readOnly property and
		set it to True.
		</para>
	    </listitem>

	    <listitem>
		<para>
		Right click on the form and click the <guimenuitem>Break
		Layout</> menu item from the pop up menu. Make some space below
		the book view &st; e.g. by dragging the bottom of the form down.
		Insert a button at the bottom of the form: click the
		<guibutton>PushButton</> toolbar button then click the bottom of
		the form. Now insert two more buttons to the right of the first
		one. Shift+Click the buttons then click the <guibutton>Lay Out
		Horizontally</> toolbar button. Click the form and then click
		the <guibutton>Lay Out Vertically</> toolbar button.
		</para>
	    </listitem>

	    <listitem>
		<para>
		Click the first (left-most) button and change its name to
		"InsertBookPushButton" and its text to "&amp;Insert Book". Click
		the second (middle) button and change its name to
		"UpdateBookPushButton" and its text to "&amp;Update Book". Click
		the third (right-most) button and change its name to
		"DeleteBookPushButton" and its text to "&amp;Delete Book".
		</para>
	    </listitem>

	    <listitem>
		<para>
		Click <guimenuitem>Edit|Slots</> to invoke the Edit Slots
		dialog. Click the <guibutton>New Slot</> button and replace the
		default slot name with <literal>insertBook()</>. Click the
		<guibutton>New Slot</> button again and replace the default slot
		with <literal>updateBook()</>. Create one more slot called
		<literal>deleteBook()</>. Click &ok; to save the
		new slots. 
		</para>
	    </listitem>

	    <listitem>
		<para>
		Click the <guibutton>Connect Signals/Slots</> toolbar button
		then click the Insert Book <classname>QPushButton</> and drag to
		the form; release the mouse over the form. The Edit Connections
		dialog will appear showing Signals for the InsertBookPushButton
		and Slots for BookFormBase. Click the clicked() signal and the
		insertBook() slot. Click &ok;. In the same way
		connect the Update Book <classname>QPushButton</>'s clicked()
		signal to the updateBook() slot and connect the Delete Book
		<classname>QPushButton</>'s clicked() signal to the
		deleteBook() slot.
		</para>
	    </listitem>
	
	</orderedlist>
	</para>
	
	<para>
	The buttons will invoke a &sd; through which
	the user will be able to &i;, &u; or &d; records in the book
	table. To make the slots available in our subclass we need a few
	additions to our code.
<example><title>BookForm from <filename>qt/tools/designer/eg/book5/bookform.h</></><programlisting>
\scan eg/book5/bookform.h /class BookForm/ /^};/
</programlisting></example>
	Our BookForm class now contains declarations for the slots we
	created; we need to do this because we will be reimplementing
	them. For now we will just put stub functions in the
	implementation file:
<example><title>BookForm from <filename>qt/tools/designer/eg/book5/bookform.cpp</></><programlisting>
\scan eg/book5/bookform.cpp /void BookForm::insert/ 0 
\scan /void BookForm::update/ 0
\scan /void BookForm::delete/ 0
</programlisting></example>
	We will put the appropriate code into these stubs once we have
	created the pop-up dialog which the user will use to edit the
	book table: this is covered in <xref
	linkend="subclassing-the-qsqldialog-form"> "Subclassing the &sd;
	Form". 
	</para>

	</sect3>

    </sect2>

</sect1>

<sect1 id="using-qdialog-to-create-data-aware-forms">
<title>Using &sd; to Create Data-Aware Forms</title>

<para>
The &sd; class provides an easy way of generating data aware forms. In
this section we will explain how to create a simple &sd; that provides
browsing and editing of the book table. We will then specialise the
dialog and integrate it with the book_view &st;.
<screenshot>
<graphic format="jpg" fileref="images/book-dialog.jpg"></graphic>
</screenshot>
</para>

    <sect2 id="browsing-a-table-through-a-qsqldialog-form">
    <title>Browsing a Table through a &sd; Form</>
    <!-- Do a form over the book table with navigation: book6 -->

    <para>
    Click <guimenuitem>File|New</> to invoke the New Form dialog. Click the
    SQL Dialog template and then click &ok; to invoke the SQL Form Wizard.
    </para>

    <para>
	<orderedlist numeration="arabic">
	    <listitem>
		<para>
		The <emphasis>Database Connection and Table</>
		wizard page is used to set up a connection if one doesn't exist
		and to choose the table or view for the &st;. (See <xref
		linkend="setting-up-qt-designers-connections"> "Setting
		Up &qd;'s Connections".)
		</para>

		<para>
		Click the connection you wish to use, listed in the left hand
		list box, e.g. "(default)". The tables and views will appear in
		the right hand Table list box. Click the book table and then
		click the <guibutton>Next</> button. 
		</para>
	    </listitem>

	    <listitem>
		<para>
		The <emphasis>Displayed Fields</> wizard page
		wizard provides a means of selecting which fields should be
		displayed in the &st; and in what order. By default all fields
		except the primary key (if there is one) are in the right hand
		Displayed Fields list box. The left and right blue arrow buttons
		can be used to move fields between the Displayed Fields and the
		Available Fields list boxes. The blue up and down arrow buttons
		are used to select the display order of the displayed fields. 
		</para>

		<para>
		Move the formatid and authorid fields to the Available
		Fields list box. Move the title field to the top of the
		Displayed Fields list box. Click <guibutton>Next</>.
		</para>
	    </listitem>

	    <listitem>
		<para>
		The <emphasis>Navigation and Editing</> wizard page allows
		us to choose which navigation and editing buttons should
		appear on the form.
		</para>
		
		<para>
		We will accept the defaults and simply click the
		<guibutton>Next</> button. 
		</para>
	    </listitem>

	    <listitem>
		<para>
		The <emphasis>SQL</> wizard page is used to set
		the &st;'s Filter and Sort properties. The Filter is an SQL
		<literal>WHERE</> clause (without the word 'WHERE'). For
		example, to only list books that cost less than 50 (of our
		currency, e.g. dollars), we 
		would enter <literal>price < 50</>. The Available Fields
		list box lists all the fields. The Sort By list box lists the
		fields that the &st; is to sort by and the direction of their
		sorting (ASCending or DESCending). The left and right blue
		arrows are used to move fields between the two list boxes. The
		up and down blue arrows move fields up and down within the Sort
		By list box. The ASC or DESC setting is changed with the sort
		order button.
		</para>

		<para>
		Move the title field into the Sort By list box and click
		<guibutton>Finish</>.
		</para>
	    </listitem>
	</orderedlist>
    </para>

    <para>
    Click <guimenuitem>File|Save</> and call the form
    <filename>editbook.ui</>. For ease of reference we will rename the form:
    click the form and change its name to "EditBookFormBase" and its caption
    to "Edit Book". If you click the <classname>QLineEdit</> box to the
    right of the price field you will see that its name has been set
    automatically to "QLineEditPrice". Run the form in preview mode (press
    Ctrl+T) and navigate through the book records.
    </para>

    <important>
    <para>
    Note: Whenever we create a new file for a project we must add it
    to the <literal>.pro</> project file and run <application>qmake</> on
    the project file so that the new form is included in the build, e.g.
    <literal>qmake -o Makefile book.pro</>.

    </para>
    </important>

    <para>
    To make our &sd; available to the user we must update our code slightly: 
<example><title>insertBook from <filename>qt/tools/designer/eg/book6/bookform.cpp</></><programlisting>
\scan eg/book6/bookform.cpp /void BookForm::insertBook/ /^}/
</programlisting></example>
    We put the same code into <literal>deleteBook</> and
    <literal>updateBook</>. The effect of this is that whichever button
    the user presses on the main form the same Edit Book dialog will appear.
    In the following sections we will specialise the dialog to remove its
    buttons and change its behaviour so that it only provides &i; if the user
    clicked the main form's Insert Book button, only provides &u; if the
    user clicked the Update Book button and similarly for the Delete Book
    button. We will also improve the appearance of the form and subclass
    it to provide &i;. We will deal with the foreign key fields in <xref
    linkend="using-foreign-keys-in-a-qsqldialog-form"> "Using Foreign Keys
    in a &sd; Form".
    </para>

	<sect3 id="subclassing-the-qsqldialog-form">
	<title>Subclassing the &sd; Form</>

	    <sect4 id="subclassing-to-perform-the-correct-action">
	    <title>Subclassing to Perform the Correct Action</>

		<para>
		We need to subclass EditBookFormBase so that we can
		pass it a parameter identifying which action it is to
		perform, i.e. &i;, &u; or &d;.
		</para>

		<para>
		We begin by creating a new header file for our inherited
		dialog class.
<example><title><filename>qt/tools/designer/eg/book7/editbookform.h</></><programlisting>
\scan eg/book7/editbookform.h /^#include/ /^};/
</programlisting></example>
		We include the headers generated from the
		<literal>.ui</> file, <filename>book.h</> and
		<filename>editbook.h</>. We add a new parameter to the
		constructor, action, which we'll used to identify which
		action should be  performed by the dialog. And we create
		an enum to give meaningful names to our actions.
		</para>

		<para>
<example><title><filename>qt/tools/designer/eg/book7/editbookform.cpp</></><programlisting>
\scan eg/book7/editbookform.cpp /^#include/ /^$/ 
\scan /^EditBookForm/ /break/
	// ...
</programlisting></example>
		We implement our constructor in
		<filename>editbookform.cpp</>. At this stage all we do
		is change the caption of the form to indicate the action
		to be performed. Later we will build in the appropriate
		functionality.
		</para>

		<para>
		Our BookForm subclass should now use our EditBookForm
		subclass.
<example><title>From <filename>qt/tools/designer/eg/book7/bookform.cpp</></><programlisting>
\scan eg/book7/bookform.cpp /void BookForm::insertBook/ /^}/
</programlisting></example>
		Apart from changing the class name all we need do is
		pass in the appropriate enum. We also pass the
		<emphasis>this</> pointer so that the parent class
		(BookForm) will take care of memory cleanup. We make the
		equivalent changes to updateBook and deleteBook.
		</para>

		<para>
		The final change is to the project file. We need to add
		<filename>editbookform.h</> to the <literal>HEADERS</>
		list and <filename>editbookform.cpp</> to the
		<literal>SOURCES</> list. We must of course regenerate
		the Makefile, e.g. <literal>qmake -o Makefile
		book.pro</>. If we run the book application at this
		point and press one of its buttons the BookForm dialog
		will pop up as before only this time the caption will
		reflect the button we pressed.
		</para>

	    </sect4>

	    <sect4 id="update-and-delete-in-forms">
	    <title>&u; and &d; in Forms</>

		<para>
		The EditBookForm already provides the capability to
		update and delete records. But we can only update
		the book title and price since we do not have
		access to the foreign keys, formatid and authorid,
		because we didn't include them when we used the SQL Form
		Wizard. We could add them now but that would leave us
		with numerical fields rather than the foreign key
		lookups we want, so we will leave this issue for the
		time being and come back to it in <xref
		linkend="using-foreign-keys-in-a-qsqldialog-form">
		"Using Foreign Keys in a &sd; Form". And there's an
		additional issue: we haven't told the dialog
		<emphasis>which</> book is to be edited. First we will focus
		on cleaning up the design of the form and then we'll
		pass in the current book to the dialog and add the
		ability to perform inserts. Start up &qd; and load in
		the book project. Click on the EditBookFormBase form in
		the Form List. (Click <guimenuitem>Window|Form List</>
		to get the list to appear.) 
		<orderedlist numeration="arabic">
		    <listitem>
			<para>
			Shift+Click the navigation buttons, First, Prev,
			Next and Last and press the Delete key.
			</para>
		    </listitem>

		    <listitem>
			<para>
			Shift+Click the Insert, Update and Delete
			buttons and drag them to the bottom of the form.
			Click the <guibutton>Lay Out Horizontally</>
			toolbar button.
			</para>
		    </listitem>

		    <listitem>
			<para>
			Shift+Click the Title label and the Price label
			and their QLineEdit boxes then click the
			<guibutton>Lay Out in a Grid</> toolbar button.
			</para>
		    </listitem>

		    <listitem>
			<para>
			Drag the buttons below the title and price and
			drag the bottom of the form up to make it
			smaller. Click the form itself and click the
			<guibutton>Lay Out Vertically</> toolbar button. 
			</para>
		    </listitem>
		</orderedlist>
		</para>

		<para>
		We now need to update our code so that only the
		appropriate button is enabled. Save the form in &qd; and
		edit the <filename>editbookform.cpp</> file. 
		We need the id of the current book from the
		EditBookForm constructor, so we need to update its
		signature and ensure that it uses the book id we've
		passed in.
<example><title>From <filename>qt/tools/designer/eg/book8/editbookform.cpp</></><programlisting>
\scan eg/book8/editbookform.cpp /^EditBookForm::EditBookForm/ /setFilter/
    // ...
</programlisting></example>
		The <function>setFilter()</> call is crucial; it ensures
		that the form shows the current book from the book_view.
		</para>

		<para>
		We also change the calls to the dialog to include the
		current book's id and to update the &st; of books after
		the dialog has executed to reflect any changes the user
		made.
<example><title>From <filename>qt/tools/designer/eg/book8/bookform.cpp</></><programlisting>
\scan eg/book8/bookform.cpp /^void BookForm::update/ /^}/
</programlisting></example>
		In the full source code for the example we have also
		disabled the irrelevant buttons.
		</para>

	    </sect4>

	    <sect4 id="subclassing-to-provide-insert">
	    <title>Subclassing to Provide &i;</>
	    <!-- SUBCLASS THE CURSOR IF WE HAVEN'T ALREADY -->
	    <!-- book9 -->

		<para>
		Z
		</para>

	    </sect4>

	</sect3>

    </sect2>

    <sect2 id="using-foreign-keys-in-a-qsqldialog-form">
    <title>Using Foreign Keys in a &sd; Form</>
    <!-- book10 the last one! -->

    <para>
    intro - custom controls
    </para>

	<sect3 id="creating-custom-widgets">
	<title>Creating Custom Widgets</>
	<!-- AuthorComboBox and FormatComboBox -->

	<para>
	</para>

	</sect3>

	<sect3 id="subclassing-the-custom-widgets">
	<title>Subclassing the Custom Widgets</>
	<!-- AuthorComboBox and FormatComboBox book10 -->

	<para>
	</para>

	</sect3>


    </sect2>

<note><para>@@@@@ TODO QSqlWidget @@@@@</para></note>


</chapter>
