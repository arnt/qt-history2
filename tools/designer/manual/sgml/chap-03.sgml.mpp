<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook V3.1//EN">
<chapter>
<title>Adding Functionality To A Dialog By Subclassing</title>

    <para>
    Using the same pizza entry form presented in the last chapter, you
    will now learn how to continue work on an already existing dialog
    and how to add functionality to the dialog classes that Qt
    Designer creates for you.
    </para>

    <sect1>
    <title>Continuing Work On An Already Existing Dialog</title>

	<para>
	When you run your application, you might decide the dialog
	still needs work. This is no problem. Just restart Qt Designer
	(if you have shut it down in the meantime) and load the
	<filename>.ui</> file via the menu entry
	<guimenuitem>File|Open</> or the load button on the toolbar
	(Figure 3-1). If you use Windows or the K Desktop Environment
	on a Unix system, you can also drag an icon representing a
	<filename>.ui</> file from an Explorer/Konqueror window or the
	desktop onto the Qt Designer window and drop it there.
	</para>

	<figure>
	    <title>The load icon</title>
	    <graphic format="gif" fileref="images/.gif"></graphic>
	</figure>

	<para>
	You will see the form as you left it. Qt Designer does not
	bother with any generated source files; both when saving and
	when loading, it uses only XML-based <filename>.ui</>
	files.<footnote>
	<para>### footnote goes here ###</para>
	</footnote>
	</para>

	<para>
	This behavior of Qt Designer has one important consequence:
	you must never change the files generated by <command>uic</>!
	Changes will be lost. Whenever you apply changes to the
	<filename>.ui</> file, save it, and rerun <command>uic</>. If
	you need to change some of the generated code&mdash;e.g.,
	because you want to add some functionality&mdash;you must
	subclass (we'll see in a minute how to do this). First let's
	define the objectives of this exercise:
	</para>

	<itemizedlist>
	    <listitem>
	    <para>
	    The <guibutton>OK</> and <guibutton>Cancel</> buttons
	    should actually close the dialog; when the
	    <guibutton>OK</> button is pressed a message box should
	    inform the user that the order has been sent to the pizza
	    place (functionality; see section 3.2 below).
	    </para>
	    </listitem>

	    <listitem>
	    <para>
	    Since our pizza service wants to have as much business as
	    possible, we want all toppings and <guilabel>Family</>
	    size to be selected by default. If you tried the dialog
	    from the previous chapter, you might have noted that no
	    size was shown at the beginning, which of course is bad,
	    since the customer might forget to select one.
	    </para>
	    </listitem>

	    <listitem>
	    <para>
	    And since business is slow on Mondays, as an incentive our
	    pizza service will provide extra cheese on Mondays at no
	    additional cost. So we want the extra cheese check box
	    automatically checked on Mondays only; it will remain
	    unchecked all other days (initialize widgets; see Section
	    3.3 below).
	    </para>
	    </listitem>

	    <listitem>
	    <para>
	    Customers ordering anchovies topping usually go for extra
	    cheese as well. Therefore our pizza service would like the
	    extra cheese box checked whenever an anchovies selection
	    is made (connect widgets; see Section 3.4 below).
	    </para>
	    </listitem>
	</itemizedlist>

	<para>
	We will now implement these features one by one.
	</para>
    </sect1>

    <sect1>
    <title>Adding Functionality To The Push Buttons</title>

	<para>
	Responding to user interaction with Qt widgets is mainly done
	by connecting <emphasis>signals</> that these widgets emit to
	<emphasis>slots</>. If you have never heard about signals and
	slots, see the following text-box about <emphasis>signals and
	slots</>or, even better, read the Qt Tutorial or
	<emphasis>Programming with Qt</>.
	</para>

	<para>
	The first thing we will do now is connect the
	<guibutton>Cancel</> button's <function>clicked()</> signal,
	which is emitted when this button is clicked, to the dialog's
	<function>reject()</> method, which closes the dialog and sets
	a negative return code. To do this, start the
	<emphasis>connection tool</> by hitting <keycap>F3</>,
	choosing <guimenuitem>Edit|Connections</> from the menu, or
	clicking on the connections icon on the toolbar (Figure 3-2).
	As soon as you have done this, click the <guibutton>Cancel</>
	button on your form, hold down the mouse button, and move the
	mouse cursor to somewhere on the background of the form.
	Release it there. By this gesture you indicate that you want
	to create a connection from the <guibutton>Cancel</> button to
	the form as a whole. Pink frames show which widgets you have
	currently selected while you move the mouse.
	</para>

	<figure>
	    <title>The connections icon</title>
	    <graphic format="gif" fileref="images/.gif"></graphic>
	</figure>

	<para>
	Once you have released the mouse button the
	<guilabel>Connections</> dialog opens (see Figure 3-3). In
	this dialog select <function>clicked()</> in the
	<guibutton>Cancel</> button's signals list to the left and
	<function>reject()</> in the dialog's slot list to the right.
	The connection will appear in the list in the lower half of
	the dialog.
	</para>

	<figure>
	    <title>The connections dialog</title>
	    <graphic format="gif" fileref="images/.gif"></graphic>
	</figure>

	<para>
	Close the dialog. Your first signal-slot connection is in
	place, without having to write a single line of code!
	</para>

	<para>
	Now for the <guibutton>OK</> button. We want this button to
	close the dialog with a positive return code&mdash;i.e., call
	the dialog's <function>accept()</> slot&mdash;but we also want
	to show the aforementioned message box. In order to do the
	latter, we need to create our own slot.
	</para>

	<para>
	To do this, select <guimenuitem>Edit|Slots...</> from the
	menu. This shows the <guilabel>Slots</> dialog (see Figure
	3-4). Click on the <guilabel>Add</> button to add a slot. A
	slot is added with the default name
	<function>new&lowbar;slot()</>. Go to the edit field labeled
	<guilabel>Slot:</> in the <guilabel>Slot properties</> box and
	change the name to <function>sendOrder()</>. Leave everything
	else as it is and click <guibutton>OK</>.
	</para>

	<figure>
	    <title>The slots dialog</title>
	    <graphic format="gif" fileref="images/.gif"></graphic>
	</figure>

	<para>
	Now start the connection tool again, but this time connect the
	<guibutton>OK</> button to the dialog. When the
	<guilabel>Connections</> dialog re-opens, you see not only the
	predefined slots but also your newly created slot
	<function>sendOrder()</>. Click on the <function>clicked()</>
	signal first and then on the <function>sendOrder()</> slot so
	that the connection appears in the lower half. Close the
	<guilabel>Connections</> dialog.
	</para>

	<para>
	When the user now clicks the <guibutton>OK</> button, both the
	<function>accept()</> slot (which closes the dialog), and the
	<function>sendOrder()</> slot are invoked. But we still have
	to implement the <function>sendOrder()</> slot.
	</para>

	<para>
	Now it looks as if we have a problem: in order to implement a
	slot we need to change the source code, but we've already
	stated that you should not edit the source code generated by
	<command>uic</>.
	</para>

	<para>
	This is true. To solve this apparent problem we need to
	inherit a new class from our <classname>PizzaEntry</> class where
	we can implement the new slot. This sounds like somewhat of a
	bother, but you will get used to it. The whole thing works
	because Qt Designer declares all user-defined slots as virtual
	and provides an empty implementation for them. At runtime,
	then, you do not create an instance of the
	<command>uic</>-generated class but an instance of your own
	implementation class instead. When the <guibutton>OK</> button
	is clicked, your own virtual method will be called instead of
	the generated empty one. If this sounds like black magic, take
	it on faith or read any good C++ book about virtual methods
	and polymorphism!
	</para>

	<para>
	Let's call our inherited class <classname>PizzaEntryImpl</>,
	because we will put some implementation in there (for other
	naming suggestions, see the text-box <emphasis>&ldquo;The Name
	Of The Game&rdquo;</> below).
	</para>

	<para>
	All we need in this implementation class is an empty
	constructor, so that we can pass the usual parameters and the
	slot we want to implement. Here's what the header file
	<filename>PizzaEntryImpl.h</> for our implementation class
	<classname>PizzaEntryImpl</> looks like:
	</para>

	<programlisting>
&num;ifndef PIZZAENTRYIMPL&lowbar;H
&num;define PIZZAENTRYIMPL&lowbar;H

&num;include "PizzaEntry.h"

class PizzaEntryImpl : public PizzaEntry
{
  Q&lowbar;OBJECT

public:
    PizzaEntryImpl( QWidget* parent = 0, const char* name = 0,
                    bool modal = FALSE, WFlags f = 0 )
    : PizzaEntry( parent, name, modal, f ) {}

public slots:
        virtual void sendOrder();
};
&num;endif
</programlisting>

	<para>
	The implementation file is even simpler, since all we want to
	do for now is to show a message box that tells the user that
	the order has been sent (in a real pizza order application,
	you would package the data somehow and send it over the
	network). Here is <filename>PizzaEntryImpl.cpp</>:
	</para>

	<programlisting>
&num;include "PizzaEntryImpl.h"

&num;include &lt;qmessagebox.h&gt;

void PizzaEntryImpl::sendOrder()
{
  QMessageBox::information( this, "Pizza Entry Information",
  "Your order has been sent. Your pizza will arrive in 30-45 minutes",
  QMessageBox::Ok );
}
</programlisting>

	<para>
	Finally, by using the slots <function>accept()</> and
	<function>reject()</> we have committed ourselves to use the
	dialog as a modal dialog (instead of as a modeless dialog, as
	in the previous tutorial). Therefore we need to stretch the
	notion of &ldquo;clean Qt programming&rdquo; a bit in order to
	keep our test bed simple. Usually, you start the event
	processing by calling <function>QApplication::exec()</>, but
	since modal dialogs have an event loop of their own, we can
	get away with just calling <function>exec()</> on our dialog
	class. Here is the new file <filename>PizzaEntryTest.cpp</>:
	</para>

	<programlisting>
&num;include &lt;qapplication.h&gt;
&num;include "PizzaEntryImpl.h"

int main( int argc, char* argv[] )
{
  QApplication app( argc, argv );

  PizzaEntryImpl pizzaEntry( 0, "pizza entry", true);
  app.setMainWidget( &amp;pizzaEntry );
  int ret = pizzaEntry.exec();
  return ret;
}
</programlisting>

	<para>
	We should add that the <command>uic</> command has a special
	mode for generating empty skeletons for classes inheriting
	from the Qt Designer&ndash;generated classes. Section 5.4
	explains how to use this feature, but for now our application
	is still small enough that we can easily write everything by
	hand.
	</para>

	<para>
	You can now save your dialog in Qt Designer and compile and
	run it. Here are the command lines you need. For Unix with the
	<command>g++</> compiler:
	</para>

	<screen>
uic -o PizzaEntry.h pizza.ui
uic -i PizzaEntry.h -o PizzaEntry.cpp pizza.ui
moc -o moc&lowbar;PizzaEntry.cpp PizzaEntry.h
moc -o moc&lowbar;PizzaEntryImpl.cpp PizzaEntryImpl.h
moc -o moc&lowbar;PizzaEntryTest.cpp PizzaEntryTest.cpp
g++ -I&dollar;QTDIR/include PizzaEntry.cpp &bsol;
PizzaEntryTest.cpp PizzaEntryImpl.cpp
moc&lowbar;PizzaEntry.cpp moc&lowbar;PizzaEntryImpl.cpp &bsol;
-L&dollar;QTDIR/lib -lqt
</screen>

	<para>
	and for Windows with Visual C++:
	</para>

	<screen>
uic -o PizzaEntry.h pizza.ui
uic -i PizzaEntry.h -o PizzaEntry.cpp pizza.ui
moc -o moc&lowbar;PizzaEntry.cpp PizzaEntry.h
moc -o moc&lowbar;PizzaEntryImpl.cpp PizzaEntryImpl.h
moc -o moc&lowbar;PizzaEntryTest.cpp PizzaEntry.cpp
cl -c -nologo -I&percnt;QTDIR&percnt;/include &bsol;
-FoPizzaEntry.obj PizzaEntry.cpp
cl -c -nologo -I&percnt;QTDIR&percnt;/include &bsol;
-FoPizzaEntryImpl.obj PizzaEntryImpl.cpp
cl -c -nologo -I&percnt;QTDIR&percnt;/include &bsol;
-FoPizzaEntryTest.obj PizzaEntryTest.cpp
cl -c -nologo -I&percnt;QTDIR&percnt;/include &bsol;
-Fomoc&lowbar;PizzaEntry.obj moc&lowbar;PizzaEntry.cpp
cl -c -nologo -I&percnt;QTDIR&percnt;/include &bsol;
-Fomoc&lowbar;PizzaEntryImpl.obj &bsol;
moc&lowbar;PizzaEntryImpl.cpp
link /NOLOGO /SUBSYSTEM:windows &bsol;
/OUT:PizzaEntry PizzaEntry.obj &bsol; PizzaEntryTest.obj PizzaEntryImpl.obj &bsol;moc&lowbar;PizzaEntry.obj moc&lowbar;PizzaEntryImpl.obj &bsol;
&percnt;QTDIR&percnt;/lib/qt.lib kernel32.lib user32.lib &bsol;
gdi32.lib comdlg32.lib advapi32.lib &bsol;shell32.lib ole32.lib oleaut32.lib uuid.lib &bsol;imm32.lib winmm.lib wsock32.lib
</screen>

	<para>
	Now run the program and see what happens when you click either
	<guibutton>Cancel</> or <guibutton>OK</>.
	</para>
    </sect1>

    <sect1>
    <title>Initializing Widgets In The Form</title>

	<para>
	Our next objective is to initialize the widgets in the dialog.
	Continuing our pizza form exercise, we want to check all the
	toppings check boxes and select <guilabel>Family</> size.
	Finally, we want to check the extra cheese check box on
	Mondays, but only on Mondays.
	</para>

	<para>
	Initialization is usually done in a constructor, and our pizza
	order-entry application is no different. As before, we will
	not touch the code generated by <command>uic</>, because this
	code would be lost the next time we run <command>uic</>. So we
	are in for another addition to our derived class
	<classname>PizzaEntryImpl</>. So far, the constructor has been
	empty; now we will fill it with content.
	</para>

	<para>
	The task at hand is not very difficult, but we need to
	distinguish two different cases here. Checking the various
	toppings and selecting the <guilabel>Family</> size is static;
	we always want to do that. But checking the <guilabel>Extra
	Cheese</> check box on Mondays is not static; we need to
	compute the day of the week first. Let's start with the simple
	case, the static selections.
	</para>

	<para>
	Whether or not a check box is checked is a property of the
	check box and the radio buttons. So we can use the property
	editor to set these properties: click each of the toppings
	check boxes and set the value of the property
	<literal>checked</> to <literal>true</> by selecting
	<literal>true</> from the combo box in the value column. Do
	the same for the <guilabel>Family</> radio button. That's it.
	</para>

	<para>
	Now for the <guilabel>Extra Cheese</> check box. Since we do
	not know before runtime whether or not the check box should be
	checked when the pizza entry form is shown, we cannot use the
	property editor; we have to do this programmatically. In
	theory, we just have to determine whether it is a Monday, call
	<function>setChecked()</> on the <guilabel>Extra Cheese</>
	check box, and pass the desired value. The question is, how do
	we get access to this widget?
	</para>

	<para>
	Situations like this are very common, so Qt Designer provides
	a very simple solution: all widgets are represented as
	pointers with <literal>public</> access in the generated base
	class. All you need to do is identify the correct widget
	pointer and call <function>setChecked()</> on it.
	</para>

	<para>
	If you refer to the generated file <filename>PizzaEntry.h</>,
	you will see that the widget pointers have non-obvious names
	like <literal>CheckBox1</> or <literal>RadioButton3</>. It is
	not too late to appropriately assign the <literal>name</>
	properties for all the widgets. Just load the file
	<filename>pizza.ui</> into Qt Designer, change all
	<literal>name</> properties, save the file, and regenerate
	<filename>PizzaEntry.h</> and <filename>PizzaEntry.cpp</>.
	</para>

	<para>
	But as this pizza exercise is just a simple example, we could
	also just guess or check in Qt Designer which variable
	represents the <guilabel>Extra Cheese</> check box. Here is
	what we guessed (the name might be slightly different for you,
	depending on the order in which you originally inserted the
	widgets):
	</para>

	<programlisting>
&num;include &lt;qcheckbox.h&gt;
&num;include &lt;qradiobutton.h&gt;
&num;include &lt;qdatetime.h&gt;

PizzaEntryImpl::PizzaEntryImpl( QWidget* parent,
                const char* name, bool modal, WFlags f )
: PizzaEntry( parent, name, modal, f )
{
  QDate date = QDate::currentDate();
  if( date.dayOfWeek() == 1 )
    CheckBox5-&gt;setChecked( true );
  else
    CheckBox5-&gt;setChecked( false );
}
</programlisting>

	<para>
	As you can see, we use the class <classname>QDate</> and its
	methods <function>currentDate()</> and
	<function>dayOfWeek()</> to determine whether the current day
	is a Monday. Based on this information, we either call
	<literal>setChecked( true )</> or <literal>setChecked( false
	)</>.
	</para>

	<para>
	Now add this code to your file <classname>PizzaEntryImpl.cpp</>,
	and don't forget to remove the empty constructor
	implementation from <filename>PizzaEntryImpl.h</>. Compile
	your program with exactly the same commands as in Section 2.3
	and run it. The widgets should appear initialized as
	specified.
	</para>
    </sect1>

    <sect1>
    <title>Connecting Widgets</title>

	<para>
	We have one task left: to enable the <guilabel>Extra Cheese</>
	check box when ever the <guilabel>Anchovies</> check box is
	checked and disable it if the <guilabel>Anchovies</> check box
	is unchecked. You might expect to make more additions to the
	<classname>PizzaEntryImpl</> class, but this is not the case: All
	we have to do is connect the right signals and slots to each
	other and let Qt Designer and <command>uic</> do the rest!
	</para>

	<para>
	First restart Qt Designer again and load
	<filename>pizza.ui</>. This time we can use predefined slots
	instead of creating new ones. Start the connection tool by
	hitting <keycap>F3</> (or by any other of the previously
	described means&mdash;see Section 3.2) and &ldquo;draw&rdquo;
	a connection between the <guilabel>Anchovies</> check box and
	the <guilabel>Extra Cheese</>. In the <guilabel>Connections</>
	dialog that appears, connect the <function>toggled(bool)</>
	signal (which is emitted when the <guilabel>Anchovies</> check
	box is operated), to the <function>setEnabled(bool)</> slot.
	Close the dialog with <guibutton>OK</>. That's all! Save your
	work and compile your program as previously described in
	Section 3.2. Run the program and check that it actually does
	what we wanted.
	</para>
    </sect1>
</chapter>
