<chapter>
<title id="subclassingdynamicdialogs">
Subclassing and Dynamic Dialogs</title>
<para id="amuw">
<indexterm><primary>Subclassing</primary></indexterm>

<indexterm><primary>Dynamic Dialogs</primary></indexterm>

<indexterm><primary>Dialogs</primary><secondary>Dynamic</secondary></indexterm>

This chapter describes two different approaches that you can take to
creating forms with <emphasis>Qt Designer</>. Subclassing is used to extend the functionality
of a form by creating your own class based upon a form you create in
<emphasis>Qt Designer</>. Dynamic dialogs are <indexterm><primary>Files and file types</primary><secondary>.ui</secondary></indexterm>
<filename>.ui</> files which can be
executed by a Qt application; this keeps the GUI design and the code
separate and is useful in environments where the GUI may have to
change more often than the underlying application logic.
</para>

<sect1 id="subclassing">
<title>Subclassing</title>
<!--
<sidebar id="subclassingvscodinginqtdesigner">
<title>Subclassing vs Coding in <emphasis>Qt Designer</></title>
<para id="amvl">
Adding slots directly in <emphasis>Qt Designer</> is a useful technique suitable for most
situations. But in some cases we want to use our own constructor or
destructor rather than the supplied <indexterm><primary>Functions</primary><secondary>init()</secondary></indexterm>
<function>init()</> and
<indexterm><primary>Functions</primary><secondary>destroy()</secondary></indexterm>
<function>destroy()</> functions. Also, for more complex
applications, it may be easier to debug the code in separate files since
the line numbers in error messages refer to the lines where our code
appears in the generated code rather where they appear in <emphasis>Qt Designer</>'s code
editor.
</para>
<para id="amvv">
Many applications consist of a main window plus dialogs, where most of
the functionality is in the main window, and where the dialogs are used
to get preferences from the user. In such cases the most convenient
approach may be to subclass the main window (to ease debugging) and code
the dialogs wholly within <emphasis>Qt Designer</>. 
</para>
</sidebar>
-->
<para id="amwe">
We'll start with a general description of how to subclass a form and
follow with a short example.
</para>

<sect2 id="turningdesignersuifilesintosourcecode">
<title>Generating Source Code from <emphasis>Qt Designer</> .ui Files</title>
<para id="amwl">
<emphasis>Qt Designer</> reads and writes <indexterm><primary>qmake</primary></indexterm>
<command>qmake</> <indexterm><primary>Files and file types</primary><secondary>.pro</secondary></indexterm>
<filename>.pro</> (project)
files which are used to record the files used to build the application
and from which Makefiles are generated. <emphasis>Qt Designer</> also reads and writes
<indexterm><primary>Files and file types</primary><secondary>.ui</secondary></indexterm>
<filename>.ui</> (user interface) files. These are XML files
that record the widgets, layouts, source code and settings you've used
for a form. Every <indexterm><primary>Files and file types</primary><secondary>.ui</secondary></indexterm>
<filename>.ui</> file is converted by
the <indexterm><primary>uic</primary></indexterm>
<command>uic</> (user interface compiler) into a C++ <indexterm><primary>Files and file types</primary><secondary>.h</secondary></indexterm>
<filename>.h</>
file and a C++ <indexterm><primary>Files and file types</primary><secondary>.cpp</secondary></indexterm>
<filename>.cpp</> file. These C++ files are then
read by <indexterm><primary>moc</primary></indexterm>
<command>moc</> (meta object compiler), and finally compiled by your
compiler into a working application.
</para>

<para id="amwy">
<indexterm><primary>Makefiles</primary></indexterm>

<indexterm><primary>Projects</primary><secondary>Adding Files</secondary></indexterm>

<indexterm><primary>Adding</primary><secondary>Files to Projects</secondary></indexterm>

If you create applications wholly within <emphasis>Qt Designer</> you only need to create a
<indexterm><primary>Files and file types</primary><secondary>main.cpp</secondary></indexterm>
<filename>main.cpp</> and add 
<programlisting>
SOURCES += main.cpp
</programlisting>
at the end of your project's <indexterm><primary>Files and file types</primary><secondary>.pro</secondary></indexterm>
<filename>.pro</> file. You can
then use <indexterm><primary>qmake</primary></indexterm>
<command>qmake</> to generate the Makefile. (For example
<literal>qmake -o Makefile myproject.pro</literal>.) Running <indexterm><primary>make</primary></indexterm>
<command>make</>
(Linux, Unix or Borland compilers), or <indexterm><primary>nmake</primary></indexterm>
<command>nmake</> (Visual C++), will
then call <indexterm><primary>uic</primary></indexterm>
<command>uic</>, <indexterm><primary>moc</primary></indexterm>
<command>moc</> and your compiler as necessary to build
your application.
</para>

<para id="amxm">
<indexterm><primary>Errors</primary><secondary>Undefined reference</secondary></indexterm>

<indexterm><primary>Undefined references, Error</primary></indexterm>

<indexterm><primary>qmake</primary><secondary>HEADERS</secondary></indexterm>

<indexterm><primary>qmake</primary><secondary>SOURCES</secondary></indexterm>

If you use <emphasis>Qt Designer</> to create your main window and dialogs, but also add
other C++ files, or if you subclass any of your forms you will need to
add these files to the <indexterm><primary>Files and file types</primary><secondary>.pro</secondary></indexterm>
<filename>.pro</> file so that they are
compiled with the rest of your application's source files. Each
<indexterm><primary>Files and file types</primary><secondary>.h</secondary></indexterm>
<filename>.h</> file that you create separately from <emphasis>Qt Designer</> should
be added to the <literal>HEADERS</literal> line, and each
<indexterm><primary>Files and file types</primary><secondary>.cpp</secondary></indexterm>
<filename>.cpp</> file should be added to the
<literal>SOURCES</literal> line, just as we've done for
<indexterm><primary>Files and file types</primary><secondary>main.cpp</secondary></indexterm>
<filename>main.cpp</>. If you get undefined reference errors it
is worth checking that you've added the names of all your header and
implementation files to the <indexterm><primary>Files and file types</primary><secondary>.pro</secondary></indexterm>
<filename>.pro</> file.
</para>

</sect2>


<sect2 id="subclassingaform">
<title>Subclassing a Form </title>

<para id="amyg">
<indexterm><primary>Subclassing</primary></indexterm>

When subclassing a form it is helpful to use a naming convention 
to help us identify which files are generated from <emphasis>Qt Designer</>'s
<indexterm><primary>Files and file types</primary><secondary>.ui</secondary></indexterm>
<filename>.ui</> files and which are hand coded. 
</para>
<para id="amyl">
Suppose, for example, that we are developing a dialog and writing the
code directly in <emphasis>Qt Designer</>. We might call our dialog 'OptionsForm' and the
<indexterm><primary>Files and file types</primary><secondary>.ui</secondary></indexterm>
<filename>.ui</> file, <filename>optionsform.ui</>. The
automatically generated files will be <filename>optionsform.h</>
and <filename>optionsform.cpp</>.
</para>
<para id="amys">
If we were developing another dialog, but this time one that we intended
to subclass, we want to make it easy to distinguish between the
automatically generated files and our hand coded files. For example, we
might call our dialog 'SettingsFormBase' and the
<indexterm><primary>Files and file types</primary><secondary>.ui</secondary></indexterm>
<filename>.ui</> file <filename>settingsformbase.ui</>.
The automatically generated files would then be called
<filename>settingsformbase.h</> and
<filename>settingsformbase.cpp</>. We would then call our
subclass 'SettingsForm' and code it in the files
<filename>settingsform.h</> and
<filename>settingsform.cpp</>. 
</para>
<para id="amzf">
<indexterm><primary>Q_OBJECT</primary><seealso>Macros</seealso></indexterm>

<indexterm><primary>Macros</primary><secondary>Q_OBJECT</secondary></indexterm>

<indexterm><primary>Signals and Slots</primary><secondary>Q_OBJECT</secondary></indexterm>

Any subclass of a form should include the <literal>Q_OBJECT</literal>
macro so that slots and signals will work correctly. Once you've created
your subclass be sure to add the <indexterm><primary>Files and file types</primary><secondary>.h</secondary></indexterm>
<filename>.h</> and the
<indexterm><primary>Files and file types</primary><secondary>.cpp</secondary></indexterm>
<filename>.cpp</> files to the <indexterm><primary>Files and file types</primary><secondary>.pro</secondary></indexterm>
<filename>.pro</> project
file. For example we would add the following lines for our subclassed
'SettingsForm' at the end of the <indexterm><primary>Files and file types</primary><secondary>.pro</secondary></indexterm>
<filename>.pro</> file:
<programlisting>
HEADERS += settingsform.h
SOURCES += settingsform.cpp
</programlisting>
<emphasis>Qt Designer</> will have added
<programlisting>
INTERFACES = settingsformbase.ui
</programlisting>
to the project file. The <filename>settingsformbase.h</> and
<filename>settingsformbase.cpp</> files will be generated from
the <indexterm><primary>Files and file types</primary><secondary>.ui</secondary></indexterm>
<filename>.ui</> file automatically.
</para>
</sect2>


<sect2 id="asubclassingexample">
<title>A Subclassing Example </title>
<para id="anad">
We will write a small example dialog to show the use of subclassing in
practice. The dialog will present a choice of customer credit ratings
with an option of choosing a 'special' rating for which a specific
amount must be given. We'll implement the functionality in a subclass.
We'll start by creating the base form and connecting its signals and
slots, then we'll create the subclass and a simple
<indexterm><primary>Files and file types</primary><secondary>main.cpp</secondary></indexterm>
<filename>main.cpp</> so that we can test it.
</para>

<sect3>
<title>Designing the Form </title>

<para id="anaq">
<indexterm><primary>Projects</primary><secondary>Creating New</secondary></indexterm>

We'll begin by creating a new project.
Click <indexterm><primary>Menu Options</primary><secondary>File|New Project</secondary></indexterm>
<guimenuitem>File|New Project</> to invoke the <indexterm><primary>Dialogs</primary><secondary>Project Settings</secondary></indexterm>
Project Settings
dialog, and type in a project
name of 'credit' and a project file name of 'credit.pro' then click
<guibutton>OK</>. Now we'll add a form to the project.
Click <indexterm><primary>Menu Options</primary><secondary>File|New</secondary></indexterm>
<guimenuitem>File|New</> to invoke the <indexterm><primary>Dialogs</primary><secondary>New Form</secondary></indexterm>
New Form
dialog. The default form is Dialog which is what we want; click <guibutton>OK</>.
Resize the form to make it smaller; it should be about 2 inches (5 cm)
square. Change the form's name to 'CustomerFormBase' and the caption to
'Credit Rating'. Save the form as 'customerformbase.ui'.
</para>
<para id="anbb">
We'll now add the widgets we need.
<orderedlist numeration="arabic">
<listitem>
<para id="anbf">
Click the <indexterm><primary>Toolbar Buttons</primary><secondary>Button Group</secondary></indexterm>
<indexterm><primary>Widgets</primary><secondary>Button Group</secondary></indexterm>
<guibutton>Button Group</> toolbar button, then click
near the top left of the form. Resize the button group so that it takes
up approximately half the form. Change the button group's <indexterm><primary>Properties</primary><secondary>name</secondary></indexterm>
name to
'creditButtonGroup' and its <indexterm><primary>Properties</primary><secondary>title</secondary></indexterm>
title property to 'Credit Rating'.
</para>
</listitem>
<listitem>
<para id="anbn">
We'll now add some radio buttons. <emphasis>Double</emphasis> click the
<indexterm><primary>Toolbar Buttons</primary><secondary>Radio Button</secondary></indexterm>
<indexterm><primary>Widgets</primary><secondary>Radio Button</secondary></indexterm>
<guibutton>Radio Button</> toolbar button. Click towards the
top of the Credit Rating button group and a radio button will appear.
Click below this button, to create a second radio button, then click
below the second button to create a third. Now we will switch off the
effect of the <emphasis>double</> click by clicking the
<indexterm><primary>Toolbar Buttons</primary><secondary>Pointer</secondary></indexterm>
<guibutton>Pointer</> (arrow) toolbar button. The pointer will now
behave normally, i.e. clicking the form will no longer create
more radio buttons. 
Change the first radio button's <indexterm><primary>Properties</primary><secondary>name</secondary></indexterm>
name to
'stdRadioButton' and its text to '&amp;Standard'. Change its <indexterm><primary>Properties</primary><secondary>checked</secondary></indexterm>
checked
property to True. Change the second
button's name to 'noneRadioButton' and its text to '&amp;None'. Change
the third radio button's properties to 'specialRadioButton' and
'Sp&amp;ecial' respectively.
</para>
</listitem>
<listitem>
<para id="ance">
If the user chooses the special credit rating they must specify an amount.
Click the <indexterm><primary>Toolbar Buttons</primary><secondary>SpinBox</secondary></indexterm>
<indexterm><primary>Widgets</primary><secondary>SpinBox</secondary></indexterm>
<guibutton>SpinBox</> toolbar button and click the
form just below the button group. Change the spin box's <indexterm><primary>Properties</primary><secondary>name</secondary></indexterm>
name to
'amountSpinBox'. Change its <indexterm><primary>Properties</primary><secondary>prefix</secondary></indexterm>
prefix to '$ ' (note the space), its
<indexterm><primary>Properties</primary><secondary>maxValue</secondary></indexterm>
maxValue to '100000' and its <indexterm><primary>Properties</primary><secondary>lineStep</secondary></indexterm>
lineStep to '10000'. 
Change its <indexterm><primary>Properties</primary><secondary>enabled</secondary></indexterm>
enabled property to False.
</para>
</listitem>
<listitem>
<para id="anco">
Click the <indexterm><primary>Toolbar Buttons</primary><secondary>Push Button</secondary></indexterm>
<indexterm><primary>Widgets</primary><secondary>Push Button</secondary></indexterm>
<guibutton>Push Button</> toolbar button and click
the form below the spin box. Change the button's <indexterm><primary>Properties</primary><secondary>name</secondary></indexterm>
name to
'okPushButton', its <indexterm><primary>Properties</primary><secondary>text</secondary></indexterm>
text to 'OK' and its <indexterm><primary>Properties</primary><secondary>default</secondary></indexterm>
default 
property to 'True'. Add
a second button to the right of the first. Change the second button's
<indexterm><primary>Properties</primary><secondary>name</secondary></indexterm>
name to 'cancelPushButton' and its <indexterm><primary>Properties</primary><secondary>text</secondary></indexterm>
text to 'Cancel'.
</para>
</listitem>
</orderedlist>
</para>

<para id="ancz">
We'll now lay out the widgets and connect up the slots we need.
<orderedlist numeration="arabic">
<listitem>
<para id="andd">
Click the form so that no widgets are selected. <indexterm><primary>Keypresses (Qt Designer)</primary><secondary>Ctrl+Click</secondary></indexterm>
<keycap>Ctrl+Click</> the Standard
radio button and drag the rubber band so that it touches the other two
radio buttons, then release. Press <indexterm><primary>Keypresses (Qt Designer)</primary><secondary>Ctrl+L</secondary></indexterm>
<keycap>Ctrl+L</> (lay out
vertically). Click the Credit Rating button group, then press
<indexterm><primary>Keypresses (Qt Designer)</primary><secondary>Ctrl+H</secondary></indexterm>
<keycap>Ctrl+H</> (lay out horizontally).
</para>
</listitem>
<listitem>
<para id="andm">
Click the form so that the button group is no longer selected.
<indexterm><primary>Keypresses (Qt Designer)</primary><secondary>Ctrl+Click</secondary></indexterm>
<keycap>Ctrl+Click</> the OK button and drag the rubber band to touch the Cancel
button, then release. Press <indexterm><primary>Keypresses (Qt Designer)</primary><secondary>Ctrl+H</secondary></indexterm>
<keycap>Ctrl+H</>.
</para>
</listitem>
<listitem>
<para id="andt">
Click the form, then press <indexterm><primary>Keypresses (Qt Designer)</primary><secondary>Ctrl+L</secondary></indexterm>
<keycap>Ctrl+L</>.
</para>
<para id="andw">
<indexterm><primary>Layouts</primary><secondary>Spacers</secondary></indexterm>

The buttons expand to take up the full width of the form. It might look
more attractive to use spacers with them. Click the OK button, then
press <indexterm><primary>Keypresses (Qt Designer)</primary><secondary>Ctrl+B</secondary></indexterm>
<keycap>Ctrl+B</> (break layout). Resize both buttons to
make them narrower leaving space on either side of them. Click the
<indexterm><primary>Toolbar Buttons</primary><secondary>Spacer</secondary></indexterm>
<indexterm><primary>Widgets</primary><secondary>Spacer</secondary></indexterm>
<guibutton>Spacer</> toolbar button then click to the left of
the OK button; click Horizontal from the pop up spacer menu. Copy this
spacer and place the copy between the two buttons. Copy the spacer again
and place the copy to the right of the Cancel button. (For the second
and third spacers, click on the first spacer, press
<indexterm><primary>Keypresses (Qt Designer)</primary><secondary>Ctrl+C</secondary></indexterm>
<keycap>Ctrl+C</> then <indexterm><primary>Keypresses (Qt Designer)</primary><secondary>Ctrl+V</secondary></indexterm>
<keycap>Ctrl+V</>. Drag the new
spacer to the desired position.) Ctrl+Click the left most spacer and
drag the rubber band so that it touches the buttons and the spacers,
then release. Press <indexterm><primary>Keypresses (Qt Designer)</primary><secondary>Ctrl+H</secondary></indexterm>
<keycap>Ctrl+H</>.
Click the form then press <indexterm><primary>Keypresses (Qt Designer)</primary><secondary>Ctrl+L</secondary></indexterm>
<keycap>Ctrl+L</>.
</para>
</listitem>
</orderedlist>
</para>

<para id="aneq">
<indexterm><primary>Signals and Slots</primary></indexterm>

We'll now connect the signals and slots. Press <indexterm><primary>Keypresses (Qt Designer)</primary><secondary>F3</secondary></indexterm>
<keycap>F3</>
(connect signals/slots), then click the OK button. Drag to the form and
release. In the <indexterm><primary>Dialogs</primary><secondary>Edit Connections</secondary></indexterm>
Edit Connections dialog that pops up connect the
<indexterm><primary>Signals and Slots</primary><secondary>clicked()</secondary></indexterm>
<function>clicked()</> signal to the <indexterm><primary>Signals and Slots</primary><secondary>accept()</secondary></indexterm>
<function>accept()</> slot. (Click the
<indexterm><primary>Signals and Slots</primary><secondary>clicked()</secondary></indexterm>
<function>clicked()</> signal, click the <indexterm><primary>Signals and Slots</primary><secondary>accept()</secondary></indexterm>
<function>accept()</> slot, then click <guibutton>OK</>.)
Connect the Cancel button to the <indexterm><primary>Signals and Slots</primary><secondary>reject()</secondary></indexterm>
<function>reject()</> slot using the same
technique. 
</para>
<para id="anfc">
We want the amount spin box to be enabled only if the special radio
button is checked. Press <indexterm><primary>Keypresses (Qt Designer)</primary><secondary>F3</secondary></indexterm>
<keycap>F3</> (connect signals/slots),
then click the
special radio button. Drag to the spin box and release. In the 
<indexterm><primary>Dialogs</primary><secondary>Edit Connections</secondary></indexterm>
Edit Connections dialog that pops up click the <indexterm><primary>Signals and Slots</primary><secondary>toggled()</secondary></indexterm>
<function>toggled()</>
signal and the <indexterm><primary>Signals and Slots</primary><secondary>setEnabled()</secondary></indexterm>
<function>setEnabled()</> slot. 
</para>
<para id="anfk">
If the user checks the standard or none radio buttons we want to set the
amount accordingly. Press <indexterm><primary>Keypresses (Qt Designer)</primary><secondary>F3</secondary></indexterm>
<keycap>F3</>,
then click the credit rating button group. Drag to the form and release.
Click the <indexterm><primary>Signals and Slots</primary><secondary>clicked()</secondary></indexterm>
<function>clicked()</> signal.
We want to connect this signal to our own custom slot, but we
haven't created one yet. Click the <guibutton>Edit Slots</>
button and the Edit Slots dialog will pop up. Click
<guibutton>New Slot</> and change the Slot's name to
'setAmount()'. Click <guibutton>OK</>. This new slot is now
available in the list of slots. Click the
<function>setAmount()</> slot then click <guibutton>OK</>.
</para>

<para id="anfy">
We'll subclass the form to set the amount in the spin box depending on
which radio button is checked. Save the form as 'creditformbase.ui' (press
<indexterm><primary>Keypresses (Qt Designer)</primary><secondary>Ctrl+S</secondary></indexterm>
<keycap>Ctrl+S</>). 
</para>
</sect3>


<sect3 id="creatingthetestharness">
<title>Creating the Test Harness </title>
<para id="angi">
<indexterm><primary>Forms</primary><secondary>Creating Test Harnesses</secondary></indexterm>

<indexterm><primary>Creating Test Harnesses for Forms</primary></indexterm>

<indexterm><primary>Subclassing</primary></indexterm>

Although we intend our dialog to be used within an application it is
useful to create a test harness so that we can develop and test it
stand-alone. We'll create a standard <indexterm><primary>Files and file types</primary><secondary>main.cpp</secondary></indexterm>
<filename>main.cpp</> as
follows:
<programlisting>
#include &lt;qapplication.h&gt;
#include "creditformbase.h"

int main( int argc, char *argv[] ) 
{
    QApplication app( argc, argv );

    CreditFormBase creditForm;
    app.setMainWidget( &amp;creditForm );
    creditForm.show();

    return app.exec();
}
</programlisting>
Note that we're including <filename>creditformbase.h</> and
instantiating a CreditFormBase object; once
we've written our subclass we'll replace the header with our subclass,
<filename>creditform.h</>, and instantiate a CreditForm.
</para>
<para id="anhh">
<indexterm><primary>Projects</primary><secondary>Adding Files</secondary></indexterm>

<indexterm><primary>Adding</primary><secondary>Files to Projects</secondary></indexterm>

Add <indexterm><primary>Files and file types</primary><secondary>main.cpp</secondary></indexterm>
<filename>main.cpp</> to the <indexterm><primary>Files and file types</primary><secondary>credit.pro</secondary></indexterm>
<filename>credit.pro</>
project file by adding the following line at the end:
<programlisting>
SOURCES += main.cpp
</programlisting>
We can now generate the application with <indexterm><primary>qmake</primary></indexterm>
<command>qmake</>, e.g.
<literal>qmake -o Makefile credit.pro</literal>, make it and run it.
The form should run fine, but doesn't yet have the behaviour we require.
</para>
</sect3>


<sect3 id="creatingthesubclass">
<title>Creating the Subclass </title>
<para id="anhw">
We need to create a header and an implementation file for our subclass.
The code for our subclass is minimal. The header file is
<filename>qt/tools/designer/examples/credit/creditform.h</>:
<programlisting>
#include &quot;creditformbase.h&quot;

class CreditForm : public CreditFormBase
{
    Q_OBJECT
public:
    CreditForm( <emphasis role="bold">QWidget</>* parent = 0, const char* name = 0, 
                bool modal = FALSE, WFlags fl = 0 );
    ~CreditForm();
public slots:
    void setAmount();
};
</programlisting>
<indexterm><primary>Macros</primary><secondary>Q_OBJECT</secondary></indexterm>

<indexterm><primary>Q_OBJECT</primary></indexterm>

We've declared the slot, <function>setAmount()</>,
that we created in <emphasis>Qt Designer</>. The <literal>Q_OBJECT</literal> macro is
included because it is essential for classes that use signals and slots.
</para>
<para id="anih">
The implementation in 
<filename>qt/tools/designer/examples/credit/creditform.cpp</> is
simple:
<programlisting>
#include &lt;qradiobutton.h&gt;
#include &lt;qspinbox.h&gt;
#include &quot;creditform.h&quot;

CreditForm::CreditForm( <emphasis role="bold">QWidget</>* parent, const char* name, 
                        bool modal, WFlags fl )
    : CreditFormBase( parent, name, modal, fl ) 
{  
    setAmount(); 
}

CreditForm::~CreditForm() { <emphasis>/* NOOP */</> }

void CreditForm::setAmount() 
{
    if ( stdRadioButton-&gt;isChecked() )
        amountSpinBox-&gt;setValue( amountSpinBox-&gt;maxValue() / 2 );
    else if ( noneRadioButton-&gt;isChecked() )
        amountSpinBox-&gt;setValue( amountSpinBox-&gt;minValue() );
}
</programlisting>
We call <function>setAmount()</> in the constructor to ensure
that the correct amount is shown when the form starts based on whichever
radio button we checked in <emphasis>Qt Designer</>. In <function>setAmount()</> we
set the amount if the standard or none radio button is checked. If the
user has checked the special radio button they are free to change the
amount themselves.
</para>

<para id="aniw">
<indexterm><primary>Makefiles</primary></indexterm>

<indexterm><primary>qmake</primary><secondary>HEADERS</secondary></indexterm>

<indexterm><primary>qmake</primary><secondary>SOURCES</secondary></indexterm>

To be able to test our subclass we change <indexterm><primary>Files and file types</primary><secondary>main.cpp</secondary></indexterm>
<filename>main.cpp</>
to include <filename>creditform.h</> rather than
<filename>creditformbase.h</> and change the instantiation of
the creditForm object:
<programlisting>
#include &lt;qapplication.h&gt;
#include &quot;creditform.h&quot;
int main( int argc, char *argv[] ) 
{
    <emphasis role="bold">QApplication</> app( argc, argv );

    CreditForm creditForm;
    app.setMainWidget( &amp;creditForm );
    creditForm.show();

    return app.exec();
}
</programlisting>
We must also update the project file by adding two new lines at the end:
<programlisting>
HEADERS += creditform.h
SOURCES += creditform.cpp
</programlisting>
To test the form rerun <indexterm><primary>qmake</primary></indexterm>
<command>qmake</> to regenerate the Makefile, then make
and run.
</para>

<para id="anjo">
The subclassing example we've used is simple, but this reflects
subclassing forms in Qt: it is easy to do. 
</para>

</sect3>

</sect2>

</sect1>

<sect1 id="creatingdynamicdialogsfromuifiles">
<title>Creating Dynamic Dialogs from .ui Files </title>
<para id="ankb">
<indexterm><primary>Dynamic Dialogs</primary></indexterm>

<indexterm><primary>Dialogs</primary><secondary>Dynamic</secondary></indexterm>

<indexterm><primary>Code Editing</primary><secondary>Not in Dynamic Dialogs</secondary></indexterm>

Qt programs are capable of
loading <emphasis>Qt Designer</> <indexterm><primary>Files and file types</primary><secondary>.ui</secondary></indexterm>
<filename>.ui</> files and instantiating the forms
represented by the <indexterm><primary>Files and file types</primary><secondary>.ui</secondary></indexterm>
<filename>.ui</> files. Since the
<indexterm><primary>Files and file types</primary><secondary>.ui</secondary></indexterm>
<filename>.ui</> file is not compiled it
cannot include any C++ code, (e.g. slot implementations). In this
section we will explain how to load a dynamic dialog and how to create a
class that can be used to implement the dynamic dialog's custom slots.
</para>
<para id="ankk">
We will use the credit form that we created in the subclassing section
as our example form. We will start by simply instantiating and running
the form and then we'll cover how to implement custom slots. 
</para>

<para id="ankq">
We'll create a <indexterm><primary>Files and file types</primary><secondary>main.cpp</secondary></indexterm>
<filename>main.cpp</> file to use as a test
harness, and manually create a project file. 
</para>


<sect2 id="creatingtheprojectfile">
<title>Creating the Project File </title>

<para id="ankz">
The project file
<filename>qt/tools/designer/examples/receiver1/receiver.pro</> looks like
this:
<programlisting>
TEMPLATE    = app
CONFIG     += qt warn_on release
TARGET      = receiver
SOURCES    += main.cpp
unix:LIBS  += -lqui
win32:LIBS += $(QTDIR)/lib/qui.lib
INTERFACES  = mainform.ui 
IMAGEFILE   = images.cpp
PROJECTNAME = receiver
LANGUAGE    = C++
INCLUDEPATH += $(QTDIR)/tools/designer/uilib
</programlisting>
We do <emphasis>not</emphasis> include the
<filename>creditformbase.ui</> file since this file will be read
at runtime, as we'll see shortly. We must include the
<function>qresource</> library since the functionality we
require is not part of the standard Qt library.
</para>
</sect2>


<sect2 id="creatingmaincpp">
<title>Creating main.cpp </title>

<para id="anlz">
The <indexterm><primary>Files and file types</primary><secondary>main.cpp</secondary></indexterm>
<filename>main.cpp</> is quite standard. It will invoke the
form we're going to create in <emphasis>Qt Designer</> as its main form. This form will then
load and execute the dynamic dialog. 
<programlisting>
#include &lt;qapplication.h&gt;
#include &quot;mainform.h&quot;

int main( int argc, char *argv[] ) 
{
    <emphasis role="bold">QApplication</> app( argc, argv );

    MainForm *mainForm = new MainForm;
    app.setMainWidget( mainForm );
    mainForm-&gt;show(); 

    return app.exec();
}
</programlisting>
We create a new instance of our MainForm class, set it to be the main
widget, show it and enter the event loop in the
<filename>app.exec()</> call.
</para>
</sect2>


<sect2 id="creatingthemainform">
<title>Creating the Main Form </title>

<sect3 id="designingtheform">
<title>Designing the Form </title>

<para id="anmv">
    <orderedlist numeration="arabic">
    <listitem>
	<para id="anmy">
	Open the <indexterm><primary>Files and file types</primary><secondary>receiver.pro</secondary></indexterm>
<filename>receiver.pro</> project file in <emphasis>Qt Designer</>. We'll create a
	dialog as our main window which we'll use to invoke the dynamic
	dialog. Press <indexterm><primary>Keypresses (Qt Designer)</primary><secondary>Ctrl+N</secondary></indexterm>
<keycap>Ctrl+N</> to launch the <indexterm><primary>Dialogs</primary><secondary>New Form</secondary></indexterm>
New Form dialog and
	click <guibutton>OK</> to get the default which is a dialog. Change the
	dialog's name to 'MainForm' and its caption to 'Main Form'. Add
	two buttons, one called 'creditPushButton' with the text
	'&amp;Credit Dialog', and the other called 'quitPushButton' with
	the text '&amp;Quit'. (For each button click the
	<indexterm><primary>Toolbar Buttons</primary><secondary>Push Button</secondary></indexterm>
<indexterm><primary>Widgets</primary><secondary>Push Button</secondary></indexterm>
<guibutton>Push Button</> toolbar button, then click the form.
	Change the properties in the property window to those we've just
	described.)
	</para>
    </listitem>
    <listitem>
	<para id="annm">
	We will now add a couple of labels so that we can show the
	settings the user chose in the dynamic dialog. Click the
	<indexterm><primary>Toolbar Buttons</primary><secondary>Text Label</secondary></indexterm>
<indexterm><primary>Widgets</primary><secondary>Text Label</secondary></indexterm>
<guibutton>Text Label</> toolbar button, then click the
	form below the Credit Dialog button. Change the label's <indexterm><primary>Properties</primary><secondary>text</secondary></indexterm>
text to
	'Credit Rating'. Add another text label below the Quit button.
	Change its <indexterm><primary>Properties</primary><secondary>name</secondary></indexterm>
name to 'ratingTextLabel' and its <indexterm><primary>Properties</primary><secondary>text</secondary></indexterm>
text
	to 'Unrated'. 
	</para>
    </listitem>
    <listitem>
	<para id="annw">
	We'll now lay out the widgets. Click the form then press
	<indexterm><primary>Keypresses (Qt Designer)</primary><secondary>Ctrl+G</secondary></indexterm>
<keycap>Ctrl+G</> (lay out in a grid).
	</para>
    </listitem>
    <listitem>
	<para id="anoc">
	<indexterm><primary>Signals and Slots</primary><secondary>Connecting to Close a Dialog</secondary></indexterm>

	We'll now handle the signals and slots connections. Press
	<indexterm><primary>Keypresses (Qt Designer)</primary><secondary>F3</secondary></indexterm>
<keycap>F3</> (connect signals/slots). Click the Credit Dialog
	button, drag to the form and release. Click the
	<indexterm><primary>Signals and Slots</primary><secondary>clicked()</secondary></indexterm>
<function>clicked()</> signal. We'll need to implement a custom
	slot. Click <guibutton>Edit Slots</> to invoke the <indexterm><primary>Dialogs</primary><secondary>Edit Slots</secondary></indexterm>
Edit Slots
	dialog. Click <guibutton>New Slot</> and type in the Slot name
	'creditDialog()'. Click <guibutton>OK</>. The new slot is now in
	the list of slots; click the <function>creditDialog()</> slot to
	make the connection then click <guibutton>OK</>. Connect the Quit button's
	<indexterm><primary>Signals and Slots</primary><secondary>clicked()</secondary></indexterm>
<function>clicked()</> signal to the
	dialog's <indexterm><primary>Signals and Slots</primary><secondary>accept()</secondary></indexterm>
<function>accept()</> function. (Press
	<indexterm><primary>Keypresses (Qt Designer)</primary><secondary>F3</secondary></indexterm>
<keycap>F3</>. Click the Quit button and drag to the form;
	release. Click the <indexterm><primary>Signals and Slots</primary><secondary>clicked()</secondary></indexterm>
<function>clicked()</> signal and the
	<indexterm><primary>Signals and Slots</primary><secondary>accept()</secondary></indexterm>
<function>accept()</> slot, then click <guibutton>OK</>.)
	</para>
    </listitem>
    </orderedlist>
</para>
<para id="anov">
Save the form and call it <filename>mainform.ui</>. (Press
<indexterm><primary>Keypresses (Qt Designer)</primary><secondary>Ctrl+S</secondary></indexterm>
<keycap>Ctrl+S</> and enter the filename.) In the next section
we'll write the code for loading and launching the dynamic dialog
directly in <emphasis>Qt Designer</>.
</para>
</sect3>


<sect3 id="loadingandexecutingadynamicdialog">
<title>Loading and Executing a Dynamic Dialog </title>
<para id="anpg">
<indexterm><primary>Dynamic Dialogs</primary><secondary>Loading and Executing</secondary></indexterm>

<indexterm><primary>Dialogs</primary><secondary>Dynamic</secondary></indexterm>

<indexterm><primary>Forms</primary><secondary>Forward declarations</secondary></indexterm>

<indexterm><primary>Forward declarations</primary></indexterm>

<indexterm><primary>Includes</primary></indexterm>

We'll now add the code to invoke the credit dialog. Before we can do
this we need to add the widget factory's header file to the form. Click
the Source tab in the Object Hierarchy. Right click Included (in
Implementation), then click <guibutton>New</>. Type in
'<literal>&lt;qwidgetfactory.h&gt;</literal>', then press
<indexterm><primary>Keypresses (Qt Designer)</primary><secondary>Enter</secondary></indexterm>
<keycap>Enter</>. Because we will need to access the spin box in
the dynamic dialog we must add its header file. Right click Included
(in Implmentation), then click New. Type in
'<literal>&lt;qspinbox.h&gt;</literal>', then press
<indexterm><primary>Keypresses (Qt Designer)</primary><secondary>Enter</secondary></indexterm>
<keycap>Enter</>. 
</para>

<para id="anpt">
In our main form we created a slot called
<function>creditDialog()</>. We will implement this slot
directly in <emphasis>Qt Designer</> and use it to load and execute the dynamic dialog. The
code is taken from <filename>qt/tools/designer/examples/receiver1/mainform.cpp</> which is generated from <filename>mainform.ui</>.
<programlisting>
void creditDialog()
{
    <emphasis role="bold">QDialog</> *creditForm = (<emphasis role="bold">QDialog</> *)
            <emphasis role="bold">QWidgetFactory::create</>( &quot;../credit/creditformbase.ui&quot; );
   <emphasis> // Set up the dynamic dialog here
</>
    
    if ( creditForm-&gt;exec() ) {
       <emphasis> // The user accepted, act accordingly
</>
        <emphasis role="bold">QSpinBox</> *amount = (<emphasis role="bold">QSpinBox</> *) creditForm-&gt;child( &quot;amountSpinBox&quot;, &quot;<emphasis role="bold">QSpinBox</>&quot; );
        if ( amount )
            ratingTextLabel-&gt;setText( amount-&gt;text() ); 
    }
    delete creditForm;
}
</programlisting>
The <indexterm><primary>Functions</primary><secondary>create()</secondary></indexterm>
<function>create()</> function is a static
<indexterm><primary>QWidgetFactory</primary></indexterm>
<classname>QWidgetFactory</> function. It loads the specified
<indexterm><primary>Files and file types</primary><secondary>.ui</secondary></indexterm>
<filename>.ui</> file and returns a pointer to the toplevel
<indexterm><primary>QWidget</primary></indexterm>
<classname>QWidget</> created from the <indexterm><primary>Files and file types</primary><secondary>.ui</secondary></indexterm>
<filename>.ui</>
file. We have cast the pointer to <indexterm><primary>QDialog</primary></indexterm>
<classname>QDialog</> since
we know that the <filename>creditformbase.ui</> file defines a
<indexterm><primary>QDialog</primary></indexterm>
<classname>QDialog</>. After creating the dialog we
<indexterm><primary>Functions</primary><secondary>exec()</secondary></indexterm>
<function>exec()</> it. If the user clicked
<guibutton>OK</> the dialog returns Accepted and we enter the
body of the <literal>if</literal> statement. We want to know the amount
of credit that the user selected. We call the
<indexterm><primary>Functions</primary><secondary>child()</secondary></indexterm>
<function>child()</> function on the dialog passing it the name
of the widget we're interested in. The <indexterm><primary>Functions</primary><secondary>child()</secondary></indexterm>
<function>child()</>
function returns a pointer to the widget with the name we passed, or
returns 0 if no widget of that name was found. In the example we call
<indexterm><primary>Functions</primary><secondary>child()</secondary></indexterm>
<function>child()</> to get a pointer to the 'amountSpinBox'. If
the pointer we get back is not 0 we set the rating text to the amount in
the dialog's spin box. At the end we delete the dynamic dialog. Deleting
the dialog ensures that we free up its resources as soon as it is no
longer required.
</para>

<para id="anqx">
We used the <indexterm><primary>Functions</primary><secondary>child()</secondary></indexterm>
<function>child()</> to gain access to a widget
within the dynamic dialog, passing it the name of the widget we were
interested in. In some situations we might not know what a widget is
called. We can access the first widget of a specified class by calling
<indexterm><primary>Functions</primary><secondary>child()</secondary></indexterm>
<function>child()</> with a null widget name and a classname,
e.g. <literal>child(0,"QPushButton")</literal>. This will return a
pointer to the first <indexterm><primary>QPushButton</primary></indexterm>
<classname>QPushButton</> it finds (or 0
if there isn't one). If you want pointers to all the widgets of a given
class you can call the <indexterm><primary>Functions</primary><secondary>QObject::queryList()</secondary></indexterm>
<function>QObject::queryList()</>
function, passing it the name of the class. It returns a
<indexterm><primary>QObjectList</primary></indexterm>
<classname>QObjectList</> pointer which points to every object
in the dialog that is derived from the given class. See the online
<ulink url="http://doc.trolltech.com/qobject.html">QObject</>
documentation for further details.
</para>
</sect3>

<sect3 id="implementingslotsfordynamicdialogs">
<title>Implementing Slots for Dynamic Dialogs </title>


<para id="anrt">
<indexterm><primary>Signals and Slots</primary><secondary>Dynamic Dialogs</secondary></indexterm>

<indexterm><primary>Dynamic Dialogs</primary></indexterm>

There is one outstanding issue that we haven't addressed: the dynamic
dialog does not have the behaviour of the original credit dialog because
we have not implemented the <function>setAmount()</> slot. We
can implement slots for dynamic dialogs by creating a
<indexterm><primary>QObject</primary></indexterm>
<classname>QObject</> subclass. We then create an instance of
this subclass and pass a pointer to it to the
<indexterm><primary>Functions</primary><secondary>QWidgetFactory::create()</secondary></indexterm>
<function>QWidgetFactory::create()</>
function which will connect the dynamic dialog's signals to the slots
implemented in our subclass.
</para>

<para id="ansf">
We need to create a <indexterm><primary>QObject</primary></indexterm>
<classname>QObject</> subclass and
change our <function>creditDialog()</> to create an instance of
our subclass that can be passed to the
<indexterm><primary>Functions</primary><secondary>QWidgetFactory::create()</secondary></indexterm>
<function>QWidgetFactory::create()</>
function. Here is the modified <function>creditDialog()</>
function from the
<filename>qt/tools/designer/examples/receiver2/mainform.cpp</> file
generated by <filename>mainform.ui</>.
<programlisting>
void creditDialog()
{
    Receiver *receiver = new Receiver; 
    <emphasis role="bold">QDialog</> *creditForm = (<emphasis role="bold">QDialog</> *) 
    <emphasis role="bold">QWidgetFactory::create</>( &quot;../credit/creditformbase.ui&quot;, receiver );   
    receiver-&gt;setParent( creditForm );   

   <emphasis> // Set up the dynamic dialog here 
</>
     
    if ( creditForm-&gt;exec() ) { 
       <emphasis> // The user accepted, act accordingly 
</>
        <emphasis role="bold">QSpinBox</> *amount = (<emphasis role="bold">QSpinBox</> *) creditForm-&gt;child( &quot;amountSpinBox&quot;, &quot;<emphasis role="bold">QSpinBox</>&quot; ); 
        if ( amount ) 
            ratingTextLabel-&gt;setText( amount-&gt;text() );  
    } 
    
    delete receiver; 
    delete creditForm; 
}
</programlisting>
We create a new instance of our 'Receiver' subclass. (We'll write the
code for this class shortly.) We then create the
<indexterm><primary>QDialog</primary></indexterm>
<classname>QDialog</> using
<indexterm><primary>Functions</primary><secondary>QWidgetFactory::create()</secondary></indexterm>
<function>QWidgetFactory::create()</>. This call differs from our
previous example because we pass in the subclass object so that the
<indexterm><primary>Functions</primary><secondary>create()</secondary></indexterm>
<function>create()</> function can set up the signals/slots
connections automatically for us. Since our slot must access the widgets
in the dynamic form we pass a pointer to the form to the receiver object
through our <function>setParent()</> function. The remainder of
the function is the same as before except that we delete our receiver
object.
</para>

<para id="ante">
<indexterm><primary>Dynamic Dialogs</primary></indexterm>

We'll now look at the implementation of our 'Receiver' subclass. The code
is taken from
<filename>qt/tools/designer/examples/receiver2/receiver.h</> and the
corresponding <filename>receiver.cpp</> file. We'll start with
the header file.
<programlisting>
#include &lt;qobject.h&gt;
#include &lt;qdialog.h&gt;

class Receiver : public <emphasis role="bold">QObject</>
{
    Q_OBJECT
public:
    void setParent( <emphasis role="bold">QDialog</> *parent );
public slots:
    void setAmount();
private:
    <emphasis role="bold">QDialog</> *p;
};
</programlisting>
<indexterm><primary>Macros</primary><secondary>Q_OBJECT</secondary></indexterm>

<indexterm><primary>Q_OBJECT</primary><seealso>Macros</seealso></indexterm>

Our class must be a <indexterm><primary>QObject</primary></indexterm>
<classname>QObject</> subclass and because
we're using signals and slots it must include the
<literal>Q_OBJECT</literal> macro. We declare a function and the
<function>setAmount()</> slot that we wish to implement as well
as a private <indexterm><primary>QDialog</primary></indexterm>
<classname>QDialog</> pointer.
</para>

<para id="antu">
We'll discuss the implementation of each function separately.
<programlisting>
void creditDialog()
{
    Receiver *receiver = new Receiver; 
    <emphasis role="bold">QDialog</> *creditForm = (<emphasis role="bold">QDialog</> *) 
    <emphasis role="bold">QWidgetFactory::create</>( &quot;../credit/creditformbase.ui&quot;, receiver );   
    receiver-&gt;setParent( creditForm );   

   <emphasis> // Set up the dynamic dialog here 
</>
     
    if ( creditForm-&gt;exec() ) { 
       <emphasis> // The user accepted, act accordingly 
</>
        <emphasis role="bold">QSpinBox</> *amount = (<emphasis role="bold">QSpinBox</> *) creditForm-&gt;child( &quot;amountSpinBox&quot;, &quot;<emphasis role="bold">QSpinBox</>&quot; ); 
        if ( amount ) 
            ratingTextLabel-&gt;setText( amount-&gt;text() );  
    } 
    
    delete receiver; 
    delete creditForm; 
}
</programlisting>
The <function>setParent()</> function assigns a pointer to the
dynamic dialog to our private pointer. We could not do this in a
constructor call because we have to construct our Receiver object before
we call <indexterm><primary>Functions</primary><secondary>QWidgetFactory::create()</secondary></indexterm>
<function>QWidgetFactory::create()</>, since we must
pass the Receiver object to the <indexterm><primary>Functions</primary><secondary>create()</secondary></indexterm>
<function>create()</> function.
Once we've called <indexterm><primary>Functions</primary><secondary>create()</secondary></indexterm>
<function>create()</> we then have a pointer
to the dynamic dialog which we can then pass via
<function>setParent()</> to our Receiver class. In the subclass
version of this example we called <function>setAmount()</> in
the constructor; but we cannot do that here because the implementation
of <function>setAmount()</> depends on knowledge of the dynamic
dialog which is not available at construction time. Because of this we
call <function>setAmount()</> in the
<function>setParent()</> function. 
</para>

<para id="anup">
Since we may be updating the amount spin box we need to get a pointer to
it. We call <indexterm><primary>Functions</primary><secondary>child()</secondary></indexterm>
<function>child()</> on the pointer
<literal>p</literal> which points to the dynamic dialog assigned in the
<function>setParent()</> call. We cast the resulting pointer to
the correct type so that we can call any functions relevant to that
type. In the example we call <indexterm><primary>Functions</primary><secondary>child()</secondary></indexterm>
<function>child()</> to get a
pointer to the amount spin box, and then call
<indexterm><primary>Functions</primary><secondary>child()</secondary></indexterm>
<function>child()</> again to get a pointer to the
'stdRadioButton'. If we get a pointer to the radio button and the  
button is checked we set the amount providing we have a pointer to the
amount spin box. If this radio button was checked we're finished so we
return. If the 'stdRadioButton' isn't checked we
get a pointer to the 'noneRadioButton' and set the amount if this button
is checked. We do nothing if the 'specialRadioButton' is checked because
the user is free to enter a value of their choice. 
</para>

<sidebar id="complingvsdynamicallyloadingdialogs">
<title>Compiling vs Dynamically Loading Dialogs</title>
<para id="anvm">
<indexterm><primary>Dynamic Dialogs</primary><secondary>Compared with Compiling</secondary></indexterm>

<indexterm><primary>Dynamic Dialogs</primary><secondary>Subclassing</secondary></indexterm>

<indexterm><primary>Subclassing</primary><secondary>Dynamic Dialogs</secondary></indexterm>

The differences between using a 'compiled in' <indexterm><primary>Files and file types</primary><secondary>.ui</secondary></indexterm>
<filename>.ui</>
file and a dynamically loaded <indexterm><primary>Files and file types</primary><secondary>.ui</secondary></indexterm>
<filename>.ui</> file are these:
<itemizedlist>
<listitem>
<para id="anvr">
Dynamic dialogs cannot have any C++ code in the <indexterm><primary>Files and file types</primary><secondary>.ui</secondary></indexterm>
<filename>.ui</>
file; any custom slots must be implemented via a
<indexterm><primary>QObject</primary></indexterm>
<classname>QObject</> subclass. Compiled dialogs can contain
code either in the <indexterm><primary>Files and file types</primary><secondary>.ui</secondary></indexterm>
<filename>.ui</> file or in a subclass.
</para>
</listitem>
<listitem>
<para id="anvz">
Dynamic dialogs will load slower because the <indexterm><primary>Files and file types</primary><secondary>.ui</secondary></indexterm>
<filename>.ui</>
file must be read and a <indexterm><primary>QWidget</primary></indexterm>
<classname>QWidget</> instance
instantiated based on the <indexterm><primary>Files and file types</primary><secondary>.ui</secondary></indexterm>
<filename>.ui</> file's parse tree.
Compiled code will load much faster because no file reading or parsing
is necessary. Note that the user may not notice any difference in speed
since the difference may be mere fractions of a second.
</para>
</listitem>
<listitem>
<para id="anwj">
Dynamic dialogs allow you to change the <indexterm><primary>Files and file types</primary><secondary>.ui</secondary></indexterm>
<filename>.ui</> file
independently of the code so long as none of the changes impact the
code. This means that you can change the appearance of the form, e.g.
move widgets and lay them out differently. If you want to change a
compiled dialog you must change the <indexterm><primary>Files and file types</primary><secondary>.ui</secondary></indexterm>
<filename>.ui</> file and
recompile. If you are building an application and want your customers to
be able to customize aspects of the user interface you can give them a
copy of <emphasis>Qt Designer</> and use dynamic dialogs.
</para>
</listitem>
</itemizedlist>
</para>
</sidebar>

</sect3>

</sect2>

</sect1>
</chapter>

