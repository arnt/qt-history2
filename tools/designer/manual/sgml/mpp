#!/usr/bin/perl -w

# $Id: mpp,v 1.8 2001/01/24 22:52:45 mark Exp mark $

# Documented at the __END__

# Copyright (c) 2001 Mark Summerfield. All Rights Reserved.
# May be used/distributed under the GPL.

use strict;

use File::Find;
use Getopt::Long;
use Symbol();

use vars qw( $VERSION );
$VERSION = '1.10';

my %Opt;
my $Param;
my $Macro;

my %Audit = (
    -files	=> 0,
    -config	=> 0,
    -skipped	=> 0,
    -lines	=> 0,
    -started	=> time,
    );


if ( not caller ) {
    process_options();
    configure();
    process_files();
    show_audit() if $Opt{'m'};
}


sub show_audit {
    my $time = time - $Audit{'-started'};
    my $sec  = $time % 60; $time /= 60;
    my $min  = $time % 60; $time /= 60;
    my $ls   = $Audit{'-lines'}  == 1 ? '' : 's';
    my $s    = $Audit{'-files'}  == 1 ? '' : 's';
    my $cs   = $Audit{'-config'} == 1 ? '' : 's';
    printf STDERR "%1d:%02d:%02d " .
		  "$Audit{'-lines'} line$ls, " .
		  "$Audit{'-files'} file$s, " .
		  "$Audit{'-skipped'} skipped, " .
		  "$Audit{'-config'} config$cs.\n",
		  $time, $min, $sec;
}


sub process_files {

    if ( $Opt{'r'} ) {
	find( \&process_file, scalar @ARGV ? @ARGV : '.' );
    }
    else {
	foreach my $file ( @ARGV ) {
	    process_file( $file );
	}
    }
}


sub process_file {
    my $file = shift || $_;

    return if $Opt{'M'} and $file !~ /\.mpp$/;
    return unless -f $file;

    my $out = Symbol::gensym();
    my $outfile;
    eval {
	if ( $Opt{'s'} ) {
	    $outfile = 'STDOUT';
	    open $out, '>-' or 
	    die "failed to open STDOUT: $!\n";
	}
	else {
	    $outfile = $file;	
	    $outfile =~ s/(?:\.$Opt{'S'})?\.mpp$/.$Opt{'S'}/;
	    die "infile and outfile have the same name\n" 
	    if $file eq $outfile;
	    if ( $Opt{'l'} and -e $outfile and 
                 ( (stat( $file ))[9] <= (stat( $outfile ))[9] ) ) { 
		die "$outfile is up-to-date\n";
	    }
	    open $out, ">$outfile" or 
	    die "failed to open $outfile: $!\n";
	}
    };
    if ( $@ ) {
	if ( $@ =~ /up-to-date/ ) {
	    warn " 000000 $file skipped, $@" if $Opt{'m'} > 1;
	}
	elsif ( $Opt{'w'} ) {
	    warn "*000000 $file skipped, $@";
	}
	$Audit{'-skipped'}++;
	return;
    }

    my $mpp = Mpp->new(
		'-format'   => $Opt{'f'},
		'-filter'   => $Opt{'F'},
		'-infile'   => $file,
		'-outfile'  => $outfile,
		'-out'	    => $out,
		'-warnings' => $Opt{'w'},
		'-messages' => $Opt{'m'},
		'-macros'   => $Macro,
		'-params'   => $Param,
		);
    $mpp->process();
    $mpp->msg( "converted to $outfile", 1 );
    $Macro = $mpp->get( '-macros' );
    $Audit{'-lines'} += $mpp->get( '-lino' );
    $Audit{'-files'}++;
}


sub configure {

    my @config = ();
    my $global = ( $ENV{MPPDIR} or '/etc' );
    my $home   = ( $ENV{HOME} or $ENV{LOGDIR} or (getpwuid( $> ))[7] );
    push @config, "$global/mpp.conf"		if -e "$global/mpp.conf";	
    push @config, "$global/mpp.$Opt{'f'}.conf"	if -e "$global/mpp.$Opt{'f'}.conf";
    push @config, "$home/.mpp.conf"		if -e "$home/.mpp.conf";	
    push @config, "$home/.mpp.$Opt{'f'}.conf"	if -e "$home/.mpp.$Opt{'f'}.conf";
    push @config, "mpp.conf"			if -e "mpp.conf";	
    push @config, "mpp.$Opt{'f'}.conf"		if -e "mpp.$Opt{'f'}.conf";	

    $Macro = {};

    foreach my $config ( @config ) {
	my $mpp = Mpp->new(
		    '-format'	    => $Opt{'f'},
		    '-filter'	    => $Opt{'F'},
		    '-infile'	    => $config,
		    '-warnings'	    => $Opt{'w'},
		    '-messages'	    => $Opt{'m'},
		    '-configuring'  => 1,
		    '-macros'	    => $Macro,
		    '-params'	    => $Param,
		    );
	$mpp->process();
	$mpp->msg( "read configuration", 2 );
	$Macro = $mpp->get( '-macros' );
	$Audit{'-lines'} += $mpp->get( '-lino' );
	$Audit{'-config'}++;
    }
}


sub process_options {

    usage() unless @ARGV;

    $Opt{'a'} = 1;
    $Opt{'f'} = '';
    $Opt{'S'} = '';
    $Opt{'F'} = '';
    $Opt{'m'} = 1;
    $Opt{'M'} = 1;
    $Opt{'s'} = 0;
    $Opt{'r'} = 0;
    $Opt{'w'} = 1;
    $Opt{'l'} = 1;
    $Opt{'P'} = '';

    Getopt::Long::config 'no_ignore_case';
    usage() unless GetOptions( 
	\%Opt, 
	'h|help', 
	'a|autofilter:i',
	'f|format=s',
	'S|suffix=s',
	'F|filter=s',
	'm|messages=i', 
	'M|mpponly:i',
	'r|recurse:i',
	's|stdout:i',
	'w|warnings=i', 
	'l|lazy:i',
	'P|params=s',
	);
    usage() if $Opt{'h'};
    die "*000000 no input file specified\n" if not $Opt{'r'} and not @ARGV;

    local $_ ;
    foreach ( @ARGV ) {
	next if $Opt{'M'} and $_ !~ /\.mpp$/;
	$Opt{'f'} = $1 if not $Opt{'f'} and /\.([^.]+)(?:\.mpp)?$/;
	last;
    }
    $Opt{'f'} = 'text' unless $Opt{'f'};
    $Opt{'F'} = $Opt{'f'} . '-filter' if not $Opt{'F'} and $Opt{'a'};
    $Opt{'S'} = $Opt{'f'} if not $Opt{'S'};
    $Opt{'S'} = 'txt' if $Opt{'f'} eq 'text';

    $Param = { map { split /=/ } split /[ ,]+/, $Opt{'P'} } if $Opt{'P'}; 
}


sub usage {

    die <<EOT;
usage: mpp [options] <files>

expands macros and filters files to the specified or implied format

options: (these are rarely needed)
-r --recurse	process files in subdirs, default is 0
-l --lazy	only process files newer than their target, default is 1
-P --params	string of 'name=val name=val' pairs for runtime configuration
-m --messages	output messages, 0, 1 or 2, default is 1
-w --warnings	output warnings, 0, 1 or 2, default is 1	
-s --stdout	output to STDOUT, default is 0
-f --format	format to use for macros, default is suffix of first file 
-S --suffix	suffix name for files of given format, default is <format>
-a --autofilter filter the text with the filter called <format>-filter
-F --filter	name of the filter to use, default is <format>-filter
-M --mpponly	only process files with suffix .mpp, default is 1
-h --help	show this usage text and exit

mpp supports six functions:
    \\macro name {% "perl subroutine or string" %}
    \\load file
    \\scan file filter.numbering start end
    \\set param = value
    \\if param -or- \\if param = value -or- \\if param != value
    \\endif
macros are invoked like this
    \\name or \\name[parameter string]

mpp includes the Mpp class which you can use in your own applications

see the pod documentation for full details
EOT
}


package Mpp;


sub new {
    my $self  = shift;
    my $class = ref( $self ) || $self;
    my %arg   = @_;

    local $_;
    if ( ref( $self ) ) { # Copy constructor, args override
	my $newself = {};
	foreach ( qw( -format -filter -outfile -out -params -skip
		      -warnings -messages -configuring -macros ) ) {
	    $newself->{$_} = exists $arg{$_} ? delete $arg{$_} : $self->get( $_ ); 
	}
	foreach ( keys %arg ) { # Args which must be given anew, e.g. -infile
	    $newself->{$_} = $arg{$_};
	}
	$newself->{'-lino'} = 0;
	$self = $newself;
    }
    else {
	$self = {
		'-format'	=> 'text',
		'-filter'	=> '',
		'-infile'	=> '',
		'-in'		=> undef,
		'-outfile'	=> '',
		'-out'		=> undef,
		'-warnings'	=> 1,
		'-messages'	=> 1,
		'-configuring'	=> 0,
		'-skip'		=> 0,
		'-macros'	=> {},
		'-params'	=> {},
		'-lino'		=> 0,
		%arg,
	    }
    }

    # Private
    $self->{'_lastwarning'} = '',
    $self->{'_macro_re'} = qr/(?!<\\)\\([A-Za-z][-A-Za-z_0-9]*)(?:\[([^\]]*?)\])?/, #/
    $self->{'_warn_re'}  = qr/(?!<\\)(\\[A-Za-z][-A-Za-z_0-9]*\[[^\]]*)\n$/s, #/
    $self->{'_scan'}	    = undef,
    $self->{'_scanfile'}    = undef,
    $self->{'_scanlino'}    = 0,
    $self->{'_scanfilter'}  = '',
    $self->{'_scanstart'}   = -1,

    bless $self, $class;

    $self->warning( "no input file specified", 1 ) 
    if not $self->{'-infile'} and not defined $self->{'-in'};

    $self->warning( "no output file specified", 1 ) 
    if not $self->{'-configuring'} and
       not $self->{'-outfile'} and not defined $self->{'-out'};

    if ( not defined $self->{'-in'} ) {
	my $fh = Symbol::gensym();
	open $fh, $self->{'-infile'} or 
	$self->warning( "failed to open $self->{'-infile'}: $!", 1 );
	$self->{'-in'} = $fh;
    }

    if ( not $self->{'-configuring'} and not defined $self->{'-out'} ) {
	my $fh = Symbol::gensym();
	open $fh, ">$self->{'-outfile'}" or 
	$self->warning( "failed to open $self->{'-outfile'}: $!", 1 );
	$self->{'-out'} = $fh;
    } #{

    $self->setmacro( 'text-filter', '$_[1]' )
    unless exists $self->{'-macros'}{'text-filter'}; 
    
    return $self;
}


sub get {
    my $self  = shift;
    my $field = shift;

    if ( $field =~ /^[-_]/ ) { 
	$self->{$field};
    }
    else {
	$self->{'-params'}{$field} || '';
    }
}


sub _getref {
    my $self  = shift;
    my $field = shift;

    if ( ref( $self->{$field} ) ) {
	return $self->{$field};
    }
    else {
	return \$self->{$field};
    }
}


sub set {
    my $self  = shift;
    my $field = shift;

    if ( $field =~ /^[-_]/ ) { 
	$self->{$field} = shift;
    }
    else {
	$self->{'-params'}{$field} = shift;
    }
}


sub _inc {
    my $self  = shift;
    my $field = shift;

    $self->{$field}++;
}


sub process {
    my $self = shift;

    my $macroref = $self->get( '-macros' );
    my $pre	 = $self->get( '-format' ) . '-pre';
    $macroref->{$pre}->( $self ) if exists $macroref->{$pre};

    my $configuring = $self->get( '-configuring' ); 
    my $in	    = $self->get( '-in' ); 
    my $out	    = $self->get( '-out' ); 
    my $skip	    = $self->_getref( '-skip' );
    local $_;
    while ( <$in> ) {
	$self->_inc( '-lino' );		
	$$skip = 0, next if /^\s*\\endif/;
	next if $$skip;
	if ( /^\s*\\(?:if|set|macro|load|scan)/ ) {
	    if ( /^\s*\\if\s+(\S+)\s*(?:(=|==|!=)\s*(.*))?$/ ) {
		$self->_if( $1, defined $2 ? $2 : '', defined $3 ? $3 : '' );
	    }
	    elsif ( /^\s*\\set\s+(\S+)(?:\s*=(.*))?$/ ) {
		$self->set( $1, defined $2 ? $2 : '' );
	    }
	    elsif ( /^\s*\\macro\s+(\S+)\s*\{%(.*)/ ) { #}
		$self->_read_macro( $1, $2 );
	    }
	    elsif ( /^\s*\\load\s+(\S+)/ ) {
		$self->load_file( $1 );
	    }
	    elsif ( /^\s*\\scan\s+(.*)/ ) {
		if ( $configuring ) {
		    $self->warning( "\\scan does nothing when configuring", 2 );
		}
		else {
		    $self->scan_file( $1 );
		}
	    }
	    elsif ( /(if|set|macro|load|scan)/ ) {
		$self->warning( "syntax error in \\$1", 1 );
	    }
	}
	elsif ( not $configuring ) {	     
	    print $out $self->_expand_macros( $self->filter( $_ ) );
	}
    }

    my $post = $self->get( '-format' ) . '-post';
    $macroref->{$post}->( $self ) if exists $macroref->{$post};
}


sub _if {
    my $self  = shift;
    my $param = shift;
    my $op    = shift;
    my $val   = shift;

    my $result = $self->get( $param );
    if ( not $op ) {
	# NOOP
    }
    elsif ( $val =~ /^\d+(?:\.\d+)?$/ ) {
	if ( $op eq '!=' ) {
	    $result = $result != $val;
	}
	else {
	    $result = $result == $val;
	}
    }
    else {
	if ( $op eq '!=' ) {
	    $result = $result ne $val;
	}
	else {
	    $result = $result eq $val;
	}
    }
    $self->set( '-skip', not $result );
}


sub setmacro {
    my $self	  = shift;
    my $macroname = shift;
    my $macro	  = shift; 

    $self->_read_macro( $macroname, $macro . '%}' );
}


sub _read_macro { 
    my $self	  = shift;
    my $macroname = shift;
    my $macro	  = shift; #{

    my $pos = index( $macro, '%}' );
    if ( $pos > -1 ) { 
	$macro = substr( $macro, 0, $pos );
    }
    else {
	local $_; 
	my $in = $self->get( '-in' );
	while ( <$in> ) { 
	    $self->_inc( '-lino' ); #{
	    $pos = index( $_, '%}' );
	    if ( $pos > -1 ) {
		last;
	    }
	    else {
		$macro .= $_;
	    }
	} #{ 
	$macro .= substr( $_, 0, $pos ) if $_ and index( $_, '%}' );
    }

    my $format = $self->get( '-format' );
    $macroname = 'text-' . $macroname unless $macroname =~ /^(?:text|$format)-.+$/;

    eval {
	my $macroref = $self->get( '-macros' );
	$macroref->{$macroname} = eval "sub {$macro}";
    };
    $self->warning( "failed to eval \\$macroname: $@", 2 ) if $@; # Doesn't work
}


sub load_file {
    my $self = shift;
    my $file = shift;

    $self->msg( "loading $file", 2 );
    my $mpp = $self->new( '-infile' => $file );
    $mpp->process();
}


sub scan_file {
    my $self = shift;
    local $_ = shift;

    chomp;
    my ( $filename, $filter, $linestart, $start, $end );

    if ( /^\S+\s*$/ ) {
	$filename = $_;
    }
    elsif ( ( $filename, $filter, $linestart ) = 
	    /^(\S+)\s+([A-Za-z][-A-Za-z_0-9]*)(?:\.(\d+))?\s*$/ ) {
	# NOOP
    }
    else {
	( $filename, $filter, $linestart, $start, $end ) = 
	    /^(?:
		  (?:
		    (\S+)	    # opt filename
		    (?:\s+	    
		       ([A-Za-z][-A-Za-z_0-9]*) # opt filter
		       (?:\.(\d+))? # opt line numbering number
		    )?
		  )?
		  \s*	   
		  (\/.+\/|\d+)	    # regex or line count 
		  \s+
		  (\/.+\/|\d+)	    # regex or line count
		)		
		  \s*
	      $/x;
	if ( not defined $start ) {
	    $self->warning( "invalid \\scan syntax \\scan $_", 1 );
	    return;
	}
    }

    $filter    = '' unless defined $filter;
    $linestart = -1 unless defined $linestart;	# -1=none 0=real lino >0=relative
    $start     = 1  unless defined $start;	#  1=start of file
    $end       = -1 unless defined $end;	# -1=end of file

    if ( defined $filename ) {
	# We've got a filename so open it
	my $fh = Symbol::gensym();
	if ( open( $fh, $filename ) ) {
	    $self->set( '_scan',	$fh );
	    $self->set( '_scanfile',	$filename );
	    $self->set( '_scanlino',	1 );
	    $self->set( '_scanfilter',	$filter );
	    $self->set( '_scanstart',	$linestart );
	    $self->msg( "scanning $filename", 2 );
	}
	else {
	    $self->warning( "failed to scan $filename: $!", 1 );
	    $self->set( '_scan', undef );
	}
    }

    if ( defined $self->get( '_scan' ) ) {
	$self->_perform_scan( $start, $end );
    }
    else {
	$self->warning( "no file to scan", 1 );
	$self->set( '_scan', undef );
    }
}


# $self->{'_scanstart'} -1=none 0=real lino (in $self->{'scanlino'}), 
#		        >0=relative from this no.
# $start \d = skip \d lines, otherwise from & incl. first line matching regex
# $end \d = print \d lines, otherwise to & incl. first line matching regex
#
sub _perform_scan {
    my $self  = shift;
    my $start = shift;
    my $end   = shift;

    my $fh	 = $self->get( '_scan' );
    my $scanlino = $self->_getref( '_scanlino' );
    local $_;
    my @line = ();

    if ( $start =~ /^\d+/ ) {
	while ( <$fh> ) { 
	    $start--; 
	    $$scanlino++;
	    last unless $start;
	}
    }
    else {
	$start = substr( $start, 1 );
	chop $start;
	my $regex = qr/$start/; #/
	while ( <$fh> ) {
	    $$scanlino++;
	    last if /$regex/;
	}
    }

    my $firstlino = $$scanlino - 1;
    push @line, $_;

    if ( $end eq '0' ) { # Just the first line, no extra lines required
	# NOOP
    }
    elsif ( $end eq '-1' or $end =~ /^\d+/ ) {
	while ( <$fh> ) { 
	    $end--; 
	    $$scanlino++;
	    push @line, $_;
	    last unless $end;
	}
    }
    else {
	$end = substr( $end, 1 );
	chop $end;
	my $regex = qr/$end/; #/
	while ( <$fh> ) {
	    $$scanlino++;
	    push @line, $_;
	    last if /$regex/;
	}
    }

    my $lino;
    my $scanstart = $self->_getref( '_scanstart' );
    if ( $$scanstart == -1 ) {
	$lino = -1;
    }
    elsif ( $$scanstart == 0 ) {
	$lino = $firstlino;
    }
    else {
	$lino = $$scanstart ||= 1;
    }

    my $width = length( sprintf( "%d", scalar @line ) );

    my $out	 = $self->get( '-out' );
    my $macroref = $self->get( '-macros' );
    my $filter	 = $self->get( '_scanfilter' );
    my $format	 = $self->get( '-format' );
    foreach ( 
	$filter, "$format-$filter", "$format-scanfilter", 'text-scanfilter' ) {
	if ( exists $macroref->{$_} ) {
	    $filter = $macroref->{$_};
	    last;
	}
    }

    foreach ( @line ) {
	$_ = $filter->( $self, $_ ) if ref( $filter ) eq 'CODE';
	my $num = $lino != -1 ? sprintf( "%${width}d ", $lino++ ) : '';
	print $out $num, $_;
    }
}


sub filter {
    my $self = shift;
    local $_ = shift;

    my $filter = $self->get( '-filter' );
    if ( $filter ) {
	my $format   = $self->get( '-format' );
	my $orig     = $filter;
	my $poss     = ( index( $filter, "$format-" ) != 0 ? 
			    "$format-$filter" : '' );
	my $macroref = $self->get( '-macros' );
	if ( not exists $macroref->{$filter} and $poss ) {
	    $filter = $poss;
	    $self->set( '-filter', $poss ) if exists $macroref->{$filter};
	}
	if ( exists $macroref->{$filter} ) {
	    $_ = $macroref->{$filter}->( $self, $_ );
	}
	else {
	    $poss = ", also tried $poss" if $poss;
	    $self->warning( 
		"cannot apply non-existent filter $orig$poss", 1 );
	}
    }

    return $_;
}


sub _expand_macros {
    my $self = shift;
    local $_ = shift;

    my $warn_re  = $self->get( '_warn_re' );
    $self->warning( "possibly line-wrapped macro $1", 1 ) if /$warn_re/; 
    my $macro_re = $self->get( '_macro_re' );
    s/$macro_re/defined $1 ? $self->getval( $1, defined $2 ? $2 : '' ) : ''/ge;

    return $_;
}


sub getval {
    my $self  = shift;
    my $macro = shift;
    my $arg   = shift || '';

    $macro = $self->_find_macro( $macro );

    defined $macro ? $self->get( '-macros' )->{$macro}->( $self, $arg ) : $arg;  
}


sub _find_macro {
    my $self  = shift;
    my $macro = shift;

    my @tried;
    my $macroref = $self->get( '-macros' );
    if ( not exists $macroref->{$macro} ) {
	$macro =~ s/^[^-]+-//;
	my $format = $self->get( '-format' );
	foreach my $form ( $Opt{'f'}, 'text' ) {
	    my $poss = $form . '-' . $macro;
	    if ( exists $macroref->{$poss} ) {
		$macro = $poss;
		last;
	    }
	    push @tried, $poss;
	}
    }

    if ( exists $macroref->{$macro} ) {
	return $macro;
    }
    else {
	my $tried = shift @tried;
	$tried = $tried ne $tried[0] ? 
	    "$tried and " . shift( @tried )  : $tried;
	$self->warning( "undefined macro $macro, also tried $tried", 2 );
	return undef;
    }
}


sub msg {
    my $self  = shift;
    my $msg   = shift;
    my $level = shift; # Lowest level is most important

    return unless $level <= $self->get( '-messages' );

    printf STDERR " %6d %s %s\n",
	$self->get( '-lino' ), $self->get( '-infile' ), $msg
    if $self->get( '-messages' ) > 0;
}


sub warning {
    my $self  = shift;
    my $msg   = shift;
    my $level = shift; # Lowest level is most important
    my $die   = shift || 0;

    return unless $level <= $self->get( '-warnings' );

    my $warning = sprintf "*%6d %s %s\n",
	$self->get( '-lino' ), $self->get( '-infile' ), $msg;
    if ( $self->get( '-warnings' ) > 0 ) {
	my ( $prev ) = $self->get( '_lastwarning' ) =~ /^\*?\s*\d+ \S+ (.*)$/;
	print STDERR $warning if not defined $prev or $msg ne $prev;
	$self->set( '_lastwarning', $warning );
    }
    die if $die;
}


1;


__END__

=head1 NAME

mpp -- macro pre-processor, filter and file extract inserter

=head1 SYNOPSIS

    usage: mpp [options] <files>
    options: (these are rarely needed)
    -r --recurse    process files in subdirs, default is 0
    -l --lazy	    only process files newer than their target, default is 1
    -P --params	    string of 'name=val name=val' pairs for runtime configuration
    -m --messages   output messages, 0, 1 or 2, default is 1
    -w --warnings   output warnings, 0, 1 or 2, default is 1	
    -s --stdout	    output to STDOUT, default is 0
    -f --format	    format to use for macros, default is suffix of first file 
    -S --suffix	    suffix name for files of given format, default is <format>
    -a --autofilter filter the text with the filter called <format>-filter
    -F --filter	    name of the filter to use, default is <format>-filter
    -M --mpponly    only process files with suffix .mpp, default is 1
    -h --help	    show this usage text and exit

    mpp supports six functions:
	\macro name {% "perl subroutine or string" %}
	\load file
	\scan file filter.numbering start end
	\\set param = value
	\\if param -or- \\if param = value -or- \\if param != value
	\\endif
    macros are invoked like this
	\name or \name[parameter string]

=head1 README

=head2 Introduction

mpp is used to expand macros, filter and to insert file extracts (scan) in the
files it processes. It includes an object module so you can also use it in
your own programs.

A macro appears in one of two forms: C<\macroname> and 
C<\macroname[parameter string]>. The parameter string may not contain a ] and
may not be wrapped onto multiple lines. The first form is useful for
abbreviations, e.g. \mpp might be replaced with the text `Macro
Pre-Processor'. Because every macro definition is a subroutine the text
returned may dynamically depend on the execution of the subroutine; for
example a \time macro might be replaced by the time at which mpp is run.

mpp supports six built-in commands:

=over

=item *

\macro -- define a macro

=item *

\set -- set a parameter

=item *

\scan -- insert a file extract

=item *

\load -- insert a file as if it were inline, i.e. process it for macros

=item *

\if -- process lines up to the \endif if the expression is true, otherwise skip
them

=item *

\endif -- lines will be processed from this point on (until an \if whose
expression is false is encountered)

=back

The built-in commands are always placed on a line of their own (except \macro
which delimits its contents with {% and %} and may span multiple lines). 

=head2 Defining Macros with C<\macro>

Macros may be defined in configuration files or in the files that are
processed or both.

A definition takes the form:

    \macro macroname {% body of macro %}

Definitions may be spread over multiple lines after the initial %, i.e.

    \macro macroname {%
	body of macro
    %}

A macro body may be a simple string or a perl subroutine, for example:

    \macro mpp {%"Macro Pre-Processor"%}

    \macro datestamp {% scalar localtime %}

Macros are called with two parameters, the C<$self> reference of the Mpp
object that is processing the file and the parameter string the macro was
called with if any. For example if we are processing a docbook file we might
define some macros to reduce our typing:

    \macro b {%
	my $self = shift;
	local $_ = shift;

	my $format = $self->get( '-format' );
	if ( $format eq 'sgml' ) {
	    return '<emphasis role="bold">' . $_ . '</emphasis>';
	}
	else {
	    return $_;
	}
    %}

However the recommended approach to defining macros is to define the format
for which the macro definition is applicable by using it in the macro's name: 

    \macro sgml-b {%
	'<emphasis role="bold">' . $_[1] . '</emphasis>';
    %}

Note that our argument is in C<$_[1]> - C<$self> is in C<$_[0]>.

In the case of both the above examples to use the macros you'd write
\b[this is bold] in your text.

If you use format-specific macros you can still define generic ones, and the
format-specific will be used if the output format matches, otherwise the
generic one will be used.

=head2 Special Macro Names

If you define a macro name called C<format-pre> where I<format> is the name of
an output format, e.g. html, this macro will be executed before each html file
is processed. This is useful for loading in modules and setting up object
variables. A complimentary macro called C<format-post> executes after each
file has been processed.

You can define your own object variables but they must not begin with a hyphen
or underscore.

    \macro html-pre {%    
	my $self = shift;	# Special sub called before start of file

	use HTML::Entities;

	$self->set( 'mode', '' );
    %}

The other special macros are C<format-filter> and C<format-scanfilter> which
we'll come to next. 

=head2 Filtering

By default a filter, C<format-filter>, is applied to all text. This can be
switched off with C<--autofilter=0> or by defining a filter that returns its
input unchanged:

    \macro sgml-filter {% $_[1] %}

You can specify another macro to be used as the filter on the command line
C<--filter=html-myfilter>.

All scanned in text is passed through the C<format-scanfilter> filter; this
can be useful for example if you are including source code in an html file and
need to ensure that the entities are converted:

    \macro html-scanfilter {%
	my $self = shift;	# Special sub called to filter scanned file
	local $_ = shift;

	encode_entities( $_ );
    %}

When you scan a file you can specify the filter to be applied 

    \scan main.cpp c_filter

mpp will look for a macro called I<c_filter>, and failing that will try
I<format-c_filter> using the current format. 

Note that filtering applies to macro names and their parameters.

You can easily change filters using C<\set -filter = filtername> or switch
filtering off by giving no filtername.

=head2 Scanning: Inserting File Extracts with C<\scan>

Files are scanned in using the \scan command whose syntax is:

    \scan filename filter.numbering start end

The filename is the file to be scanned (and may include a path). If no
filename is given the previous file will be used from the point where the
previous scan left off; if no filename is given and there was no previous scan
a warning will be given.

The filter is the name of a macro; it can be written using a specific format,
e.g. C<html-myscanfilter>, but it is recommended that no format name is given,
e.g. C<myscanfilter>, leaving mpp to apply the right format at runtime. If you
don't specify a scan filter, mpp will use a macro called C<format-scanfilter>
if it exists. If no filter is given the filter from the previous scan is used
if any otherwise C<format-scanfilter> will be used if it exists.

The numbering part is optional, but if present consists of a dot followed by a
number. If no numbering part is specified then no line numbering is inserted
into the output. If the number is 0 (zero) then the real line numbers in the
scanned file are used; if the number is > 0, then line numbers starting at
this number are used (typically the number in this case will be 1). 

The start part is either a number or a regex enclosed in //. If a number is
given this many lines will be skipped in the scanned file and output will
commence from the number + 1 line. If a regex is given lines will be skipped
until a line matching the regex is found at which point output will commence
from the line where the match occurred. If the start part is specified the end
part must be specified. If neither start not end is specified then the whole
file will be inserted into the output.

The end part is either a number or a regex enclosed in //. If a number is
given this many lines will be output in the scanned file from the starting
point. If a regex is given lines will be output until a line matching the
regex is found at which point the matching line will be output and output will
cease. If you just want a single line then the end part should be 0, i.e. no
subsequent lines. In the same way if you want two lines then the end should be
1, i.e. 1 extra line after the starting line.

Examples:

    \scan main.cpp
    \scan main.cpp c_filter
    \scan main.cpp c_filter.0
    \scan main.cpp c_filter.0 /main\(/ /QApp/
    \scan main.cpp c_filter.1 /main\(/ /QApp/
    \scan /resize/ /show/
    \scan mpp perl_filter /foreach\s*\(\s*\@line/ /\s+\}/

The regex language is perl's.

=head2 Loading Files with C<\load>

The \load function is used to load a file and apply macro expansion and
filtering to that file as if its text was inline. Its syntax is simple:

    \load filename

=head2 Setting Parameters with C<\set>

    \set param = value

Parameters can be set in files using C<\set>, on the command line with
C<--params> and in code with C<set>.

Although normally used for user parameters, internal ones can also be set,
although the only internal parameters that should be set are -filter and
-skip.

=head2 Skipping Lines with C<\if> and C<\endif>

    \if param
	:
    \endif

If the param (set with C<\set param = val> or with C<$self-E<gt>set( param, val )>)
is true, i.e. not zero or empty string, the lines up to the \endif will be
processed otherwise they will be skipped.

    \if param = val
	:
    \endif

Similar to the above; the lines will be processed if the param has the value
val, otherwise they will be skipped until the \endif. Can also be written
C<\if param == val>.

    \if param != val
	:
    \endif

Similar to the above; the lines will be processed if the param is not equal to
the val, otherwise they will be skipped until the \endif.

=head2 Configuration Files

mpp will load configuration i.e. macros from a default set of configuration
files in the order specified below. Macros with the same name over-write the
originals. 

    $MPPDIR/mpp.conf or /etc/mpp.conf
    $MPPDIR/mpp.format.conf or /etc/mpp.format.conf
    $HOME/.mpp.conf 
    $HOME/.mpp.format.conf
    ./mpp.conf 
    ./mpp.format.conf

Format may be any format you wish to define macros for, e.g. mpp.html.conf.

Configuration files should only contain comments in perl style, i.e. # comment
and \macro commands.

You can run C<mpp2perl> on mpp*.conf files to convert them to perl files which
can be checked with C<perl -wc>.

Some default .conf files are supplied for illustrative purposes.

=head2 DESCRIPTION

mpp is a driver for the Mpp class which is defined in the same file. To access
this class yourself do the following:

    require 'mpp'; # mpp must be in Perl's search path or a path given

    my $mpp1 = Mpp->new(...);
    $mpp1->process();

    my $mpp2 = $mpp1->new(...);
    $mpp2->process();

The parameters you give will vary depending on what you want to do. The
minimum is C<-infile=E<gt>filename> and either C<-configuring=E<gt>1> or
C<-outfile=E<gt>filename>. If used as a copy constructor all you need pass is
C<-infile=E<gt>filename>.

No fields that you create using C<set> or C<--params> should begin with a
hyphen or underscore.

METHODS

B<new>

This method creates Mpp objects. It can be called as a class method or as an
object method -- in the latter case it becomes a copy constructor inheriting
everything except the input file. 

=over

=item

C<-format> String that defaults to 'text'. The formats available are
whatever you create either in mpp.format.conf files or in the files in which
you want the macros expanded. See the example configuration files,
mpp.html.conf and mpp.sgml.conf.

=item

C<-filter> String that defaults to 'format-filter' (or 'text-filter'
if no format is specified). It is the name of a macro that you define and
which is applied to all your text. If you don't define it the fallback is the
built in 'text-filter' which returns its input unchanged.

=item

C<-infile> String; the name of the input file (including any path).
It is mandatory and has no default.

=item

C<-in> String; the input file's filehandle. Not normally used outside the
object.

=item

C<-outfile> String; the name of the output file (including any
path). It is mandatory and has no default unless C<-configuring> is true.
Output goes to this file. There is no output if C<-configuring> is true.

=item

C<-out> String; the output file's filehandle. You'd might use this if you
wanted many input files to output to the same output file; however this effect
is better achieved using a `master' file which C<\load>s other files.

=item

C<-warnings> Integer; defaults to 1, emit warnings. 0 switches off warnings.

=item

C<-messages> Integer; defaults to 1, emit messages. 0 switches off messages.

=item

C<-configuring> Integer; defaults to 0. If true there is no output.

=item

C<-macros> Hashref; keys are the names of the macros, values are coderefs. It
shouldn't normally be accessed.

=back

B<get>

    my $format = $self->get( '-format' );

Get the value of one of the fields (as listed in the new() constructor above),
or that has been created with C<set>, C<\set> or C<--params>.

B<set>

Set the value of one of the fields (as listed in the new() constructor above),
or that has been created with C<set>, C<\set> or C<--params>. Don't create any
with names that begin with a hyphen or underscore. To create/set fields on the
command line is achieved thus:

    --params='name1=val1 name2=val2' 

Each pair is either space or comma-separated.

B<process>

    $mpp->process();

Process a file. If you use a `master file', i.e. a file that consists of \load
statements all the files listed will be processed.

B<getval>

Get the value of a macro. Usually you'd pass the name of the macro without the
format since the right format will be used, e.g.

    my $val = $self->getval( 'year' ); # Equiv of \year

you can also pass the parameter:

    my $val = $self->getval( 'sum', '10,20,30' ); # Equiv of \sum[10,20,30]

B<setmacro>

Set the value of a macro.

    $self->setmacro( 'macroname', '"perl code"' );

B<load_file>

Load a file, performing filtering and macro expansion based on current
object's settings.

    $self->load_file( 'filename' );

B<scan_file>

Scan a file (insert an extract) based on the current object's settings.

    $self->scan_file( scanspec );

The scanspec is a string with the format:

    filename filter.numbering start end

See "Scanning: Inserting File Extracts with C<\scan>" for details of the
scanspec.

B<filter>
    
    my $filtered = $self->filter( 'some string' );

Apply the current filter to the given string.

B<msg>
    
    $self->msg( 'action is complete', 2 );

Issue the given message. The second parameter is a priority level, lower
numbers have higher priority.

B<warning>

    $self->warning( 'action failed', 1 );

Issue the given warning. The second parameter is a priority level, lower
numbers have higher priority. If a third non-zero parameter is passed die will
be called.

=head1 PREREQUISITES

C<strict>
C<File::Find>
C<Getopt::Long>
C<Symbol>

=head1 COREQUISITES

=head1 COPYRIGHT

Copyright (c) Mark Summerfield 2001. All Rights Reserved.
May be used/distributed under the GPL.

Email <summer@perlpress.com> with 'mpp' in the subject line.

=head1 OSNAMES

Linux

=head1 SCRIPT CATEGORIES

Text-processing
Macros
UNIX/System_administration

=cut

