<chapter>
<title>Useful Techniques</title>

    <para>
    Having explained the basic features of Qt Designer in the previous
    chapters, we will now consider details of some useful techniques
    so you can use this special programming tool more effectively.
    </para>

    <sect1>
    <title>Working With Signals And Slots</title>

	<para>
	The concept of signals and slots is central to Qt. Qt Designer
	provides two means to facilitate the use of signals and slots
	in Qt dialogs: the slots tool and the connection tool.
	</para>
    </sect1>

    <sect1>
    <title>The Connection Tool</title>

	<para>
	The connection tool (Figure 5-1) lets you view and edit
	already existing connections between components. A tabular
	display for each connection shows the sender by name, the
	emitted signal, the receiver by name, and the slot to which
	the signal is connected. To make additional connections
	between a sending and a receiving object, just click on the
	<guilabel>Edit</> button. A new window pops up that shows the
	signals of the sending widget GUI element and the slots of the
	receiving widget, as well as a list of already existing
	connections. By simply clicking on a slot you can add a new
	connection between these two components. When you mark a
	connection, the <guilabel>Disconnect</> button becomes
	available which also lets you remove a connection.
	</para>

	<figure>
	    <title>The connection tool</title>
	    <graphic format="gif" fileref="images/.gif"></graphic>
	</figure>

	<para>
	Note that the connection tool does not distinguish between
	predefined Qt slots and slots that you have defined yourself.
	You can easily augment the connection possibilities by
	creating your own slots (see following Section 5.1.2).
	</para>

	<para>
	As useful as the connection tool is, it only lets you delete
	or add connections between those components that already have
	existing connections. You cannot add new component pairs; that
	is done exclusively by graphics in the form editor. Nor is it
	possible to create a new connection with the keyboard; you
	must use the following mouse technique.
	</para>

	<para>
	We have already explained how to connect two widgets in the
	form editor: simply hit the <keycap>F3</> key or click on the
	connection icon. The mouse cursor then changes into a cross.
	Click on the widget that should be the sender in your new
	connection and see how a pink rectangle is drawn around it.
	Now move the mouse cursor across your form and watch how a
	second pink rectangle surrounds your current target object,
	i.e., the object that is on the receiving side of the
	connection. Once you release the mouse button, the connection
	tool window that you already know will open.
	</para>

	<para>
	In case you hit <keycap>F3</> by accident, you should know how
	to leave this distressing mode (everything suddenly gets
	pink). If you have not started dragging the mouse&mdash;i.e.,
	you have not even clicked on the sending
	component&mdash;simply hit the <keycap>Esc</> key; this works
	even if you are already dragging the mouse button but have not
	yet released it. However, depending on your mouse and
	keyboard, it might be difficult to operate the mouse and hit a
	key at the same time. In that case, either click on the
	pointer tool icon or just release the mouse anywhere and click
	<guibutton>Cancel</> in the dialog that pops up&mdash;no
	connection whatsoever will be made.
	</para>
    </sect1>

    <sect1>
    <title>The Slots Tool</title>

	<para>
	In simpler dialogs, using just the predefined slots is
	probably enough. But in more sophisticated dialogs you will
	probably want to define your own slots. This is done with the
	slots tool. Access the slots tool by selecting
	<guimenuitem>Edit|Slots</> from the menu. A dialog window will
	pop up that shows all self-defined slots of the form you are
	currently editing. Each slot is listed with its name and
	parameters, its access specifier, and whether it is &ldquo;in
	use,&rdquo; meaning whether it has a signal connected to it.
	Note that it is not necessary for each slot to be in use; a
	slot could be defined for outside use, in connections being
	made from other forms or other parts of the application you
	are writing (these connections would then be created in
	handwritten code, not with the Qt Designer).
	</para>

	<para>
	The access specifier might need some explanation. As you
	probably know, a public C++ method can be called from within
	any other class, but a protected method can be called only
	from within the same class or from within classes that inherit
	from it. A private method can be called only from within the
	same class. The same applies to slots, because slots are
	really just C++ methods.
	</para>

	<para>
	When should a slot be public, and when should it be protected?
	Here, the same criteria apply as for ordinary non-slot
	methods. If the slot is connected from outside the class it
	must be public; otherwise it should be protected, following
	the rule to expose as little as possible of the functionality
	of a class to the outside.
	</para>

	<para>
	If you look at the <guilabel>Slot Properties</> group box
	(where you can change the properties of the currently marked
	slot) and more specifically at the combo box (where you can
	select the access specifier) you might notice that it is not
	possible to make a slot private. Why is that? As we explained
	in Section 3.2, in order to implement your own functionality
	you need to subclass from the created form class and implement
	the functionality there (whether it is in a slot or
	elsewhere). But since we now have a hierarchy of classes, the
	slot cannot be made private because it would then be
	impossible to call it from another class; it would simply not
	be useful in the Qt Designer context.<footnote>
	<para>### footnote goes here ###</para>
	</footnote>
	</para>

	<para>
	To change the name and access specifier of a slot, click on
	the slot in the slot list and change the name and parameters
	and/or the access specifier in the <guilabel>Slot
	Properties</> group box. You can similarly remove a slot by
	marking it and clicking the <guilabel>Delete Slot</> button.
	To create a new slot, click on the <guilabel>New Slot</>
	button. A new slot will be added to the slot list with the
	name <function>new&lowbar;slot()</>, no parameters, and public
	access. It is marked as the current slot, so you can edit its
	properties right away. Consider whether you want to connect to
	this slot from the outside (in which case it should have
	public access) or not (in which case it should have protected
	access). Change the name to something more descriptive (many
	developers like to start the names of their slots with
	<literal>slot</> to make it more obvious that they are slots).
	Finally, if your slot should have parameters, add these
	between the parentheses after the slot name. For example, if
	the slot should have two integer parameters and be called
	<function>slotMovePosition()</>, you would provide the
	following in the edit field:
	</para>

	<programlisting>
slotMovePosition(int,int)
</programlisting>

	<para>
	Note that you cannot specify the return type. Slots must
	always have <literal>void</> as their return type, and Qt
	Designer adds this automatically.
	</para>

	<para>
	Any changes you make are directly taken over to the slot list,
	so you do not need to &ldquo;save&rdquo; your changes; just
	click the <guibutton>OK</> button when you are done. If you
	want to remove changes, close the dialog with the
	<guibutton>Cancel</> button or <keycap>Esc</> key.
	</para>
    </sect1>

    <sect1>
    <title>Changing The Tab Order</title>

	<para>
	The <emphasis>tab order</> is more relevant for those who
	prefer to use the keyboard instead of a mouse. However, as the
	application developer you will be catering to both groups of
	users, so this topic is important for you, too.
	</para>

	<para>
	The tab order is the order in which focus (i.e., the ability
	to accept keyboard input) is assigned to the individual
	widgets in a form. The user can then, for example, enter text
	in a text-entry field, use the <keycap>Tab</> key to move the
	focus to a combo box, select an entry, use the <keycap>Tab</>
	key to move to a push button, and press the
	<keycap>Spacebar</> to emulate a mouse click on this button.
	It is also possible to go backward in the so-called
	<emphasis>tab chain</> by using <keycap>Shift-Tab</>.
	</para>

	<para>
	A well-designed tab order is thus instrumental in making a
	form user-friendly to keyboard users. If the focus is to jump
	from the top of the dialog to the bottom and back while the
	tab chain is traversed, the user always has to search for
	where the focus is. Also, since the widgets in a form should
	usually be arranged in an order that allows a natural sequence
	of data entry, such an ill-formed tab chain would force the
	user to either enter the data in a non-natural order or use
	the mouse again to select another widget&mdash;which was
	exactly what should have been avoided by using the
	<keycap>Tab</> key in the first place.
	</para>

	<para>
	The default tab order is the one in which the widgets are
	inserted in the form; if you design your dialog from top to
	bottom and in the order that is most natural for data entry,
	you do not need to change anything. But rare are the cases
	where these conditions are really true; often you need to add
	a widget later but not necessarily at the bottom and at the
	end of the logical data-entry sequence, which would break the
	whole tab order. So you will likely need to change the tab
	order; in Qt Designer this is done with the <emphasis>tab
	order tool</>.
	</para>

	<para>
	But first we need to determine if the tab order is the correct
	one. This is not always obvious. Of course, users should not
	have to move their eyes up and down, and the order in which
	the widgets are traversed should be natural with respect to
	the type of data entered. But imagine you have a number of
	more or less independent entry fields that are arranged in two
	columns. Is it better to traverse the fields column by column
	or row by row? This depends on your users, and it would be
	best to ask them, if you can. Or, even better, implement one
	solution, let them try it, and look over their shoulder. Does
	the order feel natural to them? Is the focus always where they
	expect it to be? Or do they have to shift their attention at
	each press of the <keycap>Tab</> key?
	</para>

	<para>
	After considering these preliminaries, let's put the tab order
	tool in action. Begin by opening a form, our familiar pizza
	one or any other you have available.<footnote>
	<para>### footnote goes here ###</para>
	</footnote> Now click on the tab order icon (Figure 5-2),
	select <guimenuitem>Tools|Tab Order</> from the menu, or
	simply hit the <keycap>F4</> key. Suddenly, your form will be
	decorated with blue circles with white numbers in them (Figure
	5-3).
	</para>

	<figure>
	    <title>The tab order icon</title>
	    <graphic format="gif" fileref="images/.gif"></graphic>
	</figure>

	<figure>
	    <title>A form in tab order mode</title>
	    <graphic format="gif" fileref="images/.gif"></graphic>
	</figure>

	<para>
	To change the tab order, click on the blue circles in the new
	order you want the tab order to be in hereafter. The numbers
	in the circles change accordingly. This is easy and intuitive,
	but note that you must always start from 1. If, for example,
	you want to change the order of the widgets labeled 2 and 3,
	it is not possible to click on the 3 to make it the 2; it will
	become the 1 instead. So you must first click on the 1 (which
	will change nothing, because the widget here is already first
	in the tab order), then on the 3; the 3 will become the new 2,
	and the old 2 will move down one place, thus becoming the 3,
	exactly what you wanted. This also means that in order to
	change the order of an 11 and a 12, you have to click on the
	numbers 1 through 10 in their already existing order. This
	might feel like playing a game for small children, but there
	is no way around it.
	</para>

	<para>
	When you are done changing the tab order, press the
	<keycap>Esc</> key to leave tab order mode. There is no way to
	back out of your changes once you have started to make them.
	However you can make use of the general undo feature via
	<guimenuitem>Edit|Undo</>, <keycap>Ctrl-Z</>, or the undo
	icon.
	</para>
    </sect1>

    <sect1>
    <title>Advanced Layout Management</title>

	<para>
	In Chapter 4 we discussed the basics of layout management. Now
	let's fill in some missing pieces.
	</para>

	<para>
	To summarize what we've covered so far, layout management
	consists of two steps:
	</para>

	<orderedlist>
	    <listitem>
	    <para>
	    Adding widgets to a form, and
	    </para>
	    </listitem>

	    <listitem>
	    <para>
	    Aligning widgets by assigning a layout manager to the
	    surrounding container.
	    </para>
	    </listitem>
	</orderedlist>

	<para>
	If you later decide to add more widgets, you will first have
	to remove a layout manager (&ldquo;break the layout&rdquo;).
	But the two-step model is still valid: you first add the new
	widget, then you reassign the layout manager to the
	surrounding container.
	</para>

	<para>
	Note that there are two ways to select the surrounding
	container. If you already have a natural surrounding
	widget&mdash;such as a group box for the contained radio
	buttons, or the form itself if you want to lay out all already
	existing widgets or layout managers&mdash;then you just click
	on this container and assign the layout manager by using one
	of the options from the <guilabel>Lay Out</> menu, the toolbar
	buttons, or the accelerators (<keycap>Ctrl-H</>,
	<keycap>Ctrl-L</>, and <keycap>Ctrl-G</>, respectively).
	</para>

	<para>
	If, on the other hand, you do not have a natural
	container&mdash;e.g., you just want to group a number of
	widgets together so you can later take this group as a whole
	when you add another layout manager&mdash;then you can have Qt
	Designer create a widget for you. You do this by simply
	selecting all the widgets that should be laid out and then
	assigning a layout manager. The rest will be handled
	internally by Qt Designer; in the generated code, this becomes
	a sublayout.<footnote>
	<para>### footnote goes here ###</para>
	</footnote>
	</para>

	<para>
	As we noted in Section 4.1, there are three different layout
	arrangements available: a vertical box layout manager that
	arranges widgets in a column, a horizontal box layout manager
	that arranges widgets in a row, and a grid layout manager that
	arranges widgets in a grid. Obviously, the vertical and the
	horizontal box layout managers differ only in their
	orientation; otherwise, they are identical. These two box
	layout managers are also often used together; for example, it
	makes for a very natural layout to group some widgets into a
	few rows, then group these rows into a few columns, then group
	these columns into even fewer rows, etc. The outermost layout
	manager is then usually a vertical box layout manager, but
	this depends on your forms, of course.
	</para>

	<para>
	The <emphasis>grid layout manager</>, on the other hand, is
	less flexible. It arranges its widgets in a fixed number of
	rows and columns. While each column can have a different
	width, all the widgets in one column automatically have the
	same width (otherwise, you could hardly speak of a column).
	The same goes for rows. If you really want a widget not to
	extend its width to the full column width (which is determined
	by either the widest widget or the total available space or
	both), you can use spacers to the left and right of the widget
	that take up the remaining space. Again, the same applies to
	rows: you can also put spacers on top of and below a widget.
	</para>

	<para>
	If you are unsure about whether you should use a grid layout
	or a combination of vertical and horizontal box layouts, think
	about what feels more natural, given the nature of the
	widgets. For example, if you have a data-entry form with a
	number of vertically arranged line-entry fields and each has a
	label to the left of it, the grid is probably the better
	option because all the rows, each consisting of a label and a
	line-entry field, are uniform and should be laid out the same.
	On the other hand, if you have a less uniform collection of
	widgets, the more flexible solution of nested box layouts
	might produce better results.
	</para>

	<para>
	We discussed <emphasis>spacers</>in Section 4.2. Spacers are
	&ldquo;things&rdquo; that are not visible in the final dialog,
	except that they take up some of the available space. As
	already mentioned, this is useful if you do not want the
	widgets in a layout to claim all the available space for
	themselves, which would make them look unnaturally large.
	Spacers are represented by a spring-like drawing in the form
	editor and can be either horizontal or vertical&mdash;you have
	to select the orientation when you insert them but it can be
	changed later.
	</para>

	<para>
	Spacers are one of the things that can be used easily and
	intuitively but are awkward to describe. We will not say any
	more about them here except to suggest that you insert one
	whenever you think that a widget takes up more space than it
	should and whenever you think that two widgets should be
	further apart.
	</para>

	<para>
	As with all other things that you put on a form, layouts have
	<emphasis>properties</>. If you select a layout (make sure
	that you really select the layout and not one of the contained
	widgets or sublayouts; the handles should be all around the
	red rectangle symbolizing the layout), you can see the
	layout's properties in the form editor. Layouts have far fewer
	properties than widgets, and most of them are pretty generic
	anyway; but there are two properties that you might want to
	change: <literal>layoutSpacing</> and
	<literal>layoutMargin</>. <literal>layoutSpacing</>, whose
	value is 6 by default, indicates how much space should be
	between the individual widgets or sublayouts in the layout.
	The default value of 6 is chosen because that's what Microsoft
	recommends in its user interface guidelines.<footnote>
	<para>### footnote goes here ###</para>
	</footnote> You might want to choose different values for
	other platforms. You might also have special needs that call
	for more or less space between the widgets; in that case,
	change the <literal>layoutSpacing</> property.
	</para>

	<para>
	There is a significant difference between the
	<literal>layoutSpacing</> property and spacers. The
	<literal>layoutSpacing</> property specifies how much space
	<emphasis>must</> be between two widgets. For example, if you
	have three widgets in a horizontal box layout, the width that
	is required for this layout is the widths of all three widgets
	added together plus two times the value of the
	<literal>layoutSpacing</> property; there is no way the layout
	can display itself and its widgets correctly if it has less
	space than this. Spacers, on the other hand, take up
	additional available space that would otherwise go to the
	widgets. If the container that surrounds our horizontal box
	layout can provide more horizontal space, then either the
	widgets take up this space or, if there are spacers in between
	them, the spacers take up this space. In the latter case, the
	space between the widgets will of course be more than the
	required minimum that is specified by the
	<literal>layoutSpacing</> property.
	</para>

	<para>
	The second property, <literal>layoutMargin</>, is used less
	often; its default is 0. It specifies an additional margin
	that should be around all the widgets and sublayouts in the
	layout. After the necessary widths and heights for all the
	widgets and sublayouts in the layout have been computed, two
	times this value is added to both the width and the height to
	get the final necessary width and height of the layout. This
	property can be used if two sublayouts would otherwise be too
	close together to look good, but you will very rarely need it.
	</para>
    </sect1>

    <sect1>
    <title>Integrating Qt Designer Files Into Your Project</title>

	<para>
	Creating forms with Qt Designer gets you only halfway to
	completing your application. Somehow you have to integrate the
	created forms into your application&mdash;and not only into
	your application but also into your automatic build process.
	</para>

	<para>
	Before explaining how to achieve this, let's review the steps
	needed to create a form with Qt Designer:
	</para>

	<itemizedlist>
	    <listitem>
	    <para>
	    Design the form interactively in Qt Designer.
	    </para>
	    </listitem>

	    <listitem>
	    <para>
	    Save the form as an XML <filename>.ui</> file.
	    </para>
	    </listitem>

	    <listitem>
	    <para>
	    Run <command>uic</> twice from the command line on the
	    <filename>.ui</> file to generate the header and
	    implementation files.
	    </para>
	    </listitem>

	    <listitem>
	    <para>
	    If necessary (which is usually the case), create a
	    subclass of the generated class and implement the dialog
	    functionality there. You can use <command>uic</> to create
	    a skeleton for this class.
	    </para>
	    </listitem>

	    <listitem>
	    <para>
	    Compile the generated source file as well as the
	    implementation file of the subclass and all other files
	    belonging to the application.
	    </para>
	    </listitem>

	    <listitem>
	    <para>
	    Run <command>moc</> on the generated header file and the
	    subclass header file.
	    </para>
	    </listitem>

	    <listitem>
	    <para>
	    Compile the <command>moc</>-generated files.
	    </para>
	    </listitem>

	    <listitem>
	    <para>
	    Link all object files together.
	    </para>
	    </listitem>
	</itemizedlist>

	<para>
	As you can see, there are quite a number of steps involved.
	From the command line, the following could be the steps needed
	once you have saved the <filename>.ui</> file (let's call it
	<filename>myform.ui</>) in Qt Designer:
	</para>

	<programlisting>
uic -o myform.h myform.ui &num; generate header file
uic -o myform.cpp -impl myform.h myform.ui &num; generate implementation file

uic -o myformimpl.h -subdecl MyFormImpl&bsol; myform.h myform.ui &num; generate subclass header file

uic -o myformimpl.cpp -subimpl MyFormImpl&bsol; myformimpl.h myform.ui  &num; generate subclass implementation file

edit myformimpl.h &num; edit subclass header file
edit myformimpl.cpp &num; edit subclass implementation file
moc -o moc&lowbar;myform.cpp myform.h &num; generate moc code for base class

moc -o moc&lowbar;myformimpl.cpp myformimpl.h  &num; generate moc code for subclass

c++ -c myform.cpp -I&dollar;(QTDIR)/include  &num; compile base class, use similar &num; command on Windows

c++ -c moc&lowbar;myform.cpp -I&dollar;(QTDIR)/include  &num; compile base class moc code, use similar &num; command on Windows

c++ -c myformimpl.cpp -I&dollar;(QTDIR)/include  &num; compile subclass, use similar command &num; on Windows

c++ -c moc&lowbar;myformimpl.cpp -I&dollar;(QTDIR)/include  &num; compile subclass moc code, use similar  &num; command on Windows

c++ -o myform myform.o moc&lowbar;myform.o&bsol; myformimpl.o moc&lowbar;myformimpl.o&bsol; -L&dollar;(QTDIR)/lib -lqt  &num; link everything together, use similar &num; command on Windows
</programlisting>

	<para>
	But this is not enough. If you need to change anything in your
	dialog design, go back to Qt Designer, make your changes
	interactively, save the <literal>ui</> file again, and repeat
	most of the previous steps. All this cries for automation, but
	before you learn how to automate these steps we need to
	consider the generation of subclass files.
	</para>

	<para>
	The generation of subclass files falls a bit out of the
	ordinary build process for two reasons: First, you are
	required to edit the generated files (hinted at earlier); if
	you do not change these files and do not add your own
	implementation of certain methods, there is no point in having
	a subclass at all.
	</para>

	<para>
	Second&mdash;and this is a consequence of the first
	point&mdash;you do not regenerate the files over and over
	again after changes as you do with the other files. This is
	because you add changes to these files by hand, and if you
	overwrote the files, your changes would be lost.
	</para>

	<para>
	You thus usually use <command>uic</> only once per form with
	the options <literal>-subdecl</>and <literal>-subimpl</>.
	</para>

	<para>
	If you later add a new slot with Qt Designer, you cannot
	easily use <command>uic</> to add this slot to the subclass
	because your changes would be overwritten. Of course, you can
	always copy your changed versions of the files to files with
	different names, let <command>uic</> generate the new
	skeletons, and manually copy your changes back (e.g., in an
	editor), but this is usually more work and trouble than just
	adding the individual slots by hand.
	</para>

	<para>
	But even without these steps in the ordinary build process,
	there is an awful lot left. How you integrate everything into
	your build process largely depends on how your build process
	is organized, which tools you use, etc. If you use handwritten
	makefiles (a solution we do not recommend) and your project is
	very small, you could just add the build steps by hand. For
	the aforementioned project, this could look like the following
	in Unix-<emphasis>make</> syntax (Windows-<emphasis>make</>
	syntax will differ slightly but not much):
	</para>

	<programlisting>
all: myform
myform: myform.o moc&lowbar;myform.o myformimpl.o&bsol; moc&lowbar;myformimpl.o

	c++ -o &dollar;&commat; &dollar;+ -L&dollar;(QTDIR)/lib -lqt
myform.o: myform.cpp myform.h
	c++ -c &dollar;&dollar;&lt; -I&dollar;(QTDIR)/include
myformimpl.o: myformimpl.cpp myformimpl.h&bsol; myform.h
	c++ -c &dollar;&dollar;&lt; -I&dollar;(QTDIR)/include
moc&lowbar;myform.o: moc&lowbar;myform.cpp myform.h
	c++ -c &dollar;&dollar;&lt; -I&dollar;(QTDIR)/include
moc&lowbar;myformimpl.o: moc&lowbar;myformimpl.cpp&bsol;myformimpl.h myform.h

	c++ -c &dollar;&dollar;&lt; -I&dollar;(QTDIR)/include
moc&lowbar;myform.cpp: myform.h
	moc -o &dollar;&commat; &dollar;&lt;
moc&lowbar;myformimpl.cpp: myformimpl.h
	moc -o &dollar;&commat; &dollar;&lt;
myform.h: myform.ui
	uic -o &dollar;&commat; &dollar;&lt;
myform.cpp: myform.ui myform.h
	uic -o &dollar;&commat; -impl myform.h &dollar;&lt;
</programlisting>

	<para>
	Note that there is no rule here for generating
	<filename>myformimpl.cpp</> and <filename>myformimpl.h</>. As
	mentioned earlier (see Section 2.3), you generate them once by
	hand from the command line and then edit them with your text
	editor without regenerating them.
	</para>

	<para>
	Of course, the previous makefile with every relation
	explicitly spelled out does not hold for anything but the
	smallest project. You can achieve more generality by using
	suffix rules as follows:
	</para>

	<screen>
&num; clear SUFFIXES list
.SUFFIXES:
&num; define SUFFIXES
.SUFFIXES: .h .cpp .ui
&num; create a .h file from a .ui file
.h.ui:
	uic -o &dollar;&commat; &dollar;&lt;
&num; create a .cpp file from a .ui file
.cpp.ui:
	uic -o &dollar;&commat; -impl &dollar;*.h &dollar;&lt;
</screen>

	<para>
	But depending on your project, this might not be sophisticated
	enough.
	</para>
    </sect1>

    <sect1>
    <title>Using tmake To Generate And Build Qt Designer Files</title>

	<para>
	We heartily recommend a good system to automatically generate
	makefiles from a project description. There are several
	available for both Unix and Windows, but for projects
	involving Qt and the Qt Designer, we suggest you give
	<command>tmake</> a try.
	</para>

	<para>
	<command>tmake</> is free software that can be downloaded from
	<guimenuitem>ftp:||ftp.trolltech.com|pub|freebies|tmake|</>.
	Just make sure that you get Version 1.5 or higher. On Unix
	systems, <command>tmake</> requires Perl to be installed,
	which is usually the case these days.
	</para>

	<para>
	If you are not familiar with <command>tmake</>, we suggest
	that you read the documentation included; <command>tmake</> is
	really easy to use. We will only cover <command>tmake</>'s
	special features for use with Qt Designer here.
	</para>

	<para>
	Actually, once you know how to use <command>tmake</> for
	ordinary Qt projects, using it for projects that involve Qt
	Designer files is surprisingly easy. All you need to do is
	list your <filename>.ui</> files in the new
	<literal>INTERFACES</> tag in your <command>tmake</> project
	file. For the aforementioned project, the following could be
	enough:
	</para>

	<screen>
INTERFACES = myform.ui
</screen>

	<para>
	When you then generate the makefile from the <command>tmake</>
	project file, it will contain all the clauses mentioned
	earlier. The only thing you need to be sure of is that
	<command>uic</> is in your path, just as <command>moc</> and
	your C++ compiler are.
	</para>

	<para>
	Again, this method does not work with generated and edited
	subclass files, which are generated by hand and then edited as
	if they were ordinary source or header files (which in fact
	they are).
	</para>
    </sect1>

    <sect1>
    <title>Accessing The Help System</title>

	<para>
	There are many ways to get online help in Qt Designer. For
	example, you can read an online version of this manual by
	selecting <guimenuitem>Help|Manual</> from the menu or by
	hitting <keycap>Ctrl-F1</>. But the most interesting help
	feature will probably be context help. When you edit a
	property in the property editor, just press the <keycap>F1</>
	key to be shown the part of the Qt reference documentation
	that explains exactly that property. Similarly, when a widget
	is selected in the form editor, pressing <keycap>F1</> will
	show the description of that widget in the Qt reference
	documentation. When the background of a form is selected,
	pressing <keycap>F1</> will get you the description of the Qt
	class that is the base class of the form class (usually
	<classname>QWidget</>, <classname>QWizard</>, or <classname>QDialog</>).
	</para>

	<para>
	Whenever you are in the Qt help browser (which you open by
	pressing <keycap>F1</> or <keycap>Shift-F1)</>, you can access
	a comprehensive help index by hitting <keycap>Shift-T</> or
	selecting <guimenuitem>Go|Topics|Index</> from the help
	browser menu.
	</para>

	<para>
	Another way of getting help is the so-called What's This help.
	If, for example, you are uncertain what a particular toolbar
	button is for, you can click on the toolbar button with the
	arrow and the question mark and then click on the toolbar
	button in question, and a small information window will pop up
	that explains what the button is for. All dialogs have What's
	This help as well; just hit the <keycap>Shift-F1</> key (you
	won't be able to use the toolbar button in a modal dialog) and
	click on the widget you are uncertain about. The same applies
	to all the views: the widget hierarchy view, the form list,
	and the property editor.
	</para>
    </sect1>

    <sect1 id="old-custom-widgets">
    <title>Custom Widgets</title>

	<para>
	So far, we have only used widgets that are part of
	Qt&mdash;radio buttons, check boxes, push buttons, etc. But in
	many projects you will want to use widgets that you have defined
	yourself. Qt provides two methods for making custom widgets. 
	\list[1]
	\item\p
	The original \qd version 1 method involves little more than
	completing a dialog box. This approach is very simple and
	particularly well suited to custom widgets that do not add any
	new properties, slots or signals. We'll explain this approach in
	this section.
	\P\Item

	\item\p
	The \qd version 2 method involves creating custom widgets
	in code and embedding the widgets in a plugin. This approach
	provides more power and flexibility than the older method and is
	explained in <xref
	linkend="creating-custom-widgets-with-plugins"> "Creating Custom
	Widgets with Plugins".
	\P\Item
	\List1
	</para>

	<para>
	To make these custom widgets accessible for Qt Designer, you
	need to write <emphasis>descriptions</> for them. Writing
	these descriptions is rather easy, and Qt Designer facilitates
	it by providing a special dialog.
	</para>

	<para>
	You reach this dialog by selecting <guimenuitem>Tools|Custom|Edit
	Custom Widgets</> from the menu bar. The dialog shown in
	Figure 5-4 then opens. It consists of three parts. On the left
	is a list of all custom widgets that are currently known to Qt
	Designer. When you open this dialog for the first time, this
	list will of course be empty. To the right of this list are
	four action buttons to create a new custom widget description,
	delete an existing description, load a description file, and
	save the current descriptions to a file.
	</para>

	<figure>
	    <title>The dialog for describing custom widgets</title>
	    <graphic format="gif" fileref="images/.gif"></graphic>
	</figure>

	<para>
	Probably the most interesting part is the right half of this
	dialog, where all the properties of a custom widget can be
	defined on four tab pages: <guilabel>Definition</>,
	<guilabel>Signals</>, <guilabel>Slots</>, and
	<guilabel>Properties</>.
	</para>

	<para>
	In most cases, your widget will already be finished when you
	write a Qt Designer description for it. Thus all you need to
	do is mechanically go through all the fields, look for the
	information in (mostly) the header file of the widget, and
	fill it in.
	</para>

	<para>
	You start this process by clicking the <guilabel>New Widget</>
	button. Qt Designer will create an entry for a class called
	<literal>MyCustomWidget</> that has default values. Now go to
	the <guilabel>Definition</> tab page. The two pieces of data
	that you want to change in every custom widget are of course
	the class name and the header file. You can assign a pixmap to
	this widget that will then be used in the menus and the
	toolbar, where you can select your new custom widget. If your
	widget has a size hint and/or a size policy, you can set these
	on this tab page as well.<footnote>
	<para>### footnote goes here ###</para>
	</footnote>
	</para>

	<para>
	On the <guilabel>Signals</> tab page you enter all the signals
	that your widget has. This will make it possible to connect
	these signals later to slots in other widgets by means of the
	ordinary Qt Designer technique. Just click on the
	<guilabel>New Signal</> button and change the default signal
	name <function>clicked()</> to the name of your signal. Add
	the parameter types in the parentheses.
	</para>

	<para>
	The <guilabel>Slots</> tab page works the same way&mdash;you
	can define all the slots here that your custom widget defines.
	In addition to the slot name and parameters, you also need to
	specify the access. Remember that all this is already
	determined in your class definition; you just need to copy
	this information from the header file.
	</para>

	<para>
	Finally, you can set the properties on the last tab page.
	Again, just copy the information from your class declaration.
	</para>

	<para>
	Once you are done entering the data for all your custom
	widgets, you can save them to a file by clicking the
	<guilabel>Save Descriptions</> button. If you want to access
	these definitions later, you can load them again via the
	<guilabel>Load Descriptions</> button. This also makes it
	possible to load custom widget definitions that others have
	provided. (Third-party Qt widgets shipped in the future may be
	shipped with Qt Designer description files.) You can load as
	many description files as you like. But any description files
	that you have loaded once will be automatically loaded again
	the next time. When you open a form with custom widgets that
	are not yet loaded into Qt Designer, they are also loaded
	automatically. After you have defined your custom widgets or
	loaded a description file you can access the custom widgets
	from the toolbar or via the <guimenuitem>Tools|Custom</> submenu.
	</para>
    </sect1>
</chapter>
