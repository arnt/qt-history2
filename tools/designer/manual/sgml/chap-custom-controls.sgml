<chapter id="creating-custom-widgets-with-plugins">
<title>Creating Custom Widgets</>

<para id="ahkj">
<indexterm><primary>Custom Widgets</primary></indexterm>

<indexterm><primary>Widgets</primary><secondary>Custom</secondary></indexterm>

Custom widgets are created in code. They may comprise a combination of
existing widgets but with additional functionality, slots and signals,
or they may be written from scratch, or a mixture of both.
</para>
<para id="ahko">
<indexterm><primary>Previewing</primary><secondary>Custom Widgets</secondary></indexterm>

<indexterm><primary>Custom Widgets</primary><secondary>Previewing</secondary></indexterm>

<emphasis>Qt Designer</> provides two mechanisms for incorporating custom widgets:
<orderedlist numeration="arabic">
<listitem><para id="ahkr">
The original method involves little more than completing a dialog box.
Widgets incorporated this way appear as flat pixmaps when added to a
form in <emphasis>Qt Designer</>, even in preview mode. They only appear in their true form
at runtime. We'll explain how to create custom widgets using the
original approach in "Simple Custom Widgets".
</para></listitem>

<listitem><para id="ahla">
<indexterm><primary>Plugins</primary></indexterm>

The new method involves embedding the widgets in a plugin. Widgets that
are incorporated through plugins appear in their true form in <emphasis>Qt Designer</>, both
when laying out the form and in preview mode. This approach provides
more power and flexibility than the original method and is covered in
<xref linkend="creatingcustomwidgetswithplugins"> "Creating Custom
Widgets with Plugins"</para></listitem>
</orderedlist>
</para>

<sect1 id="old-custom-widgets">
<title>Simple Custom Widgets</title>
<para id="ahlm">
<indexterm><primary>Custom Widgets</primary><secondary>Simple</secondary></indexterm>

There are two stages to creating a custom widget. Firstly we must create
a class that defines the widget, and secondly we must incorporate the
widget into <emphasis>Qt Designer</>. Creating the widget has to be done whether we are
creating a simple custom widget or a plugin, but for simple custom
widgets the incorporation into <emphasis>Qt Designer</> is very easy.
</para>
<para id="ahlt">
We will create a VCR style widget comprising four buttons, rewind,
play, next and stop. The widget will emit signals according to which
button is clicked.
</para>

<sect2 id="codingthecustomwidget">
<title>Coding the Custom Widget </title>
<para id="ahmb">
A custom widget may consist of one or more standard widgets placed
together in a particular combination, or may be written from scratch. We
will combine some <indexterm><primary>QPushButton</primary></indexterm>
<classname>QPushButton</> widgets to form the
basis of our custom widget. 
</para>
<para id="ahmh">
We'll look at the header file,
<filename>qt/tools/designer/examples/vcr/vcr.h</> first.
<programlisting>
#ifndef VCR_H
#define VCR_H
#include &lt;qwidget.h&gt;

class Vcr : public <emphasis role="bold">QWidget</>
{
    Q_OBJECT
public:
    Vcr( <emphasis role="bold">QWidget</> *parent = 0, const char *name = 0 );
    ~Vcr() {}
signals:
    void rewind();
    void play();
    void next();
    void stop();
};
#endif
</programlisting>
<indexterm><primary>Macros</primary><secondary>Q_OBJECT</secondary></indexterm>

<indexterm><primary>Q_OBJECT</primary><seealso>Macros</seealso></indexterm>

We include <filename>qwidget.h</> since we'll be deriving our
custom widget from
<indexterm><primary>QWidget</primary></indexterm>
<classname>QWidget</>. We declare a constructor where the
widget will be created and the four signals we want our widget to emit.
Since we're using signals we must also include the
<literal>Q_OBJECT</literal> macro.
</para>

<para id="ahmv">
The implementation is straightforward. The only function we implement is
the constructor. The rest of the file consists of include statements and
embedded <indexterm><primary>Files and file types</primary><secondary>.xpm</secondary></indexterm>
<filename>.xpm</> images.
<programlisting>
Vcr::Vcr( <emphasis role="bold">QWidget</> *parent, const char *name )
    : <emphasis role="bold">QWidget</>( parent, name )
{
    <emphasis role="bold">QHBoxLayout</> *layout = new <emphasis role="bold">QHBoxLayout</>( this );
    layout-&gt;setMargin( 0 );

    <emphasis role="bold">QPushButton</> *rewind = new <emphasis role="bold">QPushButton</>( <emphasis role="bold">QPixmap</>( rewind_xpm ), 0, this, &quot;vcr_rewind&quot; );
    layout-&gt;addWidget( rewind );
    connect( rewind, SIGNAL(clicked()), SIGNAL(rewind()) ); 
</programlisting>
We create a <indexterm><primary>QHBoxLayout</primary></indexterm>
<classname>QHBoxLayout</> in which we'll place the
buttons. We've only shown the rewind button in the code above since all
the others are identical except for the names of the buttons, pixmaps
and signals. For each of the buttons we require we call the
<indexterm><primary>QPushButton</primary></indexterm>
<classname>QPushButton</> constructor passing it the
appropriate embedded pixmap. We then add it to the layout. Finally we
connect the button's <indexterm><primary>Signals and Slots</primary><secondary>clicked()</secondary></indexterm>
<function>clicked()</> signal to the
appropriate <emphasis>signal</emphasis>. Since the
<indexterm><primary>Signals and Slots</primary><secondary>clicked()</secondary></indexterm>
<function>clicked()</> signals aren't specific to our widget we
want to emit signals that reflect the widget's use. The
<function>rewind()</>, <function>play()</>, etc. signals
are meaningful in the context of our widget so we propagate each
button's <indexterm><primary>Signals and Slots</primary><secondary>clicked()</secondary></indexterm>
<function>clicked()</> signal to the appropriate
widget-specific signal. 
</para>

<para id="ahns">
<indexterm><primary>Forms</primary><secondary>Creating Test Harnesses</secondary></indexterm>

The implementation is complete, but to make sure that our widget
compiles and runs we'll create a tiny test harness. The test harness
will require two files, a <indexterm><primary>Files and file types</primary><secondary>.pro</secondary></indexterm>
<filename>.pro</> project file and a
<indexterm><primary>Files and file types</primary><secondary>main.cpp</secondary></indexterm>
<filename>main.cpp</>. The
<filename>qt/tools/designer/examples/vcr/vcr.pro</> project file:
<programlisting>
TEMPLATE = app
CONFIG+= qt warn_on release
HEADERS  = vcr.h
SOURCES  = vcr.cpp main.cpp
TARGET   = vcr
</programlisting>
The <filename>qt/tools/designer/examples/vcr/main.cpp</> file is
also brief:
<programlisting>
#include &lt;qapplication.h&gt;
#include &quot;vcr.h&quot;

int main( int argc, char ** argv )
{
    <emphasis role="bold">QApplication</> app( argc, argv );
    Vcr *vcr = new Vcr;
    vcr-&gt;show();
    return app.exec();
}
</programlisting>
Once we're satisfied that the custom widget compiles and runs we are
ready to incorporate it into <emphasis>Qt Designer</>.
</para>

<para id="ahok">
In <xref linkend="baseclasstemplates"> "Base-class Templates" 
the creation of a container custom widget is described.
</para>

</sect2>

<sect2 id="addingthecustomwidgettoqtdesigner">
<title>Adding the Custom Widget to Qt Designer </title>
<para id="ahot">
<indexterm><primary>Custom Widgets</primary><secondary>Adding to Qt Designer</secondary></indexterm>

<indexterm><primary>Adding</primary><secondary>Custom Widgets to Qt Designer</secondary></indexterm>

Click <indexterm><primary>Menu Options</primary><secondary>Tools|Custom|Edit Custom Widgets</secondary></indexterm>
<guimenuitem>Tools|Custom|Edit Custom Widgets</> to
invoke the <indexterm><primary>Dialogs</primary><secondary>Edit Custom Widgets</secondary></indexterm>
Edit Custom Widgets dialog. 
    <orderedlist numeration="arabic">
    <listitem>
	<para id="ahoy">
	Click <guibutton>New Widget</> so that we are ready to add our new widget.
	</para>
    </listitem>
    <listitem>
	<para id="ahpe">
	Change the Class name from 'MyCustomWidget' to 'Vcr'. 
	</para>
    </listitem>
    <listitem>
	<para id="ahpj">
	Click the ellipsis (<guibutton>...</>) button to the right of
	the Headerfile line edit to invoke the file Open dialog. Locate
	<filename>vcr.h</>, select it, and click
	<guibutton>Open</>. It will now appear as the header file. 
	</para>
    </listitem>
    <listitem>
	<para id="ahpr">
	If you have a pixmap that you want to use to identify your
	widget on the toolbar click the ellipsis button
	to the right of Pixmap.
	</para>
	<para id="ahpw">
	In our example we have the file
	<filename>qt/tools/designer/examples/vcr/play.xpm</> which we'll use
	for this purpose.
	</para>
    </listitem>
    <listitem>
	<para id="ahqd">
	Since we know the minimum sensible size for our widget we'll put
	these values into the Size Hint spin boxes. Enter a width of 80 (in
	the left hand spin box), and a height of 20 (in the right hand
	spin box).
	</para>
    </listitem>
    </orderedlist>
</para>
<para id="ahql">
The remaining items to be completed will depend on the characteristics
of the widget you've created. If, for example, your widget can be used
to contain other widgets you'd check the Container Widget checkbox. In
the case of our Vcr example the only items we need to add are its
signals.
</para>

<para id="ahqt">
Click the Signals tab. Click the <guibutton>New Signal</>
button and type in the signal name 'rewind()'. Click <guibutton>New Signal</>
again and this time type in 'play()'. Add the
'next()' and 'stop()' signals in the same way.
</para>

<para id="ahra">
Since our example hasn't any slots or properties we've finished and can
click <guibutton>Close</>. A new icon will appear in <emphasis>Qt Designer</>'s
toolbars which represents the new widget. If you create a new
form you can add Vcr widgets and connect the Vcr's signals to your
slots.
</para>

<para id="ahri">
Incorporating custom widgets that have their own slots and properties is
achieved in a similar way to adding signals. All the required
information is in our custom widget's header file. 
</para>
</sect2>
</sect1>



<sect1 id="creatingcustomwidgetswithplugins">
<title>Creating Custom Widgets with Plugins </title>


<para id="ahrw">
<indexterm><primary>Custom Widgets</primary><secondary>Plugins</secondary></indexterm>

<indexterm><primary>Plugins</primary><secondary>Implementing Custom Widgets</secondary></indexterm>

This section will show you how to write a custom widget and how to embed
the custom widget into a plugin. There are no restrictions or special
considerations that must be taken into account when creating a widget
that is destined to become a plugin. If you are an experienced Qt
programmer you can safely skip the section on creating a custom widget
and go directly to <xref linkend="creating-a-plugin"> "Creating a
Plugin". 
</para>

    <sect2 id="creatingacustomwidget"><title>Creating a Custom Widget</>
    <para id="ahsh">
    <indexterm><primary>Creating Custom Widgets</primary></indexterm>

    <indexterm><primary>Widgets</primary><secondary>Creating a Custom Widget</secondary></indexterm>

    <indexterm><primary>Subclassing</primary><secondary>Widgets</secondary></indexterm>

    A custom widget is often a specialization (subclass) of another
    widget or a combination of widgets working together or a blend of
    both these approaches. If you simply want a collection of widgets
    in a particular configuration it is easiest to create them, select
    them as a group, and copy and paste them as required within <emphasis>Qt Designer</>.
    Custom widgets are generally created when you need to add new
    functionality to existing widgets or groups of widgets. 
    </para>
    
    <para id="ahsr">
    <indexterm><primary>Properties</primary><secondary>Creating Custom Properties</secondary></indexterm>

    We have two recommendations that you should consider when creating a
    custom widget for a plugin:
	<orderedlist numeration="arabic">
	<listitem><para id="ahsv">
	Using Qt's property system will provide <emphasis>Qt Designer</> users with a direct
	means of configuring the widget through the property editor.
	(See the <ulink
	url="http://doc.trolltech.com/properties.html">Qt
	Properties</ulink> documentation.)
	</para></listitem>
	
	<listitem><para id="ahtd">
	Consider making your widget's public 'set' functions into
	public slots so that you can perform signal-slot connections
	with the widget in <emphasis>Qt Designer</>.
	</para></listitem>
	</orderedlist>
    </para>
    
    <para id="ahtl">
    In the course of this chapter we will create a simple but useful
    widget, 'FileChooser', which we'll later make available in <emphasis>Qt Designer</> as a
    plugin. In practice most custom widgets are created to add
    functionality rather than to compose widgets, so we will create our
    widget in code rather than using <emphasis>Qt Designer</> to reflect this approach.
    FileChooser consists of a <indexterm><primary>QLineEdit</primary></indexterm>
<classname>QLineEdit</> and a
    <indexterm><primary>QPushButton</primary></indexterm>
<classname>QPushButton</>. The <indexterm><primary>QLineEdit</primary></indexterm>
<classname>QLineEdit</> is used to hold a file or
    directory name, the <indexterm><primary>QPushButton</primary></indexterm>
<classname>QPushButton</> is used to launch a file
    dialog through which the user can choose a file or directory.
    <figure><title>The FileChooser Custom Widget</title>
    <graphic fileref="images\filechooser.png"></graphic>
    </figure>
    If you've followed the manual up to this point you may well be able
    to create this custom widget yourself. If you're confident that you
    can make your own version of the widget, or have another widget that
    you want to turn into a plugin, skip ahead to <xref
    linkend="creating-a-plugin"> "Creating a Plugin". If you prefer to
    read how we created the widget then read on.
    </para>

	<sect3><title>Coding the Widget's Interface</>
	<para id="ahuh">
	We will work step-by-step through the widget's header file,
	<filename>qt/tools/designer/examples/filechooser/widget/filechooser.h</>.
	</para>
	
	<para id="ahum">
<programlisting>
#include &lt;qwidget.h&gt;
class <emphasis role="bold">QLineEdit</>;
class <emphasis role="bold">QPushButton</>;
</programlisting>
	Our widget will be derived from <indexterm><primary>QWidget</primary></indexterm>
<classname>QWidget</> so we include
	the <filename>qwidget.h</> header file. We also forward declare the two
	classes that our widget will be built from. 
	</para>

	<para id="ahuw">
<programlisting>
class FileChooser : public <emphasis role="bold">QWidget</>
{
    Q_OBJECT
    Q_ENUMS( Mode )
    Q_PROPERTY( Mode mode READ mode WRITE setMode )
    Q_PROPERTY( <emphasis role="bold">QString</> fileName READ fileName WRITE setFileName )
</programlisting>
	<indexterm><primary>Macros</primary><secondary>Q_OBJECT</secondary></indexterm>

	<indexterm><primary>Macros</primary><secondary>Q_ENUMS</secondary></indexterm>

	<indexterm><primary>Q_ENUMS</primary><seealso>Macros</seealso></indexterm>

	We include the <indexterm><primary>Functions</primary><secondary>Q_OBJECT</secondary></indexterm>
<function>Q_OBJECT</> macro since this is required for
	classes that declare signals or slots. The <indexterm><primary>Functions</primary><secondary>Q_ENUMS</secondary></indexterm>
<function>Q_ENUMS</>
	declaration is used to register the Mode enumeration. Our widget
	has two properties, mode, to store whether the user should
	select a File or a Directory and fileName which stores the file
	or directory they chose.
	</para>

	<para id="ahvk">
<programlisting>
    FileChooser( <emphasis role="bold">QWidget</> *parent = 0, const char *name = 0);
    <emphasis role="bold">QString</> fileName() const;
    Mode mode() const;
</programlisting>
	The constructor is declared in the standard way for widgets. We
	declare two public functions, <function>fileName()</> to return the
	filename, and <function>mode()</> to return the mode.
	</para>

	<para id="ahvu">
<programlisting>
public slots:
    void setFileName( const <emphasis role="bold">QString</> &amp;fn );
    void setMode( Mode m );
signals:
    void fileNameChanged( const <emphasis role="bold">QString</> &amp; );
private slots:
    void chooseFile();
</programlisting>
	The two 'set' functions are declared as public slots.
	<function>setFileName()</> and <function>setMode()</> set the filename and mode
	respectively. We declare a single signal, <function>fileNameChanged()</>. The
	private slot, <function>chooseFile()</> is called by the widget itself
	when its button is clicked.
	</para>

	<para id="ahwh">
<programlisting>
private:
    <emphasis role="bold">QLineEdit</> *lineEdit;
    <emphasis role="bold">QPushButton</> *button;
    Mode md;
</programlisting>
	A pointer to <indexterm><primary>QLineEdit</primary></indexterm>
<classname>QLineEdit</> and <indexterm><primary>QPushButton</primary></indexterm>
<classname>QPushButton</>, as well
	as a Mode variable are held as private data. 
	</para>

	</sect3>

	<sect3><title>Coding the Implementation</>
	<para id="ahws"> 
	We will work step-by-step through the implementation which is in
	<filename>qt/tools/designer/examples/filechooser/widget/filechooser.cpp</>.
	</para>

	<para id="ahwx">
<programlisting>
FileChooser::FileChooser( <emphasis role="bold">QWidget</> *parent, const char *name )
    : <emphasis role="bold">QWidget</>( parent, name ), md( File )
</programlisting>
	The constructor passes the parent and name to its superclass,
	<indexterm><primary>QWidget</primary></indexterm>
<classname>QWidget</>, and also initializes the private mode data, md,
	to File mode.
	</para>

	<para id="ahxg">
<programlisting>
    <emphasis role="bold">QHBoxLayout</> *layout = new <emphasis role="bold">QHBoxLayout</>( this );

    lineEdit = new <emphasis role="bold">QLineEdit</>( this, &quot;filechooser_lineedit&quot; );
    layout-&gt;addWidget( lineEdit );

    button = new <emphasis role="bold">QPushButton</>( &quot;...&quot;, this, &quot;filechooser_button&quot; );
    layout-&gt;addWidget( button );
</programlisting>
	We begin by creating a horizontal box layout
	(<indexterm><primary>QHBoxLayout</primary></indexterm>
<classname>QHBoxLayout</>) and add a <indexterm><primary>QLineEdit</primary></indexterm>
<classname>QLineEdit</> and a
	<indexterm><primary>QPushButton</primary></indexterm>
<classname>QPushButton</> to it. 
	</para>

	<para id="ahxu">
<programlisting>
    connect( lineEdit, SIGNAL( textChanged( const <emphasis role="bold">QString</> &amp; ) ),
             this, SIGNAL( fileNameChanged( const <emphasis role="bold">QString</> &amp; ) ) );

    connect( button, SIGNAL( clicked() ),
             this, SLOT( chooseFile() ) );
</programlisting>
	We connect the lineEdit's <indexterm><primary>Signals and Slots</primary><secondary>textChanged()</secondary></indexterm>
<function>textChanged()</> signal to the custom
	widget's <function>fileNameChanged()</> signal. This ensures that if the
	user changes the text in the <indexterm><primary>QLineEdit</primary></indexterm>
<classname>QLineEdit</> this fact will be
	propagated via the custom widget's own signal. The button's
	<indexterm><primary>Signals and Slots</primary><secondary>clicked()</secondary></indexterm>
<function>clicked()</> signal is connected to the custom widget's
	<function>chooseFile()</> slot which invokes the appropriate dialog for
	the user to choose their file or directory.
	</para>

	<para id="ahyj">
<programlisting>
    setFocusProxy( lineEdit );
</programlisting>
	We set the lineEdit as the focus proxy for our custom widget.
	This means that when the widget is given focus the focus
	actually goes to the lineEdit. 
	</para>

	<para id="ahys">
<programlisting>
void FileChooser::setFileName( const <emphasis role="bold">QString</> &amp;fn )
{
    lineEdit-&gt;setText( fn );
}
<emphasis role="bold">QString</> FileChooser::fileName() const
{
    return lineEdit-&gt;text();
}
</programlisting>
	The <function>setFileName()</> function sets the filename in the
	<indexterm><primary>QLineEdit</primary></indexterm>
<classname>QLineEdit</>, and the <function>fileName()</> function returns the
	filename from the <indexterm><primary>QLineEdit</primary></indexterm>
<classname>QLineEdit</>. The <function>setMode()</> and
	<function>mode()</> functions (not shown) are similarly set and return the
	given mode.
	</para>

	<para id="ahze">
<programlisting>
void FileChooser::chooseFile()
{
    <emphasis role="bold">QString</> fn;
    if ( mode() == File )
        fn = <emphasis role="bold">QFileDialog::getOpenFileName</>( lineEdit-&gt;text(), <emphasis role="bold">QString::null</>, this );
    else
        fn = <emphasis role="bold">QFileDialog::getExistingDirectory</>( lineEdit-&gt;text(),this );

    if ( !fn.isEmpty() ) {
        lineEdit-&gt;setText( fn );
        emit fileNameChanged( fn );
    }
}
</programlisting>
	When <function>chooseFile()</> is called it presents the user with a file
	or directory dialog depending on the mode. If the user chooses a
	file or directory the <indexterm><primary>QLineEdit</primary></indexterm>
<classname>QLineEdit</> is updated with the
	chosen file or directory and the <function>fileNameChanged()</> signal is
	emitted.
	</para>

	<para id="ahzp">
	Although these two files complete the implementation of the
	FileChooser widget it is good practice to write a test harness
	to check that the widget behaves as expected before attempting
	to put it into a plugin.
	</para>

	</sect3>

	<sect3><title>Testing the Implementation</>
	<para id="ahzz">
	<indexterm><primary>Forms</primary><secondary>Creating Test Harnesses</secondary></indexterm>

	We present a rudimentary test harness which will allow us
	to run our custom widget. The test harness requires two
	files, a <indexterm><primary>Files and file types</primary><secondary>main.cpp</secondary></indexterm>
<filename>main.cpp</> to contain the FileChooser, and a <literal>.pro</>
	file to create the Makefile from. Here is
	<filename>qt/tools/designer/examples/filechooser/widget/main.cpp</>:
<programlisting>
#include &lt;qapplication.h&gt;
#include &quot;filechooser.h&quot;

int main( int argc, char ** argv )
{
    <emphasis role="bold">QApplication</> a( argc, argv );
    FileChooser *fc = new FileChooser;
    fc-&gt;show();
    return a.exec();
}
</programlisting>
	And here is <filename>qt/tools/designer/examples/filechooser/widget/filechooser.pro</>
<programlisting>
TEMPLATE        = app
CONFIG+= qt warn_on release
HEADERS                = filechooser.h
SOURCES                = filechooser.cpp main.cpp
INTERFACES        =
TARGET                = filechooser
</programlisting>
	We can create the makefile using <indexterm><primary>qmake</primary></indexterm>
<command>qmake</>: 
	<literal>qmake -o Makefile filechooser.pro</>, then we can make and run
	the harness to test our new widget. Once we're satisfied that
	the custom widget is robust and has the behaviour we require we
	can embed it into a plugin.
	</para>

	</sect3>

    </sect2>

    <sect2 id="creating-a-plugin"><title>Creating a Plugin</>
    <para id="aiay">
    <indexterm><primary>Creating Plugins</primary></indexterm>

    <indexterm><primary>Plugins</primary><secondary>Creating a Plugin</secondary></indexterm>

    <indexterm><primary>Component</primary><seealso>Plugins</seealso></indexterm>

    A plugin is a software component. Plugins are not specific to <emphasis>Qt Designer</>;
    they can be used generally to wrap any number of classes which can
    then be supplied within a stand-alone component. <emphasis>Qt Designer</> can load any
    plugins that provide an interface which it understands: the
    <indexterm><primary>WidgetInterface</primary></indexterm>
<classname>WidgetInterface</> is such an interface and the one we'll use
    for our example. <emphasis>Qt Designer</> also provides an application interface through
    which plugins can access its own functionality. We will demonstrate
    how to wrap a custom widget, (the FileChooser widget we created in
    the previous section), inside an interface implementation and how to
    place the interface implementation inside a plugin. Although we will
    only include one widget in our interface implementation there is no
    limit to the number of widgets that could be included.
    </para>

    <sidebar><title>Plugin Terminology</title>
    <para id="aibo">
    <indexterm><primary>Plugins</primary><secondary>Terminology</secondary></indexterm>

    <indexterm><primary>Terminology</primary><secondary>Plugins</secondary></indexterm>

    <itemizedlist>
    <listitem><para id="aibq">
    A <emphasis>Plugin</> is a library that is dynamically loaded by
    applications. A plugin contains any number of interface
    implementations and possibly other functionality.
    </para></listitem>

    <listitem><para id="aibw">
    An <emphasis>Interface</> is an abstract base class which defines the
    signatures for the functions that a particular type of interface
    implementation will provide. Applications can query plugins to see
    if the plugin can provide an implementation of an interface that the
    application wishes to use.
    </para></listitem>

    <listitem><para id="aice">
    An <emphasis>Interface Implementation</> is a class that implements an
    interface. For example an interface implementation might implement
    the <indexterm><primary>WidgetInterface</primary></indexterm>
<classname>WidgetInterface</> interface. 
    </para></listitem>

    </itemizedlist>

    </para>
    </sidebar>

    <para id="aicp">
    In our example we wish to make a custom widget available through a
    plugin so we must derive the interface implementation from the
    <indexterm><primary>WidgetInterface</primary></indexterm>
<classname>WidgetInterface</> class. We must implement all the
    <indexterm><primary>WidgetInterface</primary></indexterm>
<classname>WidgetInterface</>'s pure virtual functions. In most cases the
    implementations are simple and can easily be adapted from the
    example we present. 
    </para>
 
    <para id="aicy">
    Within the context of the <indexterm><primary>WidgetInterface</primary></indexterm>
<classname>WidgetInterface</> a <emphasis>feature</> is a
    widget class that a <indexterm><primary>WidgetInterface</primary></indexterm>
<classname>WidgetInterface</> implementation makes
    available to applications. Since a <indexterm><primary>WidgetInterface</primary></indexterm>
<classname>WidgetInterface</>
    implementation can include any number of features most of the
    interface functions take the name of the feature, (the particular
    widget class we wish to access through the interface), as their
    first argument to distinguish which feature we are referring to.
    </para>
   
    <para id="aidi">
    To make your own plugin it is probably easiest to start by copying
    the <indexterm><primary>Files and file types</primary><secondary>plugin.h</secondary></indexterm>
<filename>plugin.h</> and <indexterm><primary>Files and file types</primary><secondary>plugin.cpp</secondary></indexterm>
<filename>plugin.cpp</> files and changing
    'CustomWidgetInterface' to the name you wish to use for your
    widget interface implementation class. Below we provide an
    introduction to the header file although it needs no changes beyond
    class renaming. The implementation file requires simple changes,
    mostly more class renaming; we will review each function in turn and
    explain what you need to do.
    </para>
    
    <para id="aidt">
    <indexterm><primary>UUID (Universal Unique Identifier)</primary></indexterm>

    <indexterm><primary>Universal Unique Identifier, UUID</primary></indexterm>

    Note that if two different interface implementations, e.g. from two
    different suppliers, use the same class name there will be no
    conflict. This is because every interface (i.e. abstract base
    class) has a unique uuid (<emphasis>universal unique identifier</>). When the
    application wants the functionality of a particular interface it
    calls <indexterm><primary>Functions</primary><secondary>queryInterface()</secondary></indexterm>
<function>queryInterface()</> passing the uuid of the interface it is
    interested in, for example, <literal>IID_Widget</>. If the
    implementation provides the requested interface it returns a
    pointer to the interface's implementation. The application never
    uses (or knows) the name of the class that actually provides the
    implementation so no name conflict can occur.
    </para>

	<sect3><title>The <indexterm><primary>WidgetInterface</primary></indexterm>
<classname>WidgetInterface</> Implementation</title>
	<para id="aiei">
	We have called our header file <indexterm><primary>Files and file types</primary><secondary>plugin.h</secondary></indexterm>
<filename>plugin.h</> and we've
	called our interface class <indexterm><primary>CustomWidgetInterface</primary></indexterm>
<classname>CustomWidgetInterface</> since we
	will be using our interface class to wrap our custom widgets. We
	present the entire header file to give you an impression of the
	scope of the implementation required. Most of the functions
	require just a few lines of code. 
<example><title>From <filename>qt/tools/designer/examples/filechooser/plugin/plugin.h</></><programlisting>
#include &lt;widgetinterface.h&gt;
#include &lt;qobjectcleanuphandler.h&gt;

class CustomWidgetInterface : public WidgetInterface
{
public:
    CustomWidgetInterface();
    virtual ~CustomWidgetInterface() {}

   <emphasis> // From <emphasis role="bold">QUnknownInterface</>
</>
    <emphasis role="bold">QRESULT</> queryInterface( const <emphasis role="bold">QUuid</>&amp;, <emphasis role="bold">QUnknownInterface</> **iface );
    Q_REFCOUNT;

   <emphasis> // From <emphasis role="bold">QFeatureListInterface</>
</>
    <emphasis role="bold">QStringList</> featureList() const;

   <emphasis> // From WidgetInterface
</>
    <emphasis role="bold">QWidget</>* create( const <emphasis role="bold">QString</> &amp;classname, <emphasis role="bold">QWidget</>* parent = 0, const char* name = 0 );
    <emphasis role="bold">QString</> group( const <emphasis role="bold">QString</>&amp; ) const;
    <emphasis role="bold">QIconSet</> iconSet( const <emphasis role="bold">QString</>&amp; ) const;
    <emphasis role="bold">QString</> includeFile( const <emphasis role="bold">QString</>&amp; ) const;
    <emphasis role="bold">QString</> toolTip( const <emphasis role="bold">QString</>&amp; ) const;
    <emphasis role="bold">QString</> whatsThis( const <emphasis role="bold">QString</>&amp; ) const;
    bool isContainer( const <emphasis role="bold">QString</>&amp; ) const;

private:
    <emphasis role="bold">QObjectCleanupHandler</> objects;

    ulong ref;
};
</programlisting></example>
	</para>

	    <para id="aieu">
	    There are two items of private data, <literal>objects</> and
	    <literal>ref</>. The <literal>ref</> item is used to store the widget
	    interface implementation's reference count. The <literal>objects</>
	    item is a guarded cleanup handler that ensures that the
	    widgets that get instantiated by the interface
	    implementation are deleted when the plugin is unloaded. (See
	    the <ulink url="http://doc.trolltech.com/qplugin.html">Qt
	    Plugin documentation</> and the class documentation for
	    <ulink
	    url="http://doc.trolltech.com/qcleanuphandler.html">QCleanupHandler</>
	    for more information.)
	    </para>


	</sect3>

	<sect3><title>The WidgetInterface Functions</>
	<para id="aifm">
	Create your own plugin <literal>.cpp</> file by copying our
	<indexterm><primary>Files and file types</primary><secondary>plugin.cpp</secondary></indexterm>
<filename>plugin.cpp</> file and changing all occurrences of
	'CustomWidgetInterface' to the name you wish to use for your
	widget interface implementation. Most of the other changes are
	simply replacing the name of our custom control, 'FileChooser',
	with the name of your custom control. You may need to
	add extra <literal>else if</> clauses if you have more than one custom
	control in your interface implementation.
	</para>

	    <para id="aifx">
	    We'll now look at the constructor.
<programlisting>
CustomWidgetInterface::CustomWidgetInterface()
    : ref( 0 )
{
}
</programlisting>
	    The constructor sets the widget interface implementation's
	    reference count to zero. Simply copy ours with the class
	    name you wish to use for your widget interface
	    implementation.
	    </para>

	    <para id="aigi">
	    No destructor is necessary. We defined it in the header
	    file as follows:
<programlisting>
    virtual ~CustomWidgetInterface() {}
</programlisting>
	    If you copied our <indexterm><primary>Files and file types</primary><secondary>plugin.h</secondary></indexterm>
<filename>plugin.h</>, and renamed the widget
	    interface implementation's class name throughout, your
	    destructor is finished.
	    </para>

	    <para id="aigt">
	    The <indexterm><primary>Functions</primary><secondary>queryInterface()</secondary></indexterm>
<function>queryInterface()</> is the most complicated function:
	    but it can simply be copied into your own widget interface
	    implementation. Change the class name to whatever class
	    you've called your widget interface implementation. (It
	    isn't implemented for us in the <indexterm><primary>WidgetInterface</primary></indexterm>
<classname>WidgetInterface</>
	    class because some types of plugin need to specialise it.)
<programlisting>
<emphasis role="bold">QRESULT</> CustomWidgetInterface::queryInterface( const <emphasis role="bold">QUuid</>&amp; uuid, <emphasis role="bold">QUnknownInterface</> **iface )
{
    if ( uuid == IID_QUnknown )
        *iface = (<emphasis role="bold">QUnknownInterface</>*)this;
    else if ( uuid == IID_QFeatureList )
        *iface = (<emphasis role="bold">QFeatureListInterface</>*)this;
    else if ( uuid == IID_Widget )
        *iface = (WidgetInterface*)this;

    if ( *iface )
        (*iface)-&gt;addRef();
}
</programlisting>
	    <indexterm><primary>UUID (Universal Unique Identifier)</primary></indexterm>

	    <indexterm><primary>Universal Unique Identifier, UUID</primary></indexterm>

	    <indexterm><primary>Globally Unique Identifier</primary><seealso>Univeral Unique Identifier</seealso></indexterm>

	    The <indexterm><primary>Functions</primary><secondary>queryInterface()</secondary></indexterm>
<function>queryInterface()</> function is called by programs that
	    load a plugin so that they can determine whether the plugin
	    provides an implementation for a particular interface. Every
	    interface has a unique uuid 
	    (<emphasis>universal unique identifier</>, also known as a
	    <emphasis>globally unique identifier</>), which is passed to the
	    function as <literal>uuid</>. The function also takes a pointer to a
	    pointer to an
	    <indexterm><primary>QUnknownInterface</primary></indexterm>
<classname>QUnknownInterface</> object, <literal>iface</>, and tries
	    to assign a matching interface to it. If the interface
	    implementation supports the requested interface the
	    interface's reference count is incremented. 
	    </para>

	    <sidebar><title>Why we need <indexterm><primary>Functions</primary><secondary>addRef()</secondary></indexterm>
<function>addRef()</> and <indexterm><primary>Functions</primary><secondary>release()</secondary></indexterm>
<function>release()</></title>
	    <para id="aihs">
	    Plugins are different from most other Qt classes with
	    regards to memory management. In Qt programming we often pass
	    on responsibility for memory management to the containing
	    widgets and ultimately to <literal>QApplication</> itself by
	    parenting our widgets. Plugins are different because they
	    wrap interfaces which are not <indexterm><primary>QObject</primary></indexterm>
<classname>QObject</>s, so we cannot
	    predict what their memory handling requirements are. This
	    means that when you get a reference to a widget interface
	    implementation object a reference count is incremented, and
	    when you have no further use for the reference <emphasis>you</> must
	    call <indexterm><primary>Functions</primary><secondary>release()</secondary></indexterm>
<function>release()</>. The reference counting prevents the
	    unloading of a library (plugin) that is still in use. If all
	    of a plugin's reference counts are zero the library can be
	    automatically unloaded.
	    </para>

	    <para id="aiij">
	    Since we are writing a widget interface implementation for
	    <emphasis>Qt Designer</>, all we need to do is provide the <indexterm><primary>Functions</primary><secondary>addRef()</secondary></indexterm>
<function>addRef()</> and
	    <indexterm><primary>Functions</primary><secondary>release()</secondary></indexterm>
<function>release()</> functions. <emphasis>Qt Designer</> (or any other application using
	    our plugin) is responsible for calling these functions when
	    appropriate.
	    </para>

	    <para id="aiir">
	    <indexterm><primary>Macros</primary><secondary>Q_REFCOUNT</secondary></indexterm>

	    <indexterm><primary>Q_REFCOUNT</primary><seealso>Macros</seealso></indexterm>

	    You don't have to implement these functions yourself. Just
	    add the <literal>Q_REFCOUNT</literal> macro to your
	    <indexterm><primary>Files and file types</primary><secondary>.h</secondary></indexterm>
<filename>.h</> file and they will be
	    created for you.
	    </para>
	    </sidebar>
<!--

	    <para id="aija">
	    The <indexterm><primary>Functions</primary><secondary>addRef()</secondary></indexterm>
<function>addRef()</> function.
<programlisting>
</programlisting>
	    This function increments the reference count. Usually you
	    just need to copy this code and change the class name to
	    the class name of your widget interface implementation.
	    </para>

	    <para id="aijk">
	    The <indexterm><primary>Functions</primary><secondary>release()</secondary></indexterm>
<function>release()</> function.
<programlisting>
</programlisting>
	    This function decrements the reference count and deletes the
	    object if no more references exist. Usually you just need
	    to copy this code and change the class name to the class
	    name of your widget interface implementation.
	    </para>
-->
	    <para id="aijv">
	    <indexterm><primary>Macros</primary><secondary>Q_EXPORT_INTERFACE</secondary></indexterm>

	    <indexterm><primary>Q_EXPORT_INTERFACE</primary><seealso>Macros</seealso></indexterm>

	    The <indexterm><primary>Functions</primary><secondary>Q_EXPORT_INTERFACE</secondary></indexterm>
<function>Q_EXPORT_INTERFACE</> Macro
<programlisting>
Q_EXPORT_INTERFACE()
{
    Q_CREATE_INSTANCE( CustomWidgetInterface );
}
</programlisting>
	    This macro is the only code that identifies your module as a
	    plugin -- all the other code simply implements the relevant
	    interface, i.e. wraps the classes you wish to make
	    available.
	    </para>

	    <para id="aikg">
	    This macro must appear <emphasis>once</> in your plugin. It should be
	    copied with the class name changed to the name of your
	    interface's class. (See the <ulink
	    url="http://doc.trolltech.com/qplugin.html">Qt Plugin
	    documentation</> for more information on the plugin entry
	    point.)
	    </para>

	    <para id="aikp">
	    Each widget you wrap in a widget interface implementation
	    becomes a feature that the interface implementation offers.
	    There is no limit to the number of features that you may
	    include in an interface implementation.
<programlisting>
<emphasis role="bold">QStringList</> CustomWidgetInterface::featureList() const
{
    <emphasis role="bold">QStringList</> list;
    list &lt;&lt; &quot;FileChooser&quot;;
    return list;
}
</programlisting>
	    For each widget class that you want to wrap in the interface
	    implementation you should supply a feature name, (often the
	    class name), by which the class can be identified. In our
	    example we add a single feature, 'FileChooser'.
	    </para>

	    <para id="aild">
	    The <indexterm><primary>Functions</primary><secondary>create()</secondary></indexterm>
<function>create()</> function.
<programlisting>
<emphasis role="bold">QWidget</>* CustomWidgetInterface::create( const <emphasis role="bold">QString</> &amp;feature, <emphasis role="bold">QWidget</>* parent, const char* name )
{
    <emphasis role="bold">QWidget</>* w = 0;

    if ( feature == &quot;FileChooser&quot; )
        w = new FileChooser( parent, name );

    objects.add( w );
    return w;
}
</programlisting>
	    In this function we create an instance of the requested
	    feature, register it with the cleanup handler, with
	    the <literal>objects.add( w )</> call, and return a pointer to the
	    widget for the caller to use. Copy this function changing
	    the class name and the feature name and create an instance
	    of your widget just as we've done here with 
	    <literal>w = new FileChooser( parent, name);</>. (See the <ulink
	    url="http://doc.trolltech.com/qplugin.html">Qt Plugin
	    documentation</> for more information on cleanup handling.)
	    </para>

	    <para id="ailt">
	    The <indexterm><primary>Functions</primary><secondary>includeFile()</secondary></indexterm>
<function>includeFile()</> function.
<programlisting>
<emphasis role="bold">QString</> CustomWidgetInterface::includeFile( const <emphasis role="bold">QString</>&amp; feature ) const
{
    if ( feature == &quot;FileChooser&quot; )
        return &quot;filechooser.h&quot;;
    return <emphasis role="bold">QString::null</>;
}
</programlisting>
	    This function returns the name of the include file for the
	    custom widget. Copy this function changing the class name,
	    feature name and filename to suit your own custom widget.
	    </para>

	    <para id="aimd">
	    The <indexterm><primary>Functions</primary><secondary>group()</secondary></indexterm>
<function>group()</>, <indexterm><primary>Functions</primary><secondary>iconSet()</secondary></indexterm>
<function>iconSet()</>, <indexterm><primary>Functions</primary><secondary>iconset()</secondary></indexterm>
<function>iconset()</>,
	    <indexterm><primary>Functions</primary><secondary>toolTip()</secondary></indexterm>
<function>toolTip()</> and <indexterm><primary>Functions</primary><secondary>whatsThis()</secondary></indexterm>
<function>whatsThis()</> functions.
<programlisting>
<emphasis role="bold">QString</> CustomWidgetInterface::group( const <emphasis role="bold">QString</>&amp; feature ) const
{
    if ( feature == &quot;FileChooser&quot; )
        return &quot;Input&quot;;
    return <emphasis role="bold">QString::null</>;
}
</programlisting>
	    We use the <indexterm><primary>Functions</primary><secondary>group()</secondary></indexterm>
<function>group()</> function to identify which <emphasis>Qt Designer</> toolbar
	    group this feature (custom widget) should be part of. If we
	    use a name that is not in use <emphasis>Qt Designer</> will create a new toolbar
	    group with the given name. Copy this function, changing the
	    class name, feature name and group name to suit your own
	    widget interface implementation.
	    </para>

	    <para id="aimr">
	    The <indexterm><primary>Functions</primary><secondary>iconSet()</secondary></indexterm>
<function>iconSet()</> function returns the pixmap to
	    use in the toolbar to represent the custom widget. The
	    <indexterm><primary>Functions</primary><secondary>toolTip()</secondary></indexterm>
<function>toolTip()</> function returns the tooltip text and the
	    <indexterm><primary>Functions</primary><secondary>whatsThis()</secondary></indexterm>
<function>whatsThis()</> function returns the Whats This text. Copy
	    each of these functions changing the class name, feature
	    name and the string you return to suit your own widget
	    interface implementation.
	    </para>

	    <para id="ainb">
	    The <indexterm><primary>Functions</primary><secondary>isContainer()</secondary></indexterm>
<function>isContainer()</> function.
<programlisting>
bool CustomWidgetInterface::isContainer( const <emphasis role="bold">QString</>&amp; ) const
{
    return FALSE;
}
</programlisting>
	    Copy this function changing the class name to suit your
	    widget interface implementation. It should return <literal>TRUE</>
	    if your custom widget can contain other widgets, e.g. like
	    <indexterm><primary>QFrame</primary></indexterm>
<classname>QFrame</>, or <literal>FALSE</> if it must not contain other
	    widgets, e.g. like <indexterm><primary>QPushButton</primary></indexterm>
<classname>QPushButton</>.
	    </para>

	</sect3>

	<sect3><title>The Project File</>
	<para id="ainq">
	The project file for a plugin is somewhat different from an
	application's project file but in most cases you can use our
	project file changing only the <literal>HEADERS</> and <literal>SOURCES</>
	lines.
<example><title><filename>qt/tools/designer/examples/filechooser/plugin/plugin.pro</></><programlisting>
TEMPLATE        = lib
CONFIG+= qt warn_on release plugin
HEADERS                = plugin.h ../widget/filechooser.h
SOURCES                = plugin.cpp ../widget/filechooser.cpp
INTERFACES        =
DESTDIR                = ../../../../../../../plugins/designer
INCLUDEPATH     += $(<emphasis role="bold">QTDIR</>)/tools/designer/interfaces
TARGET                = filechooser

target.path=$$plugins.path
isEmpty(target.path):target.path=$$QT_PREFIX/plugins
INSTALLS += target
</programlisting></example>
	Change the <literal>HEADERS</> line to list your plugin's header file
	plus a header file for each of your widgets. Make the equivalent
	change for the <literal>SOURCES</> line. If you create a Makefile with
	<indexterm><primary>qmake</primary></indexterm>
<command>qmake</> and make the project the plugin will be created and
	placed in a directory where <emphasis>Qt Designer</> can find it. The next time you
	run <emphasis>Qt Designer</> it will detect your new plugin and load it
	automatically, displaying its icon in the toolbar you specified. 
	</para>
	</sect3>
<!-- TODO 
	<sect2><title>Considerations for Making Distributable Plugins</>
	<para id="aioj">
	</para>
	</sect2>
-->
    </sect2>

</sect1>


</chapter>
