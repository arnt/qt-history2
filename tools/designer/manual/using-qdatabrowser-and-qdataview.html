<HTML
><HEAD
><TITLE
>Using 
QDataBrowser and 
QDataView</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.57"><LINK
REL="HOME"
HREF="book1.html"><LINK
REL="UP"
TITLE="Creating Database Applications"
HREF="creating-database-applications.html"><LINK
REL="PREVIOUS"
TITLE="Using 
QDataTable"
HREF="using-qdatatable.html"><LINK
REL="NEXT"
TITLE="Customizing and Integrating Qt Designer"
HREF="c5889.html"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="using-qdatatable.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 6. Creating Database Applications</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="c5889.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="USING-QDATABROWSER-AND-QDATAVIEW"
>Using 
<TT
CLASS="CLASSNAME"
>QDataBrowser</TT
> and 
<TT
CLASS="CLASSNAME"
>QDataView</TT
></A
></H1
><P
><DIV
CLASS="FIGURE"
><A
NAME="AEN5256"
></A
><P
><B
>Figure 6-4. The Book Application's Edit Books Dialog</B
></P
><P
><IMG
SRC="images\book-dialog.png"></P
></DIV
></P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="DRILLING-DOWN-TO-A-FORM-WITH-QDATABROWSER"
>Drilling Down to a Form using 
<TT
CLASS="CLASSNAME"
>QDataBrowser</TT
></A
></H2
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="SETTING-UP-A-QDATABROWSER"
>Setting up a 
<TT
CLASS="CLASSNAME"
>QDataBrowser</TT
></A
></H3
><P
>	

	

	

	

	We will now create a new form to allow users to edit book
	records. Click the 

<SPAN
CLASS="GUIBUTTON"
>New</SPAN
> toolbar button, click the
	Dialog template from the 
New Form dialog and click <SPAN
CLASS="GUIBUTTON"
>OK</SPAN
>. Change
	the name of the form to EditBookForm and its caption to 'Edit
	Books'. Click the 

<SPAN
CLASS="GUIBUTTON"
>Save</SPAN
> toolbar button and call the
	file <TT
CLASS="FILENAME"
>editbook.ui</TT
>. Now that we have the form we can add a
	
<TT
CLASS="CLASSNAME"
>QDataBrowser</TT
> to show the book records.

	<P
></P
><OL
TYPE="1"
><LI
><P
>		Click the 

<SPAN
CLASS="GUIBUTTON"
>Data Browser</SPAN
> toolbar button, then
		click the form. The Data Browser Wizard will appear.
		</P
></LI
><LI
><P
>		The <I
CLASS="EMPHASIS"
>Database Connection and Table</I
> wizard
		page is used to set up a connection if one doesn't exist
		and to choose the table or view for the
		
<TT
CLASS="CLASSNAME"
>QDataBrowser</TT
>. (See <A
HREF="creating-database-applications.html#SETTING-UP-QT-DESIGNERS-CONNECTIONS"
>the section called <I
>Setting Up <I
CLASS="EMPHASIS"
>Qt Designer</I
>'s Connections</I
></A
> "Setting
		Up <I
CLASS="EMPHASIS"
>Qt Designer</I
>'s Connections".)
		</P
><P
>		Click the connection you wish to use, listed in the
		Connection list box, e.g. "(default)". The available
		tables and views will appear in the Table list
		box. Click the book table and then click the
		<SPAN
CLASS="GUIBUTTON"
>Next</SPAN
> button.
		</P
></LI
><LI
><P
>		The <I
CLASS="EMPHASIS"
>Displayed Fields</I
> wizard page provides a
		means of selecting which fields should be displayed in
		the 
<TT
CLASS="CLASSNAME"
>QDataBrowser</TT
> and in what order. By default
		all fields except the primary key (if there is one) are
		in the right hand Displayed Fields list box. The left
		and right blue arrow buttons can be used to move fields
		between the Displayed Fields and the Available Fields
		list boxes. The blue up and down arrow buttons are used
		to select the display order of the displayed fields.
		</P
><P
>		We don't want to see the authorid foreign key field on
		the form, so move it to the Available Fields list
		box. Also, move the title field to the top of the
		Displayed Fields list. Click the <SPAN
CLASS="GUIBUTTON"
>Next</SPAN
>
		button.
		</P
></LI
><LI
><P
>		The <I
CLASS="EMPHASIS"
>Navigation and Editing</I
> wizard page allows
		us to choose which navigation and editing buttons should
		appear on the form.
		</P
><P
>		We will accept the defaults and simply click the
		<SPAN
CLASS="GUIBUTTON"
>Next</SPAN
> button.
		</P
></LI
><LI
><P
>		The <I
CLASS="EMPHASIS"
>SQL</I
> wizard page is used to set the
		
<TT
CLASS="CLASSNAME"
>QDataBrowser</TT
>'s Filter and Sort properties. The
		Filter is an SQL <TT
CLASS="LITERAL"
>WHERE</TT
> clause (without the
		word 'WHERE'). For example, to only list books that
		cost less than 50 (of some currency, e.g. dollars), we
		would enter <TT
CLASS="LITERAL"
>price &lt; 50</TT
>. We will leave the
		filter empty. The Available Fields list box lists all
		the fields. The Sort By list box lists the fields that
		the 
<TT
CLASS="CLASSNAME"
>QDataBrowser</TT
> is to sort by and the
		direction of their sorting (ASCending or
		DESCending). The left and right blue arrows are used
		to move fields between the two list boxes. The up and
		down blue arrows move fields up and down within the
		Sort By list box. The ASC or DESC setting is changed
		with the sort order button.
		</P
><P
>		Move the title field into the Sort By list box and click
		<SPAN
CLASS="GUIBUTTON"
>Next</SPAN
>.
		</P
></LI
><LI
><P
>		The <I
CLASS="EMPHASIS"
>Layout</I
> wizard page is used to specify the
		initial layout of the form.
		</P
><P
>		Change the Number of Columns to 1, then click
		<SPAN
CLASS="GUIBUTTON"
>Next</SPAN
>. Now click <SPAN
CLASS="GUIBUTTON"
>Finish</SPAN
>.
		</P
></LI
><LI
><P
>		The 
<TT
CLASS="CLASSNAME"
>QDataBrowser</TT
> will now appear on the form.
		Resize the form to make it shorter. Click
		the 
<TT
CLASS="CLASSNAME"
>QDataBrowser</TT
> then click the <SPAN
CLASS="GUIBUTTON"
>Break
		Layout</SPAN
> toolbar button. Click the buttons then click
		the 

<SPAN
CLASS="GUIBUTTON"
>Break Layout</SPAN
> toolbar button. Add
		another button called 'PushButtonClose' with the text
		'&amp;Close' and place it to the right of the Delete button.
		</P
></LI
><LI
><P
>		
<B
CLASS="KEYCAP"
>Shift+Click</B
> the Insert, Update, Delete and Close
		buttons, then click the <SPAN
CLASS="GUIBUTTON"
>Lay Out
		Horizontally</SPAN
> toolbar button. Click the
		
<TT
CLASS="CLASSNAME"
>QDataBrowser</TT
>, then click the <SPAN
CLASS="GUIBUTTON"
>Lay Out
		in a Grid</SPAN
> toolbar button. Finally click the form and
		click the 

<SPAN
CLASS="GUIBUTTON"
>Lay Out Vertically</SPAN
> toolbar
		button. Now click the 
<TT
CLASS="CLASSNAME"
>QDataBrowser</TT
> and rename it
		'BookDataBrowser'.
		</P
></LI
><LI
><P
>		<I
CLASS="EMPHASIS"
>Qt Designer</I
> will generate the necessary code to make the
		browser operational (including generating the
		appropriate cursor, sort and filter code).
		</P
><P
>		For finer control over the form, we will be creating
		our own database cursor.  Therefore, set the
		BookDataBrowser's frameworkCode property to FALSE in
		the Properties window to prevent <I
CLASS="EMPHASIS"
>Qt Designer</I
> from generating
		redundant code for the cursor.
		</P
></LI
></OL
>
	</P
><TABLE
CLASS="SIDEBAR"
BORDER="1"
CELLPADDING="5"
><TR
><TD
><DIV
CLASS="SIDEBAR"
><A
NAME="AEN5397"
></A
><P
><B
>&#13;<TT
CLASS="CLASSNAME"
>QDataBrowser</TT
> User Interface Interaction</B
></P
><P
>	The user-interface behaviour for 
<TT
CLASS="CLASSNAME"
>QDataBrowser</TT
>s
	is created by connecting slots and signals. The slots provided are:
	    <P
></P
><UL
><LI
><P
>		
<TT
CLASS="FUNCTION"
>insert()</TT
>, 
<TT
CLASS="FUNCTION"
>update()</TT
> and 
<TT
CLASS="FUNCTION"
>del()</TT
> for editing;
		</P
></LI
><LI
><P
>		
<TT
CLASS="FUNCTION"
>first()</TT
>, 
<TT
CLASS="FUNCTION"
>next()</TT
>, 
<TT
CLASS="FUNCTION"
>prev()</TT
>, and 
<TT
CLASS="FUNCTION"
>last()</TT
> for
		navigation;
		</P
></LI
><LI
><P
>		
<TT
CLASS="FUNCTION"
>refresh()</TT
> to refresh the cursor from the database;
		</P
></LI
><LI
><P
>		
<TT
CLASS="FUNCTION"
>readFields()</TT
> to read data from the cursor's edit
		buffer and 
<TT
CLASS="FUNCTION"
>writeFields()</TT
> to write the form's data to
		the cursor's edit buffer;
		</P
></LI
><LI
><P
>		
<TT
CLASS="FUNCTION"
>clearValues()</TT
> to clear the form's values.
		</P
></LI
></UL
>
	</P
><P
>	If you use <I
CLASS="EMPHASIS"
>Qt Designer</I
>'s
	
<TT
CLASS="CLASSNAME"
>QDataBrowser</TT
> wizard you will be given the option of
	creating a default set of buttons for navigation and editing.
	The behaviour of these buttons is set up using the slots
	described above to provide the following functionality:
	    <P
></P
><UL
><LI
><P
>		<TT
CLASS="LITERAL"
>INSERT</TT
> is initiated by pressing the 
<B
CLASS="KEYCAP"
>Ins</B
> (Insert) button. The
		user moves between fields using 
<B
CLASS="KEYCAP"
>Tab</B
> and 
<B
CLASS="KEYCAP"
>Shift+Tab</B
>. If
		the user presses the Update button the <TT
CLASS="LITERAL"
>INSERT</TT
> will take
		place and the user will be taken to the record they have
		just inserted. If the user presses the Insert button
		(i.e. a second time) the <TT
CLASS="LITERAL"
>INSERT</TT
> will take place and a new
		insertion will be initiated. If autoEdit is TRUE the
		<TT
CLASS="LITERAL"
>INSERT</TT
> will take place if the user navigates to another
		record. <TT
CLASS="LITERAL"
>INSERT</TT
> is cancelled by pressing the
		
<B
CLASS="KEYCAP"
>Esc</B
>
		key or by pressing the 
<B
CLASS="KEYCAP"
>Del</B
> (Delete) button. If autoEdit is
		FALSE then navigating to another record also cancels the
		<TT
CLASS="LITERAL"
>INSERT</TT
>. Setting confirmInsert to TRUE will require the
		user to confirm each <TT
CLASS="LITERAL"
>INSERT</TT
>.
		</P
></LI
><LI
><P
>		<TT
CLASS="LITERAL"
>UPDATE</TT
> is automatically initiated whenever the user
		navigates to a record. An update will take place if the
		user presses the Update button. If autoEdit is TRUE the
		update will take place if the user navigates to another
		record. <TT
CLASS="LITERAL"
>UPDATE</TT
> is cancelled by pressing the
		
<B
CLASS="KEYCAP"
>Esc</B
>
		key or by pressing the 
<B
CLASS="KEYCAP"
>Del</B
> button. If autoEdit is
		FALSE then navigating to another record also cancels the
		<TT
CLASS="LITERAL"
>UPDATE</TT
>. Setting confirmUpdate to TRUE will require the
		user to confirm each <TT
CLASS="LITERAL"
>UPDATE</TT
>. </P
></LI
><LI
><P
>		<TT
CLASS="LITERAL"
>DELETE</TT
> is achieved by pressing the 
<B
CLASS="KEYCAP"
>Del</B
> button.
		Setting confirmDelete to TRUE will require the user to
		confirm each <TT
CLASS="LITERAL"
>DELETE</TT
>.
		</P
></LI
></UL
>
	</P
></DIV
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="PERFORMING-THE-DRILLDOWN"
>Performing the Drilldown</A
></H3
><P
>	

	

	We now have a working form for editing book records. We need to
	start the form when the user clicks our 'Edit Books' button, and to
	navigate to the record they have selected in the BookDataTable.
	We also need to provide a means of editing the foreign keys,
	e.g. authorid.

	<P
></P
><OL
TYPE="1"
><LI
><P
>		We need to make a new slot to connect the Edit Books'
		button's 
<TT
CLASS="FUNCTION"
>clicked()</TT
> signal to. Click on the Book
		form to make it <I
CLASS="EMPHASIS"
>Qt Designer</I
>'s active form. Invoke the 
		
Edit Slots
		dialog and create a new slot called <TT
CLASS="FUNCTION"
>editClicked()</TT
>. Now
		click the 

<SPAN
CLASS="GUIBUTTON"
>Connect Signals/Slots</SPAN
> toolbar button.
		Click the Edit Books button and drag to the form; release
		the mouse on the form. In the 
Edit Connections dialog
		connect the 
<TT
CLASS="FUNCTION"
>clicked()</TT
> signal to the
		<TT
CLASS="FUNCTION"
>editClicked()</TT
> slot. Click <SPAN
CLASS="GUIBUTTON"
>OK</SPAN
> to leave the
		dialog.
		</P
></LI
><LI
><P
>		

		In the
		Object Hierarchy window click Source and then click the
		<TT
CLASS="FUNCTION"
>editClicked</TT
> function. We need to change it to
		the following:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void BookForm::editClicked()
{
    EditBookForm *dialog = new EditBookForm( this, &quot;Edit Book Form&quot;, TRUE );
    <I
CLASS="EMPHASIS"
>QSqlCursor</I
> cur( &quot;book&quot; );
    dialog-&gt;BookDataBrowser-&gt;setCursor( &amp;cur );
    dialog-&gt;BookDataBrowser-&gt;setFilter( BookDataTable-&gt;filter() );
    dialog-&gt;BookDataBrowser-&gt;setSort(<I
CLASS="EMPHASIS"
>QSqlIndex::fromStringList</I
>( 
            BookDataTable-&gt;sort(), &amp;cur ) );
    dialog-&gt;BookDataBrowser-&gt;refresh();
    int i = BookDataTable-&gt;currentRow();
    if ( i == -1 ) i = 0;<I
CLASS="EMPHASIS"
> // Always use the first row</I
>
    dialog-&gt;BookDataBrowser-&gt;seek( i );
    dialog-&gt;exec();
    delete dialog;
    BookDataTable-&gt;refresh();
}</PRE
></TD
></TR
></TABLE
>
		</P
><P
> We create our dialog as before. We also create a
		cursor over the book table and set the dialog's
		
<TT
CLASS="CLASSNAME"
>QDataBrowser</TT
>, BookDataBrowser, to use this new
		cursor. We set the 
<TT
CLASS="CLASSNAME"
>QDataBrowser</TT
>'s filter and
		sort to those that applied to the main form's book
		
<TT
CLASS="CLASSNAME"
>QDataTable</TT
>. We refresh the
		
<TT
CLASS="CLASSNAME"
>QDataBrowser</TT
> and seek to the same record the
		user was viewing on the main form. Then we exec the
		dialog and delete it when the user has finished with
		it. Finally we update the BookDataTable in the main
		form to reflect any changes that were made in the
		dialog.  </P
></LI
><LI
><P
>		Because our code refers to a class declared in
		<TT
CLASS="FILENAME"
>editbook.h</TT
> and to a 
<TT
CLASS="CLASSNAME"
>QDataBrowser</TT
>
		we need to add two additional include files. Click on
		the BookForm, then click on the Source tab of the
		Object Hierarchy window. Right click the 'Includes (In
		Declaration)' item and click New. Type in
		<TT
CLASS="FILENAME"
>"editbook.h"</TT
>. Now add a second include,
		this time, <TT
CLASS="FILENAME"
>&lt;qdatabrowser.h&gt;</TT
>.
		</P
></LI
></OL
>
	</P
><P
>	Now when we navigate through the author and book records in the
	BookForm we can click the Edit Books button to launch our Edit Books
	dialog. Although the dialog supports <TT
CLASS="LITERAL"
>UPDATE</TT
>, <TT
CLASS="LITERAL"
>DELETE</TT
> and navigation over
	the book table, we cannot edit the foreign keys nor perform
	inserts. We will deal with insertion in the same way as we did
	with the 
<TT
CLASS="CLASSNAME"
>QDataTable</TT
>, then we will handle the foreign
	key relationship to author.
	</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="INSERTING-INTO-A-QDATABROWSER"
>Inserting into a 
<TT
CLASS="CLASSNAME"
>QDataBrowser</TT
></A
></H3
><P
>	We will create a slot to receive the Edit Books form's
	
<TT
CLASS="FUNCTION"
>primeInsert()</TT
> signal so that we can insert a unique
	primary key.

	<P
></P
><OL
TYPE="1"
><LI
><P
>		Click on the Edit Books form, then
		create a new Slot called <TT
CLASS="FUNCTION"
>primeInsertBook(QSqlRecord*)</TT
>.
		</P
><P
>		Click 
<SPAN
CLASS="GUIMENUITEM"
>Edit|Slots</SPAN
>, then click the
		<SPAN
CLASS="GUIBUTTON"
>New Slot</SPAN
> button and type the new slot name
		in the Slot Properties Slot edit box. Click <SPAN
CLASS="GUIBUTTON"
>OK</SPAN
>.
		</P
></LI
><LI
><P
>		Connect the BookDataBrowser's 
<TT
CLASS="FUNCTION"
>primeInsert()</TT
>
		signal to the <TT
CLASS="FUNCTION"
>primeInsertBook()</TT
> slot.
		</P
><P
>		Click the
		

<SPAN
CLASS="GUIBUTTON"
>Connect Signals/Slots</SPAN
> toolbar button, then
		click the BookDataBrowser and drag to the form; release
		the mouse on the form. Now click the
		
<TT
CLASS="FUNCTION"
>primeInsert()</TT
> signal and the
		primeInsertBook slot. Click <SPAN
CLASS="GUIBUTTON"
>OK</SPAN
>.
		</P
></LI
><LI
><P
>		In the
		Object Hierarchy window click Source and then click the
		<TT
CLASS="FUNCTION"
>primeInsertBook</TT
> slot. We need to change
		it to the following:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void EditBookForm::primeInsertBook( <I
CLASS="EMPHASIS"
>QSqlRecord</I
> * buffer )
{
    <I
CLASS="EMPHASIS"
>QSqlQuery</I
> query;  
    query.exec( &quot;UPDATE sequence SET sequence = sequence + 1 WHERE tablename='book';&quot; );  
    query.exec( &quot;SELECT sequence FROM sequence WHERE tablename='book';&quot; );  
    if ( query.next() ) {  
        buffer-&gt;setValue( &quot;id&quot;, query.value( 0 ) );  
    }     
}</PRE
></TD
></TR
></TABLE
>
		</P
></LI
><LI
><P
>		We will also tidy up the user interface slightly. Click
		the Update button and set its default property to True.
		Connect the Close button's 
<TT
CLASS="FUNCTION"
>clicked()</TT
> signal to the
		EditBookForm's 
<TT
CLASS="FUNCTION"
>accept()</TT
> slot.
		</P
></LI
></OL
>
	</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="HANDLING-FOREIGN-KEYS-IN-A-QDATABROWSER"
>Handling Foreign Keys in a 
<TT
CLASS="CLASSNAME"
>QDataBrowser</TT
></A
></H3
><P
>	

	

	Qt's SQL module provides two approaches to dealing with foreign
	keys. The most powerful and flexible is to subclass widgets and
	use property maps to relate the widgets to the database. This
	approach is described in the <A
HREF="http://doc.trolltech.com/sql.html#Custom_Editor_Widgets"
TARGET="_top"
>Qt
	SQL Module documentation</A
>, particularly the StatusPicker
	example. A simpler approach that can be taken wholly within <I
CLASS="EMPHASIS"
>Qt Designer</I
>
	is presented here.
	</P
><P
>	We will add a new field to the EditBookForm so that authors can
	be edited along with the title and price. Once we've handled the
	visual design we'll write the code to make it all work.

	<P
></P
><OL
TYPE="1"
><LI
><P
>	First we'll add the new widgets. Click the BookDataBrowser and
	click the 

<SPAN
CLASS="GUIBUTTON"
>Break Layout</SPAN
> toolbar button. Resize the form
	to make it larger and drag each set of buttons down to make some
	room below the title and price QLineEdits. Click the
	

<SPAN
CLASS="GUIBUTTON"
>Text Label</SPAN
> toolbar button and click on the form beneath
	the Price label. Click the 
Text Label and change its text to
	'Author'. Click the 

<SPAN
CLASS="GUIBUTTON"
>ComboBox</SPAN
> toolbar button and click
	on the form beneath the price QLineEdit. In the Property Window
	change the 
ComboBox's 
name to ComboBoxAuthor and
	change its 
sizePolicy 
hSizeType to Expanding.
	</P
></LI
><LI
><P
>	Now we'll lay out the dialog. 
<B
CLASS="KEYCAP"
>Shift+Click</B
> the Author label and
	the 
ComboBox then click the 

<SPAN
CLASS="GUIBUTTON"
>Lay Out Horizontally</SPAN
>
	toolbar button. Now click the BookDataBrowser and click the
	

<SPAN
CLASS="GUIBUTTON"
>Lay Out in a Grid</SPAN
> toolbar button.
	</P
></LI
></OL
>
	</P
><P
>	We need to write some code so that the 
ComboBox will be
	populated with author names and scroll to the current book's
	author. We also need to ensure that we put the author's id into
	the book table's authorid field when a book record is inserted
	or updated. We'll ensure the code is executed at the right time
	by putting it in slots and connecting signals to our slots.

	<P
></P
><OL
TYPE="1"
><LI
><P
>	Create two new slots called 
	<TT
CLASS="FUNCTION"
>beforeUpdateBook(QSqlRecord *buffer)</TT
> and 
	<TT
CLASS="FUNCTION"
>primeUpdateBook(QSqlRecord *buffer)</TT
>. (Click
	
<SPAN
CLASS="GUIMENUITEM"
>Edit|Slots</SPAN
>, then in the 
Edit Slots dialog click New Slot
	and enter the first new slot. Click New Slot again and enter the
	second slot then click <SPAN
CLASS="GUIBUTTON"
>OK</SPAN
>.)
	</P
></LI
><LI
><P
>	When the user navigates through the dialog, each time they move
	to a new record, a 
<TT
CLASS="FUNCTION"
>primeUpdate()</TT
> signal is emitted. We connect
	to this so that we can update the 
ComboBox's display. Just
	before a record is updated or inserted into the database a
	
<TT
CLASS="FUNCTION"
>beforeUpdate()</TT
> or 
<TT
CLASS="FUNCTION"
>beforeInsert()</TT
> signal is emitted. We
	connect our <TT
CLASS="FUNCTION"
>beforeUpdateBook()</TT
> slot to both these signals so
	that we can ensure that the book's authorid field is correctly
	populated.
	</P
><P
>	Click the BookDataBrowser and drag the mouse to the form;
	release the mouse and the 
Edit Connections dialog will appear.
	Connect the 
<TT
CLASS="FUNCTION"
>beforeUpdate()</TT
> signal to our
	<TT
CLASS="FUNCTION"
>beforeUpdateBook()</TT
> slot. Connect the 
<TT
CLASS="FUNCTION"
>beforeInsert()</TT
> signal
	to our <TT
CLASS="FUNCTION"
>beforeUpdateBook()</TT
> slot. Finally connect the
	
<TT
CLASS="FUNCTION"
>primeUpdate()</TT
> signal to our <TT
CLASS="FUNCTION"
>primeUpdateBook()</TT
> slot.
	</P
></LI
><LI
><P
>	All that remains is to write the underlying code. All the
	code snippets are taken from
	<TT
CLASS="FILENAME"
>qt/tools/designer/examples/book/book7/editbook.ui</TT
>.
	    <P
></P
><OL
TYPE="1"
><LI
><P
>	    We start with the 
<TT
CLASS="FUNCTION"
>init()</TT
> function; this is called after
	    the dialog is constructed and we will use it to populate the
	    
ComboBox with author names.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void EditBookForm::init()
{
    <I
CLASS="EMPHASIS"
>QSqlQuery</I
> query( &quot;SELECT surname FROM author ORDER BY surname;&quot; );    
    while ( query.next() ) 
        ComboBoxAuthor-&gt;insertItem( query.value( 0 ).toString()); 
}</PRE
></TD
></TR
></TABLE
>
	    Here we execute a query to get a list of author names and
	    insert each one into the 
ComboBox.
	    </P
></LI
><LI
><P
>	    We next write the code which will be executed just before a
	    record is updated (or inserted) in the database.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void EditBookForm::beforeUpdateBook( <I
CLASS="EMPHASIS"
>QSqlRecord</I
> * buffer )
{
    <I
CLASS="EMPHASIS"
>QSqlQuery</I
> query( &quot;SELECT id FROM author WHERE surname ='&quot; + 
        ComboBoxAuthor-&gt;currentText() + &quot;';&quot; );
    if ( query.next() )
        buffer-&gt;setValue( &quot;authorid&quot;, query.value( 0 ) );
}</PRE
></TD
></TR
></TABLE
>
	    We look up the id of the 
ComboBox's current author
	    and place it in the update (or insert) buffer's authorid
	    field.
	    </P
></LI
><LI
><P
>	    As the user navigates through the records we ensure
	    that the 
ComboBox reflects the current author.  
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void EditBookForm::primeUpdateBook( <I
CLASS="EMPHASIS"
>QSqlRecord</I
> * buffer )
{
   <I
CLASS="EMPHASIS"
> // Who is this book's author?</I
>
    <I
CLASS="EMPHASIS"
>QSqlQuery</I
> query( &quot;SELECT surname FROM author WHERE id='&quot; +  
        buffer-&gt;value( &quot;authorid&quot; ).toString() + &quot;';&quot; ); 
    <I
CLASS="EMPHASIS"
>QString</I
> author = &quot;&quot;;    
    if ( query.next() )
        author = query.value( 0 ).toString();
   <I
CLASS="EMPHASIS"
> // Set the ComboBox to the right author</I
>
    for ( int i = 0; i &lt; ComboBoxAuthor-&gt;count(); i++ ) {
        if ( ComboBoxAuthor-&gt;text( i ) == author ) {
            ComboBoxAuthor-&gt;setCurrentItem( i ) ;
            break;
        }
    }
}</PRE
></TD
></TR
></TABLE
>
	    Firstly we look up the book's author and secondly we iterate
	    through the 
ComboBox's items until we find the author and
	    set the 
ComboBox's current item to the matching author.
	    </P
></LI
></OL
>
	</P
></LI
></OL
>
    </P
><P
>    If the author name has changed or been deleted the query will
    fail and no author id will be inserted into the buffer causing the <TT
CLASS="LITERAL"
>INSERT</TT
>
    to fail.  An alternative is to record
    the author id's as we populate the 
ComboBox and store them in a
    
<TT
CLASS="CLASSNAME"
>QMap</TT
> which we can then look up as required. This approach
    requires changes to the 
<TT
CLASS="FUNCTION"
>init()</TT
>, <TT
CLASS="FUNCTION"
>beforeUpdateBook()</TT
> and
    <TT
CLASS="FUNCTION"
>primeInsertBook()</TT
> functions and the addition of a new function,
    <TT
CLASS="FUNCTION"
>mapAuthor()</TT
>.
    The relevant code from
    <TT
CLASS="FILENAME"
>qt/tools/designer/examples/book/book8/editbook.ui</TT
> is shown below.

	    <P
></P
><OL
TYPE="1"
><LI
><P
>	    First we need to create a class variable to map author names
	    to author id's. Click in the Source tab of the Object
	    Hierarchy, then right click the Class Variables item and
	    click 
<SPAN
CLASS="GUIMENUITEM"
>New</SPAN
>. Type in
	    'QMap&lt;QString,int&gt; authorMap;'.
	    </P
></LI
><LI
><P
>	    We now record the author id's in the 
<TT
CLASS="FUNCTION"
>init()</TT
> function.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void EditBookForm::init()
{
    <I
CLASS="EMPHASIS"
>QSqlQuery</I
> query( &quot;SELECT surname, id FROM author ORDER BY surname;&quot; );    
    while ( query.next() ) {
        ComboBoxAuthor-&gt;insertItem( query.value( 0 ).toString() ); 
        int id = query.value( 1 ).toInt();
        mapAuthor( query.value( 0 ).toString(), id, TRUE );
    }
}</PRE
></TD
></TR
></TABLE
>
	    After inserting each author's name into the 
ComboBox we
	    populate a 
<TT
CLASS="CLASSNAME"
>QMap</TT
> with the author's name and id.
	    </P
></LI
><LI
><P
>	    Instead of looking up the author's id in the database we
	    look it up in the 
<TT
CLASS="CLASSNAME"
>QMap</TT
>.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void EditBookForm::beforeUpdateBook( <I
CLASS="EMPHASIS"
>QSqlRecord</I
> * buffer )
{
    int id;
    mapAuthor( ComboBoxAuthor-&gt;currentText(), id, FALSE );
    buffer-&gt;setValue( &quot;authorid&quot;, id );
}</PRE
></TD
></TR
></TABLE
>
	    </P
></LI
><LI
><P
>	    We use a single function for storing author id's and
	    returning them so that we can use a static data structure.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void EditBookForm::mapAuthor( const <I
CLASS="EMPHASIS"
>QString</I
> &amp; name, int &amp; id, bool populate )
{
    if ( populate ) 
        authorMap[ name ] = id;
    else
        id = authorMap[ name ];
}</PRE
></TD
></TR
></TABLE
>
	    If the populate flag is TRUE, we store the author's name and
	    id in the 
<TT
CLASS="CLASSNAME"
>QMap</TT
>, otherwise we look up the given
	    author name and set id appropriately.
	    </P
></LI
></OL
>
    </P
><P
>&#13;


Another approach which is especially useful if the same foreign key
lookups are required in different parts of the application is to
subclass a cursor and use this for our lookups. This is described in the
<A
HREF="http://doc.trolltech.com/sql.html"
TARGET="_top"
>Qt SQL Module
documentation</A
>, particulary the section on subclassing

<TT
CLASS="CLASSNAME"
>QSqlCursor</TT
>.</P
><P
>The 'book' example demonstrates the basic techniques needed for SQL
programming with Qt. Additional information on the Qt SQL classes,
especially the 
<TT
CLASS="CLASSNAME"
>QSqlQuery</TT
> and 
<TT
CLASS="CLASSNAME"
>QSqlCursor</TT
> classes is
provided in the <A
HREF="http://doc.trolltech.com/sql.html"
TARGET="_top"
>Qt SQL
Module documentation</A
>.</P
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="using-qdatatable.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="c5889.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Using 
<TT
CLASS="CLASSNAME"
>QDataTable</TT
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="creating-database-applications.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Customizing and Integrating Qt Designer</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>