<HTML
><HEAD
><TITLE
>Adding Functionality To The Push Buttons</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.52"><LINK
REL="HOME"
HREF="book1.html"><LINK
REL="UP"
TITLE="Tutorial: Adding Additional Functionality To A Dialog By
	  Subclassing"
HREF="c291.html"><LINK
REL="PREVIOUS"
TITLE="Tutorial: Adding Additional Functionality To A Dialog By
	  Subclassing"
HREF="c291.html"><LINK
REL="NEXT"
TITLE="Initializing The State Of Widgets In The Form"
HREF="x442.html"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="c291.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 3. Tutorial: Adding Additional Functionality To A Dialog By
	  Subclassing</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x442.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AEN326"
>Adding Functionality To The Push Buttons</A
></H1
><P
>Responding to user interaction with Qt widgets is mostly
		done by connecting <I
CLASS="EMPHASIS"
>signals</I
> that these
		widgets <I
CLASS="EMPHASIS"
>emit</I
> to
		<I
CLASS="EMPHASIS"
>slots</I
>. If you have never heard about
		signals and slots before, please check at least the sidebar or
		even better read the Qt Tutorial or <I
CLASS="EMPHASIS"
>Programming with
		Qt</I
>.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Signals And Slots: </B
>The connection between user interaction and program
		  functionality is done via so-called signals and slots in
		  Qt. A widget emits a slot when something interesting
		  happens. What this means depends on the widget; for a push
		  button, one of the signals is the
		  <TT
CLASS="LITERAL"
>clicked()</TT
> signal, which is emitted when
		  the user clicks the push button. Other widgets have other
		  signals.</P
><P
>Slots are just ordinary C++ methods that are marked as
		  slots in the class declaration. Any C++ method can be a
		  slot. Methods that are declared as slots can still be called
		  the ordinary way.</P
><P
>The method <TT
CLASS="LITERAL"
>QObject::connect()</TT
> ties
		  signals and slots together. When a widget emits a signal,
		  the Qt runtime system checks whether any slots are connected
		  to this signal and calls these slots.</P
><P
>Not all the signals need the be connected to a slot,
		  in fact, in most applications, only very few signals
		  are. Likewise, there does not have to be a signal connected
		  to each slot; the slot can still be called the ordinary
		  way.</P
><P
>It is a part of the class declaration of any class
		  which signals and slots it emits. For the Qt classes, this
		  is thoroughly documented in the reference documentation, for
		  third-party classes, please see the respective
		  manufacturer's documentation.</P
></BLOCKQUOTE
></DIV
><P
>The first thing we will do now is connect the
		  <SPAN
CLASS="GUILABEL"
>Cancel</SPAN
> button's
		  <TT
CLASS="LITERAL"
>clicked()</TT
> signal which is emitted when
		  this button is clicked to the dialog's
		  <TT
CLASS="LITERAL"
>reject()</TT
> method which closes the dialog
		  and sets a negative return code. To do this, start the
		  <I
CLASS="EMPHASIS"
>connection tool</I
> by hitting
		  <B
CLASS="KEYCAP"
>F3</B
>, choosing
		  <SPAN
CLASS="GUIMENU"
>Edit/Connections</SPAN
> from the menu or
		  clicking on the connections icon on the toolbar (see <A
HREF="x326.html#QT-DESIGNER-ICON-CONNECTIONS"
>Figure 3-2</A
>). As soon as you
		  have done this, click on the <SPAN
CLASS="GUILABEL"
>Cancel</SPAN
>
		  button on your form, hold the mouse button pressed and move
		  the mouse cursor to somewhere on the background of the
		  form. Release it there. With this gesture, you indicate that
		  you want to create a connection from the
		  <SPAN
CLASS="GUILABEL"
>Cancel</SPAN
> button to the form as a
		  whole. Pink frames show which widgets you have currently
		  selected while you move the mouse.</P
><DIV
CLASS="FIGURE"
><A
NAME="QT-DESIGNER-ICON-CONNECTIONS"
></A
><P
><B
>Figure 3-2. The connections icon</B
></P
><P
><IMG
SRC="figures/connecttool.png"></P
></DIV
><P
>Once you have released the mouse button, the
		  <SPAN
CLASS="GUILABEL"
>Connections</SPAN
> dialog opens (see <A
HREF="x326.html#QT-DESIGNER-FIG-CONNECTIONS"
>Figure 3-3</A
>). In this dialog,
		  select <TT
CLASS="LITERAL"
>clicked()</TT
> in the
		  <SPAN
CLASS="GUILABEL"
>Cancel</SPAN
> button's signals list to the
		  left and <TT
CLASS="LITERAL"
>reject()</TT
> in the dialogs' slot
		  list to the right. The connection will show in the list in
		  the lower half of the dialog.</P
><DIV
CLASS="FIGURE"
><A
NAME="QT-DESIGNER-FIG-CONNECTIONS"
></A
><P
><B
>Figure 3-3. The Connections dialog</B
></P
><P
><IMG
SRC="figures/connections.png"></P
></DIV
><P
>Close the dialog. Your first signal-slot-connection is
		  in place, and you did not even have to write a single line
		  of code yet.</P
><P
>Now for the <SPAN
CLASS="GUILABEL"
>OK</SPAN
> button. We want
		  this button to close the dialog with a positive return code,
		  i.e., call the dialog's <TT
CLASS="LITERAL"
>accept()</TT
> slot,
		  but we also want to show the aforementioned message box. In
		  order to do the latter, we need to create our own
		  slot.</P
><P
>To do this, select
		  <SPAN
CLASS="GUIMENU"
>Edit/Slots...</SPAN
> 
		  from the menu. This shows the <SPAN
CLASS="GUILABEL"
>Slots</SPAN
>
		  dialog (see <A
HREF="x326.html#QT-DESIGNER-FIG-SLOTS"
>Figure 3-4</A
>). Click
		  on the <SPAN
CLASS="GUILABEL"
>Add</SPAN
> button to add a slot. A slot
		  is added with the default name
		  <TT
CLASS="LITERAL"
>new_slot()</TT
>. Go to the edit field
		  labelled <SPAN
CLASS="GUILABEL"
>Slot:</SPAN
> in the <SPAN
CLASS="GUILABEL"
>Slot
		  properties</SPAN
> box and change the name to
		  <TT
CLASS="LITERAL"
>slotSendOrder()</TT
>.<A
NAME="AEN379"
HREF="#FTN.AEN379"
>[1]</A
>. Leave everything else as it
			  is and click <SPAN
CLASS="GUILABEL"
>OK</SPAN
>.</P
><DIV
CLASS="FIGURE"
><A
NAME="QT-DESIGNER-FIG-SLOTS"
></A
><P
><B
>Figure 3-4. The Slots dialog</B
></P
><P
><IMG
SRC="figures/slots.png"></P
></DIV
><P
>Now start the connection tool again, but this time
		  connect the <SPAN
CLASS="GUILABEL"
>OK</SPAN
> button to the
		  dialog. When the <SPAN
CLASS="GUILABEL"
>Connections</SPAN
> dialog
		  opens again, you can see not only the predefined slots, but
		  also your newly created slot
		  <TT
CLASS="LITERAL"
>sendOrder()</TT
>. Click on the
		  <TT
CLASS="LITERAL"
>clicked()</TT
> signal first and then on the
		  <TT
CLASS="LITERAL"
>sendOrder()</TT
> slot so that the connection
		  appears in the lower half. Close the
		  <SPAN
CLASS="GUILABEL"
>Connections</SPAN
> dialog.</P
><P
>When the user now clicks the <SPAN
CLASS="GUILABEL"
>OK</SPAN
>
		  button, both the <TT
CLASS="LITERAL"
>accept()</TT
> slot to close
		  the dialog and the <TT
CLASS="LITERAL"
>sendOrder()</TT
> slot are
		  invoked. But this time we do not get away as easily as with
		  the <SPAN
CLASS="GUILABEL"
>Cancel</SPAN
> button: We still have to
		  implement the <TT
CLASS="LITERAL"
>sendOrder()</TT
> slot.</P
><P
>But wait a minute, this looks like we have run into a
		  problem: In order to implement a slot, we need to change the
		  source code, but you just learned at the beginning of this
		  tutorial that you should not edit the source code generated
		  by <B
CLASS="COMMAND"
>uic</B
>.</P
><P
>That's true, and to solve this problem, we need to
		  inherit a new class from our <TT
CLASS="LITERAL"
>PizzaEntry</TT
>
		  class where we can implement the new slot. This sounds like
		  somewhat of a bother now, but you will get used to
		  it. The whole thing works because Qt Designer declares all
		  user-defined slots as virtual and provides an empty
		  implementation for them. At runtime, then, you do not create
		  an instance of the <B
CLASS="COMMAND"
>uic</B
>-generated class
		  but an instance of your own implementation class
		  instead. When the <SPAN
CLASS="GUILABEL"
>OK</SPAN
> button is clicked,
		  your own virtual method will be called instead of the
		  generated empty one. If this sounds like black magic to you,
		  you can either simply believe that this works, or
		  (recommended) read in any good C++ book about virtual
		  methods and polymorphy.</P
><P
>Let's call our inherited class
		  <TT
CLASS="LITERAL"
>PizzaEntryImpl</TT
>, because we will put some
		  implementation in there. For other naming suggestions,
		  please see the sidebar &#8220;The Name Of The
		  Game&#8221;.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>The Name Of The Game: </B
>In a larger project, you will have a possibly large
		  number of dialog (or other) classes generated by Qt Designer
		  and <B
CLASS="COMMAND"
>uic</B
> as well as implementation classes
		  for many (if not all) of these dialogs. In such a situation,
		  it is best to think of a smart naming scheme right away in
		  order to avoid confusion later.</P
><P
>There two demands on such a naming scheme: It should
		  be easy, obvious, and unique to get from the generated
		  class' name to the implementation class name or the other
		  way around, and the class names should not be too cumbersome
		  to type. One naming scheme that fulfills these conditions is
		  the one used in this tutorial: The generated dialog class
		  gets the name that seems &#8220;natural&#8221; (like
		  <TT
CLASS="LITERAL"
>PizzaEntry</TT
> in this case), the
		  implementation class the same name with
		  <TT
CLASS="LITERAL"
>Impl</TT
> attached.</P
><P
>Another option is the one chosen by the TrollTech
		  developers: Choose the &#8220;natural&#8221; name for the
		  implementation class and append <TT
CLASS="LITERAL"
>Base</TT
> to
		  this name for the generated class.</P
><P
>Both schemes described here and many others are
		  equally well. The important thing is that you pick one
		  consistent scheme and stick to it throughout your
		  project.</P
></BLOCKQUOTE
></DIV
><P
>All we need in this implementation is class is an empty
		constructor so that we can pass the usual parameters, and the
		slot we want to implement. Here's
		what the header file <TT
CLASS="FILENAME"
>PizzaEntryImpl.h</TT
> for
		our implementation class <TT
CLASS="LITERAL"
>PizzaEntryImpl</TT
>
		looks like:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>#ifndef PIZZAENTRYIMPL_H
#define PIZZAENTRYIMPL_H

#include "PizzaEntry.h"

class PizzaEntryImpl : public PizzaEntry
{
  Q_OBJECT

public:
    PizzaEntryImpl( QWidget* parent = 0, const char* name = 0, 
					 bool modal = FALSE, WFlags f = 0 ) :
	  PizzaEntry( parent, name, modal, f ) {}

public slots:
	virtual void sendOrder();
};
#endif</PRE
></TD
></TR
></TABLE
><P
>The implementation file is even simpler, since all we
		want to do for now is showing a message box that tells the
		user that his order has been sent. In a real pizza order
		application, you would of course package the data somehow and
		send them over the network. Here is
		<TT
CLASS="FILENAME"
>PizzaEntryImpl.cpp</TT
>:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>#include "PizzaEntryImpl.h"

#include &#60;qmessagebox.h&#62;

void PizzaEntryImpl::sendOrder()
{
  QMessageBox::information( this, "Pizza Entry Information",
							"Your order has been sent. Your pizza will arrive in 30-45 minutes", QMessageBox::Ok );
}</PRE
></TD
></TR
></TABLE
><P
>Finally, since by using the slots
		<TT
CLASS="LITERAL"
>accept()</TT
> and <TT
CLASS="LITERAL"
>reject()</TT
>,
		we have committed to using the dialog as a modal dialog
		(instead of as a modeless dialog like in the previous
		tutorial), which means that we need to stretch the notion of
		&#8220;clean Qt programming&#8221; a bit in order to keep our
		test bed simple. Usually, you start the event processing by
		calling <TT
CLASS="LITERAL"
>QApplication::exec()</TT
>, but since
		modal dialogs have an event loop of their own, we can get away
		with just calling <TT
CLASS="LITERAL"
>exec()</TT
> on our dialog
		class. Here is the new file
		<TT
CLASS="FILENAME"
>PizzaEntryTest.cpp</TT
>:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>#include &#60;qapplication.h&#62;
#include "PizzaEntryImpl.h"

int main( int argc, char* argv[] )
{
  QApplication app( argc, argv );

  PizzaEntryImpl* pizzaEntry = new PizzaEntryImpl( 0, "pizza entry", true);
  app.setMainWidget( pizzaEntry );
  int ret = pizzaEntry-&#62;exec();
  delete pizzaEntry;
  return ret;
}&#13;</PRE
></TD
></TR
></TABLE
><P
>We should add that the <B
CLASS="COMMAND"
>uic</B
> command has a
special mode for generating empty skeletons for classes inheriting
from the Designer-generated classes. You will learn in 
how to use this feature, but for now, our application is still small
enough that we can easily write everything by hand.</P
><P
>That's all for now. You can now save your dialog in Qt
		Designer, compile and run it. Here are the command lines you
		need. For Unix with the <B
CLASS="COMMAND"
>g++</B
> compiler:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>uic -o PizzaEntry.h pizza.ui
uic -i PizzaEntry.h -o PizzaEntry.cpp pizza.ui
moc -o moc_PizzaEntry.cpp PizzaEntry.h
moc -o moc_PizzaEntryImpl.cpp PizzaEntryImpl.h
moc -o moc_PizzaEntryTest.cpp PizzaEntryTest.cpp
g++ -I$QTDIR/include PizzaEntry.cpp PizzaEntryTest.cpp \
	PizzaEntryImpl.cpp moc_PizzaEntry.cp moc_PizzaEntryImpl.cpp \ 
	-L$QTDIR/lib -lqt</PRE
></TD
></TR
></TABLE
><P
>and for Windows with Visual C++:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
></PRE
></TD
></TR
></TABLE
><P
>Now run the program and see what
		happens when you click either <SPAN
CLASS="GUILABEL"
>Cancel</SPAN
> or
		<SPAN
CLASS="GUILABEL"
>OK</SPAN
>.</P
></DIV
><H3
CLASS="FOOTNOTES"
>Notes</H3
><TABLE
BORDER="0"
CLASS="FOOTNOTES"
WIDTH="100%"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN379"
HREF="x326.html#AEN379"
>[1]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>It is by no means a requirement that names of
			  slots start with <TT
CLASS="LITERAL"
>slot</TT
> but many people
			  like to do this because it makes the purpose more
			  explicit.</P
></TD
></TR
></TABLE
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="c291.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x442.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Tutorial: Adding Additional Functionality To A Dialog By
	  Subclassing</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c291.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Initializing The State Of Widgets In The Form</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>