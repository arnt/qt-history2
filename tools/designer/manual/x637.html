<HTML
><HEAD
><TITLE
>Converting the Design into an Executable Application</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.57"><LINK
REL="HOME"
HREF="book1.html"><LINK
REL="UP"
TITLE="Creating Main Windows with Actions, Toolbars and Menus"
HREF="main-windows.html"><LINK
REL="PREVIOUS"
TITLE="Creating Main Windows with Actions, Toolbars and Menus"
HREF="main-windows.html"><LINK
REL="NEXT"
TITLE="Using Qt Designer's Value Editors"
HREF="c733.html"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="main-windows.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 2. Creating Main Windows with Actions, Toolbars and Menus</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="c733.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AEN637"
>Converting the Design into an Executable Application</A
></H1
><P
>&#13;    We've built the user interface through <I
CLASS="EMPHASIS"
>Qt Designer</I
> and connected those slots
    that provided sufficient default functionality. The last steps are to
    code the slots that require customization and then to create
    <TT
CLASS="FILENAME"
>main.cpp</TT
> so that we can compile and build our application.
    </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN642"
>Implementing the Main Window's Functionality</A
></H2
><P
>&#13;	When the user starts the richedit application we want the focus
	to be in the textEdit widget so we'll add one line of code to
	the <TT
CLASS="FUNCTION"
>init()</TT
> function to achieve this. (All the code snippets
	are from <TT
CLASS="FILENAME"
>eg/richedit/richedit.cpp</TT
> which is generated by
	<B
CLASS="COMMAND"
>uic</B
> from <TT
CLASS="FILENAME"
>richedit.ui</TT
>.)
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>    textEdit-&gt;setFocus();  </PRE
></TD
></TR
></TABLE
>
	</P
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN650"
>New Files and Loading and Saving Existing 
	    Files</A
></H3
><P
>&#13;	    The code for these tasks is straightforward. When the user
	    clicks <SPAN
CLASS="GUIMENUITEM"
>File|New</SPAN
> we check to see if there are
	    unsaved changes in the existing text and give them the
	    opportunity to save, continue without saving or cancel the
	    operation. When the user opts to open an existing file or
	    exit the application we perform the same check and offer
	    them the same choices. 	    
	    </P
><P
>&#13;<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void EditorForm::fileNew()
{
    if ( saveAndContinue( &quot;New&quot; ) )
            textEdit-&gt;clear();
}</PRE
></TD
></TR
></TABLE
>
	    The <TT
CLASS="FUNCTION"
>fileNew()</TT
> function clears the text and the filename.
	    </P
><P
>&#13;<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void EditorForm::fileOpen()
{
    if ( saveAndContinue( &quot;Open&quot; ) ) {
            <I
CLASS="EMPHASIS"
>QString</I
> fn( <I
CLASS="EMPHASIS"
>QFileDialog::getOpenFileName</I
>( 
                        <I
CLASS="EMPHASIS"
>QString::null</I
>, 
                        &quot;Rich Text Files (*.htm*)&quot;, this ) );   
        if ( !fn.isEmpty() ) {
            fileName = fn;
            <I
CLASS="EMPHASIS"
>QFile</I
> file( fileName );
            if ( file.open( IO_ReadOnly ) ) {
                <I
CLASS="EMPHASIS"
>QTextStream</I
> ts( &amp;file );
                textEdit-&gt;setText( ts.read() );
            }
        }
    }
}</PRE
></TD
></TR
></TABLE
>
	    The <TT
CLASS="FUNCTION"
>fileOpen()</TT
> function asks the user to choose a file
	    using <TT
CLASS="FUNCTION"
>QFileDialog::getOpenFileName()</TT
>. If they 
	    choose a file we set the fileName member to its name, open
	    it and read its contents directly into the text edit via a
	    text stream. 
	    </P
><P
>&#13;<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void EditorForm::fileSave()
{
    if ( fileName.isEmpty() ) {
        fileSaveAs();
    } else {
        <I
CLASS="EMPHASIS"
>QFile</I
> f( fileName );
        if ( f.open( IO_WriteOnly ) ) {
            <I
CLASS="EMPHASIS"
>QTextStream</I
> ts( &amp;f );
            ts &lt;&lt; textEdit-&gt;text();
            textEdit-&gt;setModified( FALSE );
        }
    }
}</PRE
></TD
></TR
></TABLE
>
	    If there is no current file name we call
	    <TT
CLASS="FUNCTION"
>fileSaveAs()</TT
> which will prompt for a
	    file name and if a file name is given calls
	    <TT
CLASS="FUNCTION"
>fileSave()</TT
>. If we have a file name we
	    open a file and write the text from the text edit into the
	    file via a text stream. We also set the text edit's modified
	    property to FALSE.
	    </P
><P
>&#13;<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void EditorForm::fileSaveAs()
{
    <I
CLASS="EMPHASIS"
>QString</I
> fn = <I
CLASS="EMPHASIS"
>QFileDialog::getSaveFileName</I
>( 
                                    &quot;&quot;, &quot;Rich Text Files (*.htm*)&quot;, this );
    if ( !fn.isEmpty() ) {
        fileName = fn;
        fileSave();
    }
}</PRE
></TD
></TR
></TABLE
>
	    The <TT
CLASS="FUNCTION"
>fileSaveAs</TT
> function prompts the user for a file
	    name and if they give a file name, saves the text to the
	    file by calling <TT
CLASS="FUNCTION"
>fileSave()</TT
>.
	    </P
><P
>&#13;<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void EditorForm::fileExit()
{
    if ( saveAndContinue( &quot;Exit&quot; ) )
        qApp-&gt;exit();
}</PRE
></TD
></TR
></TABLE
>
	    When we exit the application we must perform the same check
	    for unsaved changes as we've done in the preceding
	    functions, so we've included the <TT
CLASS="FUNCTION"
>fileExit</TT
> function's
	    code here.
	    </P
><P
>&#13;<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>int EditorForm::saveAndContinue( const <I
CLASS="EMPHASIS"
>QString</I
> &amp; action )
{
    int continueAction = 1;
    
    if ( textEdit-&gt;isModified() ) {  
        switch( <I
CLASS="EMPHASIS"
>QMessageBox::information</I
>(     
                this, &quot;Rich Edit&quot;,   
                &quot;The document contains unsaved changes.\n&quot;   
                &quot;Do you want to save the changes?&quot;,   
                &quot;&amp;Save&quot;, &quot;&amp;Don't Save&quot;, &quot;&amp;Cancel &quot; + action,   
                0,<I
CLASS="EMPHASIS"
> // Enter == button 0   </I
>
                2 ) ) {<I
CLASS="EMPHASIS"
> // Escape == button 2   </I
>
        case 0:<I
CLASS="EMPHASIS"
> // Save; continue  </I
>
                     fileSave();  
                break;   
            case 1:<I
CLASS="EMPHASIS"
> // Do not save; continue</I
>
                break;   
            case 2:<I
CLASS="EMPHASIS"
> // Cancel</I
>
                continueAction = 0;
                break;  
            }          
    }  
    
    return continueAction;
}</PRE
></TD
></TR
></TABLE
>
	    The <TT
CLASS="FUNCTION"
>saveAndContinue</TT
> function is included for
	    completeness. 	    
	    </P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="ALIGNING-TEXT"
>Aligning Text</A
></H3
><P
>&#13;<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void EditorForm::changeAlignment( <I
CLASS="EMPHASIS"
>QAction</I
> * align )
{
    if ( align == leftAlignAction ) 
        textEdit-&gt;setAlignment( Qt::AlignLeft );
    else if ( align == rightAlignAction )
        textEdit-&gt;setAlignment( Qt::AlignRight );
    else if ( align == centerAlignAction )
        textEdit-&gt;setAlignment( Qt::AlignCenter );
}</PRE
></TD
></TR
></TABLE
>
	    We compare the chosen alignment action's pointer to the
	    the pointers stored in the form and if we get a match set
	    the appropriate alignment in the textEdit widget.
	    </P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="CHANGING-FONTS"
>Changing Fonts</A
></H3
><P
>&#13;	    We've already connected the fontComboBox's <TT
CLASS="FUNCTION"
>activated()</TT
>
	    signal to the textEdit's <TT
CLASS="FUNCTION"
>setFamily()</TT
> slot so we just
	    have to populate the combo box with the font names when we
	    call <TT
CLASS="FUNCTION"
>init()</TT
>.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void EditorForm::init()
{
    textEdit-&gt;setFocus();  
 
    <I
CLASS="EMPHASIS"
>QFontDatabase</I
> fonts;
    fontComboBox-&gt;insertStringList( fonts.families() );
    <I
CLASS="EMPHASIS"
>QString</I
> font = textEdit-&gt;family();
    font = font.lower();
    for ( int i = 0 ; i &lt; fontComboBox-&gt;count(); i++ ) {
        if ( font == fontComboBox-&gt;text( i ) ) {
            fontComboBox-&gt;setCurrentItem( i );
            break;
        }
    }
}</PRE
></TD
></TR
></TABLE
>
	    The first line sets the focus as we've already mentioned. We
	    then create a <TT
CLASS="CLASSNAME"
>QFontDatabase</TT
> object and insert its
	    list of font families into the fontComboBox. Finally we set
	    the fontComboBox's current item to the textEdit's current
	    font.
	    </P
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN706"
>Making the Application Run</A
></H2
><P
>&#13;	With all the connections and code in place we are now ready to
	make our application run. Click on the Source tab of the Object
	Hierarchy window and click on the Includes (in Implementation)
	item. We need to include the files that our source code
	depends on. Right click the Includes item and click New. Type in
	<TT
CLASS="LITERAL"
>&lt;qapplication.h&gt;</TT
> for <TT
CLASS="FUNCTION"
>fileExit()</TT
>'s <TT
CLASS="FUNCTION"
>exit()</TT
> call.
	In the same way add <TT
CLASS="LITERAL"
>&lt;qmessagebox.h&gt;</TT
> for
	<TT
CLASS="FUNCTION"
>saveAndContinue()</TT
>'s message box, <TT
CLASS="LITERAL"
>&lt;qfiledialog.h&gt;</TT
>
	for the <TT
CLASS="FUNCTION"
>fileOpen()</TT
> and <TT
CLASS="FUNCTION"
>fileSaveAs()</TT
> functions, and
	<TT
CLASS="LITERAL"
>&lt;qfontdatabase.h&gt;</TT
> for the <TT
CLASS="CLASSNAME"
>QFontDatabase</TT
> class
	in <TT
CLASS="FUNCTION"
>init()</TT
>.
	</P
><P
>	We referred to a member variable, <TT
CLASS="LITERAL"
>fileName</TT
>,
	in our source code so we must add it to the form. Click the
	Source tab, right click the Class Variables item, click New from
	the pop up menu, then enter 'QString fileName;'.
	</P
><P
>&#13;	Create a <TT
CLASS="FILENAME"
>main.cpp</TT
> file in a plain text editor. Ours looks
	like this:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;qapplication.h&gt;
#include &quot;richedit.h&quot;

int main( int argc, char *argv[] ) 
{
    <I
CLASS="EMPHASIS"
>QApplication</I
> app( argc, argv );

    EditorForm richeditForm;
    app.setMainWidget( &amp;richeditForm );
    richeditForm.show();

    return app.exec();
}</PRE
></TD
></TR
></TABLE
>
	</P
><P
>&#13;	In a plain text editor open the <TT
CLASS="FILENAME"
>richedit.pro</TT
> project file
	and add the line <TT
CLASS="LITERAL"
>SOURCES += main.cpp</TT
> to the end of the file.
	The file should look similar to this:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>TEMPLATE        = app
CONFIG += qt warn_on release
TARGET        = richedit
INTERFACES        = richedit.ui 
DBFILE        = richedit.db
IMAGEFILE        = images.cpp
PROJECTNAME        = richedit
LANGUAGE        = C++
{SOURCES+=images.cpp}
SOURCES += main.cpp</PRE
></TD
></TR
></TABLE
>
	All that's left to do is to generate the Makefile, compile and
	run. The Makefile is created with <B
CLASS="COMMAND"
>qmake</B
>:
	<TT
CLASS="LITERAL"
>qmake -o Makefile richedit.pro</TT
>. 
	</P
><P
>&#13;	The richedit application demonstrates how easy it is to create a
	Qt application's main window with menus and dockable toolbars. A
	great deal of functionality was obtained by connecting the
	appropriate built-in signals and slots. The remaining
	functionality was achieved by connecting built-in signals to our
	own custom slots. We could continue developing the application,
	for example updating the fontComboBox, the font size spinbox and
	the actions with the font attributes as the user moves the
	cursor through their text. But our objective has been to
	demonstrate the creation of a main window with actions, menus
	and toolbars so we must stop at this point and leave further
	development and experimentation to you.
	</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="main-windows.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="c733.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Creating Main Windows with Actions, Toolbars and Menus</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="main-windows.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Using Qt Designer's Value Editors</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>