<HTML
><HEAD
><TITLE
>Connecting Signals and Slots </TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.57"><LINK
REL="HOME"
HREF="book1.html"><LINK
REL="UP"
TITLE="Creating a Qt Application"
HREF="c87.html"><LINK
REL="PREVIOUS"
TITLE="Laying Out Widgets & Previewing "
HREF="layingoutwidgetsandpreviewing.html"><LINK
REL="NEXT"
TITLE="Compiling and Building an Application "
HREF="compilingampbuildinganapplication.html"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="layingoutwidgetsandpreviewing.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 1. Creating a Qt Application</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="compilingampbuildinganapplication.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="CONNECTINGUPANAPPLICATION"
>Connecting Signals and Slots</A
></H1
><P
>&#13;


Qt provides the signals and slots mechanism for communicating between
widgets. Signals are emitted by widgets when particular events occur. We
can connect signals to slots, either pre-defined slots or those we
create ourselves. In older toolkits this communication would be achieved
using callbacks. (For a full explanation of Qt's signals and slots mechanism
see the on-line <A
HREF="http://doc.trolltech.com/signalsandslots.html"
TARGET="_top"
>Signals and Slots</A
>
documentation.)</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="CONNECTINGPREDEFINEDSIGNALSAMPSLOTS"
>Connecting Predefined Signals &amp; Slots</A
></H2
><P
>    

    Some of an application's functionality can be obtained simply by
    connecting pre-defined signals and slots. In multiclip there is only
    one pre-defined connection that we can use, but in the richedit
    application that we'll build in <A
HREF="main-windows.html"
>Chapter 2</A
>
    "Creating Main Windows with Actions, Toolbars &amp; Menus" we will
    use many pre-defined signals and slots to get a lot of the functionality
    we need without having to write any code. 
    </P
><P
>    We will connect the Quit button's 
<TT
CLASS="FUNCTION"
>clicked()</TT
>
    signal to the form's 
<TT
CLASS="FUNCTION"
>accept()</TT
> slot. The
    
<TT
CLASS="FUNCTION"
>accept()</TT
> slot notifies the dialog's caller that
    the dialog is no longer required; since our dialog is our main
    window this will close the application. Preview the form (press
    
<B
CLASS="KEYCAP"
>Ctrl+T</B
>); click the <SPAN
CLASS="GUIBUTTON"
>Quit</SPAN
>
    button. The button works visually but does nothing. Press
    
<B
CLASS="KEYCAP"
>Esc</B
> or close the preview window to leave the
    preview.
    </P
><P
>    

    

    Click the 

<SPAN
CLASS="GUIBUTTON"
>Connect Signals/Slots</SPAN
> toolbar
    button. Click the Quit button, drag to the form and release. The
    
Edit Connections dialog will pop up. The top left hand list box
    lists the Signals that the widget we've clicked can emit. At the top
    right is a combobox which lists the form and its widgets; any of
    these are candidates for receiving signals. Since we released on the
    form rather than a widget the slots combobox shows the 
    form's name, 'MulticlipForm'. Beneath the combobox
    is a list box which shows the slots available in the form or widget
    shown in the combobox. Note that only those slots that can be
    connected to the highlighted signal are shown. If you clicked a
    different signal, for example the 
<TT
CLASS="FUNCTION"
>toggled()</TT
>
    signal, the list of available slots would change. Click the
    
<TT
CLASS="FUNCTION"
>clicked()</TT
> signal, then click the
    
<TT
CLASS="FUNCTION"
>accept()</TT
> slot. The connection will be shown in
    the Connections list box. Click <SPAN
CLASS="GUIBUTTON"
>OK</SPAN
>.
    </P
><P
>    We will make a great many signal/slot connections as we work through
    the examples, including connections to our own custom slots.
    Signal/slot connections (using pre-defined signals and slots) work
    in preview mode. Press 
<B
CLASS="KEYCAP"
>Ctrl+T</B
> to preview the form;
    click the form's <SPAN
CLASS="GUIBUTTON"
>Quit</SPAN
> button. The button now
    works correctly.
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="CREATINGAMPCONNECTINGCUSTOMSLOTS"
>Creating and Connecting Custom Slots</A
></H2
><P
>    

    

    In the first version of <I
CLASS="EMPHASIS"
>Qt Designer</I
> you could create the signatures of your
    custom slots and make the connections, but you could not implement
    your slots directly. Instead you had to subclass the form and
    code your slots in the subclass. The subclassing approach is
    still available, and makes sense in some situations. But now you can
    implement your slots directly in <I
CLASS="EMPHASIS"
>Qt Designer</I
>, so for many
    straightforward dialogs and windows subclassing is no longer
    necessary.
    </P
><P
>    The multiclip application requires four slots, one for each button,
    but only three need to be custom slots since we connected a signal
    to a pre-defined slot to make the Quit button functional. We need a
    slot for the Add Clipping button; this will add the current clipping
    to the list box. The Copy Previous button requires a slot which will
    copy the selected list box item to the current clipping line edit
    (and to the clipboard). The Delete Clipping button needs a slot to
    delete the current clipping and the current list box item. We will
    also need to write some initialization code so that when the
    application starts it will put the current clipboard text (if any)
    into the line edit. The code is written directly in <I
CLASS="EMPHASIS"
>Qt Designer</I
>; the
    snippets are taken from the generated
    <TT
CLASS="FILENAME"
>qt/tools/designer/examples/multiclip/multiclip.cpp</TT
>
    file. 
    </P
><P
>    

    We'll need Qt's global clipboard object throughout the
    code which would mean calling 
    
<TT
CLASS="FUNCTION"
>QApplication::clipboard()</TT
> or
    
<TT
CLASS="FUNCTION"
>qApp-&gt;clipboard()</TT
> in several places. Rather
    than perform all these function calls we'll keep
    a pointer to the clipboard in the form itself. Click the Source tab
    of the Object Explorer. (If the Object Explorer isn't visible click
    
<SPAN
CLASS="GUIMENUITEM"
>Window|Views|Object Explorer</SPAN
>.) The Source
    tab shows us the functions in our form, the class variables, the
    forward declarations and the names of the include files we've asked for. 
    </P
><P
>    

    

    

    

    

    

    

    

    

    

    

    

    

    Right click the Class Variables item, then click
    
<SPAN
CLASS="GUIMENUITEM"
>New</SPAN
> on the popup menu. (If there had
    been any existing variables the popup menu would also have a Delete
    option.) Type in 'QClipboard *cb;' and press
    
<B
CLASS="KEYCAP"
>Enter</B
>. In the 
<TT
CLASS="FUNCTION"
>init()</TT
> function
    we will assign this pointer to Qt's global clipboard object. We also
    need to declare the clipboard header file. Right click Includes (in
    Declaration), then click 
<SPAN
CLASS="GUIMENUITEM"
>New</SPAN
>. Type in
    '&lt;qclipboard.h&gt;' and press 
<B
CLASS="KEYCAP"
>Enter</B
>. Since we
    need to refer to the global application object,
    <TT
CLASS="LITERAL"
>qApp</TT
>, we need to add another include declaration.
    Right click Includes (in Implementation), then click
    
<SPAN
CLASS="GUIMENUITEM"
>New</SPAN
>. Type in '&lt;qapplication.h&gt;' and
    press 
<B
CLASS="KEYCAP"
>Enter</B
>. The variable and declarations will be
    included in the code generated from <I
CLASS="EMPHASIS"
>Qt Designer</I
>'s 
<TT
CLASS="FILENAME"
>.ui</TT
>
    file.
    </P
><P
>    We will invoke <I
CLASS="EMPHASIS"
>Qt Designer</I
>'s code editor and write the code.
    </P
><P
>    

    We'll look at the 
<TT
CLASS="FUNCTION"
>init()</TT
> function first. <I
CLASS="EMPHASIS"
>Qt Designer</I
>
    creates an empty 
<TT
CLASS="FUNCTION"
>init()</TT
> into which we can add
    our own code. To invoke the code editor click a function, e.g. click
    
<TT
CLASS="FUNCTION"
>init()</TT
> in the Source tab of the Object Hierarchy.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void MulticlipForm::init()
{ 
    lengthLCDNumber-&gt;setBackgroundColor( darkBlue ); 
    currentLineEdit-&gt;setFocus(); 
     
    cb = qApp-&gt;clipboard(); 
    connect( cb, SIGNAL( dataChanged() ), SLOT( dataChanged() ) ); 
    if ( cb-&gt;supportsSelection() ) 
        connect( cb, SIGNAL( selectionChanged() ), SLOT( selectionChanged() ) ); 
     
    dataChanged(); 
}</PRE
></TD
></TR
></TABLE
>
    The first couple of lines change the LCD
    number's background color and make the form start with the focus in the
    line edit. We take a pointer to Qt's global clipboard and keep it in our
    class variable, cb. We connect the clipboard's
    
<TT
CLASS="FUNCTION"
>dataChanged()</TT
> signal to a slot called
    
<TT
CLASS="FUNCTION"
>dataChanged()</TT
>; we will create this slot ourselves
    shortly. If the clipboard supports selection (under the X Window
    system for example), we also connect the clipboard's
    
<TT
CLASS="FUNCTION"
>selectionChanged()</TT
> signal to a slot of the same name that
    we will create. Finally we call our 
<TT
CLASS="FUNCTION"
>dataChanged()</TT
>
    slot to populate the line edit with the clipboard's text (if any) when
    the application begins.
    </P
><P
>    Since we've referred to the 
<TT
CLASS="FUNCTION"
>dataChanged()</TT
> and
    
<TT
CLASS="FUNCTION"
>selectionChanged()</TT
> slots we'll code them next,
    starting with 
<TT
CLASS="FUNCTION"
>dataChanged()</TT
>.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void MulticlipForm::dataChanged()
{ 
    <I
CLASS="EMPHASIS"
>QString</I
> text;  
    text = cb-&gt;text();            
    clippingChanged( text ); 
    if ( autoCheckBox-&gt;isChecked() ) 
        addClipping(); 
}</PRE
></TD
></TR
></TABLE
>
    We take a copy of the clipboard's text and call our own
    <TT
CLASS="FUNCTION"
>clippingChanged()</TT
> slot with the text we've
    retrieved. If the user has checked the Auto Add Clippings checkbox
    we call our <TT
CLASS="FUNCTION"
>addClipping()</TT
> slot to add the
    clipping to the list box.
    </P
><P
>    

    

    

    The 
<TT
CLASS="FUNCTION"
>selectionChanged()</TT
> slot is only applicable
    under the X Window System. Users of MS Windows can still include the
    code to ensure that the application works cross-platform.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void MulticlipForm::selectionChanged()
{ 
    cb-&gt;setSelectionMode( TRUE );  
    dataChanged(); 
    cb-&gt;setSelectionMode( FALSE );  
}</PRE
></TD
></TR
></TABLE
>
    We tell the clipboard to use selection mode, we call
    our 
<TT
CLASS="FUNCTION"
>dataChanged()</TT
> slot to retrieve any selected
    text, then set the clipboard back to its default mode.
    </P
><P
>    In the 
<TT
CLASS="FUNCTION"
>dataChanged()</TT
> slot we called another
    custom slot, <TT
CLASS="FUNCTION"
>clippingChanged()</TT
>. 
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void MulticlipForm::clippingChanged( const <I
CLASS="EMPHASIS"
>QString</I
> &amp; clipping )
{ 
    currentLineEdit-&gt;setText( clipping ); 
    lengthLCDNumber-&gt;display( (int)clipping.length() );  
}</PRE
></TD
></TR
></TABLE
>
    We set the line edit to whatever text is passed to the
    <TT
CLASS="FUNCTION"
>clippingChanged()</TT
> slot and update the LCD
    number with the length of the new text.
    </P
><P
>    

    The next slot we'll code will perform the Add Clipping function.
    This slot is called by our code internally (see the
    
<TT
CLASS="FUNCTION"
>dataChanged()</TT
> slot above), and when the user
    clicks the Add Clipping button.
    Since we want <I
CLASS="EMPHASIS"
>Qt Designer</I
> to be able to set up a connection to this slot
    instead of just typing it in the editor window we'll let <I
CLASS="EMPHASIS"
>Qt Designer</I
>
    create its skeleton for us. Click 
<SPAN
CLASS="GUIMENUITEM"
>Edit|Slots</SPAN
> to
    invoke the 
Edit Slots dialog. Click <SPAN
CLASS="GUIBUTTON"
>New Slot</SPAN
>
    and replace the default name of 'new_slot()' with 'addClipping()'.
    There is no need to change the access specifier or return type. Now
    that we've created our slot we can implement it in the code editor
    where it has now appeared.
    </P
><P
>    The Add Clipping button is used to copy the clipping from the
    Current Clipping line edit into the list box. We also update the
    length number. 
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void MulticlipForm::addClipping()
{ 
    <I
CLASS="EMPHASIS"
>QString</I
> text = currentLineEdit-&gt;text(); 
    if ( ! text.isEmpty() ) { 
        lengthLCDNumber-&gt;display( (int)text.length() );          
        int i = 0; 
        for ( ; i &lt; (int)clippingsListBox-&gt;count(); i++ ) { 
            if ( clippingsListBox-&gt;text( i ) == text ) { 
                i = -1;<I
CLASS="EMPHASIS"
> // Do not add duplicates </I
>
                break; 
            } 
        } 
        if ( i != -1 )  
            clippingsListBox-&gt;insertItem( text, 0 );                
    } 
}</PRE
></TD
></TR
></TABLE
>
    If there is some text we change the LCD's value to the length of the
    text. We then iterate over all the items in the list box to see if
    we have the same text already. If the text is not already in the
    list box we insert it.
    </P
><P
>    

    To make the Add Clipping button functional we need to connect the
    button's 
<TT
CLASS="FUNCTION"
>clicked()</TT
> signal to our
    <TT
CLASS="FUNCTION"
>addClipping()</TT
> slot. Click the
    

<SPAN
CLASS="GUIBUTTON"
>Connect Signals/Slots</SPAN
> toolbar button. Click
    the Add Clipping button, drag to the form and release. (Make sure
    you drag to the form rather than another widget -- the form will
    have a thin pink border during the drag. If you make a mistake
    simply change the name in the Slots combobox.) The 
Edit Connections
    dialog will appear. Click the 
<TT
CLASS="FUNCTION"
>clicked()</TT
> signal
    and our <TT
CLASS="FUNCTION"
>addClipping()</TT
> slot. Click <SPAN
CLASS="GUIBUTTON"
>OK</SPAN
> to
    confirm the connection. 
    </P
><P
>    The Copy Previous button is used to copy the selected clipping from
    the list box into the line edit. The clipping is also placed on the
    clipboard. The procedure is the same as for the Add Clipping button:
    first we create the slot, then we implement it and finally we connect to
    it:
    <P
></P
><OL
TYPE="1"
><LI
><P
>    Create the slot.
    </P
><P
>    

    Click the 
<SPAN
CLASS="GUIMENUITEM"
>Edit|Slots</SPAN
> menu item to invoke
    the 
Edit Slots dialog. Click <SPAN
CLASS="GUIBUTTON"
>New Slot</SPAN
> and
    replace the default 'new_slot()' name with 'copyPrevious()'. Click
    <SPAN
CLASS="GUIBUTTON"
>OK</SPAN
>.
    </P
></LI
><LI
><P
>    Implement the slot.
    </P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void MulticlipForm::copyPrevious()
{ 
    if ( clippingsListBox-&gt;currentItem() != -1 ) { 
        cb-&gt;setText( clippingsListBox-&gt;currentText() ); 
        if ( cb-&gt;supportsSelection() ) { 
            cb-&gt;setSelectionMode( TRUE ); 
            cb-&gt;setText( clippingsListBox-&gt;currentText() ); 
            cb-&gt;setSelectionMode( FALSE ); 
        } 
    } 
}</PRE
></TD
></TR
></TABLE
>
    The code for Copy Previous checks to see if there is a selected item
    in the list box. If there is the item is copied to the line edit. If
    we are using a system that supports selection we have to repeat the
    copy, this time with selection mode set. We don't explicitly update
    the clipboard. When the line edit's text is changed it emits a
    
<TT
CLASS="FUNCTION"
>dataChanged()</TT
> signal which our
    
<TT
CLASS="FUNCTION"
>dataChanged()</TT
> slot receives. Our
    
<TT
CLASS="FUNCTION"
>dataChanged()</TT
> slot updates the clipboard.
    </P
></LI
><LI
><P
>    

    Connect to the slot.
    </P
><P
>    Click the 

<SPAN
CLASS="GUIBUTTON"
>Connect Signals/Slots</SPAN
> toolbar
    button. Click the Copy Previous button, drag to the form and
    release. The 
Edit Connections dialog will pop up. Click the
    
<TT
CLASS="FUNCTION"
>clicked()</TT
> signal and the
    <TT
CLASS="FUNCTION"
>copyPrevious()</TT
> slot. Click <SPAN
CLASS="GUIBUTTON"
>OK</SPAN
>.
    </P
></LI
></OL
>
    </P
><P
>    We take the same approach to the Delete Clipping button.
    <P
></P
><OL
TYPE="1"
><LI
><P
>    

    Click 
<SPAN
CLASS="GUIMENUITEM"
>Edit|Slots</SPAN
> to invoke the 
Edit Slots
    dialog. Click <SPAN
CLASS="GUIBUTTON"
>New Slot</SPAN
> and replace the
    default name with 'deleteClipping()'. Click <SPAN
CLASS="GUIBUTTON"
>OK</SPAN
>.
    </P
></LI
><LI
><P
>    The Delete button must delete the current item in the list box and
    clear the line edit. 
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void MulticlipForm::deleteClipping()
{  
    clippingChanged( &quot;&quot; );  
    clippingsListBox-&gt;removeItem( clippingsListBox-&gt;currentItem() ); 
}</PRE
></TD
></TR
></TABLE
>
    We call our own <TT
CLASS="FUNCTION"
>clippingChanged()</TT
> slot with an
    empty string and use the list box's
    <TT
CLASS="FUNCTION"
>removeItem()</TT
> function to remove the current
    item.
    </P
></LI
><LI
><P
>    

    Connect the Delete Clipping button's 
<TT
CLASS="FUNCTION"
>clicked()</TT
>
    signal to our <TT
CLASS="FUNCTION"
>deleteClipping()</TT
> slot.
    (Press 
<B
CLASS="KEYCAP"
>F3</B
> -- which is the same as clicking the 
    

<SPAN
CLASS="GUIBUTTON"
>Connect Signals/Slots</SPAN
> toolbar button. Click the
    Delete Clipping button and drag to the form; release. The 
    
Edit Connections dialog will appear. Click the
    
<TT
CLASS="FUNCTION"
>clicked()</TT
> signal and the
    <TT
CLASS="FUNCTION"
>deleteClipping()</TT
> slot. Click <SPAN
CLASS="GUIBUTTON"
>OK</SPAN
>.)
    </P
></LI
></OL
>
    </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="layingoutwidgetsandpreviewing.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="compilingampbuildinganapplication.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Laying Out Widgets &amp; Previewing</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c87.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Compiling and Building an Application</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>