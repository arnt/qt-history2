Roadmap for Qt Designer Interface hierarchy


General
=======

The Interface architecture of Qt's plugin system is based on three 
classes:

- QPlugInInterface to enable the application to load and access
  functionality of the plugin, using the helper classes QPlugIn
  and QPlugInManager.
- QApplicationInterface and QComponentInterface to enable the plugin 
  to access functionality or data of the application.

  There is only one QApplicationInterface, and it is requested from 
the QApplication derived class using the virtual 
requestApplicationInterface method. A plugin can acquire this interface
in it's connectNotify reimplementation.
  Each QComponentInterface represents one instance of a QObject 
derived class, e.g. a main window. The existing functionality provides 
methods to use the read and write methods of the property system, 
methods to set up connections (in both directions) and a method to 
install the plugin to host an eventfilter for the object. All methods 
are named requestXYZ, indicating that it is on the application's side 
of the interface implementation to process or reject the request. 
  Interfaces that only reimplement the functionality of 
QComponentInterface - e.g. to allow only a subset of properties to
be accessed, or to add properties that are not part of the property
system of the handled object - should be totally hidden within the 
application. It's not necessary to include any declaration files 
into the plugin, as all relevant methods of QComponentInterface are 
virtual.
  Interfaces that extend the functionality of QComponentInterface
have to be declared as abstract classes, all functions being pure
virtual. Thus the plugin doesn't have to know about any implementation
details (that is, it does not have to link against any library etc.).
The Interface has to be implemented within the application module by
subclassing.

  Similar to the QComponentInterface, the QPlugInInterface has to be 
implemented on both sides, too. In the application module this is
done using multiple inheritance from both QPlugIn, which provides the
basic loading and unloading functionality, and the custom Interface 
class. The queryPlugInInterface method has to be reimplemented inline 
in the declaration of custom widgets AND in the QPlugIn subclass (even 
though it is inherited from the interface this seems to be necessary 
for most compilers). QPlugInInterface already provides some convenient 
functions that are not necessary to reimplement in custom interfaces. 
All new functions should be pure virtual.
  The implementation has to use the plugInterface method of QPlugIn
to access the implementation in the library, and just forward the
functioncall. As the library may not be loaded in this moment it is 
strongly suggested to call the use-function before accessing the 
plugin interface.
  The library just has to subclass the interface and implement the
functions. Additionally, a C function "loadInterface" has to be 
provided that returns a new interface. This can be done platform 
independantly using the QT_EXPORT_INTERFACE macro.


Difficulties using dynamic loading of libraries
-----------------------------------------------

A common problem with dynamic linking is that memory allocated in the
library is likely to be referenced in some way within the application.
When unloading the library, all pointers to such memory become invalid,
causing segmentation faults when dereferencing.
  As the interface architecture provides something like a "library
destructor" (the interface is destroyed when the library is unloaded)
it is possible to cleanup all memory allocated. This can be done 
easily using the templates QCleanUpHandler for normal pointers, and 
QGuardedCleanUpHandler for pointers to QObject derived classes. As 
long as those objects are not referenced to in any special way this is
enough (e.g. the deletion of a QObject deletes all connections, parent
children etc.).
  There are more subtle problems associated with the usage of classes 
that provide sharing, e.g. all QString related classes. Interface 
methods returning QString or QStringList return data that is allocated 
in the library's memory, thus leaving even copies of the - shared - 
classes with references to memory already deallocated when the library 
has been unloaded. It is of critical importance to make either deep 
copies of the returned values, or to guarantee that all references to 
this data is destroyed before the library is unloaded. For copies on 
the stack this can be done using an additional scope.

### Qt's copy methods for those classes are very poor at the moment ###


Interfaces in the Qt Designer (sketch)
======================================

All interfaces for the Qt Designer are accessible by including a single
header file, designerinterface.h, which is located in the
tools\designer\plugins subdirectory of your local Qt installation.

Supported PlugIn Interfaces:
----------------------------

  All Interfaces here are subclasses of QPlugInInterface, which provides
a standard set of methods for convenience. 

  The functions name(), author() and description() are implemented in
QPlugInInterface and return QString::null, so it's not necessary, but
useful to reimplement these in each plugin.
Additionally, the featureList() function is supposed to return 
the list of features the plugin is able to provide. 

- ActionInterface

  This subinterface provides a pure virtual function "create()" which 
  has to be implemented in all plugins, so that it returns an instance
  of the QAction class.
  Additionally, the group function returns a name of a subset of 
  actions which the created action belongs to, e.g. "File".
  Note that you can use QActionGroup, which is a subclass of QAction,
  to provide a set of related actions.

- WidgetInterface

  This subinterface provides a pure virtual function "create()" which 
  has to be implemented in all plugins, so that it returns an instance 
  of a subclass of QWidget. All properties, signals and slots the 
  widget class provides will be fully integrated into the Qt Designer.
  The Interface declares additional, pure virtual functions that are
  used to provide more information about the widget. These are group,
  toolTip and whatsThis that may return arbitrary strings, iconSet and 
  includeFile that are supposed to return a filename, and isContainer,
  which has to return TRUE when the widget is capable of nesting child
  widgets.

- FilterInterface

  The featureList of this function can return a string describing a
  filter as used by the QFileDialog class, e.g. My Filetype (*.mft).
  The import function will get the desired filter and the filename
  which it is supposed to convert into a list of UI files. The function
  returns a QStringList with the filenames of the resulting files. 
  The created files are deleted by the designer as soon as they are
  loaded.


Provided Application Interfaces:
--------------------------------

DesignerApplicationInterface
    |
    |-- DesignerPropertyEditorInterface 
    |	    |
    |	    |-- DesignerWidgetInterface
    |
    |
    |-- DesignerFormListInterface
    |	    |
    |	    |-- DesignerFormWindowInterface
    |		    |
    |		    |-- DesignerSelectionInterface
    |			    |
    |			    |-- DesignerWidgetInterface
    |
    |
    |-- DesignerHierarchyViewInterface
    |	    |
    |	    |-- DesignerWidgetInterface
    |
    |
    |-- DesignerMainWindowInterface
    |	    |
    |	    |-- DesignerMenuBarInterface
    |	    |
    |	    |-- DesignerStatusBarInterface
    |
    |
    |-- DesignerConfigurationInterface



Comments
--------

- DesignerApplicationInterface

  Is created by the DesignerApplication object and acquired using the 
  requestApplicationInterface method. This interface provides the 
  QComponentInterfaces to the the plugin (see graph).
  There is no functionality beyond this right now.
  ## property ideas from MSDN, IApplication members ##
  ## - title
  ## - name
  ## - path
  ## - current directory
  ## - version

- DesignerFormWindowInterface

  Represents the currently active form window, and can provide
  a DesignerSelectionInterface.
  Properties (*=faked):
    - caption (*)
    - modified (*)

  Functions:
    - save
    - close
    - undo
    - redo
    - insertWidget

- DesignerSelectionInterface

  Represents the currently selected widgets and can provide
  a DesignerWidgetInterface
  Properties
    - count

  Functions:
    - delete

- DesignerWidgetInterface

  Represents the currently active widget.
  Properties
    - as defined by the widget

  Functions:
    - delete
    - selectNext
    - selectPrevious
    - selectParent

- DesignerPropertyEditorInterface

  Represents the Property Editor in the Qt Designer and can provide a
  DesignerWidgetInterface.
  Properties
    -

  Functions:
    -

- DesignerFormListInterface

  Provides access to the list of forms opened in the Qt Designer, and 
  can provide a DesignerFormWindowInterface.
  Properties
    - count (read only)

  Functions:
    - newForm
    - loadForm
    - saveActiveForm
    - saveAllForms
    - closeAll
    - addColumn/removeColumn (see p4 example requirements)
    - setColumnIndicator

- DesignerHierarchyViewInterface

  Represents the Hierarchy View in the Designer, and can provide a 
  DesigerWidgetInterface.
  Functions:
    - 

- DesignerMainWindowInterface

  Represents the Main Window of the Designer { and can provide a
  DesignerStatusBarInterface }
  Properties:
    - statusText

  Functions:
    - 

- DesignerConfigurationInterface

  Represents the current configuration of the Qt Designer.


Example PlugIn "P4" (Perforce integration)
------------------------------------------

Requirements:
-------------
- Support for commands edit, submit, revert, add, delete, sync, diff
- toggleable Auto-edit when controlled form is changed
- getting state of loaded files
- indicating state of file in the FormList
- submitting/reverting of multiple files
- reloading of the form after sync/revert

