Roadmap for Qt Designer Interface hierarchy


General
=======
The Interface architecture of Qt's plugin system is based on three 
classes:

- QPlugInInterface to enable the application to load and access
  functionality of the plugin, using the helper classes QPlugIn
  and QPlugInManager.
- QApplicationInterface and QComponentInterface to enable the plugin 
  to access functionality or data of the application.

  There is only one QApplicationInterface, and it is requested from 
the QApplication derived class using the virtual 
requestApplicationInterface method. A plugin can acquire this interface
in it's connectNotify reimplementation.
  Each QComponentInterface represents one instance of an QObject 
derived class, e.g. a main window. The existing functionality provides 
methods to use the read and write methods of the property system, 
methods to set up connections (in both directions) and a method to 
install the plugin to host an eventfilter for the object. All methods 
are named requestXYZ, indicating that it is on the application's side 
of the interface implementation to process or reject the request. 
  Interfaces that only reimplement the functionality of 
QComponentInterface - e.g. to allow only a subset of properties to
be accessed, or to add properties that are not part of the property
system of the handled object - should be totally hidden within the 
application. It's not necessary to include any declaration files 
into the plugin, as all relevant methods of QComponentInterface are 
virtual.
  Interfaces that extend the functionality of QComponentInterface
have to be declared as abstract classes, all functions being pure
virtual. Thus the plugin doesn't have to know about any implementation
details (that is, it does not have to link against any library etc.).
The Interface has to be implemented within the application module by
subclassing.

  Similar to the QComponentInterface, the QPlugInInterface has to be 
implemented on both sides, too. In the application module this is
done using multiple inheritance from both QPlugIn and the custom
Interface class. The queryPlugInInterface method has to be 
reimplemented inline in the declaration of custom widgets AND in the
QPlugIn subclass (even though it is inherited from the interface this
seems to be necessary for most compilers). QPlugInInterface already
provides some convenient functions that are not necessary to 
reimplement in custom interfaces. All new functions should be abstract.
  The implementation has to use the plugInterface method of QPlugIn
to access the implementation in the library, and just forward the
functioncall. As the library may not be loaded in this moment it is 
strongly suggested to call the use-function before accessing the 
plugin interface.
  The library just has to subclass the interface and implement the
functions. Additionally, a C function "loadInterface" has to be 
provided that returns a new interface. This can be done platform 
independendly using the QT_EXPORT_INTERFACE macro.


Difficulties using dynamic loading of libraries
-----------------------------------------------
A common problem with dynamic linking is that memory allocated in the
library is likely to be referenced in some way within the application.
When unloading the library, all pointers to such memory become invalid,
causing segmentation faults when dereferencing.
  As the interface architecture provides something like a "library
destructor" (the interface is destroyed when the library is unloaded)
it is possible to cleanup all memory allocated. This can be done 
easily using the templates QCleanUpHandler for normal pointers, and 
QGuardedCleanUpHandler for pointers to QObject derived classes. As 
long as those objects are not referenced to in any special way this is
enough (e.g. the deletion of a QObject deletes all connections, parent
children etc.).
  To more subtle problems leads the usage of classes that provide 
sharing, e.g. all QString related classes. Interface methods returning
QString or QStringList return data that is allocated in the library's 
memory, thus leaving even copies of the - shared - classes with 
references to memory already deallocated when the library has been 
unloaded. It is of critical importance to make either deep copies of 
the returned values, or to guarantee that all references to this data 
is destroyed before the library is unloaded. For copies on the stack
this can be done using an additional scope.

### Qt's copy methods for those classes are very poor at the moment ###


Interface Hierarchy for the Designer (sketch)
=============================================
DesignerApplicationInterface
    |
    |-- DesignerPropertyEditorInterface 
    |	    |
    |	    |-- DesignerWidgetInterface
    |
    |
    |-- DesignerFormListInterface
    |	    |
    |	    |-- DesignerFormWindowInterface
    |		    |
    |		    |-- DesignerWidgetInterface
    |
    |
    |-- DesignerHierarchyViewInterface
    |	    |
    |	    |-- DesignerWidgetInterface
    |
    |
    |-- DesignerMainWindowInterface
    |	    |
    |	    |-- DesignerMenuBarInterface
    |	    |
    |	    |-- DesignerStatusBarInterface
    |
    |
    |-- DesignerConfigurationInterface



Comments
--------

- DesignerApplicationInterface

  Is created by the DesignerApplication object and acquired using the 
  requestApplicationInterface method. This interface provides the 
  QComponentInterfaces to the the plugin (see graph).
  There is no functionality beyond this.

- DesignerFormWindowInterface

  Represents the currently active form window, and can provide
  a DesignerWidgetInterface.
  Functions:
    - 

- DesignerWidgetInterface

  Represents the currently selected widget.
  Functions:
    -

- DesignerPropertyEditorInterface

  Represents the Property Editor in the Qt Designer and can provide a
  DesignerWidgetInterface.
  Functions:
    -

- DesignerFormListInterface

  Provides access to the list of forms opened in the Qt Designer, and 
  can provide a DesignerFormWindowInterface.
  Functions:
    - newForm
    - loadForm
    - saveActiveForm
    - saveAllForms

- DesignerHierarchyViewInterface

  Represents the Hierarchy View in the Designer, and can provide a 
  DesigerWidgetInterface.
  Functions:
    - 

- DesignerMainWindowInterface

  Represents the Main Window of the Designer, and can provide a
  DesignerMenuBar- and a DesignerStatusBarInterface.
  Functions:
    - 

- DesignerConfigurationInterface

  Represents the current configuration of the Qt Designer.
