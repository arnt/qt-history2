

So far this is the start of what will look like a typical Windows installation wizard.

For Linux, the typical installation method is rpm, however Windows users and enterprises
wanting to make the transition to Linux suddenly find that they have to deal with
installing rpm packages and either must use the command line or an rpm GUI wrapper.

As far as I can tell /bin/rpm is a static binary and there isn't a library yet for
accessing the rpm database. What I think would be very nice is for systems to have
pre-installed on them an rpm library and a graphical installer stub program and associated
libraries (ie qt-mt.so). Then it is possible to create a setup install program for a Linux
binary similar to on Windows, but without the user needing to download as much as they
only download the program's files and the setup script, but none of the setup wizard
executable code. The installation is still registered in the rpm database using the rpm
library and it makes it possible to uninstalled packages similar to on Windows where there
is the add/remove program dialog. Windows is currently moving in the direction of having
setup executable code on the system and what is distributed is an .ism file.

On the Mac there is no standard, typically you download a .sit file which is similar to
a .zip file but is uncomressed with stuffit expander which is now pre-installed on current
mac systems. Some .sit packages furthur contain an installer typically using the Zero-G
installation engine, but many don't. The .sit file usually just contains the .app folder
and a README. The .app folder is what is run and contains the executable and resource files
in a mac standard folder structure. This .app folder is usually completely relocatable.
Uninstallation is done by simply dragging the folder to the trashcan.

On Windows typically once a program has been installed to a directory it can not be relocated.
Similar limitation often apply on Linux, and sometimes the installation folder can not be
chosen but must be placed in a specific location.

Part of the problem is across these different platforms there is no uniform standard
for finding resource and user data files needed by the application. On Windows the program
either looks introspectively for built-in resources which are attached to the binary,
or in its installdir, on Mac the .app's resource dir is used using mac APIs, and on Linux
either a file from /etc is read for the installdir or a relative path from the binary is
used or some other option. User files are found in different ways on the different platforms
also.

What would be helpful is perhaps 2 new cross-platform APIs. One full of static functions
which return the path for various known directories, the other for finding and loading
resource files similar to the Qtopia resource API.

For example:

class QPaths {
    static QString rootDir() const;
    static QString systemDir() const;
    static QString homeDir() const;

    static QString userDocumentsDir() const;
    static QString userMusicDir() const;
    static QString userPhotosDir() const;
};


class QResource {
    QFile find( QString resource );
    QPixmap loadPixmap( QString resource );
    ...
};

