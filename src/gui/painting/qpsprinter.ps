% the postscript header we use for our qpsprinter in uncompressed and commented form.
% use the makepsheader perl script to generate a compressed version of this header
% you can then paste into qpsprinter.cpp
%
% some compression of the code is done by the makepsheader script, so we don't need to 
% write too criptically here. 

/BD  {bind def} bind def
/d2 {dup dup} BD
/ED {exch def} BD
/D0 {0 ED} BD

/F  {setfont} BD
/RL {rlineto} BD
/NP {newpath} BD
/CM {currentmatrix} BD
/SM {setmatrix} BD
/TR {translate} BD
/SD {setdash} BD
/SC {aload pop setrgbcolor} BD
/CR {currentfile read pop} BD
/i  {index} BD
/bs {bitshift} BD
/scs {setcolorspace} BD
/DB {dict dup begin} BD
/DE {end def} BD
/ie {ifelse} BD

% these use PDF syntax
/w {setlinewidth} BD
/d {setdash} BD

/m  {moveto} BD
/l  {lineto} BD
/c  {curveto} BD
/h  {closepath} BD
/S  {stroke} BD
/W  {clip} BD
/W* {eoclip} BD

% ENDUNCOMPRESSED: Warning: leave this line in. 
% Everything before this line will be left untouched by the compression

% PDF operators
/re { % PDF re operator
  4 2 roll  % w h x y
  moveto % w h
  dup % w h h
  0 exch rlineto % w h
  exch 0 rlineto % h
  0 exch neg rlineto
  closepath
} bind def



% old operators

/BSt 0 def                             % brush style
/LWi 0 def                             % line width
/PSt 1 def                             % pen style
/WFi false def                 % winding fill
/OMo false def                 % opaque mode (not transparent)

/BCol  [ 1 1 1 ] def                   % brush color
/PCol  [ 0 0 0 ] def                   % pen color
/BkCol [ 1 1 1 ] def                   % background color
/BDArr [                             % Brush dense patterns
  0.94
  0.88
  0.63
  0.50
  0.37 
  0.12 
  0.06 
] def
/defM matrix def

% -- level3 true/false
/level3 {
  /languagelevel where {
    pop
    languagelevel 3 ge 
  } { false } ifelse
} bind def

% LArr for the Pen styles is defined in emitHeader because of scaling

% GPS: GetPenStyle 
% Returns the line pattern (from pen style PSt).
%
%   bool GPS pattern
%   true : returns draw pattern
%   false: returns fill pattern
/GPS {
  PSt 1 ge PSt 5 le and                      % valid pen pattern?
  { 
    { LArr PSt 1 sub 2 mul get }           % draw pattern
    { LArr PSt 2 mul 1 sub get } ifelse    % opaque pattern
  }
  { [] } ifelse                            % out of range => solid line
} bind def

% QS: QtStroke
% draw and fill current path
%
%     - QS -
/QS {                                % stroke command
  PSt 0 ne                         % != NO_PEN
  { 
    gsave
      LWi setlinewidth                         % set line width
      true GPS 0 setdash S           % draw line pattern
      OMo PSt 1 ne and               % opaque mode and not solid line?
      { 
	BkCol SC
	false GPS dup 0 get setdash S % fill in opaque pattern
      } if
    grestore
  } if
} bind def

%% image drawing routines

/sl D0 % ### is this needed ?

% defines for QCI
/QCIgray D0 /QCIcolor D0 /QCIindex D0

% this method prints color images if colorimage is available, otherwise
% converts the string to a grayscale image and uses the reular postscript image
% operator for printing.
% Arguments are the same as for the image operator:
% 
%     width height bits/sample matrix datasrc QCI -
/QCI {
  /colorimage where {
    pop
    false 3 colorimage
  }{  % the hard way, based on PD code by John Walker <kelvin@autodesk.com>
    exec /QCIcolor ED
    /QCIgray QCIcolor length 3 idiv string def
    0 1 QCIcolor length 3 idiv 1 sub
    { /QCIindex ED
      /x QCIindex 3 mul def
      QCIgray QCIindex
      QCIcolor x       get 0.30 mul
      QCIcolor x 1 add get 0.59 mul
      QCIcolor x 2 add get 0.11 mul
      add add cvi
      put
    } for
    QCIgray image
  } ifelse
} bind def

% general image drawing routine, used from the postscript driver
%
% Draws images with and without mask with 1, 8 and 24(rgb) bits depth.
%
%     width height matrix image 1|8|24 mask|false x y di
%
% width and height specify the width/height of the image,
% matrix a transformation matrix, image a procedure holding the image data
% (same for mask) and x/y an additional translation.
%
% ### should move the translation into the matrix!!!
/di 
{
  gsave
    translate
    1 index 1 eq { % bitmap
      false eq { % no mask, draw solid background
	pop
	true 3 1 roll % width height false matrix image
	4 index
	4 index
	false
	4 index
	4 index
	imagemask
	BkCol SC
	imagemask
      } { 
	pop
	false 3 1 roll % width height false matrix image
	imagemask
      } ifelse
    } { 
      dup false ne { 
	% have a mask, see if we can use it
	level3
      } { 
	false 
      } ifelse

      {
	% languagelevel3, we can use image mask and dicts

	% store the image mask
	/ma exch def
	% select colorspace according to 8|24 bit depth and set the decode array /dc
	8 eq {
	  /dc [0 1] def
	  /DeviceGray
	} {
	  /dc [0 1 0 1 0 1] def
	  /DeviceRGB
	} ifelse
	setcolorspace
	% the image data
	/im exch def
	% transformation matrix
	/mt exch def
	% width and height
	/h exch def
	/w exch def
	% the image dict
	/id
	<<
	  /ImageType 1
	  /Width w
	  /Height h
	  /ImageMatrix mt
	  /DataSource im
	  /BitsPerComponent 8
	  /Decode dc
	>> def
	% the mask dictionary
	/md
	<<
	  /ImageType 1
	  /Width w
	  /Height h
	  /ImageMatrix mt
	  /DataSource ma
	  /BitsPerComponent 1
	  /Decode [0 1]
	>> def
	% and the combined image dict
	<<
	  /ImageType 3
	  /DataDict id
	  /MaskDict md
	  /InterleaveType 3
	>> 
	image
      } {
	pop % no mask or can't use it, get rid of it
	8 % width height image 8|24 8 matrix
	4 1 roll
	8 eq { % grayscale
	  image
	} { %color
	  QCI
	} ifelse
      } ifelse
    } ifelse
  grestore    
} bind def


% ########## fix non level3 code path
% create a linear gradient pattern
% x1 y1 x2 y2 color_string size SetLinGrad --
/SetLinGrad {
  level3 {
    /size exch def
    /colors exch def
    /y2 exch def
    /x2 exch def
    /y1 exch def
    /x1 exch def
    /LinGrad 
    << 
      /PatternType 2
      /Shading 
	<<
        /ShadingType 2
	/ColorSpace [/DeviceRGB]
	/Coords [x1 y1 x2 y2]
	/Extend [true true]
	/Function 
	  <<
	  /FunctionType 0
	  /Domain [0 1]
          /Range [0 1 0 1 0 1]
	  /DataSource colors
          /BitsPerSample 8
	  /Size [size]
	  >>
	>>
      >>
    matrix makepattern def
  } { pop } ifelse
  /BSt 15 def
} bind def


/BF {                                % brush fill
  gsave
    BSt 1 eq                          % solid brush?
    {
      BCol SC
      WFi { fill } { eofill } ifelse
    } if
    BSt 2 ge BSt 8 le and             % dense pattern?
    {
      BDArr BSt 2 sub get /sc ED 
      % the following line scales the brush color according to the pattern. the higher the pattern the lighter the color.
      BCol 
      { 
	1. exch sub sc mul 1. exch sub 
      } forall 
      3 array astore
      SC 
      WFi { fill } { eofill } ifelse
    } if
    BSt 9 ge BSt 14 le and            % brush pattern?
    {
      WFi { clip } { eoclip } ifelse
      pathbbox                        % left upper right lower
      3 index 3 index translate
      4 2 roll                        % right lower left upper
      3 2 roll                        % right left upper lower
      exch                            % left right lower upper
      sub /h ED
      sub /w ED
      OMo {
	newpath
	0 0 moveto
	0 h rlineto
	w 0 rlineto
	0 h neg rlineto
	closepath
	BkCol SC
	fill
      } if
      BCol SC
      0.3 setlinewidth
      newpath
      BSt 9 eq BSt 11 eq or           % horiz or cross pattern
      { 0 4 h
	{ dup 0 exch moveto w exch lineto } for
      } if
      BSt 10 eq BSt 11 eq or          % vert or cross pattern
      { 0 4 w
	{ dup 0 moveto h lineto } for
      } if
      BSt 12 eq BSt 14 eq or          % F-diag or diag cross
      { w h gt
	{ 0 6 w h add
	  { dup 0 moveto h sub h lineto } for
	} { 0 6 w h add
	  { dup 0 exch moveto w sub w exch lineto } for
	} ifelse
      } if
      BSt 13 eq BSt 14 eq or          % B-diag or diag cross
      { w h gt
	{ 0 6 w h add
	  { dup h moveto h sub 0 lineto } for
	} { 0 6 w h add
	  { dup w exch moveto w sub 0 exch lineto } for
	} ifelse
      } if
      S
    } if
    BSt 15 eq
    {
      level3 {
	LinGrad setpattern
	WFi { fill } { eofill } ifelse
      } if
    } if
    BSt 24 eq                         % TexturePattern
    {
    } if
  grestore
} bind def

% for arc
/mat matrix def
/w D0 /h D0
/x D0 /y D0

/C D0

/P {                                 % PdcDrawPoint [x y]
  newpath
  moveto
  0.5 0.5 rmoveto
  0  -1 rlineto
  -1 0 rlineto
  0  1 rlineto
  closepath
  fill
} bind def

/DL {                                % PdcDrawLine [x1 y1 x0 y0]
  newpath
  moveto
  lineto
  QS
} bind def

/R {                                 % PdcDrawRect [x y w h]
  newpath
  re
  BF
  QS
} bind def

/E {                         % PdcDrawEllipse [x y w h]
  /h ED /w ED /y ED /x ED
  mat CM pop
  x w 2 div add y h 2 div add translate
  1 h w div scale
  newpath
  0 0 w 2 div 0 360 arc
  mat SM
  BF
  QS
} bind def

/BC {                                % PdcSetBkColor [[R G B]]
  /BkCol ED
} bind def

/BR {                                % PdcSetBrush [style [R G B]]
  /BCol ED /BSt ED
} bind def

/NB {                                % set nobrush
  0 [0 0 0] BR
} bind def

/PE {                                % PdcSetPen [style width R G B Cap Join]
  setlinejoin setlinecap
  /PCol ED
  /LWi ED
  /PSt ED
  PCol SC
} bind def

/P1 {                                % PdcSetPen [R G B]
  1 0 3 2 roll 0 0 PE
} bind def

/ST {                                % SET TRANSFORM [matrix]
  defM setmatrix
  concat
} bind def

%% Font handling

% the next three commands are for defining fonts. The first one
% tries to find the most suitable printer font out of a fontlist.
% if encoding is false the default one will be used.
/MF {                                % newname encoding fontlist
  % this function tries to find a suitable postscript font. 
  % We try quite hard not to get courier for a
  % proportional font. The following takes an array of fonts. 
  % The algorithm will take the first font that
  % gives a match (defined as not resulting in a courier font).
  % each entry in the table is an array of the form [ /Fontname x-stretch slant ]
  % x-strtch can be used to stretch/squeeze the font in x direction. 
  % This gives better results when eg substituting helvetica for arial
  % slant is an optional slant. 0 is non slanted, 0.2 is a typical value for a syntetic oblique.
  % encoding can be either an encoding vector of false if the default font encoding is requested.
  true exch true exch                          % push a dummy on the stack,
  {                          % so the loop over the array will leave a font in any case when exiting.
    exch pop exch pop                 % (dummy | oldfont) (dummy | fontdict) fontarray
    dup 0 get dup findfont           % get the fontname from the array and load it
    dup /FontName get                % see if the font exists
    3 -1 roll eq {                   % see if fontname and the one provided are equal
      exit
    } if
  } forall
  exch                               % font fontarray

  % newname encoding font fontarray      defines a postscript font
  dup
  1 get /fxscale exch def            % define scale, sland and encoding
  2 get /fslant exch def
  exch /fencoding exch def
  [ fxscale 0 fslant 1 0 0 ] makefont        % transform font accordingly
  fencoding false eq {               % check if we have an encoding and use it if available
  } {
    dup maxlength dict begin         % copy font
      {
	1 index /FID ne                        % don't copy FID, as it's not allowed in PS Level 1
	{def}{pop pop}ifelse
      } forall
      /Encoding fencoding def          % replace encoding
      currentdict 
    end
  } ifelse
  definefont pop
} bind def

% an embedded font. This is used for the base fonts of the composite font used later on.
/MFEmb {                             % newname encoding fontname
  findfont dup length dict 
  begin
    {
      1 index /FID ne
      {def}{pop pop}ifelse
    } forall
    /Encoding ED currentdict 
  end
  definefont pop
} bind def

% DF: define font
% used to get a scaled version of an already loaded font
%
%    newname pointsize fontmame DF -
/DF {
  findfont
  % get the fontsize on top of the stack and define font matrix
  /fs 3 -1 roll def [ fs 0 0 fs -1 mul 0 0 ]  
  makefont
  def
} bind def

/ty 0 def
/Y {
  /ty ED
} bind def

/Tl { % draw underline/strikeout line: () w x y lw ->Tl-> () w x
  gsave 
    setlinewidth
    newpath 1 index exch moveto
    1 index 0 rlineto stroke
  grestore
} bind def

/XYT {  % [string [x/y displacement array] width x]
  ty moveto % pops x

  /xyshow where { % interpreter has xyshow
    pop pop
    xyshow
  } { % use ashow
    exch pop % string cwidth
    1 index % string cwidth string
    dup length 2 div exch % string cwidth length string     !have to divide by 2 since we use unicode!
    stringwidth pop % string cwidth length pwidth
    3 -1 roll % string length pwidth cwidth
    exch sub exch div % string extraperchar
    exch 0 exch % extraperchar 0 string
    ashow
  } ifelse
} bind def

/AT {
  ty moveto % pops x
  1 index % string cwidth string
  dup length 2 div exch % string cwidth length string     !have to divide by 2 since we use unicode!
  stringwidth pop % string cwidth length pwidth
  3 -1 roll % string length pwidth cwidth
  exch sub exch div % string extraperchar
  exch 0 exch % extraperchar 0 string
  ashow
} bind def

%% start of page
/QI {
  /C save def
  pageinit
  /OMo false def
} bind def

%% end of page
/QP {                                % show page
  C restore
  showpage
} bind def

% merges one key value pair into the page device dict
%
%    key value SPD -
/SPD {
  /setpagedevice where {
    << 3 1 roll >>
    setpagedevice
  } { pop pop } ifelse
} bind def

/CLS {
  gsave
  newpath
} bind def

/ACR {                                       % add clip rect
  /h ED /w ED /y ED /x ED
  x y moveto
  0 h rlineto
  w 0 rlineto
  0 h neg rlineto
  closepath
} bind def

/CLO {                               % clipping off
  grestore                         % restore top of page state
} bind def

