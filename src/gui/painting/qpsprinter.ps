% the postscript header we use for our qpsprinter in uncompressed and commented form.
% use the makepsheader perl script to generate a compressed version of this header
% you can then paste into qpsprinter.cpp
%
% some compression of the code is done by the makepsheader script, so we don't need to 
% write too criptically here. 

/d  /def load def
/D  {bind d} bind d
/d2 {dup dup} D
/ED {exch d} D
/D0 {0 ED} D
/LT {lineto} D
/MT {moveto} D
/S  {stroke} D
/F  {setfont} D
/SW {setlinewidth} D
/CP {closepath} D
/RL {rlineto} D
/NP {newpath} D
/CM {currentmatrix} D
/SM {setmatrix} D
/TR {translate} D
/SD {setdash} D
/SC {aload pop setrgbcolor} D
/CR {currentfile read pop} D
/i  {index} D
/bs {bitshift} D
/scs {setcolorspace} D
/DB {dict dup begin} D
/DE {end d} D
/ie {ifelse} D

% ENDUNCOMPRESSED: Warning: leave this line in. 
% Everything before this line will be left untouched by the compression



/BSt 0 d                             % brush style
/LWi 0 d                             % line width
/PSt 1 d                             % pen style
/WFi false d                 % winding fill
/OMo false d                 % opaque mode (not transparent)

/BCol  [ 1 1 1 ] d                   % brush color
/PCol  [ 0 0 0 ] d                   % pen color
/BkCol [ 1 1 1 ] d                   % background color
/BDArr [                             % Brush dense patterns
  0.94
  0.88
  0.63
  0.50
  0.37 
  0.12 
  0.06 
] d
/defM matrix d

% -- level3 true/false
/level3 {
  /languagelevel where {
    pop
    languagelevel 3 ge 
  } { false } ifelse
} D

% LArr for the Pen styles is defined in emitHeader because of scaling

% GPS: GetPenStyle 
% Returns the line pattern (from pen style PSt).
%
%   bool GPS pattern
%   true : returns draw pattern
%   false: returns fill pattern
/GPS {
  PSt 1 ge PSt 5 le and                      % valid pen pattern?
  { 
    { LArr PSt 1 sub 2 mul get }           % draw pattern
    { LArr PSt 2 mul 1 sub get } ifelse    % opaque pattern
  }
  { [] } ifelse                            % out of range => solid line
} D

% QS: QtStroke
% draw and fill current path
%
%     - QS -
/QS {                                % stroke command
  PSt 0 ne                         % != NO_PEN
  { 
    gsave
      LWi SW                         % set line width
      true GPS 0 setdash S           % draw line pattern
      OMo PSt 1 ne and               % opaque mode and not solid line?
      { 
	BkCol SC
	false GPS dup 0 get setdash S % fill in opaque pattern
      } if
    grestore
  } if
} D

%% image drawing routines

/sl D0 % ### is this needed ?

% defines for QCI
/QCIgray D0 /QCIcolor D0 /QCIindex D0

% this method prints color images if colorimage is available, otherwise
% converts the string to a grayscale image and uses the reular postscript image
% operator for printing.
% Arguments are the same as for the image operator:
% 
%     width height bits/sample matrix datasrc QCI -
/QCI {
  /colorimage where {
    pop
    false 3 colorimage
  }{  % the hard way, based on PD code by John Walker <kelvin@autodesk.com>
    exec /QCIcolor ED
    /QCIgray QCIcolor length 3 idiv string d
    0 1 QCIcolor length 3 idiv 1 sub
    { /QCIindex ED
      /x QCIindex 3 mul d
      QCIgray QCIindex
      QCIcolor x       get 0.30 mul
      QCIcolor x 1 add get 0.59 mul
      QCIcolor x 2 add get 0.11 mul
      add add cvi
      put
    } for
    QCIgray image
  } ifelse
} D

% general image drawing routine, used from the postscript driver
%
% Draws images with and without mask with 1, 8 and 24(rgb) bits depth.
%
%     width height matrix image 1|8|24 mask|false x y di
%
% width and height specify the width/height of the image,
% matrix a transformation matrix, image a procedure holding the image data
% (same for mask) and x/y an additional translation.
%
% ### should move the translation into the matrix!!!
/di 
{
  gsave
    translate
    1 index 1 eq { % bitmap
      false eq { % no mask, draw solid background
	pop
	true 3 1 roll % width height false matrix image
	4 index
	4 index
	false
	4 index
	4 index
	imagemask
	BkCol SC
	imagemask
      } { 
	pop
	false 3 1 roll % width height false matrix image
	imagemask
      } ifelse
    } { 
      dup false ne { 
	% have a mask, see if we can use it
	level3
      } { 
	false 
      } ifelse

      {
	% languagelevel3, we can use image mask and dicts

	% store the image mask
	/ma exch d
	% select colorspace according to 8|24 bit depth and set the decode array /dc
	8 eq {
	  /dc [0 1] d
	  /DeviceGray
	} {
	  /dc [0 1 0 1 0 1] d
	  /DeviceRGB
	} ifelse
	setcolorspace
	% the image data
	/im exch d
	% transformation matrix
	/mt exch d
	% width and height
	/h exch def
	/w exch def
	% the image dict
	/id
	<<
	  /ImageType 1
	  /Width w
	  /Height h
	  /ImageMatrix mt
	  /DataSource im
	  /BitsPerComponent 8
	  /Decode dc
	>> d
	% the mask dictionary
	/md
	<<
	  /ImageType 1
	  /Width w
	  /Height h
	  /ImageMatrix mt
	  /DataSource ma
	  /BitsPerComponent 1
	  /Decode [0 1]
	>> d
	% and the combined image dict
	<<
	  /ImageType 3
	  /DataDict id
	  /MaskDict md
	  /InterleaveType 3
	>> 
	image
      } {
	pop % no mask or can't use it, get rid of it
	8 % width height image 8|24 8 matrix
	4 1 roll
	8 eq { % grayscale
	  image
	} { %color
	  QCI
	} ifelse
      } ifelse
    } ifelse
  grestore    
} d


% create a linear gradient pattern
% x1 y1 x2 y2 color1 color2 SetLinGrad --
/SetLinGrad {
  level3 {
    /c2 exch def
    /c1 exch def
    /y2 exch def
    /x2 exch def
    /y1 exch def
    /x1 exch def
    /LinGrad 
    << 
      /PatternType 2
      /Shading 
	<<
        /ShadingType 2
	/ColorSpace [/DeviceRGB]
	/Coords [x1 y1 x2 y2]
	/Extend [true true]
	/Function 
	  <<
	  /FunctionType 2
	  /Domain [0 1]
	  /C0 c1
	  /C1 c2
	  /N 1
	  >>
	>>
      >>
    matrix makepattern def
  } { pop } ifelse
  /BSt 15 d
} D



/BF {                                % brush fill
  gsave
    BSt 1 eq                          % solid brush?
    {
      BCol SC
      WFi { fill } { eofill } ifelse
    } if
    BSt 2 ge BSt 8 le and             % dense pattern?
    {
      BDArr BSt 2 sub get /sc ED 
      % the following line scales the brush color according to the pattern. the higher the pattern the lighter the color.
      BCol 
      { 
	1. exch sub sc mul 1. exch sub 
      } forall 
      3 array astore
      SC 
      WFi { fill } { eofill } ifelse
    } if
    BSt 9 ge BSt 14 le and            % brush pattern?
    {
      WFi { clip } { eoclip } ifelse
      defM SM
      pathbbox                        % left upper right lower
      3 index 3 index translate
      4 2 roll                        % right lower left upper
      3 2 roll                        % right left upper lower
      exch                            % left right lower upper
      sub /h ED
      sub /w ED
      OMo {
	NP
	0 0 MT
	0 h RL
	w 0 RL
	0 h neg RL
	CP
	BkCol SC
	fill
      } if
      BCol SC
      0.3 SW
      NP
      BSt 9 eq BSt 11 eq or           % horiz or cross pattern
      { 0 4 h
	{ dup 0 exch MT w exch LT } for
      } if
      BSt 10 eq BSt 11 eq or          % vert or cross pattern
      { 0 4 w
	{ dup 0 MT h LT } for
      } if
      BSt 12 eq BSt 14 eq or          % F-diag or diag cross
      { w h gt
	{ 0 6 w h add
	  { dup 0 MT h sub h LT } for
	} { 0 6 w h add
	  { dup 0 exch MT w sub w exch LT } for
	} ifelse
      } if
      BSt 13 eq BSt 14 eq or          % B-diag or diag cross
      { w h gt
	{ 0 6 w h add
	  { dup h MT h sub 0 LT } for
	} { 0 6 w h add
	  { dup w exch MT w sub 0 exch LT } for
	} ifelse
      } if
      S
    } if
    BSt 15 eq
    {
      level3 {
	LinGrad setpattern
	WFi { fill } { eofill } ifelse
      } if
    } if
    BSt 24 eq                         % TexturePattern
    {
    } if
  grestore
} D

% for arc
/mat matrix d
/ang1 D0 /ang2 D0
/w D0 /h D0
/x D0 /y D0

/ARC {                               % Generic ARC function [ X Y W H ang1 ang2 ]
  /ang2 ED /ang1 ED /h ED /w ED /y ED /x ED
  mat CM pop
  x w 2 div add y h 2 div add TR
  1 h w div neg scale
  ang2 0 ge
  {0 0 w 2 div ang1 ang1 ang2 add arc }
  {0 0 w 2 div ang1 ang1 ang2 add arcn} ifelse
  mat SM
} D

/C D0

/P {                                 % PdcDrawPoint [x y]
  NP
  MT
  0.5 0.5 rmoveto
  0  -1 RL
  -1 0 RL
  0  1 RL
  CP
  fill
} D

/DL {                                % PdcDrawLine [x1 y1 x0 y0]
  NP
  MT
  LT
  QS
} D

/R {                                 % PdcDrawRect [x y w h]
  /h ED /w ED /y ED /x ED
  NP
  x y MT
  0 h RL
  w 0 RL
  0 h neg RL
  CP
  BF
  QS
} D


/xr D0 /yr D0
/rx D0 /ry D0 /rx2 D0 /ry2 D0

/E {                         % PdcDrawEllipse [x y w h]
  /h ED /w ED /y ED /x ED
  mat CM pop
  x w 2 div add y h 2 div add translate
  1 h w div scale
  NP
  0 0 w 2 div 0 360 arc
  mat SM
  BF
  QS
} D

/BC {                                % PdcSetBkColor [[R G B]]
  /BkCol ED
} D

/BR {                                % PdcSetBrush [style [R G B]]
  /BCol ED /BSt ED
} D

/NB {                                % set nobrush
  0 [0 0 0] BR
} D

/PE {                                % PdcSetPen [style width R G B Cap Join]
  setlinejoin setlinecap
  /PCol ED
  /LWi ED
  /PSt ED
  PCol SC
} D

/P1 {                                % PdcSetPen [R G B]
  1 0 3 2 roll 0 0 PE
} D

/ST {                                % SET TRANSFORM [matrix]
  defM setmatrix
  concat
} D

%% Font handling

% the next three commands are for defining fonts. The first one
% tries to find the most suitable printer font out of a fontlist.
% if encoding is false the default one will be used.
/MF {                                % newname encoding fontlist
  % this function tries to find a suitable postscript font. 
  % We try quite hard not to get courier for a
  % proportional font. The following takes an array of fonts. 
  % The algorithm will take the first font that
  % gives a match (defined as not resulting in a courier font).
  % each entry in the table is an array of the form [ /Fontname x-stretch slant ]
  % x-strtch can be used to stretch/squeeze the font in x direction. 
  % This gives better results when eg substituting helvetica for arial
  % slant is an optional slant. 0 is non slanted, 0.2 is a typical value for a syntetic oblique.
  % encoding can be either an encoding vector of false if the default font encoding is requested.
  true exch true exch                          % push a dummy on the stack,
  {                          % so the loop over the array will leave a font in any case when exiting.
    exch pop exch pop                 % (dummy | oldfont) (dummy | fontdict) fontarray
    dup 0 get dup findfont           % get the fontname from the array and load it
    dup /FontName get                % see if the font exists
    3 -1 roll eq {                   % see if fontname and the one provided are equal
      exit
    } if
  } forall
  exch                               % font fontarray

  % newname encoding font fontarray      defines a postscript font
  dup
  1 get /fxscale exch def            % define scale, sland and encoding
  2 get /fslant exch def
  exch /fencoding exch def
  [ fxscale 0 fslant 1 0 0 ] makefont        % transform font accordingly
  fencoding false eq {               % check if we have an encoding and use it if available
  } {
    dup maxlength dict begin         % copy font
      {
	1 index /FID ne                        % don't copy FID, as it's not allowed in PS Level 1
	{def}{pop pop}ifelse
      } forall
      /Encoding fencoding def          % replace encoding
      currentdict 
    end
  } ifelse
  definefont pop
} D

% an embedded font. This is used for the base fonts of the composite font used later on.
/MFEmb {                             % newname encoding fontname
  findfont dup length dict 
  begin
    {
      1 index /FID ne
      {d}{pop pop}ifelse
    } forall
    /Encoding ED currentdict 
  end
  definefont pop
} D

% DF: define font
% used to get a scaled version of an already loaded font
%
%    newname pointsize fontmame DF -
/DF {
  findfont
  % get the fontsize on top of the stack and define font matrix
  /fs 3 -1 roll d [ fs 0 0 fs -1 mul 0 0 ]  
  makefont
  d
} D

/ty 0 d
/Y {
  /ty ED
} D

/Tl { % draw underline/strikeout line: () w x y lw ->Tl-> () w x
  gsave 
    setlinewidth
    NP 1 index exch MT
    1 index 0 rlineto stroke
  grestore
} D

/XYT {  % [string [x/y displacement array] width x]
  ty MT % pops x

  /xyshow where { % interpreter has xyshow
    pop pop
    xyshow
  } { % use ashow
    exch pop % string cwidth
    1 index % string cwidth string
    dup length 2 div exch % string cwidth length string     !have to divide by 2 since we use unicode!
    stringwidth pop % string cwidth length pwidth
    3 -1 roll % string length pwidth cwidth
    exch sub exch div % string extraperchar
    exch 0 exch % extraperchar 0 string
    ashow
  } ifelse
} D

/AT {
  ty MT % pops x
  1 index % string cwidth string
  dup length 2 div exch % string cwidth length string     !have to divide by 2 since we use unicode!
  stringwidth pop % string cwidth length pwidth
  3 -1 roll % string length pwidth cwidth
  exch sub exch div % string extraperchar
  exch 0 exch % extraperchar 0 string
  ashow
} D

%% start of page
/QI {
  /C save d
  pageinit
  /OMo false d
} D

%% end of page
/QP {                                % show page
  C restore
  showpage
} D

% merges one key value pair into the page device dict
%
%    key value SPD -
/SPD {
  /setpagedevice where {
    << 3 1 roll >>
    setpagedevice
  } { pop pop } ifelse
} D

/CLS {
  gsave
  NP
} D

/ACR {                                       % add clip rect
  /h ED /w ED /y ED /x ED
  x y MT
  0 h RL
  w 0 RL
  0 h neg RL
  CP
} D

/CLO {                               % clipping off
  grestore                         % restore top of page state
} D

