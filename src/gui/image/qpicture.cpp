/****************************************************************************
**
** Implementation of QPicture class.
**
** Copyright (C) 1992-$THISYEAR$ Trolltech AS. All rights reserved.
**
** This file is part of the kernel module of the Qt GUI Toolkit.
** EDITIONS: FREE, PROFESSIONAL, ENTERPRISE
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
****************************************************************************/

#include "qpicture.h"

#ifndef QT_NO_PICTURE

#include "private/qpaintengine_pic_p.h"
#include "qdatastream.h"
#include "qfile.h"
#include "qimage.h"
#include "qpaintdevicemetrics.h"
#include "qpainter.h"
#include "qpixmap.h"
#include "qregion.h"
#include "qmutex.h"
#include "private/qfactoryloader_p.h"

/*!
    \class QPicture qpicture.h
    \brief The QPicture class is a paint device that records and
    replays QPainter commands.

    \ingroup multimedia
    \ingroup shared

    A picture serializes painter commands to an IO device in a
    platform-independent format. For example, a picture created under
    Windows can be read on a Sun SPARC.

    Pictures are called meta-files on some platforms.

    Qt pictures use a proprietary binary format. Unlike native picture
    (meta-file) formats on many window systems, Qt pictures have no
    limitations regarding their contents. Everything that can be
    painted can also be stored in a picture, e.g. fonts, pixmaps,
    regions, transformed graphics, etc.

    QPicture can also read and write SVG (Scalable Vector Graphics)
    files; these files are in an XML format specified by \link
    http://www.w3.org/Graphics/SVG/ W3C\endlink. (See the load() and
    save() functions.)
\if defined(commercial)
    The SVG capability requires Qt's XML module which is part of
    \link commercialeditions.html Qt Enterprise Edition\endlink.
\endif

    QPicture is an \link shclass.html implicitly shared\endlink class.

    Example of how to record a picture:
    \code
    QPicture  pic;
    QPainter  p;
    p.begin(&pic);               // paint in picture
    p.drawEllipse(10,20, 80,70); // draw an ellipse
    p.end();                     // painting done
    pic.save("drawing.pic");     // save picture
    \endcode

    Example of how to replay a picture:
    \code
    QPicture  pic;
    pic.load("drawing.pic");     // load picture
    QPainter  p;
    p.begin(&myWidget);          // paint in myWidget
    p.drawPicture(pic);          // draw the picture
    p.end();                     // painting done
    \endcode

    Pictures can also be drawn using play(). Some basic data about a
    picture is available, for example, size(), isNull() and
    boundingRect().

*/

const char  *mfhdr_tag = "QPIC"; // header tag
const Q_UINT16 mfhdr_maj = 6; // major version #
const Q_UINT16 mfhdr_min = 0; // minor version #

#define d d_func()
#define q q_func()

/*!
    Constructs an empty picture.

    The \a formatVersion parameter may be used to \e create a QPicture
    that can be read by applications that are compiled with earlier
    versions of Qt.
    \list
    \i \a formatVersion == 1 is binary compatible with Qt 1.x and later.
    \i \a formatVersion == 2 is binary compatible with Qt 2.0.x and later.
    \i \a formatVersion == 3 is binary compatible with Qt 2.1.x and later.
    \i \a formatVersion == 4 is binary compatible with Qt 3.0.x and later.
    \i \a formatVersion == 5 is binary compatible with Qt 3.1.
    \endlist

    Note that the default formatVersion is -1 which signifies the
    current release, i.e. for Qt 3.1 a formatVersion of 5 is the same
    as the default formatVersion of -1.

    Reading pictures generated by earlier versions of Qt is supported
    and needs no special coding; the format is automatically detected.
*/

QPicture::QPicture(int formatVersion)
    : QPaintDevice(QInternal::Picture | QInternal::ExternalDevice),
      d_ptr(new QPicturePrivate)
{
    d_ptr->q_ptr = this;
    d->paintEngine = 0;

    if (formatVersion == 0)
        qWarning("QPicture: invalid format version 0");

    // still accept the 0 default from before Qt 3.0.
    if (formatVersion > 0 && formatVersion != (int)mfhdr_maj) {
        d->formatMajor = formatVersion;
        d->formatMinor = 0;
        d->formatOk = false;
    }
    else {
        d->resetFormat();
    }
}

/*!
    Constructs a \link shclass.html shallow copy\endlink of \a pic.
*/

QPicture::QPicture(const QPicture &pic)
    : QPaintDevice(QInternal::Picture | QInternal::ExternalDevice), d_ptr(pic.d_ptr)
{
    ++d->ref;
}

/*! \internal */
QPicture::QPicture(QPicturePrivate &dptr)
    : QPaintDevice(QInternal::Picture | QInternal::ExternalDevice),
      d_ptr(&dptr)
{
    d_ptr->q_ptr = this;
}

/*!
    Destroys the picture.
*/
QPicture::~QPicture()
{
    if (!--d->ref)
        delete d;
}


/*!
    \fn bool QPicture::isNull() const

    Returns true if the picture contains no data; otherwise returns
    false.
*/

/*!
    \fn uint QPicture::size() const

    Returns the size of the picture data.

    \sa data()
*/

/*!
    \fn const char* QPicture::data() const

    Returns a pointer to the picture data. The pointer is only valid
    until the next non-const function is called on this picture. The
    returned pointer is 0 if the picture contains no data.

    \sa size(), isNull()
*/

/*!
    Sets the picture data directly from \a data and \a size. This
    function copies the input data.

    \sa data(), size()
*/

void QPicture::setData(const char* data, uint size)
{
    detach();
    d->pictb.setData(data, size);
    d->resetFormat();                                // we'll have to check
}


/*!
    Loads a picture from the file specified by \a fileName and returns
    true if successful; otherwise returns false.

    By default, the file will be interpreted as being in the native
    QPicture format. Specifying the \a format string is optional and
    is only needed for importing picture data stored in a different
    format.

    Currently, the only external format supported is the \link
    http://www.w3.org/Graphics/SVG/ W3C SVG\endlink format. The
    corresponding \a format string is "svg".
\if defined(commercial)
    The SVG capability requires Qt's XML module which is part of
    \link commercialeditions.html Qt Enterprise Edition\endlink.
\endif

    \sa save()
*/

bool QPicture::load(const QString &fileName, const char *format)
{
    QFile f(fileName);
    if (!f.open(IO_ReadOnly))
        return false;
    return load(&f, format);
}

/*!
    \overload

    \a dev is the device to use for loading.
*/

bool QPicture::load(QIODevice *dev, const char *format)
{
    if(format) {
#ifndef QT_NO_PICTUREIO
        QPictureIO io(dev, format);
        bool result = io.read();
        if (result) {
            operator=(io.picture());

        } else if (format)
#else
            bool result = false;
#endif
        {
            qWarning("QPicture::load: No such picture format: %s", format);
        }
        return result;
    }

    detach();
    QByteArray a = dev->readAll();

    d->pictb.setData(a);                        // set byte array in buffer
    return d->checkFormat();
}

/*!
    Saves a picture to the file specified by \a fileName and returns
    true if successful; otherwise returns false.

    Specifying the file \a format string is optional. By default the
    data will be saved in the native QPicture file format. Currently
    the only other format that you can save in is \link
    http://www.w3.org/Graphics/SVG/ W3C's SVG format\endlink; use a
    \a format name of "svg" to save in SVG format.
\if defined(commercial)
    The SVG capability requires Qt's XML module which is part of
    \link commercialeditions.html Qt Enterprise Edition\endlink.
\endif
    \sa load()
*/

bool QPicture::save(const QString &fileName, const char *format)
{
    if (paintingActive()) {
        qWarning("QPicture::save: still being painted on. "
                  "Call QPainter::end() first");
        return false;
    }


    if(format) {
#ifndef QT_NO_PICTUREIO
        QPictureIO io(fileName, format);
        bool result = io.write();
        if (result) {
            operator=(io.picture());
        } else if (format)
#else
        bool result = false;
#endif
        {
            qWarning("QPicture::save: No such picture format: %s", format);
        }
        return result;
    }

    QFile f(fileName);
    if (!f.open(IO_WriteOnly))
        return false;
    return save(&f, format);
}

/*!
    \overload

    \a dev is the device to use for saving.
*/

bool QPicture::save(QIODevice *dev, const char *format)
{
    if (paintingActive()) {
        qWarning("QPicture::save: still being painted on. "
                  "Call QPainter::end() first");
        return false;
    }

    if(format) {
#ifndef QT_NO_PICTUREIO
        QPictureIO io(dev, format);
        bool result = io.write();
        if (result) {
            operator=(io.picture());
        } else if (format)
#else
        bool result = false;
#endif
        {
            qWarning("QPicture::save: No such picture format: %s", format);
        }
        return result;
    }

    dev->writeBlock(d->pictb.buffer(), d->pictb.buffer().size());
    return true;
}

/*!
    Returns the picture's bounding rectangle or an invalid rectangle
    if the picture contains no data.
*/

QRect QPicture::boundingRect() const
{
    if (!d->formatOk)
        d_ptr->checkFormat();
    return d->brect;
}

/*!
    Sets the picture's bounding rectangle to \a r. The automatically
    calculated value is overridden.
*/

void QPicture::setBoundingRect(const QRect &r)
{
    if (!d->formatOk)
        d->checkFormat();
    d->brect = r;
}

/*!
    Replays the picture using \a painter, and returns true if
    successful; otherwise returns false.

    This function does exactly the same as QPainter::drawPicture()
    with (x, y) = (0, 0).
*/

bool QPicture::play(QPainter *painter)
{
    if (d->pictb.size() == 0)                        // nothing recorded
        return true;

    if (!d->formatOk && !d->checkFormat())
        return false;

    d->pictb.open(IO_ReadOnly);                // open buffer device
    QDataStream s;
    s.setDevice(&d->pictb);                        // attach data stream to buffer
    s.device()->seek(10);                        // go directly to the data
    s.setVersion(d->formatMajor == 4 ? 3 : d->formatMajor);

    Q_UINT8  c, clen;
    Q_UINT32 nrecords;
    s >> c >> clen;
    Q_ASSERT(c == PdcBegin);
    // bounding rect was introduced in ver 4. Read in checkFormat().
    if (d->formatMajor >= 4) {
        Q_INT32 dummy;
        s >> dummy >> dummy >> dummy >> dummy;
    }
    s >> nrecords;
    if (!exec(painter, s, nrecords)) {
        qWarning("QPicture::play: Format error");
        d->pictb.close();
        return false;
    }
    d->pictb.close();
    return true;                                // no end-command
}


/*!
  \internal
  Iterates over the internal picture data and draws the picture using
  \a painter.
*/

bool QPicture::exec(QPainter *painter, QDataStream &s, int nrecords)
{
#if defined(QT_DEBUG)
    int                strm_pos;
#endif
    Q_UINT8        c;                                // command id
    Q_UINT8        tiny_len;                        // 8-bit length descriptor
    Q_INT32        len, i1_32, i2_32;                // 32-bit length descriptor
    Q_INT16        i_16, i1_16, i2_16;                // parameters...
    Q_INT8        i_8;
    Q_UINT32        ul;
    QByteArray        str1;
    QString        str;
    QPoint        p, p1, p2;
    QRect        r;
    QPointArray a;
    QColor        color;
    QFont        font;
    QPen        pen;
    QBrush        brush;
    QRegion        rgn;
#ifndef QT_NO_TRANSFORMATIONS
    QWMatrix        matrix;
#endif

    while (nrecords-- && !s.eof()) {
        s >> c;                                        // read cmd
        s >> tiny_len;                                // read param length
        if (tiny_len == 255)                        // longer than 254 bytes
            s >> len;
        else
            len = tiny_len;
#if defined(QT_DEBUG)
        strm_pos = s.device()->at();
#endif
        switch (c) {                                // exec cmd
            case PdcNOP:
                break;
            case PdcDrawPoint:
                s >> p;
                painter->drawPoint(p);
                break;
            case PdcDrawPoints:
                s >> a >> i1_32 >> i2_32;
                painter->drawPoints(a, i1_32, i2_32);
                break;
            case PdcDrawLine:
                s >> p1 >> p2;
                painter->drawLine(p1, p2);
                break;
            case PdcDrawRect:
                s >> r;
                painter->drawRect(r);
                break;
            case PdcDrawRoundRect:
                s >> r >> i1_16 >> i2_16;
                painter->drawRoundRect(r, i1_16, i2_16);
                break;
            case PdcDrawEllipse:
                s >> r;
                painter->drawEllipse(r);
                break;
            case PdcDrawArc:
                s >> r >> i1_16 >> i2_16;
                painter->drawArc(r, i1_16, i2_16);
                break;
            case PdcDrawPie:
                s >> r >> i1_16 >> i2_16;
                painter->drawPie(r, i1_16, i2_16);
                break;
            case PdcDrawChord:
                s >> r >> i1_16 >> i2_16;
                painter->drawChord(r, i1_16, i2_16);
                break;
            case PdcDrawLineSegments:
                s >> a;
                painter->drawLineSegments(a);
                break;
            case PdcDrawPolyline:
                s >> a;
                painter->drawPolyline(a);
                break;
            case PdcDrawPolygon:
                s >> a >> i_8;
                painter->drawPolygon(a, i_8);
                break;
            case PdcDrawCubicBezier:
                s >> a;
#ifndef QT_NO_BEZIER
                painter->drawCubicBezier(a);
#endif
                break;
            case PdcDrawText:
                s >> p >> str1;
                painter->drawText(p, str1);
                break;
            case PdcDrawTextFormatted:
                s >> r >> i_16 >> str1;
                painter->drawText(r, i_16, str1);
                break;
            case PdcDrawText2:
                s >> p >> str;
                painter->drawText(p, str);
                break;
            case PdcDrawText2Formatted:
                s >> r >> i_16 >> str;
                painter->drawText(r, i_16, str);
                break;
            case PdcDrawPixmap: {
                QPixmap pixmap;
                if (d->formatMajor < 4) {
                    s >> p >> pixmap;
                    painter->drawPixmap(p, pixmap);
                } else {
                    s >> r >> pixmap;
                    painter->drawPixmap(r, pixmap);
                }
            }
                break;
            case PdcDrawTiledPixmap: {
                QPixmap pixmap;
                s >> r >> pixmap >> p;
                painter->drawTiledPixmap(r, pixmap, p);
            }
                break;
            case PdcDrawImage: {
                QImage image;
                if (d->formatMajor < 4) {
                    s >> p >> image;
                    painter->drawPixmap(p, image);
                } else {
                    s >> r >> image;
                    painter->drawPixmap(r, image);
                }
            }
                break;
            case PdcBegin:
                s >> ul;                        // number of records
                if (!exec(painter, s, ul))
                    return false;
                break;
            case PdcEnd:
                if (nrecords == 0)
                    return true;
                break;
            case PdcSave:
                painter->save();
                break;
            case PdcRestore:
                painter->restore();
                break;
            case PdcSetBkColor:
                s >> color;
                painter->setBackground(color);
                break;
            case PdcSetBkMode:
                s >> i_8;
                painter->setBackgroundMode((Qt::BGMode)i_8);
                break;
	    case PdcSetROP: // NOP
                break;
            case PdcSetBrushOrigin:
                s >> p;
                painter->setBrushOrigin(p);
                break;
            case PdcSetFont:
                s >> font;
                painter->setFont(font);
                break;
            case PdcSetPen:
                s >> pen;
                painter->setPen(pen);
                break;
            case PdcSetBrush:
                s >> brush;
                painter->setBrush(brush);
                break;
// #ifdef Q_Q3PAINTER
//         case PdcSetTabStops:
//                 s >> i_16;
//                 painter->setTabStops(i_16);
//                 break;
//             case PdcSetTabArray:
//                 s >> i_16;
//                 if (i_16 == 0) {
//                     painter->setTabArray(0);
//                 } else {
//                     int *ta = new int[i_16];
//                     for (int i=0; i<i_16; i++) {
//                         s >> i1_16;
//                         ta[i] = i1_16;
//                     }
//                     painter->setTabArray(ta);
//                     delete [] ta;
//                 }
//                 break;
// #endif
            case PdcSetVXform:
                s >> i_8;
#ifndef QT_NO_TRANSFORMATIONS
                painter->setViewXForm(i_8);
#endif
                break;
            case PdcSetWindow:
                s >> r;
#ifndef QT_NO_TRANSFORMATIONS
                painter->setWindow(r);
#endif
                break;
            case PdcSetViewport:
                s >> r;
#ifndef QT_NO_TRANSFORMATIONS
                painter->setViewport(r);
#endif
                break;
            case PdcSetWXform:
                s >> i_8;
#ifndef QT_NO_TRANSFORMATIONS
                painter->setWorldXForm(i_8);
#endif
                break;
            case PdcSetWMatrix:
#ifndef QT_NO_TRANSFORMATIONS
                s >> matrix >> i_8;
                painter->setWorldMatrix(matrix, i_8);
#endif
                break;
#ifndef QT_NO_TRANSFORMATIONS
// #ifdef Q_Q3PAINTER
//             case PdcSaveWMatrix:
//                 painter->saveWorldMatrix();
//                 break;
//             case PdcRestoreWMatrix:
//                 painter->restoreWorldMatrix();
//                 break;
// #endif
#endif
            case PdcSetClip:
                s >> i_8;
                painter->setClipping(i_8);
                break;
            case PdcSetClipRegion:
                s >> rgn >> i_8;
                painter->setClipRegion(rgn);
                break;
            default:
                qWarning("QPicture::play: Invalid command %d", c);
                if (len)                        // skip unknown command
                    s.device()->seek(s.device()->at()+len);
        }
#if defined(QT_DEBUG)
        //qDebug("device->at(): %i, strm_pos: %i len: %i", s.device()->at(), strm_pos, len);
        Q_ASSERT(Q_INT32(s.device()->at() - strm_pos) == len);
#endif
    }
    return false;
}

/*!
    Internal implementation of the virtual QPaintDevice::metric()
    function.

    Use the QPaintDeviceMetrics class instead.

    A picture has the following hard-coded values: dpi=72,
    numcolors=16777216 and depth=24.

    \a m is the metric to get.
*/

int QPicture::metric(int m) const
{
    int val;
    switch (m) {
        case QPaintDeviceMetrics::PdmWidth:
            val = d->brect.width();
            break;
        case QPaintDeviceMetrics::PdmHeight:
            val = d->brect.height();
            break;
        case QPaintDeviceMetrics::PdmWidthMM:
            val = int(25.4/72.0*d->brect.width());
            break;
        case QPaintDeviceMetrics::PdmHeightMM:
            val = int(25.4/72.0*d->brect.height());
            break;
        case QPaintDeviceMetrics::PdmDpiX:
        case QPaintDeviceMetrics::PdmPhysicalDpiX:
            val = 72;
            break;
        case QPaintDeviceMetrics::PdmDpiY:
        case QPaintDeviceMetrics::PdmPhysicalDpiY:
            val = 72;
            break;
        case QPaintDeviceMetrics::PdmNumColors:
            val = 16777216;
            break;
        case QPaintDeviceMetrics::PdmDepth:
            val = 24;
            break;
        default:
            val = 0;
            qWarning("QPicture::metric: Invalid metric command");
    }
    return val;
}

/*!
    \fn void QPicture::detach()
    \internal
    Detaches from shared picture data and makes sure that this picture
    is the only one referring to the data.

    If multiple pictures share common data, this picture makes a copy
    of the data and detaches itself from the sharing mechanism.
    Nothing is done if there is just a single reference.
*/

/*! \fn bool QPicture::isDetached() const
    \internal
*/
void QPicture::detach_helper()
{
    QPicturePrivate *x = new QPicturePrivate;
    int pictsize = size();
    x->pictb.setData(data(), pictsize);
    if (d->pictb.isOpen()) {
        x->pictb.open(d->pictb.mode());
        x->pictb.seek(d->pictb.at());
    }
    x->trecs = d->trecs;
    x->formatOk = d->formatOk;
    x->formatMinor = d->formatMinor;
    x->brect = boundingRect();
    x = qAtomicSetPtr(&d_ptr, x);
    if (!--x->ref)
        delete x;
}

QPicture& QPicture::operator=(const QPicture &p)
{
    qAtomicAssign<QPicturePrivate>(d_ptr, p.d_ptr);
    return *this;
}

/*!
  \internal

  Sets formatOk to false and resets the format version numbers to default
*/

void QPicturePrivate::resetFormat()
{
    formatOk = false;
    formatMajor = mfhdr_maj;
    formatMinor = mfhdr_min;
}


/*!
  \internal

  Checks data integrity and format version number. Set formatOk to
  true on success, to false otherwise. Returns the resulting formatOk
  value.
*/
bool QPicturePrivate::checkFormat()
{
    resetFormat();

    // can't check anything in an empty buffer
    if (pictb.size() == 0)
        return false;

    pictb.open(IO_ReadOnly);                        // open buffer device
    QDataStream s;
    s.setDevice(&pictb);                        // attach data stream to buffer

    char mf_id[4];                                // picture header tag
    s.readRawBytes(mf_id, 4);                        // read actual tag
    if (memcmp(mf_id, mfhdr_tag, 4) != 0) {         // wrong header id
        qWarning("QPicturePaintEngine::checkFormat: Incorrect header");
        pictb.close();
        return false;
    }

    int cs_start = sizeof(Q_UINT32);                // pos of checksum word
    int data_start = cs_start + sizeof(Q_UINT16);
    Q_UINT16 cs,ccs;
    QByteArray buf = pictb.buffer();        // pointer to data

    s >> cs;                                // read checksum
    ccs = (Q_UINT16) qChecksum(buf.constData() + data_start, buf.size() - data_start);
    if (ccs != cs) {
        qWarning("QPicturePaintEngine::checkFormat: Invalid checksum %x, %x expected",
                  ccs, cs);
        pictb.close();
        return false;
    }

    Q_UINT16 major, minor;
    s >> major >> minor;                        // read version number
    if (major > mfhdr_maj) {                // new, incompatible version
        qWarning("QPicturePaintEngine::checkFormat: Incompatible version %d.%d",
                  major, minor);
        pictb.close();
        return false;
    }
    s.setVersion(major != 4 ? major : 3);

    Q_UINT8  c, clen;
    s >> c >> clen;
    if (c == PdcBegin) {
        if (!(major >= 1 && major <= 3)) {
            Q_INT32 l, t, w, h;
            s >> l >> t >> w >> h;
            brect = QRect(l, t, w, h);
        }
    } else {
        qWarning("QPicturePaintEngine::checkFormat: Format error");
        pictb.close();
        return false;
    }
    pictb.close();

    formatOk = true;                        // picture seems to be ok
    formatMajor = major;
    formatMinor = minor;
    return true;
}

/*! \internal */
QPaintEngine *QPicture::paintEngine() const
{
    if (!d->paintEngine)
        const_cast<QPicture*>(this)->d->paintEngine = new QPicturePaintEngine;
    return d->paintEngine;
}

/*****************************************************************************
  QPicture stream functions
 *****************************************************************************/

/*!
    \relates QPicture

    Writes picture \a r to the stream \a s and returns a reference to
    the stream.
*/

QDataStream &operator<<(QDataStream &s, const QPicture &r)
{
    Q_UINT32 size = r.d->pictb.buffer().size();
    s << size;
    // null picture ?
    if (size == 0)
        return s;
    // just write the whole buffer to the stream
    return s.writeRawBytes (r.d->pictb.buffer(), r.d->pictb.buffer().size());
}

/*!
    \relates QPicture

    Reads a picture from the stream \a s into picture \a r and returns
    a reference to the stream.
*/

QDataStream &operator>>(QDataStream &s, QPicture &r)
{
    QDataStream sr;

    // "init"; this code is similar to the beginning of QPicture::cmd()
    sr.setDevice(&r.d->pictb);
    sr.setVersion(r.d->formatMajor);
    Q_UINT32 len;
    s >> len;
    QByteArray data;
    if (len > 0) {
        data.resize(len);
        s.readRawBytes(data.data(), len);
    }

    r.d->pictb.setData(data);
    r.d->resetFormat();
    return s;
}

#undef d
#undef q

#ifndef QT_NO_PICTUREIO
#include "qregexp.h"
#include "qapplication.h"
#include "qpictureformatplugin.h"
#include "private/qfactoryloader_p.h"
#include "qfile.h"

/*!
    Returns a string that specifies the picture format of the file \a
    fileName, or 0 if the file cannot be read or if the format is not
    recognized.

    The QPictureIO documentation lists the guaranteed supported picture
    formats, or use QPicture::inputFormats() and QPicture::outputFormats()
    to get lists that include the installed formats.

    \sa load() save()
*/

const char* QPicture::pictureFormat(const QString &fileName)
{
    return QPictureIO::pictureFormat(fileName);
}

/*!
    Returns a list of picture formats that are supported for picture
    input.

    \sa outputFormats() inputFormatList() QPictureIO
*/
QList<QByteArray> QPicture::inputFormats()
{
    return QPictureIO::inputFormats();
}

static QStringList qToStringList(const QList<QByteArray> arr)
{
    QStringList list;
    for (int i = 0; i < arr.count(); ++i)
        list.append(QString(arr.at(i)));
    return list;
}

/*!
    Returns a list of picture formats that are supported for picture
    input.

    Note that if you want to iterate over the list, you should iterate
    over a copy, e.g.
    \code
    QStringList list = myPicture.inputFormatList();
    QStringList::Iterator it = list.begin();
    while(it != list.end()) {
        myProcessing(*it);
        ++it;
    }
    \endcode

    \sa outputFormatList() inputFormats() QPictureIO
*/
QStringList QPicture::inputFormatList()
{
    return qToStringList(QPictureIO::inputFormats());
}


/*!
    Returns a list of picture formats that are supported for picture
    output.

    Note that if you want to iterate over the list, you should iterate
    over a copy, e.g.
    \code
    QStringList list = myPicture.outputFormatList();
    QStringList::Iterator it = list.begin();
    while(it != list.end()) {
        myProcessing(*it);
        ++it;
    }
    \endcode

    \sa inputFormatList() outputFormats() QPictureIO
*/
QStringList QPicture::outputFormatList()
{
    return qToStringList(QPictureIO::outputFormats());
}

/*!
    Returns a list of picture formats that are supported for picture
    output.

    \sa inputFormats() outputFormatList() QPictureIO
*/
QList<QByteArray> QPicture::outputFormats()
{
    return QPictureIO::outputFormats();
}

/*****************************************************************************
  QPictureIO member functions
 *****************************************************************************/

/*!
    \class QPictureIO qpicture.h

    \brief The QPictureIO class contains parameters for loading and
    saving pictures.

    \ingroup multimedia
    \ingroup io

    QPictureIO contains a QIODevice object that is used for picture data
    I/O. The programmer can install new picture file formats in addition
    to those that Qt provides.

    Qt currently only supports \link http://www.w3.org/Graphics/SVG/
    W3C SVG \endlink picture file formats (with type string svg).
\if defined(commercial)
    The SVG capability requires Qt's XML module which is part of
    \link commercialeditions.html Qt Enterprise Edition\endlink.
\endif

    You don't normally need to use this class; QPicture::load(),
    QPiicture::save().

    \sa QPicture QPixmap QFile
*/

struct QPictureIOData
{
    QPicture        pi;                                // picture
    int                iostat;                                // IO status
    QByteArray        frmt;                                // picture format
    QIODevice  *iodev;                                // IO device
    QString        fname;                                // file name
    QString     descr;                                // picture description
    const char *parameters;
    int quality;
    float gamma;
};

/*!
    Constructs a QPictureIO object with all parameters set to zero.
*/

QPictureIO::QPictureIO()
{
    init();
}

/*!
    Constructs a QPictureIO object with the I/O device \a ioDevice and a
    \a format tag.
*/

QPictureIO::QPictureIO(QIODevice *ioDevice, const char *format)
{
    init();
    d->iodev = ioDevice;
    d->frmt = format;
}

/*!
    Constructs a QPictureIO object with the file name \a fileName and a
    \a format tag.
*/

QPictureIO::QPictureIO(const QString &fileName, const char* format)
{
    init();
    d->frmt = format;
    d->fname = fileName;
}

/*!
    Contains initialization common to all QPictureIO constructors.
*/

void QPictureIO::init()
{
    d = new QPictureIOData();
    d->parameters = 0;
    d->quality = -1; // default quality of the current format
    d->gamma=0.0f;
    d->iostat = 0;
    d->iodev  = 0;
}

/*!
    Destroys the object and all related data.
*/

QPictureIO::~QPictureIO()
{
    if (d->parameters)
        delete [] (char*)d->parameters;
    delete d;
}


/*****************************************************************************
  QPictureIO picture handler functions
 *****************************************************************************/

class QPictureHandler
{
public:
    QPictureHandler(const char *f, const char *h, const QByteArray& fl,
                     picture_io_handler r, picture_io_handler w);
    QByteArray              format;                        // picture format
    QRegExp              header;                        // picture header pattern
    enum TMode { Untranslated=0, TranslateIn, TranslateInOut } text_mode;
    picture_io_handler  read_picture;                // picture read function
    picture_io_handler  write_picture;                // picture write function
    bool              obsolete;                        // support not "published"
};

QPictureHandler::QPictureHandler(const char *f, const char *h, const QByteArray& fl,
                              picture_io_handler r, picture_io_handler w)
    : format(f), header(QString::fromLatin1(h))
{
    text_mode = Untranslated;
    if (fl.contains('t'))
        text_mode = TranslateIn;
    else if (fl.contains('T'))
        text_mode = TranslateInOut;
    obsolete = fl.contains('O');
    read_picture  = r;
    write_picture = w;
}

typedef QList<QPictureHandler *> QPHList;
static QPHList pictureHandlers;

#ifndef QT_NO_COMPONENT
Q_GLOBAL_STATIC_WITH_ARGS(QFactoryLoader, loader,
                          (QPictureFormatInterface_iid,
                           QCoreApplication::libraryPaths(),
                           "/pictureformats"))
#endif
void qt_init_picture_plugins()
{
#ifndef QT_NO_COMPONENT
    static QStaticMutex mutex = 0;
    if (mutex)
        return;
    QMutexLocker locker(mutex);
    QFactoryLoader *loader = ::loader();
    QStringList keys = loader->keys();
    for (int i = 0; i < keys.count(); ++i)
        if (QPictureFormatInterface *format = qt_cast<QPictureFormatInterface*>(loader->instance(keys.at(i))))
            format->installIOHandler(keys.at(i));
#endif
}

static void cleanup()
{
    // make sure that picture handlers are delete before plugin manager
    while (!pictureHandlers.isEmpty())
        delete pictureHandlers.takeFirst();
}

void qt_init_picture_handlers()                // initialize picture handlers
{
    static bool done = false;
    if (done) return;
    done = true;

    qAddPostRoutine(cleanup);
}

static QPictureHandler *get_picture_handler(const char *format)
{                                                // get pointer to handler
    qt_init_picture_handlers();
    qt_init_picture_plugins();
    for (int i = 0; i < pictureHandlers.size(); ++i) {
        if (pictureHandlers.at(i)->format == format)
            return pictureHandlers.at(i);
    }
    return 0;                                        // no such handler
}


/*!
    Defines a picture I/O handler for the picture format called \a
    format, which is recognized using the \link qregexp.html#details
    regular expression\endlink \a header, read using \a readPicture and
    written using \a writePicture.

    \a flags is a string of single-character flags for this format.
    The only flag defined currently is T (upper case), so the only
    legal value for \a flags are "T" and the empty string. The "T"
    flag means that the picture file is a text file, and Qt should treat
    all newline conventions as equivalent. (XPM files and some PPM
    files are text files for example.)

    \a format is used to select a handler to write a QPicture; \a header
    is used to select a handler to read an picture file.

    If \a readPicture is a null pointer, the QPictureIO will not be able
    to read pictures in \a format. If \a writePicture is a null pointer,
    the QPictureIO will not be able to write pictures in \a format. If
    both are null, the QPictureIO object is valid but useless.

    Example:
    \code
        void readSVG(QPictureIO *picture)
        {
        // read the picture using the picture->ioDevice()
        }

        void writeSVG(QPictureIO *picture)
        {
        // write the picture using the picture->ioDevice()
        }

        // add the SVG picture handler

        QPictureIO::defineIOHandler("SVG",
                                   0, 0,
                                   readSVG, writeSVG);
    \endcode

    Before the regex test, all the 0 bytes in the file header are
    converted to 1 bytes. This is done because when Qt was
    ASCII-based, QRegExp could not handle 0 bytes in strings.

    The regexp is only applied on the first 14 bytes of the file.

    (Note that if one handlerIO supports writing a format and another
    supports reading it, Qt supports both reading and writing. If two
    handlers support the same operation, Qt chooses one arbitrarily.)
*/

void QPictureIO::defineIOHandler(const char *format,
                                const char *header,
                                const char *flags,
                                picture_io_handler readPicture,
                                picture_io_handler writePicture)
{
    qt_init_picture_handlers();
    QPictureHandler *p;
    p = new QPictureHandler(format, header, QByteArray(flags), readPicture, writePicture);
    pictureHandlers.prepend(p);
}


/*****************************************************************************
  QPictureIO normal member functions
 *****************************************************************************/

/*!
    Returns the picture currently set.

    \sa setPicture()
*/
const QPicture &QPictureIO::picture() const { return d->pi; }

/*!
    Returns the picture's IO status. A non-zero value indicates an
    error, whereas 0 means that the IO operation was successful.

    \sa setStatus()
*/
int QPictureIO::status() const { return d->iostat; }

/*!
    Returns the picture format string or 0 if no format has been
    explicitly set.
*/
const char *QPictureIO::format() const { return d->frmt; }

/*!
    Returns the IO device currently set.

    \sa setIODevice()
*/
QIODevice *QPictureIO::ioDevice() const { return d->iodev; }

/*!
    Returns the file name currently set.

    \sa setFileName()
*/
QString QPictureIO::fileName() const { return d->fname; }


/*!
    Returns the picture description string.

    \sa setDescription()
*/
QString QPictureIO::description() const { return d->descr; }

/*!
    Sets the picture to \a picture.

    \sa picture()
*/
void QPictureIO::setPicture(const QPicture &picture)
{
    d->pi = picture;
}

/*!
    Sets the picture IO status to \a status. A non-zero value indicates
    an error, whereas 0 means that the IO operation was successful.

    \sa status()
*/
void QPictureIO::setStatus(int status)
{
    d->iostat = status;
}

/*!
    Sets the picture format to \a format for the picture to be read or
    written.

    It is necessary to specify a format before writing an picture, but
    it is not necessary to specify a format before reading an picture.

    If no format has been set, Qt guesses the picture format before
    reading it. If a format is set the picture will only be read if it
    has that format.

    \sa read() write() format()
*/
void QPictureIO::setFormat(const char *format)
{
    d->frmt = format;
}

/*!
    Sets the IO device to be used for reading or writing an picture.

    Setting the IO device allows pictures to be read/written to any
    block-oriented QIODevice.

    If \a ioDevice is not null, this IO device will override file name
    settings.

    \sa setFileName()
*/
void QPictureIO::setIODevice(QIODevice *ioDevice)
{
    d->iodev = ioDevice;
}

/*!
    Sets the name of the file to read or write an picture from to \a
    fileName.

    \sa setIODevice()
*/
void QPictureIO::setFileName(const QString &fileName)
{
    d->fname = fileName;
}

/*!
    Returns the quality of the written picture, related to the
    compression ratio.

    \sa setQuality() QPicture::save()
*/
int QPictureIO::quality() const
{
    return d->quality;
}

/*!
    Sets the quality of the written picture to \a q, related to the
    compression ratio.

    \a q must be in the range -1..100. Specify 0 to obtain small
    compressed files, 100 for large uncompressed files. (-1 signifies
    the default compression.)

    \sa quality() QPicture::save()
*/

void QPictureIO::setQuality(int q)
{
    d->quality = q;
}

/*!
    Returns the picture's parameters string.

    \sa setParameters()
*/

const char *QPictureIO::parameters() const
{
    return d->parameters;
}

/*!
    Sets the picture's parameter string to \a parameters. This is for
    picture handlers that require special parameters.

    Although the current picture formats supported by Qt ignore the
    parameters string, it may be used in future extensions or by
    contributions (for example, JPEG).

    \sa parameters()
*/

void QPictureIO::setParameters(const char *parameters)
{
    if (d && d->parameters)
        delete [] (char*)d->parameters;
    d->parameters = qstrdup(parameters);
}

/*!
    Sets the gamma value at which the picture will be viewed to \a
    gamma. If the picture format stores a gamma value for which the
    picture is intended to be used, then this setting will be used to
    modify the picture. Setting to 0.0 will disable gamma correction
    (i.e. any specification in the file will be ignored).

    The default value is 0.0.

    \sa gamma()
*/
void QPictureIO::setGamma(float gamma)
{
    d->gamma=gamma;
}

/*!
    Returns the gamma value at which the picture will be viewed.

    \sa setGamma()
*/
float QPictureIO::gamma() const
{
    return d->gamma;
}

/*!
    Sets the picture description string for picture handlers that support
    picture descriptions to \a description.

    Currently, no picture format supported by Qt uses the description
    string.
*/

void QPictureIO::setDescription(const QString &description)
{
    d->descr = description;
}


/*!
    Returns a string that specifies the picture format of the file \a
    fileName, or null if the file cannot be read or if the format is
    not recognized.
*/

QByteArray QPictureIO::pictureFormat(const QString &fileName)
{
    QFile file(fileName);
    QByteArray format;
    if (!file.open(IO_ReadOnly))
        return format;
    format = pictureFormat(&file);
    file.close();
    return format;
}

/*!
    \overload

    Returns a string that specifies the picture format of the picture read
    from IO device \a d, or 0 if the device cannot be read or if the
    format is not recognized.

    Make sure that \a d is at the right position in the device (for
    example, at the beginning of the file).

    \sa QIODevice::at()
*/

QByteArray QPictureIO::pictureFormat(QIODevice *d)
{
    // if you change this change the documentation for defineIOHandler()
    const int buflen = 14;

    char buf[buflen];
    char buf2[buflen];
    qt_init_picture_handlers();
    qt_init_picture_plugins();
    int pos = d->at();                        // save position
    int rdlen = d->readBlock(buf, buflen);        // read a few bytes

    QByteArray format;
    if (rdlen != buflen)
        return format;

    strncpy(buf2, buf, buflen);

    for (int n = 0; n < rdlen; n++)
        if (buf[n] == '\0')
            buf[n] = '\001';
    if (d->status() == IO_Ok && rdlen > 0) {
        buf[rdlen - 1] = '\0';
        QString bufStr = QString::fromLatin1(buf);
	for (int i = 0; i < pictureHandlers.size(); ++i) {
            if (pictureHandlers.at(i)->header.indexIn(bufStr) != -1) { // try match with headers
                format = pictureHandlers.at(i)->format;
                break;
            }
        }
    }
    d->seek(pos);                                // restore position
    return format;
}

/*!
    Returns a sorted list of picture formats that are supported for
    picture input.
*/
QList<QByteArray> QPictureIO::inputFormats()
{
    QList<QByteArray> result;

    qt_init_picture_handlers();
    qt_init_picture_plugins();

    for (int i = 0; i < pictureHandlers.size(); ++i) {
	QPictureHandler *p = pictureHandlers.at(i);
        if (p->read_picture && !p->obsolete  && !result.contains(p->format))
            result.append(p->format);
    }
    qHeapSort(result);

    return result;
}

/*!
    Returns a sorted list of picture formats that are supported for
    picture output.
*/
QList<QByteArray> QPictureIO::outputFormats()
{
    qt_init_picture_handlers();
    qt_init_picture_plugins();

    QList<QByteArray> result;
    for (int i = 0; i < pictureHandlers.size(); ++i) {
	QPictureHandler *p = pictureHandlers.at(i);
        if (p->write_picture && !p->obsolete && !result.contains(p->format))
            result.append(p->format);
    }
    return result;
}



/*!
    Reads an picture into memory and returns true if the picture was
    successfully read; otherwise returns false.

    Before reading an picture you must set an IO device or a file name.
    If both an IO device and a file name have been set, the IO device
    will be used.

    Setting the picture file format string is optional.

    Note that this function does \e not set the \link format()
    format\endlink used to read the picture. If you need that
    information, use the pictureFormat() static functions.

    Example:

    \code
        QPictureIO iio;
        QPixmap  pixmap;
        iio.setFileName("vegeburger.bmp");
        if (picture.read())        // ok
            pixmap = iio.picture();  // convert to pixmap
    \endcode

    \sa setIODevice() setFileName() setFormat() write() QPixmap::load()
*/
bool QPictureIO::read()
{
    QFile           file;
    const char          *picture_format;
    QPictureHandler *h;

    if (d->iodev) {                                // read from io device
        // ok, already open
    } else if (!d->fname.isEmpty()) {                // read from file
        file.setFileName(d->fname);
        if (!file.open(IO_ReadOnly))
            return false;                        // cannot open file
        d->iodev = &file;
    } else {                                        // no file name or io device
        return false;
    }
    if (d->frmt.isEmpty()) {
        // Try to guess format
        picture_format = pictureFormat(d->iodev);        // get picture format
        if (!picture_format) {
            if (file.isOpen()) {                        // unknown format
                file.close();
                d->iodev = 0;
            }
            return false;
        }
    } else {
        picture_format = d->frmt;
    }

    h = get_picture_handler(picture_format);
    if (file.isOpen()) {
#if !defined(Q_OS_UNIX)
        if (h && h->text_mode) {                // reopen in translated mode
            file.close();
            file.open(IO_ReadOnly | IO_Translate);
        }
        else
#endif
            file.seek(0);                        // position to start
    }
    d->iostat = 1;                                        // assume error

    if (h && h->read_picture)
        (*h->read_picture)(this);

    if (file.isOpen()) {                        // picture was read using file
        file.close();
        d->iodev = 0;
    }
    return d->iostat == 0;                                // picture successfully read?
}


/*!
    Writes an picture to an IO device and returns true if the picture was
    successfully written; otherwise returns false.

    Before writing an picture you must set an IO device or a file name.
    If both an IO device and a file name have been set, the IO device
    will be used.

    The picture will be written using the specified picture format.

    Example:
    \code
        QPictureIO iio;
        QPicture   im;
        im = pixmap; // convert to picture
        iio.setPicture(im);
        iio.setFileName("vegeburger.bmp");
        iio.setFormat("BMP");
        if (iio.write())
            // returned true if written successfully
    \endcode

    \sa setIODevice() setFileName() setFormat() read() QPixmap::save()
*/
bool QPictureIO::write()
{
    if (d->frmt.isEmpty())
        return false;
    QPictureHandler *h = get_picture_handler(d->frmt);
    if (!h || !h->write_picture) {
        qWarning("QPictureIO::write: No such picture format handler: %s",
                 format());
        return false;
    }
    QFile file;
    if (!d->iodev && !d->fname.isEmpty()) {
        file.setFileName(d->fname);
        bool translate = h->text_mode==QPictureHandler::TranslateInOut;
        int fmode = translate ? IO_WriteOnly|IO_Translate : IO_WriteOnly;
        if (!file.open(fmode))                // couldn't create file
            return false;
        d->iodev = &file;
    }
    d->iostat = 1;
    (*h->write_picture)(this);
    if (file.isOpen()) {                        // picture was written using file
        file.close();
        d->iodev = 0;
    }
    return d->iostat == 0;                                // picture successfully written?
}
#endif //QT_NO_PICTUREIO

#endif // QT_NO_PICTURE

