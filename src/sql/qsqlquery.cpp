/****************************************************************************
**
** Implementation of QSqlQuery class
**
** Created : 2000-11-03
**
** Copyright (C) 2000 Trolltech AS.  All rights reserved.
**
** This file is part of the sql module of the Qt GUI Toolkit.
**
** This file may be distributed under the terms of the Q Public License
** as defined by Trolltech AS of Norway and appearing in the file
** LICENSE.QPL included in the packaging of this file.
**
** This file may be distributed and/or modified under the terms of the
** GNU General Public License version 2 as published by the Free Software
** Foundation and appearing in the file LICENSE.GPL included in the
** packaging of this file.
**
** Licensees holding valid Qt Enterprise Edition licenses may use this
** file in accordance with the Qt Commercial License Agreement provided
** with the Software.
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
**   information about Qt Commercial License Agreements.
** See http://www.trolltech.com/qpl/ for QPL licensing information.
** See http://www.trolltech.com/gpl/ for GPL licensing information.
**
** Contact info@trolltech.com if any conditions of this licensing are
** not clear to you.
**
**********************************************************************/

#include "qsqlquery.h"

#ifndef QT_NO_SQL

#include "qsqlresult.h"
#include "qsqldriver.h"
#include "qsqldatabase.h"

QSqlResultShared::~QSqlResultShared()
{
    if ( sqlResult )
	delete sqlResult;
}

/*! \class QSqlQuery qsqlquery.h

    \brief Executes and manipulates SQL queries.

    \module sql

    This class is used to execute SQL queries on a \l QSqlDatabase.
    QSqlQuery encapsulates the functionality involved in creating,
    navigating and retrieving data from SQL queries.  This class works
    with \l QSqlResult to form a simple, but flexible, interface to
    SQL database engines.

    Once an SQL result is created, it is initially in an inactive
    state.  A result becomes active when it is supplied with a valid
    SQL query.
    
    An active result object must be 'scrolled' to valid records within
    the SQL query as generated by the SQL database.  Data cannot be
    accessed until the result is positioned on a valid record (see
    isValid()).  To 'scroll', or navigate, through the result set, use
    the following methods:

    <ul>
    <li>\c next()
    <li>\c prev()
    <li>\c first()
    <li>\c last()
    <li>\c seek()
    </ul>

    These methods allow the programmer to move forward, backward or
    randomly through the records returned by the query.  Once an
    active result object is positioned on a valid record, data can be
    retrieved using value().  All data is tranferred from the SQL
    backend using QVariant.

    For example:

    \code
    QSqlQuery mySql( "select name from customer;" );
    while ( mySql->next() ) {
	QString name = mySql.value(0).toString();
	DoSomething( name );
    }
    \endcode

    \sa QSqlDatabase QSqlResult QVariant
*/

/*!  Creates a QSqlQuery object which uses QSqlResult to communicate
    with a database.
*/

QSqlQuery::QSqlQuery( QSqlResult * r )
{
    d = new QSqlResultShared( r );
}

/*! Destroys the object and frees any allocated resources.

*/

QSqlQuery::~QSqlQuery()
{
    if (d->deref()) {
	delete d;
    }
}

/*!
    Constructs a copy of \a other.
*/

QSqlQuery::QSqlQuery( const QSqlQuery& other )
    : d(other.d)
{
    d->ref();
}

/*!  Creates a QSqlQuery object using the SQL \a query and the
  database \a db.  If \a db is 0, the default application database is
  used.

*/
QSqlQuery::QSqlQuery( const QString& query, QSqlDatabase* db )
{
    d = new QSqlResultShared( 0 );
    QSqlDatabase* database = db;
    if ( !database )
	database = QSqlDatabase::database();
    *this = database->driver()->createQuery();
    if ( !query.isNull() )
	exec( query );
}

/*!
    Assigns \a other to the query.
*/

QSqlQuery& QSqlQuery::operator=( const QSqlQuery& other )
{
    other.d->ref();
    deref();
    d = other.d;
    return *this;
}

/*!  Returns TRUE if \a field is NULL, otherwise returns FALSE.  The
     result must be active and positioned on a valid record before
     calling this method.  In addition, for some drivers, isNull()
     will not return accurate information until after an attempt is
     made to retrieve data.

     \sa isActive() isValid() value()

*/

bool QSqlQuery::isNull( int field ) const
{
    if ( d->sqlResult->isActive() && d->sqlResult->isValid() )
	return d->sqlResult->isNull( field );
    return FALSE;
}

/*! Applies the SQL \a query.  The \a query string must use SQL syntax
    appropriate for the SQL database being queried.

    If the query was successful, the object is set to an active state,
    otherwise it is set to an inactive state.  In either case, the
    query object is positioned to an invalid record, and must be
    positioned to a valid record before data values can be retrieved.

    \sa isActive() isValid() next() prev() first() last() seek()

*/

bool QSqlQuery::exec ( const QString& query )
{
    if ( d->count > 1 )
	*this = driver()->createQuery();
    d->sqlResult->setActive( FALSE );
    d->sqlResult->setAt( QSqlResult::BeforeFirst );
    d->sqlResult->setQuery( query.stripWhiteSpace() );
    if ( !driver()->isOpen() || driver()->isOpenError() )
	return FALSE;
    if ( query.isNull() || query.length() == 0 )
	return FALSE;
#ifdef QT_DEBUG_SQL
    qDebug( "\n QSqlQuery: " + query );
#endif
    return d->sqlResult->reset( query );
}

/*! Returns the value of field \a i (zero based).  
  
  An invalid QVariant is returned if field \a i does not exist, or if
  the query is inactive, or if the query is positioned on an invalid
  record.

  \sa prev() next() first() last() seek() isActive() isValid()

*/

QVariant QSqlQuery::value( int i )
{
    if ( isActive() && isValid() && ( i > QSqlResult::BeforeFirst ) ) {
	return d->sqlResult->data( i );
    }
    return QVariant();
}

/*! Returns the current internal position of the query.  If the
    position is invalid, a QSqlResult::Location will be returned
    indicating the position.

    \sa isValid()

*/

int QSqlQuery::at() const
{
    return d->sqlResult->at();
}


/*! Returns the current query being used, or QString::null if there is
  no current query.

*/

QString QSqlQuery::lastQuery() const
{
    return d->sqlResult->lastQuery();
}

/*! Returns a pointer to the database driver associated with the
  query.

*/

const QSqlDriver* QSqlQuery::driver() const
{
    return d->sqlResult->driver();
}

/*! Returns a pointer to the result associated with the query.

*/

const QSqlResult* QSqlQuery::result() const
{
    return d->sqlResult;
}

/*! Positions the result to the random position \a i.  Note that the
    result must be in an active state and isSelect() must return TRUE
    before calling this method.

    The following rules apply:
    
    If \a relative is TRUE, the position of the query is moved
    relative to the current position, otherwise (the default) \a i is
    considered an absolute position.  If successful, TRUE is
    returned. If the record is not available, FALSE is returned.

    If \a relative is FALSE (the default), the following rules apply:
    
    <ul> 
    <li> If \a i is negative, the result is positioned before the
    first record and FALSE is returned.
    <li> Otherwise, an attempt is made to move to the record at position
    \a i.
    </ul>

    If \a relative is TRUE, the following rules apply:
    
    <ul> 
    <li> If the result is currently positioned before the first
    record or on the first record, and \a i is negative, there is no
    change, and FALSE is returned.
    <li> If the result is currently located after the last record, and
    \a i is positive, there is no change, and FALSE is returned.
    <li>If the result is currently located somewhere in the middle,
    and the relative offset \a i moves the result below zero, the
    result is positioned before the first record and FALSE is
    returned.
    <li> Otherwise, an attempt is made to move the result.  
    </ul>
    
    If the attempt to move to the desired record fails, the result is
    positioned after the last record, and FALSE is returned.

*/
bool QSqlQuery::seek( int i, bool relative )
{
    if ( !isSelect() || !isActive() )
	return FALSE;
    beforeSeek();
    checkDetach();
    int actualIdx;
    if ( !relative ) { // random seek
	if ( i < 0 ) {
	    d->sqlResult->setAt( QSqlResult::BeforeFirst );
	    afterSeek();
	    return FALSE;
	}
	actualIdx = i;
    }
    else {
	switch ( at() ) { // relative seek
	case QSqlResult::BeforeFirst:
	    if ( i > 0 )
		actualIdx = i;
	    else {
		afterSeek();
		return FALSE;
	    }
	    break;
	case QSqlResult::AfterLast:
	    if ( i < 0 )
		actualIdx = i;
	    else {
		afterSeek();
		return FALSE;
	    }
	    break;
	default:
	    if ( ( at() + i ) < 0  ) {
		d->sqlResult->setAt( QSqlResult::BeforeFirst );
		afterSeek();
		return FALSE;
	    }
	    actualIdx = i;
	    break;
	}
    }
    // let drivers optimize
    if ( actualIdx == ( at() + 1 ) ) {
	if ( !d->sqlResult->fetchNext() ) {
	    d->sqlResult->setAt( QSqlResult::AfterLast );
	    afterSeek();
	    return FALSE;
	}
    }
    if ( actualIdx == ( at() - 1 ) ) {
	if ( !d->sqlResult->fetchPrev() ) {
	    d->sqlResult->setAt( QSqlResult::BeforeFirst );
	    afterSeek();
	    return FALSE;
	}
    }
    if ( !d->sqlResult->fetch( actualIdx ) ) {
	d->sqlResult->setAt( QSqlResult::AfterLast );
	afterSeek();
	return FALSE;
    }
    afterSeek();
    return TRUE;
}

/*! Retrieves the next record in the result, if available.  Note that
    the result must be in an active state and isSelect() must return
    TRUE before calling this method.
    
    The following rules apply:
    
    <ul> 
    <li>If the result is currently located before the first
    record, an attempt is made to get the first record.
    
    <li>If the result is currently located after the last record,
    there is no change and FALSE is returned.
    
    <li> If the result is located somewhere in the middle, an attempt
    is made to get the next record.
    </ul>

    In any case, if the record could not be retrieved, the result is
    positioned after the last record and FALSE is returned. If the
    record is successfully retrieved, TRUE is returned.

    \sa at() isValid()

*/

bool QSqlQuery::next()
{
    if ( !isSelect() || !isActive() )
	return FALSE;
    beforeSeek();
    checkDetach();
    bool b = FALSE;
    switch ( at() ) {
    case QSqlResult::BeforeFirst:
	b = d->sqlResult->fetchFirst();
	afterSeek();
	return b;
    case QSqlResult::AfterLast:
	afterSeek();
	return FALSE;
    default:
	if ( !d->sqlResult->fetchNext() ) {
	    d->sqlResult->setAt( QSqlResult::AfterLast );
	    afterSeek();
	    return FALSE;
	}
	afterSeek();
	return TRUE;
    }
}

/*! Positions the result to the previous record in the result, if
    available.  Note that the result must be in an active state and
    isSelect() must return TRUE before calling this method.
  
    The following rules apply:

    <ul>
    <li>If the result is currently located before the first record,
    there is no change and FALSE is returned.
    
    <li>If the result is currently located after the last record, an
    attempt is made to get the last record.
    
    <li>If the result is somewhere in the middle, an attempt is made
    to get the previous record.  
    </ul>

    In any case, if the record could not be retrieved, the result is
    positioned before the first record and FALSE is returned.  If the
    record is successfully retrieved, TRUE is returned.

    \sa at()

*/

bool QSqlQuery::prev()
{
    if ( !isSelect() || !isActive() )
	return FALSE;
    beforeSeek();
    checkDetach();
    bool b = FALSE;
    switch ( at() ) {
    case QSqlResult::BeforeFirst:
	afterSeek();
	return FALSE;
    case QSqlResult::AfterLast:
	b = d->sqlResult->fetchLast();
	afterSeek();
	return b;
    default:
	if ( !d->sqlResult->fetchPrev() ) {
	    d->sqlResult->setAt( QSqlResult::BeforeFirst );
	    afterSeek();
	    return FALSE;
	}
	afterSeek();
	return TRUE;
    }
}

/*! Positions the result to the first record of an active result.
    Note that the result must be in an active state and isSelect()
    must return TRUE before calling this method.  Returns TRUE if
    successful, FALSE otherwise.  
    
*/

bool QSqlQuery::first()
{
    if ( !isSelect() || !isActive() )
	return FALSE;
    beforeSeek();
    checkDetach();
    bool b = FALSE;
    b = d->sqlResult->fetchFirst();
    afterSeek();
    return b;
}

/*! Positions the result to the last record of an active result.  Note
    that the result must be in an active state and isSelect() must
    return TRUE before calling this method.  Returns TRUE if
    successful, FALSE otherwise. 

*/

bool QSqlQuery::last()
{
    if ( !isSelect() || !isActive() )
	return FALSE;
    beforeSeek();
    checkDetach();
    bool b = FALSE;
    b = d->sqlResult->fetchLast();
    afterSeek();
    return b;
}

/*!  Returns the size of the result, or -1 if it cannot be determined
  or the database does not support reporting information about query
  sizes.  Note that for non-SELECT statements (isSelect() returns
  FALSE), size() will return -1.  If the query is not active
  (isActive() returns FALSE), -1 is returned. 
  
  To determine the number of rows affected by a non-SELECT statement,
  use numRowsAffected().

  \sa isActive() numRowsAffected() QSqlDatabase::hasQuerySizeSupport()

*/
int QSqlQuery::size() const
{
    if ( isActive() && d->sqlResult->driver()->hasQuerySizeSupport() )
	return d->sqlResult->size();
    return -1;
}

/*!  Returns the number of rows affected by the result's SQL
  statement, or -1 if it cannot be determined.  Note that for SELECT
  statements, this value will be the same as size(), If the query is
  not active (isActive() returns FALSE), -1 is returned.

  \sa size()

*/

int QSqlQuery::numRowsAffected() const
{
    if ( isActive() )
	return d->sqlResult->numRowsAffected();
    return -1;
}

/*!  Returns error information about the last error (if any) that
occurred.

  \sa QSqlError

*/

QSqlError QSqlQuery::lastError() const
{
    return d->sqlResult->lastError();
}

/*!  Returns TRUE is the query is currently positioned on a valid
  record, otherwise FALSE is returned.
*/

bool QSqlQuery::isValid() const
{
    return d->sqlResult->isValid();
}

/*!  Returns TRUE is the query is currently active, otherwise FALSE is
  returned.
*/

bool QSqlQuery::isActive() const
{
    return d->sqlResult->isActive();
}

/*!  Returns TRUE is the current query is a SELECT statement,
  otherwise FALSE is returned.

*/

bool QSqlQuery::isSelect() const
{
    return d->sqlResult->isSelect();
}

/*!
  \internal
*/

void QSqlQuery::deref()
{
    if ( d->deref() ) {
	delete d;
	d = 0;
    }
}

/*!
  \internal
*/

bool QSqlQuery::checkDetach()
{
    if ( d->count > 1 ) {
	QString sql = d->sqlResult->lastQuery();
	*this = driver()->createQuery();
	exec( sql );
	return TRUE;
    }
    return FALSE;
}


/*!  Protected virtual called before the internal record pointer is
  moved to a new record.  The default implentation does nothing.

*/

void QSqlQuery::beforeSeek()
{

}


/*!  Protected virtual called after the internal record pointer is
  moved to a new record.  The default implentation does nothing.
*/

void QSqlQuery::afterSeek()
{

}


#endif // QT_NO_SQL
