#include "qsqlquery.h"

#ifndef QT_NO_SQL

#include "qsqlresult.h"
#include "qsqldriver.h"
#include "qsqldatabase.h"

QSqlResultShared::~QSqlResultShared()
{
    if ( sqlResult )
	delete sqlResult;
}

/*! \class QSqlQuery qsqlquery.h

    \brief Class used for executing and manipulating SQL queries.

    \module database

    This class is used to execute SQL queries on a QSqlDatabase.  QSqlQuery
    encapsulates the functionality involved in creating, navigating
    and retrieving data from SQL queries.  This class works with QSqlResult
    to form a simple, but flexible, interface to SQL database engines.

    Once an SQL result is created, it is initially in an inactive state.
    A result becomes active when it is supplied with a SQL query (see operator<<) (see
    isActive()).  Alternatively, use the QSqlDatabase::query() or QSqlDatabase::exec()
    convenience methods to create active QSqlQuery objects.

    An active result object must be 'scrolled' to valid records within the
    SQL query as generated by the SQL database.  Data cannot be accessed until
    the result is positioned on a valid record (see isValid()).  To 'scroll', or
    navigate, through the result set, use the following methods:

    <ul>
    <li>next()
    <li>prev()
    <li>first()
    <li>last()
    <li>seek()
    </ul>

    These methods allow the programmer to move forward, backward or randomly through the records
    returned by the query.  Once an active result object is positioned on a valid record, data can
    be retrieved using operator[].  All data is tranferred from the SQL backend using QVariant (see
    QVariant.

    For example:

    \code
    QSqlDatabase* myDatabase;
    ...
    QSqlQuery mySql = myDatabase->query( "select name from customer;" );
    while ( mySql->next() ) {
	QString name = mySql[0];
	DoSomething( name );
    }
    \endcode

    \sa QSqlDatabase QSqlResult QSqlRowset QVariant
*/

/*!  Creates a QSqlQuery object which uses QSqlResult to communicate
    with a database.  QSqlQuery is implicitly shared.
*/

QSqlQuery::QSqlQuery( QSqlResult * r )
{
    d = new QSqlResultShared( r );
}

/*! Destroys the object and frees any allocated resources.

*/

QSqlQuery::~QSqlQuery()
{
    if (d->deref()) {
	delete d;
    }
}

/*!
    Copy constructor.
*/

QSqlQuery::QSqlQuery( const QSqlQuery& other )
    : d(other.d)
{
    d->ref();
}

/*!

  Creates a QSqlQuery object using the SQL query \a query and the
  database \a db.

*/
QSqlQuery::QSqlQuery( const QString& query, QSqlDatabase* db )
{
    d = new QSqlResultShared( 0 );
    QSqlDatabase* database = db;
    if ( !database )
	database = QSqlDatabase::database();
    *this = database->driver()->createQuery();
    if ( !query.isNull() )
	exec( query );
}

/*!
    Assigns \a other.
*/

QSqlQuery& QSqlQuery::operator=( const QSqlQuery& other )
{
    other.d->ref();
    deref();
    d = other.d;
    return *this;
}


/*!  Returns TRUE if field \a field is NULL, otherwise returns FALSE.  The result
     must be active and valid before calling this method.  In addition, for some drivers,
     isNull() will not return accurate information until after an attempt is made to retrieve
     data (see operator[]).

     \sa isActive() isValid() operator[]

*/

bool QSqlQuery::isNull( int field ) const
{
    if ( d->sqlResult->isActive() && d->sqlResult->isValid() )
	return d->sqlResult->isNull( field );
    return FALSE;
}

/*! Applies the SQL \a query.  The \a query string must use SQL syntax appropriate for the SQL database
    being queried.

    The QSqlQuery object is reset to an invalid state, and must be positioned to
    a valid record before data values can be retrieved.

    If this operation fails, the QSqlQuery object is reset to an inactive state.

    \sa isActive(), isValid(), next(), prev(), first(), last()

*/

bool QSqlQuery::exec ( const QString& query )
{
    if ( d->count > 1 )
	*this = driver()->createQuery();
    d->sqlResult->setActive( FALSE );
    d->sqlResult->setAt( QSqlResult::BeforeFirst );
    d->sqlResult->setQuery( query.stripWhiteSpace() );
    if ( !driver()->isOpen() || driver()->isOpenError() )
	return FALSE;
    if ( query.isNull() || query.length() == 0 )
	return FALSE;
    qDebug( "\n### SQL: " + query ); // ###
    return d->sqlResult->reset( query );
}

/*! Returns the value of field \a i (zero based) in the result as reported by the database, or
    QVariant() if it cannot be determined.
    Note that the result must be active and positioned on a valid record.

    \sa prev(), next(), first(), last(), seek(), isActive(), isValid()

*/

QVariant QSqlQuery::value( int i )
{
    if ( isActive() && isValid() && ( i > QSqlResult::BeforeFirst ) ) {
	return d->sqlResult->data( i );
    }
    return QVariant();
}

/*! Retrieves current index of the result.  If the index is invalid, a
    QSqlResult::Location will be returned indicating the position.

    \sa isValid()

*/

int QSqlQuery::at() const
{
    return d->sqlResult->at();
}


/*! Returns the current query used, or QString::null if there is no current query.

*/

QString QSqlQuery::lastQuery() const
{
    return d->sqlResult->lastQuery();
}

/*! Returns a pointer to the database driver associated with the query.

*/

const QSqlDriver* QSqlQuery::driver() const
{
    return d->sqlResult->driver();
}

/*! Returns a pointer to the result associated with the query.

*/

const QSqlResult* QSqlQuery::result() const
{
    return d->sqlResult;
}

/*! Positions the result to a random index \a i.  If \a relative is TRUE,
    the index is moved relative to the current index.  If successful,
    TRUE is returned. If the record is not available, FALSE is returned.

    If \a relative==FALSE, the following rules apply:
    If \a i is negative, the result is positioned before the first record and FALSE is returned.
    Otherwise, an attempt is made to move to the record at index \a i.

    If \a relative==TRUE, the following rules apply:
    If the result is currently located before the first record or on the first
    record, and \a i is  negative, there is no change, and FALSE is returned.
    If the result is currently located after the last record, and \a i is
    positive, there is no change, and FALSE is returned.
    If the result is currently located somewhere in the middle, and the relative
    offset \a i moves the result below zero, the result is positioned before the
    first record and FALSE is returned.
    Otherwise, an attempt is made to move the result.  If the attempt fails, the
    result is positioned after the last record, and FALSE is returned.

*/
bool QSqlQuery::seek( int i, bool relative )
{
    beforeSeek();
    checkDetach();
    if ( isActive() ) {
        int actualIdx;
	if ( !relative ) { // random seek
	    if ( i < 0 ) {
		d->sqlResult->setAt( QSqlResult::BeforeFirst );
		afterSeek();
		return FALSE;
	    }
	    actualIdx = i;
	}
	else {
	    switch ( at() ) { // relative seek
	    	case QSqlResult::BeforeFirst:
		    if ( i > 0 )
		    	actualIdx = i;
		    else {
			afterSeek();
			return FALSE;
		    }
		    break;
		case QSqlResult::AfterLast:
		    if ( i < 0 )
		    	actualIdx = i;
		    else {
			afterSeek();
			return FALSE;
		    }
		    break;
		default:
		    if ( ( at() + i ) < 0  ) {
		    	d->sqlResult->setAt( QSqlResult::BeforeFirst );
			afterSeek();
			return FALSE;
		    }
		    actualIdx = i;
		    break;
	    }
	}
	// let drivers optimize
	if ( actualIdx == ( at() + 1 ) ) {
	    if ( !d->sqlResult->fetchNext() ) {
	    	d->sqlResult->setAt( QSqlResult::AfterLast );
		afterSeek();
		return FALSE;
	    }
	}
	if ( actualIdx == ( at() - 1 ) ) {
	    if ( !d->sqlResult->fetchPrev() ) {
	    	d->sqlResult->setAt( QSqlResult::BeforeFirst );
		afterSeek();
		return FALSE;
	    }
	}
	if ( !d->sqlResult->fetch( actualIdx ) ) {
	    d->sqlResult->setAt( QSqlResult::AfterLast );
	    afterSeek();
	    return FALSE;
	}
	afterSeek();
	return TRUE;
    } else {
	afterSeek();
	return FALSE;
    }
}

/*! Retrieves the next record in the result, if available.  Note that the result must be in an active
    state before calling this method.  The following rules apply:

    If the result is currently located before the first record, an attempt is made to get the first record.
    If the result is currently located after the last record, there is no change and FALSE is returned.
    If the result is located somewhere in the middle, an attempt is made to get the next record.

    In any case, if the record could not be retrieved, the result is positioned after the last record
    and FALSE is returned. If the record is successfully retrieved, TRUE is returned.

    \sa at()

*/

bool QSqlQuery::next()
{
    beforeSeek();
    checkDetach();
    bool b = FALSE;
    if ( isActive() ) {
	switch ( at() ) {
	    case QSqlResult::BeforeFirst:
		b = d->sqlResult->fetchFirst();
		afterSeek();
	    	return b;
	    case QSqlResult::AfterLast:
		afterSeek();
		return FALSE;
	    default:
		if ( !d->sqlResult->fetchNext() ) {
		    d->sqlResult->setAt( QSqlResult::AfterLast );
		    afterSeek();
		    return FALSE;
		}
		afterSeek();
        	return TRUE;
	}
    }
    afterSeek();
    return FALSE;
}

/*! Positions the result to the previous record in the result, if available.  Note that the result must
    be in an active state before calling this method.  The following rules apply:

    If the result is currently located before the first record, there is no change and FALSE is returned.
    If the result is currently located after the last record, an attempt is made to get the last record.
    If the result is somewhere in the middle, an attempt is made to get the previous record.

    In any case, is the record could not be retrieved, the result is positioned before the first record
    and FALSE is returned.  If the record is successfully retrieved, TRUE is returned.

    \sa at()

*/

bool QSqlQuery::prev()
{
    beforeSeek();
    checkDetach();
    bool b = FALSE;
    if ( isActive() ) {
	switch ( at() ) {
	    case QSqlResult::BeforeFirst:
		afterSeek();
		return FALSE;
	    case QSqlResult::AfterLast:
		b = d->sqlResult->fetchLast();
		afterSeek();
		return b;
	    default:
		if ( !d->sqlResult->fetchPrev() ) {
		    d->sqlResult->setAt( QSqlResult::BeforeFirst );
		    afterSeek();
		    return FALSE;
		}
		afterSeek();
        	return TRUE;
	}
    }
    afterSeek();
    return FALSE;
}

/*! Positions the result to the first record of an active result.  Returns TRUE on success, FALSE otherwise.
    Note that the result must be in an active state before calling this method.

*/

bool QSqlQuery::first()
{
    beforeSeek();
    checkDetach();
    bool b = FALSE;
    if ( isActive() ) {
	b = d->sqlResult->fetchFirst();
	afterSeek();
	return b;
    }
    afterSeek();
    return FALSE;
}

/*! Positions the result to the last record of an active result.  Returns TRUE on success, FALSE otherwise.
    Note that the result must be in an active state before calling this method.

*/

bool QSqlQuery::last()
{
    beforeSeek();
    checkDetach();
    bool b = FALSE;
    if ( isActive() ) {
	b = d->sqlResult->fetchLast();
	afterSeek();
	return b;
    }
    return FALSE;
}

/*!  Returns the size of the result, or -1 if it cannot be determined
  or the database does not support reporting information about query
  sizes.  Note that for non-SELECT statements, size() will return -1.
  To determine the number of rows affected by a non-SELECT statement,
  use numRowsAffected().

  \sa numRowsAffected() QSqlDatabase

*/
int QSqlQuery::size() const
{
    if ( d->sqlResult->driver()->hasQuerySizeSupport() )
	return d->sqlResult->size();
    return -1;
}

/*!
  Returns the number of rows affected by the result's SQL statement, or
  -1 if it cannot be determined.  Note that for SELECT statements, this
  value will be the same as size(),

  \sa size()

*/

int QSqlQuery::numRowsAffected() const
{
    return d->sqlResult->numRowsAffected();
}

/*!
  Returns a QSqlError object which contains information about the last error (if any) that occurred.

  \sa QSqlError

*/

QSqlError QSqlQuery::lastError() const
{
    return d->sqlResult->lastError();
}

bool QSqlQuery::isValid() const
{
    return d->sqlResult->isValid();
}

bool QSqlQuery::isActive() const
{
    return d->sqlResult->isActive();
}

/*!
  Returns TRUE is the current query is a SQL SELECT statement, otherwise false.

*/

bool QSqlQuery::isSelect() const
{
    return d->sqlResult->isSelect();
}

/*!
  \internal
*/

void QSqlQuery::deref()
{
    if ( d->deref() ) {
	delete d;
	d = 0;
    }
}

/*!
  \internal
*/

bool QSqlQuery::checkDetach()
{
    if ( d->count > 1 ) {
	QString sql = d->sqlResult->lastQuery();
	*this = driver()->createQuery();
	exec( sql );
	return TRUE;
    }
    return FALSE;
}


/*!  Protected virtual called before the internal record pointer is
  moved.  The default implentation does nothing.

*/

void QSqlQuery::beforeSeek()
{

}


/*!  Protected virtual called after the internal record pointer is
  moved.  The default implentation does nothing.
*/

void QSqlQuery::afterSeek()
{

}


#endif // QT_NO_SQL
