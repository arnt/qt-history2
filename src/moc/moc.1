.TH moc 1 "3 December 1995" "Troll Tech AS" \" -*- nroff -*-
.\"
.\" $Id: //depot/qt/main/src/moc/moc.1#7 $
.\"
.\" Copyright 1992-1995 Troll Tech AS.  All rights reserved.
.\" 
.\" This file is part of Qt.
.\"
.\" Qt is a product of Troll Tech AS and is provided for use on computers
.\" running the Linux operating system.
.\"
.\" Users may copy this beta version of the Qt toolkit provided that the
.\" entire archive is distributed as a whole, including this notice.
.\"
.\" Users may use the Qt toolkit to create programs provided that these
.\" programs are either for internal/own use or freely distributable.  THIS
.\" BETA VERSION OF QT MAY NOT BE USED IN COMMERCIAL PROGRAMS.
.\"
.\" Troll Tech makes no obligation to support or upgrade Qt, or assist in
.\" use of Qt.
.\"
.\" In no event shall Troll Tech be liable for any lost revenue or profits or
.\" other special, indirect or consequential damages, even if Troll Tech has
.\" been advised of the possibility of such damages.
.\"
.\" QT IS PROVIDED AS IS WITH NO WARRANTY OF ANY KIND, INCLUDING THE WARRANY
.\" OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
.\"
.\" hilit19 workaround: "
.SH NAME
moc \- generate Qt meta object support code
.SH SYNOPSIS
.B moc
[-o file] [-i] [-f] [-k] [-ldbg] [-dbg] [-nw] file
.SH DESCRIPTION
This manual page documents the Meta Object Compiler for the Qt GUI
application framework.  The Meta Object Compiler reads one or more C++
class declarations containing
.B signals
and
.B slots
sections from a C++ header or source file and generates one C++ source
file containing meta mbject information for the classes.
.\"  See "
.\" .B http://www.troll.no/qt/moc.html "
.\" for more information, or your local Qt HTML documentation. "
.PP
In brief, the meta object system is a structure used by Qt (see
.B http://www.troll.no/
) for component programming and run time type information.  It adds
inheritance information to (some) classes and provides a new type of
communication between those instances of those classes, signal-slot
connections.
.SH OPTIONS
.TP
.I "-o file"
Write output to
.I file
rather than to stdout.
.TP
.I -f
Force the generation of an #include statement in the output.
.B moc
automatically generates such a statement when it is run on a file whose
extension starts with the letter
.B h
or
.B H.
This option is only useful if you have header files that do not follow
the standard naming conventions (e.g.
.I vache.t
for
.IR "Fichier de la tete pour la vache." )
.TP
.I "-i"
Do not generate an #include statement in the output.  This may be used
to run 
.B moc
on a C++ file containint one or more class declarations and #include
the meta object code in the .cpp file (see USAGE below).  If both
.I -f
and
.I -i
are present, the last one wins.
.TP
.I "-nw"
Do not generate any warnings.
.TP
.I "-ldbg"
Write a flood of lex debug information on stdout.
.TP
.I "-dbg"
Treat all non-signal members as slots, for internal debugging
purposes.  This is not useful for programming Qt clients.
.SH USAGE
.B moc
is almost always invoked by
.BR make (1),
not by hand.
.PP
.B moc
is typically used with an input file containing class declarations
like this skeleton:
.PP
.in +5
class YourClass : public QObject {
.br
    Q_OBJECT
.br
public:
.br
    YourClass::YourClass( QObject * parent=0,
                          const char * name=0 );
.br
    YourClass::~YourClass();
.br

.br
signals:
.br

.br
public slots:
.br

.br
};
.in -5
.PP
Here is a useful makefile rule if you only use GNU make:
.PP
.in +5
m%.cpp: %.h
.br
        moc $< -o $@
.in -5
.PP
If you want to write portably, you can use individual rules of the
following form:
.PP
.in +5
mNAME.cpp: NAME.h
.br
        moc $< -o $@
.in -5
.PP
You must also remember to add
.I mNAME.cpp
to your SOURCES (substitute your favorite name) variable and
.I mNAME.o
to your OBJECTS variable.
.PP
(While we prefer to name our C++ source files .cpp, the
.B moc
doesn't know that, so you can use .C, .cc, .CC, .cxx or even .c++ if
you prefer.)
.PP
If you have class declarations in C++ files, we recommend that you use
a makefile rule like this:
.PP
.in +5
NAME.o: mNAME.cpp
.br

.br
mNAME.cpp: NAME.cpp
.br
        moc -i $< -o $@
.in -5
.PP
This guarantees that
.BR make (1)
will run the
.B moc
before it compiles
.IR NAME.cpp .
You can then put
.PP
.ti +5
#include "nNAME.cpp"
.PP
at the end of
.IR NAME.cpp ,
where all the classes declared in that file are fully known.
.SH DIAGNOSTICS
Sometimes you may get linkage errors, saying that
YourClass::className() is undefined or that YourClass lacks a vtbl.
Those errors happen most often when you forget to compile the
moc-generated C++ code or include that object file in the link
command.
.PP
The
.B moc
will warn you about a number of dangerous or illegal constructs.
.SH BUGS
.B moc
does not handle all of C++.  The main problem is that class templates
cannot have signals or slots.  This is an important bug.  Here is an
example:
.PP
.in +5
class SomeTemplate<int> : public QFrame {
.br
    Q_OBJECT
.br
[...]
.br
signals:
.br
    void bugInMocDetected( int );
.br
};
.in -5
.br
.PP
Multiple inheritance is supported, but imperfectly.  The class which
inherits QObject must be the first of the base classes.  Ie. this
declaration is illegal:
.PP
.in +5
class Schizophrenic: public MyClass, public QButton {
.br
    Q_OBJECT
.br
[...]
.br
};
.in -5
.br
.PP
By simply swapping the order of the base classes, it becomes legal:
.PP
.in +5
class Schizophrenic: public QButton, public MyClass {
.br
    Q_OBJECT
.br
[...]
.br
};
.in -5
.br
.PP
This bug is almost impossible to fix; since the
.B moc
does not expand #include or #define, it cannot find out which one of
the base classes is a QObject.
.PP
Less importantly, the following five constructs are illegal.  All five
have workarounds which we think are better alternatives, so fixing
these bugs is not a high priority for us.
.SS "Function pointers can not be arguments to signals or slots."
In most cases where you would consider that, we think inheritance is a
better alternative.  Here is an example of illegal syntax:
.PP
.in +5
class someClass : public QObject {
.br
    Q_OBJECT
.br
[...]
.br
public slots:
.br
    void apply(void (*applyFunction)(QList*, void*), char*);
.br
};
.in -5
.PP
You can work around this restriction like this:
.PP
.in +5
.br
typedef void (*ApplyFunctionType)(QList*, void*);
.br

.br
class someClass : public QObject {
.br
    Q_OBJECT
.br
[...]
.br
public slots:
.br
    void apply( ApplyFunctionType, char *);
.br
};
.in -5
.PP
(It may sometimes be even better to replace the function pointer with
inheritance and virtual functions, signals or slots.)
.SS "Friend declarations can not be placed in signals or slots sections"
Sometimes it will work, but in general, friend declarations can not be
placed in
.B signals
or
.B slots
sections.  Put them in the good old
.BR private ", " protected
or
.B public
sections instead.  Here is an example of the illegal syntax:
.PP
.in +5
class someClass : public QObject {
.br
    Q_OBJECT
.br
[...]
.br
signals:
.br
    friend class ClassTemplate<char>;
.br
};
.br
.in -5
.SS "Signals and slots cannot be upgraded"
The C++ feature of upgrading an inherited member function to
.B public
status is not extended to cover signals and slots.  Here is an illegal
example:
.PP
.in +5
class Whatever : public QButtonGroup {
.br
[...]
.br
public slots:
.br
    void QButtonGroup::buttonPressed;
.br
};
.in -5
.PP
The QButtonGroup::buttonPressed() slot is protected.
.PP
C++ quiz: What happens if you try to upgrade a protected member
function which is overloaded?
.IP
- All the functions are upgraded.
.IP
- That is not legal C++.
.\" Good idea, but look in the SEE ALSO section... "
.SS "Type macros can not be used for signal and slot arguments"
This is regrettable, but the
.B moc
places more emphasis on getting modern syntax like templates and
typedefs right than on anachronisms like #define.  In other words, we
don't like #define and don't want to fix this problem.  Here is an
illegal example:
.PP
.in +5
#ifdef ultrix
.br
#define SIGNEDNESS(a) unsigned a
.br
#else
.br
#define SIGNEDNESS(a) a
.br
#endif
.br
class Whatever : public QObject {
.br
[...]
.br
signals:
.br
    void someSignal( SIGNEDNESS(a) );
.br
};
.PP
A #define without arguments works.
.in -5
.SS "Constructors can not be used in signals or slots sections"
It is a mystery to me why anyone would put a constructor on either the
.B signals
or
.B slots
sections.  You can not, anyway (except that it happens to work in some
cases).  Put them in
.BR private ", " protected
or
.B public
sections, where they belong.  Here is an example of the illegal syntax:
.PP
.in +5
class SomeClass : QObject {
.br
    Q_OBJECT
.br
public slots:
.br
    SomeClass( QObject *parent, const char *name )
.br
        : QObject( parent, name ) {}
.br
[...]
.br
};
.in -5
.SH "SEE ALSO"
.BR http://www.troll.no/ " and"
.BR "C++ ARM, section r.11.3" " (for the answer to the quiz.)"
.SH AUTHOR
Eirik Eng, Troll Tech <eiriken@troll.no>
