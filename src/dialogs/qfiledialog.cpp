/****************************************************************************
** $Id: //depot/qt/main/src/dialogs/qfiledialog.cpp#55 $
**
** Implementation of QFileDialog class
**
** Created : 950429
**
** Copyright (C) 1995-1997 by Troll Tech AS.  All rights reserved.
**
*****************************************************************************/

#include "qfiledlg.h"
#include "qlined.h"
#include "qcombo.h"
#include "qlabel.h"
#include "qpushbt.h"
#include "qmsgbox.h"
#include "qlistview.h"
#include "qapp.h"
#include "qlayout.h"
#include "qlistview.h"
#include "qpixmap.h"
#include "qpopmenu.h"
#include "qwidgetstack.h"
#include "qvector.h"

#if defined(_WS_WIN_)
#if defined(_CC_BOOL_DEF_)
#undef	bool
#include <windows.h>
#define bool int
#else
#include <windows.h>
#endif
#endif

RCSTAG("$Id: //depot/qt/main/src/dialogs/qfiledialog.cpp#55 $");


/* Generated by qembed */
static const unsigned int  open_gif_len = 120;
static const unsigned char open_gif_data[] = {
    0x47,0x49,0x46,0x38,0x39,0x61,0x10,0x00,0x0d,0x00,0xc2,0x00,0x00,0x00,
    0x00,0x00,0x99,0x99,0x99,0xcc,0xcc,0xcc,0xff,0xff,0xff,0xff,0xff,0x00,
    0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x21,0xf9,0x04,0x01,0x00,
    0x00,0x03,0x00,0x2c,0x00,0x00,0x00,0x00,0x10,0x00,0x0d,0x00,0x00,0x03,
    0x3d,0x38,0x1a,0xcc,0xfa,0x70,0x84,0x42,0x69,0x88,0x6f,0x12,0xb1,0x49,
    0x69,0xcd,0x52,0x70,0x64,0x55,0x05,0x80,0x54,0x74,0x24,0x4b,0xa0,0x60,
    0x0c,0xbe,0xc0,0x64,0xde,0x8c,0x00,0xaf,0x6d,0x4b,0xd4,0x28,0x95,0xab,
    0x57,0x4b,0x4d,0x7a,0xae,0xa2,0x08,0xc9,0xa1,0xa5,0x24,0x32,0xd9,0x73,
    0x00,0xa8,0x5a,0xaf,0xd6,0x04,0x00,0x3b
};

static const unsigned int  closed_gif_len = 110;
static const unsigned char closed_gif_data[] = {
    0x47,0x49,0x46,0x38,0x39,0x61,0x0f,0x00,0x0d,0x00,0xc2,0x00,0x00,0x00,
    0x00,0x00,0x99,0x99,0x99,0xcc,0xcc,0xcc,0xff,0xff,0xff,0xff,0xff,0x00,
    0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x21,0xf9,0x04,0x01,0x00,
    0x00,0x03,0x00,0x2c,0x00,0x00,0x00,0x00,0x0f,0x00,0x0d,0x00,0x00,0x03,
    0x33,0x38,0x13,0xcc,0xfa,0x30,0x08,0x32,0x45,0x80,0x4f,0xd2,0x6d,0x9b,
    0x0b,0x45,0x28,0x8e,0x61,0x00,0x80,0x5c,0x3a,0x99,0x60,0xa5,0x52,0x6c,
    0xf1,0xba,0xb1,0x6b,0xc3,0xa7,0x7c,0xd3,0xf9,0xce,0xc5,0xb3,0x0d,0xcb,
    0x43,0xf4,0x00,0x06,0x80,0xa4,0x72,0xb9,0x4c,0x00,0x00,0x3b
};


static QPixmap * openFolderIcon = 0;
static QPixmap * closedFolderIcon = 0;


/* unused right now.  paul - ideas? */
/* static */ void makeIcons()
{
    openFolderIcon = new QPixmap();
    openFolderIcon->loadFromData( open_gif_data, open_gif_len );
    closedFolderIcon = new QPixmap();
    closedFolderIcon->loadFromData( closed_gif_data, closed_gif_len );
}


struct QFileDialogPrivate {
    bool geometryDirty;
    QComboBox * paths;
    QComboBox * types;
    QLabel * pathL;
    QLabel * fileL;
    QLabel * typeL;

    QVBoxLayout * topLevelLayout;

    QPushButton * cdToParent;

    QString currentFileName;

    struct File: public QListViewItem {
	File( const QFileInfo * fi, QListViewItem * parent, int h )
	    : info( *fi ), QListViewItem( parent ) { setHeight( h ); }
	File( const QFileInfo * fi, QListView * parent, int h  )
	    : info( *fi ), QListViewItem( parent ) { setHeight( h ); }

	const char * text( int column ) const;
	const char * key( int column ) const;

	QFileInfo info;
    };

    class MCList: public QTableView {
    public:
	MCList( QListView *, QWidget * );
	void paintCell( QPainter *, int row, int col );

	void clear();
    protected:
	void paintEvent( QPaintEvent * );
	void resizeEvent( QResizeEvent * );
	void keyPressEvent( QKeyEvent * );
    private:
	QListView * lv;
	QVector<const QListViewItem> * items;
	bool inPaintEvent;
    };
    
    MCList * moreFiles;
};


const char * QFileDialogPrivate::File::text( int column ) const
{
    static QString r;

    switch( column ) {
    case 0:
	r = info.fileName();
	break;
    case 1:
	r.sprintf( "%d", info.size() );
	break;
    case 2:
	if ( info.isFile() )
	    r = "File";
	else if ( info.isDir() )
	    r = "Directory";
	else
	    r = "Special File";
	if ( info.isSymLink() )
	    r.prepend( "Link to " );
	break;
    case 3:
	r = info.lastModified().toString();
	break;
    case 4:
	r = "ashr";
	break;
    default:
	r = "<--->";
    }

    r.detach();
    return r;
}


const char * QFileDialogPrivate::File::key( int column ) const
{
    static QString r;
    static QDateTime epoch( QDate( 1968, 6, 19 ) );

    if ( column == 1 ) {
	r.sprintf( "%08d", info.size() );
	return r;
    } else if ( column == 3 ) {
	r.sprintf( "%08d", epoch.secsTo( info.lastModified() ) );
	return r;
    } else {
	return text( column );
    }
}



QFileDialogPrivate::MCList::MCList( QListView * files, QWidget * parent )
    : QTableView( parent, "multi-column list box" )
{
    lv = files;
    items = 0;
    inPaintEvent = FALSE;
    setCellHeight( fontMetrics().height() + 6 );
    setBackgroundMode( PaletteBase );
}


void QFileDialogPrivate::MCList::paintCell( QPainter *p, int row, int col )
{
    if ( !items ) {
	debug( "yuck" );
	return;
    }
    
    if ( (uint)(col * numRows() + row) >= items->count() )
	return;

    const QListViewItem * file = (*items)[col*numRows() + row];
    if ( file )
	file->paintCell( p, colorGroup(), 0, cellWidth(), FALSE );
}


void QFileDialogPrivate::MCList::clear()
{
    delete items;
    items = 0;
    if ( isVisible() )
	repaint();
}


void QFileDialogPrivate::MCList::paintEvent( QPaintEvent * e )
{
    if ( inPaintEvent )
	return;
    bool oldAutoUpdate = autoUpdate();
    setAutoUpdate( FALSE );
    inPaintEvent = TRUE;
    const QListViewItem * file;
    if ( !items ) {
	file = lv->firstChild();
	int i = 0;
	int w, maxw;
	maxw = 40;
	while( file ) {
	    if ( file->height() ) {
		w = fontMetrics().width( file->text( 0 ) ) + 20;
		if ( w > maxw )
		    maxw = w;
		i++;
	    }
	    file = file->nextSibling();
	}
	setCellWidth( maxw );
	setNumRows( QMAX( 1, height() / cellHeight() ) );
	int ncols = (i+numRows()-1)/numRows();
	if ( ncols < 1 )
	    ncols = 1;
	if ( ncols * maxw > width() ) {
	    setNumRows( (height() - horizontalScrollBar()->height()) 
			/ cellHeight() );
	    setTableFlags( Tbl_hScrollBar
			   + Tbl_snapToHGrid + Tbl_clipCellPainting
			   + Tbl_cutCellsV + Tbl_smoothHScrolling );
	} else {
	    setTableFlags( Tbl_snapToHGrid + Tbl_clipCellPainting
			   + Tbl_cutCellsV + Tbl_smoothHScrolling );
	}
	setNumCols( (i + numRows() - 1) / numRows() );

	items = new QVector<const QListViewItem>( i );
	i = 0;
	file = lv->firstChild();
	// may have the wrong order.  fix that later.
	while( file ) {
	    if ( file->height() )
		items->insert( i++, file );
	    file = file->nextSibling();
	}
    }
    QTableView::paintEvent( e );
    setAutoUpdate( oldAutoUpdate );
    inPaintEvent = FALSE;
}


void QFileDialogPrivate::MCList::resizeEvent( QResizeEvent * e )
{
    clear();
    setNumRows( height() / cellHeight() );
    QTableView::resizeEvent( e );
}


void QFileDialogPrivate::MCList::keyPressEvent( QKeyEvent * e )
{
    QTableView::keyPressEvent( e );
    // later, okay?
}


/*!
  \class QFileDialog qfiledlg.h
  \brief The QFileDialog provides a dialog widget for inputting file names.

  Example:
  \code
    QString fileName = QFileDialog::getOpenFileName();
    if ( !fileName.isNull() ) {			// got a file name
	...
    }
  \endcode

  There are two ready-made convenience functions, getOpenFileName()
  and getSaveFileName(), which may be used like this:

  \code
    QString s( QFileDialog::getOpenFileName() );
    if ( s.isNull() )
	return;

    open( s ); // open() being your function to read the file
  \endcode

  <img src=qfiledlg-m.gif> <img src=qfiledlg-w.gif>

  \sa QPrintDialog
*/


/*!
  Constructs a file dialog with a \e parent, \e name and \e modal flag.

  The dialog becomes modal if \e modal is TRUE, otherwise modeless.
*/

QFileDialog::QFileDialog( QWidget *parent, const char *name, bool modal )
    : QDialog( parent, name, modal )
{
    init();
    cwd.convertToAbs();
    rereadDir();
}


/*!
  Constructs a file dialog with a \e parent, \e name and \e modal flag.

  The dialog becomes modal if \e modal is TRUE, otherwise modeless.
*/

QFileDialog::QFileDialog( const char *dirName, const char *filter,
			  QWidget *parent, const char *name, bool modal )
    : QDialog( parent, name, modal )
{
    init();
    if ( filter )
	cwd.setNameFilter( filter );
    if ( dirName )
	cwd.setPath( dirName );
    cwd.convertToAbs();
    rereadDir();
}


/*!
  \internal
  Initializes the file dialog.
*/

void QFileDialog::init()
{
    d = new QFileDialogPrivate();

    nameEdit = new QLineEdit( this, "name/filter editor" );
    connect( nameEdit, SIGNAL(returnPressed()),
	     this,  SLOT(fileNameEditDone()) );
    
    QWidgetStack * stack = new QWidgetStack( this, "files and more files" );
    stack->setFrameStyle( QFrame::WinPanel + QFrame::Sunken );
			  
    files = new QListView( stack, "current directory listing" );
    files->setColumn( "Name", 100 );
    files->setColumn( "Size", 50 );
    files->setColumn( "Type", 50 );
    files->setColumn( "Date", 100 );
    files->setColumn( "Attributes", 100 );
    connect( files, SIGNAL(sizeChanged()),
	     this, SLOT(updateGeometry()) );
    connect( files, SIGNAL(currentChanged(QListViewItem *)),
	     this, SLOT(updateFileNameEdit(QListViewItem *)) );
    connect( files, SIGNAL(doubleClicked(QListViewItem *)),
	     this, SLOT(selectDirectoryOrFile(QListViewItem *)) );
    connect( files, SIGNAL(returnPressed(QListViewItem *)),
	     this, SLOT(selectDirectoryOrFile(QListViewItem *)) );
    connect( files, SIGNAL(rightButtonClicked(QListViewItem *,
					      const QPoint &, int)),
	     this, SLOT(popupContextMenu(QListViewItem *,
					 const QPoint &, int)) );
    files->setFocusPolicy( StrongFocus );

    d->moreFiles = new QFileDialogPrivate::MCList( files, stack );
    d->moreFiles->setFrameStyle( QFrame::NoFrame );
    d->moreFiles->setFocusPolicy( StrongFocus );
    
    stack->raiseWidget( files );
    
    okB = new QPushButton( "OK", this, "OK" );
    okB->setAutoDefault( TRUE );
    okB->setDefault( TRUE );
    connect( okB, SIGNAL(clicked()), this, SLOT(okClicked()) );
    cancelB = new QPushButton( "Cancel" , this, "Cancel" );
    cancelB->setAutoDefault( TRUE );
    connect( cancelB, SIGNAL(clicked()), this, SLOT(cancelClicked()) );

    d->paths = new QComboBox( TRUE, this, "directory history/editor" );
    d->geometryDirty = TRUE;
    d->types = new QComboBox( FALSE, this, "file types" ); // ### TRUE

    d->pathL = new QLabel( d->paths, "Look &in", this );
    d->fileL = new QLabel( nameEdit, "File &name", this );
    d->typeL = new QLabel( d->types, "File &type", this );

    d->cdToParent = new QPushButton( "cd ..", this, "cd to parent" ); // ## pm

    d->topLevelLayout = new QVBoxLayout( this, 6 );

    QHBoxLayout * h;

    h = new QHBoxLayout();
    d->topLevelLayout->addLayout( h );
    h->addWidget( d->pathL );
    h->addWidget( d->paths );
    h->addWidget( d->cdToParent );

    d->topLevelLayout->addWidget( stack, 3 );

    h = new QHBoxLayout();
    d->topLevelLayout->addLayout( h );
    h->addWidget( d->fileL );
    h->addWidget( nameEdit );
    h->addWidget( okB );

    h = new QHBoxLayout();
    d->topLevelLayout->addLayout( h );
    h->addWidget( d->typeL );
    h->addWidget( d->types );
    h->addWidget( cancelB );

    cwd.setMatchAllDirs( TRUE );
    cwd.setSorting( cwd.sorting() | QDir::DirsFirst );

    updateGeometry();

    resize( 420, 300 );

    nameEdit->setFocus(); // ### ?
}

/*!
  Destroys the file dialog.
*/

QFileDialog::~QFileDialog()
{
    // nothing
}


/*!
  Returns the selected file name.

  If a file name was selected, the returned string contains the
  absolute path name.  The returned string is a null string if no file
  name was selected.

  \sa QString::isNull()
*/

QString QFileDialog::selectedFile() const
{
    QString s( d->currentFileName );
    return s.isNull() ? s : cwd.absFilePath( s );
}


/*!
  Returns the active directory path string in the file dialog.
  \sa dir(), setDir()
*/

const char *QFileDialog::dirPath() const
{
    return cwd.path();
}

/*!
  Sets a directory path string for the file dialog.
  \sa dir()
*/

void QFileDialog::setDir( const char *pathstr )
{
    if ( strcmp(cwd.path(),pathstr) == 0 )
	return;
    cwd.setPath( pathstr );
    cwd.convertToAbs();
    rereadDir();
}

/*!
  Returns the active directory in the file dialog.
  \sa setDir()
*/

const QDir *QFileDialog::dir() const
{
    return &cwd;
}

/*!
  Sets a directory path for the file dialog.
  \sa dir()
*/

void QFileDialog::setDir( const QDir &dir )
{
    cwd = dir;
    cwd.convertToAbs();
    cwd.setMatchAllDirs( TRUE );
    cwd.setSorting( cwd.sorting() | QDir::DirsFirst );
    if ( d ) {
	d->paths->insertItem( cwd.canonicalPath() );
	d->paths->setCurrentItem( d->paths->count() - 1 );
    }
    rereadDir();
}


/*!
  Re-reads the active directory in the file dialog.

  It is seldom necessary to call this function.	 It is provided in
  case the directory contents change and you want to refresh the
  directory list box.
*/

void QFileDialog::rereadDir()
{
    const QFileInfoList *filist = 0;

    int itemHeight = fontMetrics().height() + 6;

    while ( !filist ) {
	filist = cwd.entryInfoList();
	if ( !filist &&
	     QMessageBox::warning( this, "Open File",
				   QString( "Unable to read directory\n" ) +
				   cwd.absPath() + "\n\n"
				   "Please make sure that the directory\n"
				   "in readable.\n",
				   "Use Parent Directory",
				   "Use Old Contents", 0 ) ) {
	    return;
	}
	if ( !filist ) {
	    // change to parent, reread
	    // ...

	    // but for now
	    return;
	}
    }

    files->clear();

    QFileInfoListIterator it( *filist );
    QFileInfo *fi;
    while ( (fi = it.current()) != 0 ) {
	++it;
	(void) new QFileDialogPrivate::File( fi, files, itemHeight );
    }
    d->moreFiles->clear();
}



/*!
  \fn void QFileDialog::fileHighlighted( const char * )

  This signal is emitted when the user highlights a file.
*/

/*!
  \fn void QFileDialog::fileSelected( const char * )

  This signal is emitted when the user selects a file.
*/

/*!
  \fn void QFileDialog::dirEntered( const char * )

  This signal is emitted when the user has selected a new directory.
*/

static QString filedlg_dir;


/*!
  Opens a modal file dialog and returns the name of the file to be opened.
  Returns a \link QString::isNull() null string\endlink if the user cancelled
  the dialog.

  This static function is less capable than the full QFileDialog object,
  but is convenient and easy to use.

  Example:
  \code
    // start at the current working directory and with *.cpp as filter
    QString f = QFileDialog::getOpenFileName( 0, "*.cpp", this );
    if ( !f.isEmpty() ) {
        // the user selected a valid existing file
    } else {
        // the user cancelled the dialog
    }
  \endcode

  getSaveFileName() is another convenience function, equal to this one
  except that it allows the user to specify the name of a nonexistent file
  name.

  \sa getSaveFileName()
*/

QString QFileDialog::getOpenFileName( const char *dirName, const char *filter,
				      QWidget *parent, const char *name )
{
    if ( dirName && *dirName ) {
	filedlg_dir = dirName;
    } else if ( filedlg_dir.isNull() ) {
	filedlg_dir = QDir::currentDirPath();
    }

#if defined(_WS_WIN_)

    filedlg_dir = QDir::convertSeparators( filedlg_dir );

    const int maxstrlen = 256;
    char *file = new char[maxstrlen];
    file[0] = '\0';

    const char all_filter[] = "All Files\0*.*\0";
    const int all_len = sizeof(all_filter); // 15
    char* win_filter;
    int total_len = 0;
    if (filter) {
	int fl = strlen(filter)+1; // Include nul
	win_filter = new char[2*fl+all_len];
	for (int i=0; i<2; i++) {
	    memcpy(win_filter+total_len, filter, fl);
	    total_len += fl;
	}
    } else {
	win_filter = new char[all_len];
    }
    memcpy(win_filter+total_len, all_filter, all_len);

    OPENFILENAME ofn;
    memset( &ofn, 0, sizeof(OPENFILENAME) );
    ofn.lStructSize	= sizeof(OPENFILENAME);
    ofn.hwndOwner	= parent ? parent->topLevelWidget()->winId() : 0;
    ofn.lpstrFilter	= win_filter;
    ofn.lpstrFile	= file;
    ofn.nMaxFile	= maxstrlen;
    ofn.lpstrInitialDir = filedlg_dir;
    ofn.lpstrTitle	= "Open";
    ofn.Flags		= (OFN_CREATEPROMPT|OFN_NOCHANGEDIR);

    QString result;
    if ( GetOpenFileName(&ofn) ) {
	result = file;
	filedlg_dir = QFileInfo(file).dirPath();
    }

    delete [] win_filter;
    delete [] file;
    return result;

#else

    QFileDialog *dlg = new QFileDialog( filedlg_dir, filter, parent, name, TRUE );
    CHECK_PTR( dlg );
    dlg->setCaption( "Open" );
    QString result;
    if ( dlg->exec() == QDialog::Accepted ) {
	result = dlg->selectedFile();
	filedlg_dir = dlg->dirPath();
    }
    delete dlg;
    return result;

#endif
}

/*!
  Opens a modal file dialog and returns the name of the file to be saved.
  Returns a \link QString::isNull() null string\endlink if the user cancelled
  the dialog.

  This static function is less capable than the full QFileDialog object,
  but is convenient and easy to use.

  Example:
  \code
    // start at the current working directory and with *.cpp as filter
    QString f = QFileDialog::getSaveFileName( 0, "*.cpp", this );
    if ( !f.isEmpty() ) {
        // the user gave a file name
    } else {
        // the user cancelled the dialog
    }
  \endcode

  getOpenFileName() is another convenience function, equal to this one
  except that it allows the user to specify the name of a nonexistent file
  name.

  \sa getOpenFileName()
*/

QString QFileDialog::getSaveFileName( const char *dirName, const char *filter,
				      QWidget *parent, const char *name )
{
    if ( dirName && *dirName ) {
	filedlg_dir = dirName;
    } else if ( filedlg_dir.isNull() ) {
	filedlg_dir = QDir::currentDirPath();
    }

#if defined(_WS_WIN_)

    filedlg_dir = QDir::convertSeparators( filedlg_dir );

    const int maxstrlen = 256;
    char *file = new char[maxstrlen];
    file[0] = '\0';

    const char all_filter[] = "All Files\0*.*\0";
    const int all_len = sizeof(all_filter); // 15
    char* win_filter;
    int total_len = 0;
    if (filter) {
	int fl = strlen(filter)+1; // Include nul
	win_filter = new char[2*fl+all_len];
	for (int i=0; i<2; i++) {
	    memcpy(win_filter+total_len, filter, fl);
	    total_len += fl;
	}
    } else {
	win_filter = new char[all_len];
    }
    memcpy(win_filter+total_len, all_filter, all_len);

    OPENFILENAME ofn;
    memset( &ofn, 0, sizeof(OPENFILENAME) );
    ofn.lStructSize	= sizeof(OPENFILENAME);
    ofn.hwndOwner	= parent ? parent->topLevelWidget()->winId() : 0;
    ofn.lpstrFilter	= win_filter;
    ofn.lpstrFile	= file;
    ofn.nMaxFile	= maxstrlen;
    ofn.lpstrInitialDir = filedlg_dir;
    ofn.lpstrTitle	= "Save";
    ofn.Flags		= (OFN_CREATEPROMPT|OFN_NOCHANGEDIR);

    QString result;
    if ( GetSaveFileName(&ofn) ) {
	result = file;
	filedlg_dir = QFileInfo(file).dirPath();
    }

    delete [] win_filter;
    delete [] file;
    return result;

#else

    QFileDialog *dlg = new QFileDialog( filedlg_dir, filter, parent, name, TRUE );
    CHECK_PTR( dlg );
    dlg->setCaption( "Save As" );
    QString result;
    if ( dlg->exec() == QDialog::Accepted ) {
	result = dlg->selectedFile();
	filedlg_dir = dlg->dirPath();
    }
    delete dlg;
    return result;

#endif
}


/*!
  \internal
  Activated when the "Ok" button is clicked.
*/

void QFileDialog::okClicked()
{
    if ( strcmp( nameEdit->text(), "") != 0 ) {
	emit fileSelected( cwd.filePath( d->currentFileName ) );
	accept();
    }
}

/*!
  \internal
  Activated when the "Filter" button is clicked.
*/

void QFileDialog::filterClicked()
{
    // unused
}

/*!
  \internal
  Activated when the "Cancel" button is clicked.
*/

void QFileDialog::cancelClicked()
{
    reject();
}


/*!
  Handles resize events for the file dialog.
*/

void QFileDialog::resizeEvent( QResizeEvent * )
{
    updateGeometry();
}

/*! \internal

  Obsolete.
*/
void QFileDialog::updatePathBox( const char * )
{
    // unused
}


/*!  Make sure the minimum and maximum sizes of everything are sane.
*/

void QFileDialog::updateGeometry()
{
    if ( !d || !d->geometryDirty )
	return;

    d->geometryDirty = FALSE;

    QSize r, t;

    // we really should have a QSize::unite()
#define RM r.setWidth( QMAX(r.width(),t.width()) ); \
    r.setHeight( QMAX(r.height(),t.height()) )

    // labels first
    r = d->pathL->sizeHint();
    t = d->fileL->sizeHint();
    RM;
    t = d->typeL->sizeHint();
    RM;
    d->pathL->setFixedSize( r );
    d->fileL->setFixedSize( r );
    d->typeL->setFixedSize( r );

    // single-line input areas
    r = d->paths->sizeHint();
    t = nameEdit->sizeHint();
    RM;
    t = d->types->sizeHint();
    RM;
    t.setWidth( QCOORD_MAX );
    t.setHeight( r.height() );
    d->paths->setMinimumSize( r );
    d->paths->setMaximumSize( t );
    nameEdit->setMinimumSize( r );
    nameEdit->setMaximumSize( t );
    d->types->setMinimumSize( r );
    d->types->setMaximumSize( t );

    // buttons on top row
    r = QSize( 0, d->paths->minimumSize().height() );
    t = d->cdToParent->sizeHint();
    RM;
    // ...
    d->cdToParent->setFixedSize( r );
    // ...

    // open/save, cancel
    r = QSize( 80, 0 );
    t = okB->sizeHint();
    RM;
    t = cancelB->sizeHint();
    RM;
    okB->setFixedSize( r );
    cancelB->setFixedSize( r );

    d->topLevelLayout->activate();

#undef RM
}


/*!  Updates the dialog when the cursor moves in the listview.
*/

void QFileDialog::updateFileNameEdit( QListViewItem * newItem )
{
    if ( !newItem )
	return;

    QFileDialogPrivate::File * i = (QFileDialogPrivate::File *)newItem;

    if ( i->info.isFile() ) {
	d->currentFileName = i->info.fileName();
	nameEdit->setText( d->currentFileName );
    }
}


/*!  Updates the dialog when enter is pressed in the file name edit. */

void QFileDialog::fileNameEditDone()
{
    d->currentFileName = nameEdit->text();
}



/*!  This private slot reacts to double-clicks in the list view. */

void QFileDialog::selectDirectoryOrFile( QListViewItem * newItem )
{
    if ( !newItem || !newItem->isSelectable() )
	return;

    QFileDialogPrivate::File * i = (QFileDialogPrivate::File *)newItem;

    if ( i->info.isDir() && i->info.absFilePath() != cwd.canonicalPath() ) {
	setDir( QDir( i->info.absFilePath() ) );
    } else if ( i->info.isFile() ) {
	// should check read-only-versus-write here, perhaps?
	d->currentFileName = i->info.fileName();
	emit fileSelected( cwd.filePath( d->currentFileName ) );
	accept();
    }
}


/*!  Pops up a context menu at the global point \a p, for column \a c
  of item \a i. */

void QFileDialog::popupContextMenu( QListViewItem * i, const QPoint & p,
				    int c )
{
    QPopupMenu m( 0, "file dialog context menu" );

    int asc = m.insertItem( "&Ascending" );
    int desc = m.insertItem( "&Descending" );
    if ( i )
	m.insertItem( "&Sanctify" );

    m.move( p );
    int res = m.exec();
    if ( res == asc )
	files->setSorting( c, TRUE );
    else if ( res == desc )
	files->setSorting( c, FALSE );
}


void QFileDialog::fileSelected( int  )
{
    // unused
}

void QFileDialog::fileHighlighted( int )
{
    // unused
}

void QFileDialog::dirSelected( int )
{
    // unused
}

void QFileDialog::pathSelected( int )
{
    // unused
}
