/****************************************************************************
** $Id: //depot/qt/main/src/dialogs/qwizard.cpp#3 $
**
** Implementation of something useful.
**
** Created : 979899
**
** Copyright (C) 1992-1998 Troll Tech AS.  All rights reserved.
**
** This file is part of Troll Tech's internal development tree for Qt.
**
** This header text will be replaced by an appropriate text by the
** mkdist script which generates external distributions.
**
** If you are using the Qt Professional Edition or the Qt Free Edition,
** please notify Troll Tech at <info@troll.no> if you see this text.
**
** To Troll Tech developers: This header was generated by the script
** fixcopyright-int. It has the same number of text lines as the free
** and professional editions to avoid line number inconsistency.
**
*****************************************************************************/

#include "qwizard.h"

#include "qlayout.h"
#include "qpushbutton.h"
#include "qlabel.h"
#include "qwidgetstack.h"
#include "qapplication.h"
#include "qvector.h"
#include "qpainter.h"


/*! \class QWizard qwizard.h

  \brief The QWizard class provides a framework for easily writing wizards.

  A wizard is a dialog that consists of a sequential number of steps,
  each consisting of a single page.  QWizard provides a title for each
  page, and "Next", "Back", "Finish" and "Help" buttons, as
  appropriate.

*/


class QWizardPrivate
{
public:
    struct Page {
	Page( QWidget * widget, const QString & title ):
	    w( widget ), t( title ), back( 0 ),
	    backEnabled( TRUE ), nextEnabled( TRUE ), helpEnabled( FALSE ),
	    isLast( FALSE ), isHelpEnabled( TRUE ), appropriate( TRUE )
	{}
	QWidget * w;
	QString t;
	QWidget * back;
	bool backEnabled;
	bool nextEnabled;
	bool helpEnabled;
	bool isLast;
	bool isHelpEnabled;
	bool appropriate;
    };

    class Title: public QWidget {
    public:
	Title( QWizard * parent, QWizardPrivate * data ):
	    QWidget( parent, "title" ),
	    w( parent ), d ( data )
	{}

	QSizePolicy sizePolicy() const;
	QSize sizeHint() const;

    protected:
	void paintEvent( QPaintEvent * );

    private:
	QWizard * w;
	QWizardPrivate * d;
    };

    int currentPage;
    QWidgetStack * ws;
    QVector<Page> pages;
    Title * title;
    QPushButton * backButton;
    QPushButton * nextButton;
    QPushButton * helpButton;

    Page * page( const QWidget * w )
    {
	if ( !w )
	    return 0;
	int i = pages.count();
	while( --i >= 0 && pages[i] && pages[i]->w != w )
	    ;
	return i >= 0 ? pages[i] : 0;
    }

};


QSizePolicy QWizardPrivate::Title::sizePolicy() const
{
    return QSizePolicy( QSizePolicy::Minimum, QSizePolicy::Fixed );
}


QSize QWizardPrivate::Title::sizeHint() const
{
    return QSize( 1, fontMetrics().height() );
}


void QWizardPrivate::Title::paintEvent( QPaintEvent * )
{
    if ( !w || !d->pages.count() )
	return;

    QPainter p( this );
    p.drawText( 0, fontMetrics().ascent(), d->pages[d->currentPage]->t );
}


/*!  Constructs an empty wizard dialog. */

QWizard::QWizard( QWidget *parent, const char *name, bool modal,
		  WFlags f )
    : QDialog( parent, name, modal, f )
{
    d = new QWizardPrivate();
    d->currentPage = 0; // not quite true, but...
    d->ws = new QWidgetStack( this );
    d->title = new QWizardPrivate::Title( this, d );
    d->backButton = new QPushButton( this, "back" );
    d->nextButton = new QPushButton( this, "next" );
    d->helpButton = new QPushButton( this, "help" );

    QVBoxLayout * v = new QVBoxLayout( this, 12, 0, "top-level layout" );
    v->addWidget( d->title );
    QFrame * hbar;
    hbar = new QFrame( this, "<hr>", 0, TRUE );
    hbar->setFrameStyle( QFrame::Sunken + QFrame::HLine );
    hbar->setFixedHeight( 12 );
    v->addWidget( hbar );
    v->addWidget( d->ws );
    hbar = new QFrame( this, "<hr>", 0, TRUE );
    hbar->setFrameStyle( QFrame::Sunken + QFrame::HLine );
    hbar->setFixedHeight( 12 );
    v->addWidget( hbar );
    QBoxLayout * h = new QBoxLayout( QBoxLayout::LeftToRight );
    v->addLayout( h );
    h->addStretch( 42 );
    h->addWidget( d->backButton );
    h->addSpacing( 6 );
    h->addWidget( d->nextButton );
    h->addSpacing( 12 );
    h->addWidget( d->helpButton );

    d->helpButton->setText( tr( "Help" ) );
    d->nextButton->setText( tr( "Next>>" ) );
    d->backButton->setText( tr( "<<Back" ) );

    d->nextButton->setDefault( TRUE );

    connect( d->backButton, SIGNAL(clicked()),
	     this, SLOT(back()) );
    connect( d->nextButton, SIGNAL(clicked()),
	     this, SLOT(next()) );
}


/*! Destroys the object and frees any allocated resources, including,
of course, all pages and controllers.
*/

QWizard::~QWizard()
{
    delete d;
}


/*!  \reimp  */

void QWizard::show()
{
    if ( count() > 0 )
	showPage( d->ws->widget( d->currentPage ) );
    QDialog::show();
}


/*! \reimp */

void QWizard::setFont( const QFont & font )
{
    QApplication::postEvent( this, new QEvent( QEvent::LayoutHint ) );
    QDialog::setFont( font );
}


/*!  Adds \a page to the end of the wizard, titled \a title.  If \a
controller is 0 (the default) there will be no wizard controller for
\a page, otherwise \a controller is the controller for \a page.
*/

void QWizard::addPage( QWidget * page, const QString & title )
{
    if ( !page )
	return;
    if ( d->page( page ) ) {
#if defined(CHECK_STATE)
	debug( "already added %s/%s to %s/%s",
	       page->className(), page->name(),
	       className(), name() );
#endif	
	return;
    }
    int i = count();
    d->ws->addWidget( page, i );
    d->pages.resize( i+1 );
    d->pages.insert( i, new QWizardPrivate::Page( page, title ) );
}


/*!  Makes \a w be the displayed page. */

void QWizard::showPage( QWidget * w )
{
    int i = d->ws->id( w );
    if ( i >= 0 ) {
	setBackEnabled( i > 0 );
	setNextEnabled( TRUE );
	d->nextButton->setText( i == count()-1 ?
				tr( "Finish" ) : tr( "Next>>" ) );
	d->ws->raiseWidget( i );
	d->currentPage = i;
	d->title->repaint();
    }
}


/*!  Returns the number of pages in the wizard. */

int QWizard::count() const
{
    return d->pages.count();
}


/*!

*/

void QWizard::back()
{
    QWizardPrivate::Page * p = d->pages[d->currentPage];
    if ( p )
	p = d->page( p->back );
    if ( p )
	showPage( p->w );
}


/*!

*/






void QWizard::next()
{
    int i = d->currentPage + 1;
    while( i < (int)d->pages.count()-1 && !appropriate( d->pages[i]->w ) )
	i++;
    if ( i < (int)d->pages.count() ) {
	d->pages[i]->back = d->pages[d->currentPage]->w;
	showPage( d->pages[i]->w );
    }
}


/*!  This slot either makes the wizard help you, if it can.  The only
way it knows is to emit the helpClicked() signal, and perhaps the
QWizardPage::helpClicked() signal too, if a QWizardPage is currently
being displayed.
*/

void QWizard::help()
{
    QWidget * page = d->ws->visibleWidget();
    if ( !page )
	return;

#if 0
    if ( page->inherits( "QWizardPage" ) )
	emit ((QWizardPage *)page)->helpClicked();
#endif
    emit helpClicked();
}


void QWizard::setBackEnabled( bool enable )
{
    d->backButton->setEnabled( enable );
}


void QWizard::setNextEnabled( bool enable )
{
    d->nextButton->setEnabled( enable );
}


void QWizard::setHelpEnabled( bool enable )
{
    d->helpButton->setEnabled( enable );
}


/*!

*/

void QWizard::setFinish( QWidget * w, bool isLast )
{
    QWizardPrivate::Page * p = d->page( w );
    if ( !p )
	return;

    p->isLast = isLast;
    updateButtons();
}


/*!

*/

void QWizard::setBackEnabled( QWidget * w, bool enable )
{
    QWizardPrivate::Page * p = d->page( w );
    if ( !p )
	return;

    p->backEnabled = enable;
    updateButtons();
}


/*!

*/

void QWizard::setNextEnabled( QWidget * w, bool enable )
{
    QWizardPrivate::Page * p = d->page( w );
    if ( !p )
	return;

    p->nextEnabled = enable;
    updateButtons();
}


/*!

*/

void QWizard::setHelpEnabled( QWidget * w, bool enable )
{
    QWizardPrivate::Page * p = d->page( w );
    if ( !p )
	return;

    p->helpEnabled = enable;
    updateButtons();
}


/*!  This virtual function returns TRUE if \a w is appropriate for
display in the current context of the wizard, and FALSE if QWizard
should go on.

It is called when the Next button is clicked.

\warning The last page of a wizard will be displayed if nothing else wants
to, and the Next button was enabled when the user clicked.

The default implementation returns whatever was set using
setApproprate().  The ultimate default is TRUE.
*/

bool QWizard::appropriate( QWidget * w ) const
{
    QWizardPrivate::Page * p = d->page( w );
    return p ? p->appropriate : TRUE;
}


/*!

*/

void QWizard::setApproprate( QWidget * w, bool enable )
{
    QWizardPrivate::Page * p = d->page( w );
    if ( p )
	p->appropriate = enable;
}


void QWizard::updateButtons() const
{
    QWizardPrivate::Page * p = d->pages[d->currentPage];
    d->backButton->setEnabled( p->backEnabled );
    d->nextButton->setEnabled( p->nextEnabled );
    d->helpButton->setEnabled( p->helpEnabled );
}
