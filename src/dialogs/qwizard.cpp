/****************************************************************************
** $Id: //depot/qt/main/src/dialogs/qwizard.cpp#2 $
**
** Implementation of something useful.
**
** Created : 979899
**
** Copyright (C) 1992-1998 Troll Tech AS.  All rights reserved.
**
** This file is part of Troll Tech's internal development tree for Qt.
**
** This header text will be replaced by an appropriate text by the
** mkdist script which generates external distributions.
**
** If you are using the Qt Professional Edition or the Qt Free Edition,
** please notify Troll Tech at <info@troll.no> if you see this text.
**
** To Troll Tech developers: This header was generated by the script
** fixcopyright-int. It has the same number of text lines as the free
** and professional editions to avoid line number inconsistency.
**
*****************************************************************************/

#include "qwizard.h"

#include "qlayout.h"
#include "qpushbutton.h"
#include "qlabel.h"
#include "qwidgetstack.h"
#include "qapplication.h"
#include "qvector.h"
#include "qpainter.h"


/*! \class QWizard qwizard.h

  \brief The QWizard class provides a framework for easily writing wizards.

  A wizard is a dialog that consists of a sequential number of steps,
  each consisting of a single page.  QWizard provides a title for each
  page, and "Next", "Back", "Finish" and "Help" buttons, as
  appropriate.

*/


class QWizardPrivate
{
public:
    struct Page {
	Page( QWidget * widget, const QString & title ):
	    w( widget ), t( title ) {}
	QWidget * w;
	QString t;
    };

    class Title: public QWidget {
    public:
	Title( QWizard * parent, QWizardPrivate * data ):
	    QWidget( parent, "title" ),
	    w( parent ), d ( data )
	{}

	QSizePolicy sizePolicy() const;
	QSize sizeHint() const;

    protected:
	void paintEvent( QPaintEvent * );

    private:
	QWizard * w;
	QWizardPrivate * d;
    };

    int currentPage;
    QWidgetStack * ws;
    QVector<Page> pages;
    Title * title;
    QPushButton * backButton;
    QPushButton * nextButton;
    QPushButton * helpButton;
};

QSizePolicy QWizardPrivate::Title::sizePolicy() const
{
    return QSizePolicy( QSizePolicy::Minimum, QSizePolicy::Fixed );
}

QSize QWizardPrivate::Title::sizeHint() const
{
    return QSize( 1, fontMetrics().height() );
}


void QWizardPrivate::Title::paintEvent( QPaintEvent * )
{
    if ( !w || !d->pages.count() )
	return;

    QPainter p( this );
    p.drawText( 0, fontMetrics().ascent(), d->pages[d->currentPage]->t );
}


/*!  Constructs an empty wizard dialog. */

QWizard::QWizard( QWidget *parent, const char *name, bool modal,
		  WFlags f )
    : QDialog( parent, name, modal, f )
{
    d = new QWizardPrivate();
    d->currentPage = 0; // not quite true, but...
    d->ws = new QWidgetStack( this );
    d->title = new QWizardPrivate::Title( this, d );
    d->backButton = new QPushButton( this, "back" );
    d->nextButton = new QPushButton( this, "next" );
    d->helpButton = new QPushButton( this, "help" );

    QVBoxLayout * v = new QVBoxLayout( this, 12, 0, "top-level layout" );
    v->addWidget( d->title );
    QFrame * hbar;
    hbar = new QFrame( this, "<hr>", 0, TRUE );
    hbar->setFrameStyle( QFrame::Sunken + QFrame::HLine );
    hbar->setFixedHeight( 12 );
    v->addWidget( hbar );
    v->addWidget( d->ws );
    hbar = new QFrame( this, "<hr>", 0, TRUE );
    hbar->setFrameStyle( QFrame::Sunken + QFrame::HLine );
    hbar->setFixedHeight( 12 );
    v->addWidget( hbar );
    QBoxLayout * h = new QBoxLayout( QBoxLayout::LeftToRight );
    v->addLayout( h );
    h->addStretch( 42 );
    h->addWidget( d->backButton );
    h->addSpacing( 6 );
    h->addWidget( d->nextButton );
    h->addSpacing( 12 );
    h->addWidget( d->helpButton );

    d->helpButton->setText( tr( "Help" ) );
    d->nextButton->setText( tr( "Next>>" ) );
    d->backButton->setText( tr( "<<Back" ) );

    d->nextButton->setDefault( TRUE );

    connect( d->backButton, SIGNAL(clicked()),
	     this, SLOT(back()) );
    connect( d->nextButton, SIGNAL(clicked()),
	     this, SLOT(next()) );
}


/*! Destroys the object and frees any allocated resources, including,
of course, all pages and controllers.
*/

QWizard::~QWizard()
{
    delete d;
}


/*!  \reimp  */

void QWizard::show()
{
    if ( count() > 0 )
	showPage( d->ws->widget( d->currentPage ) );
    QDialog::show();
}


/*! \reimp */

void QWizard::setFont( const QFont & font )
{
    QApplication::postEvent( this, new QEvent( QEvent::LayoutHint ) );
    QDialog::setFont( font );
}


/*!  Adds \a page to the end of the wizard, titled \a title.  If \a
controller is 0 (the default) there will be no wizard controller for
\a page, otherwise \a controller is the controller for \a page.
*/

void QWizard::addPage( QWidget * page, const QString & title )
{
    if ( !page )
	return;
    int i = count();
    d->ws->addWidget( page, i );
    d->pages.resize( i+1 );
    d->pages.insert( i, new QWizardPrivate::Page( page, title ) );
}


/*!  Makes \a w be the displayed page. */

void QWizard::showPage( QWidget * w )
{
    int i = d->ws->id( w );
    if ( i >= 0 ) {
	setBackEnabled( i > 0 );
	setNextEnabled( TRUE );
	d->nextButton->setText( i == count()-1 ?
				tr( "Finish" ) : tr( "Next>>" ) );
	d->ws->raiseWidget( i );
	d->currentPage = i;
	d->title->repaint();
    }
}


/*!  Returns the number of pages in the wizard. */

int QWizard::count() const
{
    return d->pages.count();
}


/*!

*/

void QWizard::back()
{
    bool okay = d->currentPage > 0;
    if ( okay )
	showPage( d->ws->widget( d->currentPage - 1 ) );
}


/*!

*/

void QWizard::next()
{
    bool okay = d->currentPage < (int)d->pages.count()-1;
    if ( okay )
	showPage( d->ws->widget( d->currentPage + 1 ) );
}


/*!

*/

void QWizard::help()
{
    fatal( "sex" );
}


/*!

*/

void QWizard::setBackEnabled( bool enable )
{
    d->backButton->setEnabled( enable );
}


/*!

*/

void QWizard::setNextEnabled( bool enable )
{
    d->nextButton->setEnabled( enable );
}


/*!

*/

void QWizard::setHelpEnabled( bool enable )
{
    d->helpButton->setEnabled( enable );
}
