/****************************************************************************
** $Id: //depot/qt/main/src/kernel/qlayout.cpp#48 $
**
** Implementation of layout classes
**
** Created : 960416
**
** Copyright (C) 1992-1998 Troll Tech AS.  All rights reserved.
**
** This file is part of Troll Tech's internal development tree for Qt.
**
** This header text will be replaced by an appropriate text by the
** mkdist script which generates external distributions.
**
** If you are using the Qt Professional Edition or the Qt Free Edition,
** please notify Troll Tech at <info@troll.no> if you see this text.
**
** To Troll Tech developers: This header was generated by the script
** fixcopyright-int. It has the same number of text lines as the free
** and professional editions to avoid line number inconsistency.
**
*****************************************************************************/

#include "qlayout.h"
#include "qmenubar.h"
#include "qapplication.h"
#include "qlist.h"

class QLayoutBox
{
public:
    enum Type { Error, Layout, Widget, Spacer };
    QLayoutBox( QLayout* );
    QLayoutBox( QWidget*);
    QLayoutBox( int w, int h, bool hStretch=FALSE, bool vStretch=FALSE );
    ~QLayoutBox() {}

    Type type() const { return myType; }

    QSize minSize() const;
    bool horFixed() const;
    bool verFixed() const;

    void setAlignment( int a ) { align = a; }
    void setGeometry( const QRect& );

private:
    friend class QLayoutArray;
    Type myType;

    int align;

    int row, col;
    int width, height;
    bool hFix;
    bool vFix;
    //union {
    QLayout *lay;
    QWidget *wid;
    // }
    void init();
};

class QMultiBox
{
public:
    QMultiBox( QLayoutBox *box, int toRow, int toCol )
	:box_(box), torow(toRow), tocol(toCol) {}
    QLayoutBox *box() { return box_; }
private:
    friend QLayoutArray;
    QLayoutBox *box_;
    int torow, tocol;
};


QLayoutBox::QLayoutBox( QLayout *l )
{
    init();
    myType = Layout;
    lay = l;
}
QLayoutBox::QLayoutBox( QWidget *w )
{
    init();
    myType = Widget;
    wid = w;
}
QLayoutBox::QLayoutBox( int w, int h, bool hStretch, bool vStretch )
{
    init();
    myType = Spacer;
    width = w;
    height = h;
    hFix = !hStretch;
    vFix = !vStretch;
}

void QLayoutBox::init()
{
    myType = Error;
    lay = 0;
    wid = 0;
    width = height = 0;
    align = 0;
}


void QLayoutBox::setGeometry( const QRect &r )
{
    switch ( myType ) {
    case Spacer:
	break;
    case Layout:
	lay->setGeometry( r );
	break;
    case Widget:
	if ( align ) {
	    //### layoutHint...
	    QSize s = r.size().boundedTo( wid->maximumSize() );
	    int x = r.x();
	    int y = r.y();
	    if ( align & AlignHCenter )
		x = x + ( r.width() - s.width() ) / 2;
	    else if ( align & AlignRight )
		x = x + ( r.width() - s.width() );
	    if ( align & AlignVCenter )
		y = y + ( r.height() - s.height() ) / 2;
	    else if ( align & AlignBottom )
		y = y + ( r.height() - s.height() );
	    wid->setGeometry( x, y, s.width(), s.height() );
	} else {
	    wid->setGeometry( r );
	}
	break;
    case Error:
	warning( "QLayout error: uninitialized case D." );
	break;
    }
}

bool QLayoutBox::horFixed() const
{
    switch ( myType ) {
    case Spacer:
	return hFix;
    case Layout:
	return lay->fixedWidth();
    case Widget:
	return wid->minimumSize().width() == wid->maximumSize().width();
	//		||layoutHint...
    case Error:
	warning( "QLayout error: uninitialized case B." );
	break;
    }
    return FALSE;

}
bool QLayoutBox::verFixed() const
{
    switch ( myType ) {
    case Spacer:
	return vFix;
    case Layout:
	return lay->fixedHeight();
    case Widget:
	return wid->minimumSize().height() == wid->maximumSize().height();
	//		||layoutHint...
    case Error:
	warning( "QLayout error: uninitialized case C." );
	break;
    }
    return FALSE;
}

QSize QLayoutBox::minSize() const
{
    switch ( myType ) {
    case Spacer:
	return QSize( width, height );
    case Layout:
	return lay->minSize();
    case Widget:
	if ( wid->layout() )
	    return QSize( QMAX( wid->sizeHint().width(), wid->minimumWidth() ),
		      QMAX( wid->sizeHint().height(), wid->minimumHeight() ));
	return QSize( wid->minimumWidth() == 0 ?
		      wid->sizeHint().width() : wid->minimumWidth(),
		      wid->minimumHeight() == 0 ?
		      wid->sizeHint().height() : wid->minimumHeight() );
    case Error:
	warning( "QLayout error: uninitialized case A." );
	break;
    }
    return QSize( 0, 0 );
}


struct LayoutStruct
{
    void init() { minSize = 0; fixedSize = FALSE; stretch = 0; }

    //permanent storage:
    int stretch;
    //parameters:
    int minSize;
    bool fixedSize;
    bool empty;
    //temporary storage:
    bool done;
    //result:
    int pos;
    int size;
};


static inline int toFixed( int i ) { return i * 256; }
static inline int fRound( int i ) {
    return  i % 256 < 128 ? i / 256 : 1 + i / 256;
}
/*
  \internal
  This is the main workhorse of the QGridLayout. It portions out
  available space to the chain's children.

  The calculation is done in fixed point: "fixed" variables are scaled
  by a factor of 256.

  If the layout runs "backwards" (i.e. RightToLeft or Up) the layout
  is computed mirror-reversed, and it is the callers responsibility do
  reverse the values before use.

  chain contains input and output parameters describing the geometry.
  count is the count of items in the chain,
  pos and space give the interval (relative to parentWidget topLeft.)

*/

static void geomCalc( QArray<LayoutStruct> &chain, int count, int pos,
		      int space, int spacer )
{
    typedef int fixed;
    int sumMin = 0;
    int sumStretch = 0;
    int spacerCount = 0;

    int i; //some hateful compilers do not handle for loops correctly
    for ( i = 0; i < count; i++ ) {
	chain[i].done = FALSE;
	sumMin += chain[i].minSize;
	sumStretch += chain[i].stretch;
	if ( !chain[i].empty )
	    spacerCount++;
    }
    if ( spacerCount )
	spacerCount -= 1; //only spacers between things
    if ( space < sumMin + spacerCount*spacer ) {
	//Not enogh space... Lets just give out minimum sizes.
	for ( int i = 0; i < count; i++ )
	    chain[i].size = chain[i].minSize;
    } else {
	int n = count;
	int space_left = space - spacerCount*spacer;
	for ( i = 0; i < count; i++ ) {
	    if ( !chain[i].done && chain[i].fixedSize ) {
		//	    debug( "We have fixed size in %d", i );
		chain[i].size = chain[i].minSize;
		chain[i].done = TRUE;
		space_left -= chain[i].minSize;
		sumStretch -= chain[i].stretch;
		n--;
	    }
	}
	bool finished = n == 0;
	while ( !finished ) {
	    finished = TRUE;
	    fixed fp_space = toFixed( space_left );
	    fixed fp_w = 0;

	    for ( i = 0; i < count; i++ ) {
		if ( chain[i].done )
		    continue;
		if ( sumStretch <= 0 )
		    fp_w += fp_space / n;
		else
		    fp_w += (fp_space * chain[i].stretch) / sumStretch;
		int w = fRound( fp_w );
		chain[i].size = w;
		fp_w -= toFixed( w ); //give the difference to the next
		if ( w < chain[i].minSize ) {
		    chain[i].done = TRUE;
		    chain[i].size = chain[i].minSize;
		    finished = FALSE;
		    space_left -= chain[i].minSize;
		    sumStretch -= chain[i].stretch;
		    n--;
		    break;
		}
	    }
	}
    }

    int p = pos;
    for ( i = 0; i < count; i++ ) {
	chain[i].pos = p;
	p = p + chain[i].size;
	if ( !chain[i].empty )
	    p += spacer;
    }
}

class QLayoutArray
{
public:
    QLayoutArray();
    QLayoutArray( int nRows, int nCols );
    ~QLayoutArray();

    void add( QLayoutBox*, int row, int col );
    void add( QLayoutBox*, int row1, int row2, int col1, int col2  );
    QSize minSize( int );
    void distribute( QRect, int );
    int numRows() const { return rr; }
    int numCols() const { return cc; }
    void expand( int rows, int cols )
	{ setSize( QMAX(rows,rr), QMAX(cols,cc) ); }
    void setRowStretch( int r, int s ) { expand(r+1,0); rowData[r].stretch=s; }
    void setColStretch( int c, int s ) { expand(0,c+1); colData[c].stretch=s; }
    bool fixedWidth();
    bool fixedHeight();
    bool removeWidget( QWidget* );
    void setReversed( bool r, bool c ) { hReversed = c; vReversed = r; }
    //    void setDirty() { needRecalc = TRUE; }

private:
    void init();
    void addData ( QLayoutBox *b, bool r = TRUE, bool c = TRUE );
    void setSize( int rows, int cols );
    void setupLayoutData();
    int rr;
    int cc;
    bool hReversed;
    bool vReversed;
    QArray<LayoutStruct> rowData;
    QArray<LayoutStruct> colData;
    QList<QLayoutBox> things;
    QList<QMultiBox> *multi;
    //    bool needRecalc;
};

QLayoutArray::QLayoutArray()
{
    init();
}

QLayoutArray::QLayoutArray( int nRows, int nCols )
    :rowData(nRows), colData(nCols)
{
    init();
    rr = nRows; cc = nCols;
}
void QLayoutArray::init()
{
    //    needRecalc = TRUE;
    multi = 0;
    rr = cc = 0;
    things.setAutoDelete( TRUE );
    hReversed = vReversed = FALSE;
}
bool QLayoutArray::removeWidget( QWidget *w )
{
    QListIterator<QLayoutBox> it( things );
    QLayoutBox * box;
    while ( (box=it.current()) != 0 ) {
	++it;
	if ( box->type() == QLayoutBox::Widget && box->wid == w ) {
	    things.removeRef( box );
	    return TRUE;
	} else if ( box->type() == QLayoutBox::Layout &&
		    box->lay->removeWidget(w) ) {
	    return TRUE;
	}
    }
    if ( multi ) {
	QListIterator<QMultiBox> it( *multi );
	QMultiBox * mbox;
	while ( (mbox=it.current()) != 0 ) {
	    ++it;
	    box = mbox->box();
	    if ( box->type() == QLayoutBox::Widget && box->wid == w ) {
		multi->removeRef( mbox );
		return TRUE;
	    } else if ( box->type() == QLayoutBox::Layout &&
			box->lay->removeWidget(w) ) {
		return TRUE;
	    }
	}
    }
    return FALSE;
}

bool QLayoutArray::fixedHeight()
{
    setupLayoutData();
    bool fixed = TRUE;
    for ( int r = 0; r < rr; r++ ) {
	fixed = fixed && rowData[r].fixedSize;
    }
    return fixed;
}

bool QLayoutArray::fixedWidth()
{
    setupLayoutData();
    bool fixed = TRUE;
    for ( int c = 0; c < cc; c++ ) {
	fixed = fixed && colData[c].fixedSize;
    }
    return fixed;
}

QSize QLayoutArray::minSize( int spacer )
{
    setupLayoutData();
    int w = 0;
    int h = 0;
    int n = 0;
    for ( int r = 0; r < rr; r++ ) {
	h = h + rowData[r].minSize;
	if ( !rowData[r].empty )
	    n++;
    }
    if ( n )
	h += (n-1)*spacer;
    n = 0;
    for ( int c = 0; c < cc; c++ ) {
	w = w + colData[c].minSize;
	if ( !colData[c].empty )
	    n++;
    }
    if ( n )
	w += (n-1)*spacer;

    return QSize(w,h);
}

void QLayoutArray::setSize( int r, int c )
{
    int newR = rr;
    int newC = cc;
    if ( (int)rowData.size() < r ) {
	newR = QMAX(r,rr*2);
	rowData.resize( newR );
	for ( int i = rr; i < newR; i++ )
	    rowData[i].init();
    }
    if ( (int)colData.size() < c ) {
	newC = QMAX(c,cc*2);
	colData.resize( newC );
	for ( int i = cc; i < newC; i++ )
	    colData[i].init();
    }
    rr = r;
    cc = c;
}

void QLayoutArray::add( QLayoutBox *box, int row, int col )
{
    expand( row+1, col+1 );
    box->row = row;
    box->col = col;
    things.append( box );
}

void QLayoutArray::add( QLayoutBox *box,  int row1, int row2,
			int col1, int col2  )
{
    expand( row2+1, col2+1 );
    box->row = row1;
    box->col = col1;
    QMultiBox *mbox = new QMultiBox( box, row2, col2 );
    if ( !multi )
	multi = new QList<QMultiBox>;
    multi->append( mbox );
}

void QLayoutArray::addData ( QLayoutBox *box, bool r, bool c )
{
    QSize min = box->minSize();
    if ( c ) {
    colData[box->col].minSize = QMAX( min.width(),
				      colData[box->col].minSize );
    colData[box->col].fixedSize = box->horFixed() &&
				  colData[box->col].fixedSize;
    }
    if ( r ) {
    rowData[box->row].minSize = QMAX( min.height(),
				      rowData[box->row].minSize );
    rowData[box->row].fixedSize = box->verFixed() &&
				  rowData[box->row].fixedSize;
    }
    if ( box->type() != QLayoutBox::Spacer ) {
	//#### spacers do not get borders. This is ugly, but compatible.
	if ( c )
	    colData[box->col].empty = FALSE;
	if ( r )
	    rowData[box->row].empty = FALSE;
    }

}

void QLayoutArray::setupLayoutData()
{
    //    if ( !needRecalc )
    //		return;
    int i;
    for ( i = 0; i < rr; i++ ) {
	rowData[i].minSize = 0;
	rowData[i].fixedSize = TRUE;
	rowData[i].empty = TRUE;
    }
    for ( i = 0; i < cc; i++ ) {
	colData[i].minSize = 0;
	colData[i].fixedSize = TRUE;
	colData[i].empty = TRUE;
    }
    QListIterator<QLayoutBox> it( things );
    QLayoutBox * box;
    while ( (box=it.current()) != 0 ) {
	++it;
	addData( box );
    }

    if ( multi ) {
	QListIterator<QMultiBox> it( *multi );
	QMultiBox * mbox;
	while ( (mbox=it.current()) != 0 ) {
	    ++it;
	    QLayoutBox *box = mbox->box();
	    int r1 = box->row;
	    int c1 = box->col;
	    int r2 = mbox->torow;
	    int c2 = mbox->tocol;
	    int w = 0;
	    QSize min = box->minSize();
	    if ( r1 == r2 ) {
		addData( box, TRUE, FALSE );
	    } else {
		int r;
		for ( r = r1; r <= r2; r++ )
		    w += rowData[r].minSize;
		if ( w < min.width() ) {
		    debug( "Overwide multicell" );
		    //distribute the size somehow.
		}
	    }
	    if ( c1 == c2 ) {
		addData( box, FALSE, TRUE );
	    } else {
		int c;
		for ( c = c1; c <= c2; c++ )
		    w += colData[c].minSize;
		if ( w < min.height() ) {
		    debug( "Overtall multicell" );
		    //distribute the size somehow.
		}
	    }
	}
    }

    //    needRecalc = FALSE;
}

void QLayoutArray::distribute( QRect r, int spacing )
{
    setupLayoutData();

    geomCalc( rowData, rr, r.y(), r.height(), spacing );
    geomCalc( colData, cc, r.x(), r.width(), spacing );

    QListIterator<QLayoutBox> it( things );
    QLayoutBox * box;
    while ( (box=it.current()) != 0 ) {
	++it;
	int x = colData[box->col].pos;
	int y = rowData[box->row].pos;
	int w = colData[box->col].size;
	int h = rowData[box->row].size;
	if ( hReversed )
	    x = r.left() + r.right() - x - w;
	if ( vReversed )
	    y = r.top() + r.bottom() - y - h;
	QRect rr( x, y, w, h );
	box->setGeometry(rr);
    }
    if ( multi ) {
	QListIterator<QMultiBox> it( *multi );
	QMultiBox * mbox;
	while ( (mbox=it.current()) != 0 ) {
	    ++it;
	    QLayoutBox *box = mbox->box();
	    int r2 = mbox->torow;
	    int c2 = mbox->tocol;
	    int x = colData[box->col].pos;
	    int y = rowData[box->row].pos;
	    int x2 = colData[c2].pos + colData[c2].size;
	    int y2 = rowData[r2].pos + rowData[r2].size;
	    int w = x2 - x + 1;
	    int h = y2 - y + 1;
	    // this code is copied from above:
	    if ( hReversed )
		x = r.left() + r.right() - x - w;
	    if ( vReversed )
		y = r.top() + r.bottom() - y - h;
	    QRect rr( x, y, w, h );
	    box->setGeometry(rr);
	    //end copying
	
	}
    }
}

/*!
  \class QLayout qlayout.h
  \brief The QLayout class is the base class of geometry specifiers.

  \ingroup geomanagement

  This is an abstract base class. The concrete layout managers
  QBoxLayout and QGridLayout inherit from this one.

  Most users of Q*Layout are likely to use some of the basic functions
  provided by QLayout, such as  setMenuBar(), which is necessary
  to manage a menu bar because of the special properties of menu bars,
  and  freeze(), which allows you to freeze the widget's size and
  layout.

  To make your own layout manager, implement the functions
  minSize(), setGeometry() and removeWidget().

  Geometry management stops when the layout manager is deleted.
*/


/*!
  Creates a new top-level QLayout with main widget \a
  parent.  \a parent may not be 0.

  \a border is the number of pixels between the edge of the widget and
  the managed children.	 \a autoBorder sets the value of defaultBorder(), which
  is interpreted by subclasses.	 If \a autoBorder is -1 the value
  of \a border is used.

  \a name is the internal object name

  Having several top-level layouts for the same widget will cause
  considerable confusion.

*/

QLayout::QLayout( QWidget *parent, int border, int autoBorder, const char *name )
    : QObject( parent, name )
{
    menubar = 0;
    topLevel = FALSE;
    if ( parent ) {
	if ( parent->layout() ) {
	    warning( "QLayout \"%s\" added to %s \"%s\","
		     " which already had a layout.", QObject::name(),
		     parent->className(), parent->name() );
	} else {
	topLevel = TRUE;
	parent->installEventFilter( this );
	parent->qInternalSetLayout( this );
	}
    }
    outsideBorder = border;
    if ( autoBorder < 0 )
	insideSpacing = border;
    else
	insideSpacing = autoBorder;
}

/*!
  \fn QString QLayout::name() const

  Returns the internal object name.
*/

/*!
  \fn QMenuBar* QLayout::menuBar () const
  Returns the menu bar set for this layout, or a null pointer if no
  menu bar is set.
 */



/*!
  \fn bool QLayout::isTopLevel () const

 */

/*!
  \fn const QRect& QLayout::geometry ()

 */


/*!
  \fn bool QLayout::removeWidget (QWidget *w )
  This function is implemented in subclasses to remove \a w from geometry
  management.
 */


/*!
  \fn int QLayout::margin () const
  returns the border width.
 */


/*!
  Returns the main widget (parent widget) of this layout, or 0 if this
  layout is a sub-layout which is not yet inserted.
*/

QWidget * QLayout::mainWidget()
{
    if ( !topLevel ) {
	if ( parent() ) {
	    ASSERT( parent()->inherits( "QLayout" ) );
	    return ((QLayout*)parent())->mainWidget();
	} else {
	    return 0;
	}
    } else {
	ASSERT( parent() && parent()->isWidgetType() );
	return  (QWidget*)parent();
    }
}


/*!
  Constructs a new child QLayout,
  If \a autoBorder is -1, this QLayout inherits \a parent's
  defaultBorder(), otherwise \a autoBorder is used.
*/

QLayout::QLayout( int autoBorder, const char *name )
    : QObject( 0, name )
{
    menubar = 0;
    topLevel	 = FALSE;
    insideSpacing = autoBorder;
}



/*!
  This function is called whenever the parent widget receives a paint
  event. Reimplemented in subclasses to draw decorations that depend on
  the geometry of the layout.

  The default implementation does nothing.

  Note: The parent widget's \link QWidget::paintEvent()
  paintEvent()\endlink function is called after this function. Any
  painting done by the parent widget may obscure part or all of the
  decoration done by this function.
 */

void QLayout::paintEvent( QPaintEvent * )
{
    //############ must distribute to child layouts.
}


/*! \fn QSize QLayout::minSize()
  Returns the minimum size this layout needs.
*/

/*! \fn  bool removeWidget( QWidget *w )

  Remove \a w from geometry management. This function is called
  automatically whenever a child widget is deleted.

  This function is implemented in subclasses. It is the
  responsibility of the reimplementor to propagate the call to
  sub-layouts.  This function returns TRUE if the widget was found.
 */

#if 0
/*!
  Implemented in subclasses to remove cached values used during
  geometry calculations, if any.

  The default implementation does nothing.
*/

void QLayout::clearCache()
{
}
#endif

/*!
  This function is reimplemented in subclasses to
  perform layout.

  The default implementation maintains the geometry() information.
 */
void QLayout::setGeometry( const QRect &r )
{
    rect = r;
}


/*!
  Performs child widget layout when the parent widget is resized.
  Also handles removal of widgets.
*/

bool QLayout::eventFilter( QObject *o, QEvent *e )
{
    if ( !o->isWidgetType() )
	return FALSE;

    //    QWidget *p = (QWidget*)o;
    //		 if ( p != parentWidget() ) return FALSE;
    switch ( e->type() ) {
    case QEvent::Resize: {
	QResizeEvent *r = (QResizeEvent*)e;
	int mbh = 0;
	if ( menubar )
	    mbh = menubar->heightForWidth( r->size().width() );
	setGeometry( QRect( outsideBorder, mbh + outsideBorder,
			 r->size().width() - 2*outsideBorder,
			 r->size().height() - mbh - 2*outsideBorder ) );
	break;
    }
    case QEvent::ChildRemoved: {
	QChildEvent *c = (QChildEvent*)e;
	if ( c->child()->isWidgetType() ) {
	    QWidget *w = (QWidget*)c->child();
	    if ( w == menubar )
		menubar = 0;
	    removeWidget( w );
	    QEvent *lh = new QEvent( QEvent::LayoutHint );
	    QApplication::postEvent( o, lh );
	}
	break;
    }
    case QEvent::LayoutHint:
	activate(); //######## ######@#!#@!$ should be optimized somehow...
	break;
    case QEvent::Paint:
	paintEvent( (QPaintEvent*) e );
	break;
    default:
	break;
    }
    return FALSE;			    // standard event processing

}



/*!
  Deletes all layout children. Geometry management stops when
  a toplevel layout is deleted.
  \internal
  The layout classes will probably be fatally confused if you delete
  a sublayout
*/

QLayout::~QLayout()
{
    //note that this function may be called during the QObject destructor,
    //when the parent no longer is a QWidget.
    if ( isTopLevel() && parent()->isWidgetType() &&
	 ((QWidget*)parent())->layout() == this )
	((QWidget*)parent())->qInternalSetLayout( 0 );
}


/*!
  This function is called from addLayout functions in subclasses,
  to add \a l layout as a sublayout.
*/
//############## do we like this API???
void QLayout::addChildLayout( QLayout *l )
{
    if ( l->topLevel ) {
#if defined(CHECK_NULL)
	warning( "QLayout: Attempt to add top-level layout as child" );
#endif
	return;
    }
    insertChild( l );
    if ( l->insideSpacing < 0 )
	l->insideSpacing = insideSpacing;
}

/*!
  \fn int QLayout::defaultBorder() const
  Returns the default border for the geometry manager.
*/

/*!
  \overload void QLayout::freeze()

  This version of the method fixes the main widget at its minimum size.
  You can also achieve this with freeze( 0, 0 );
*/


/*!
  Fixes the size of the main widget and distributes the available
  space to the child widgets. For widgets which should not be
  resizable, but where a QLayout subclass is used to set up the initial
  geometry.

  A frozen layout cannot be unfrozen, the only sensible thing to do
  is to delete it.

  The size is adjusted to a valid value. Thus freeze(0,0) fixes the
  widget to its minimum size.
*/

void QLayout::freeze( int w, int h )
{
    warning( "QLayout::freeze( %d, %d ) not implemented", w, h );
}


/*!
  Makes the geometry manager take account of the menu bar \a w. All
  child widgets are placed below the bottom edge of the menu bar.

  A menu bar does its own geometry managing, never do addWidget()
  on a menu bar.
*/

void QLayout::setMenuBar( QMenuBar *w )
{
    menubar = w;
}


/*!
  Returns TRUE if this layout has a fixed horizontal size.
  The default implementation returns FALSE.
*/

bool QLayout::fixedWidth()
{
    return FALSE;
}

/*!
  Returns TRUE if this layout has a fixed vertical size.
  The default implementation returns FALSE.
*/

bool QLayout::fixedHeight()
{
    return FALSE;
}


/*!
  \class QGridLayout qlayout.h

  \brief The QGridLayout class lays out child widgets in a grid.

  \ingroup geomanagement

  QGridLayout takes the space it gets (from its parent layout or from
  the mainWidget()), divides it up into rows and columns, and puts
  each of the child widgets it manages into the correct cell(s).

  Columns and rows behave identically; we will discuss columns but
  there are eqivalent functions for rows.

  Each column has a minimum width and a stretch factor.  The minimum
  width is the greatest of that set using addRowSpacing() and the
  minimum width of each widget in that column.  The stretch factor is
  set using setColStretch() and determines how much of the available
  space the column will get, over and above its necessary minimum.

  Normally, each child widget or layout is put into a cell of its own
  using addWidget() or addLayout(), but you can also put widget into
  multiple cells using addMultiCellWidget().  However, if you do that,
  QGridLayout does not take the child widget's minimum size into
  consideration (because it does not known what column the minimum
  width should belong to).  Thus you must set the minimum width of
  each column using addColSpacing().

  This illustration shows a fragment of a dialog with a five-column,
  three-row grid (the grid is shown overlaid in magenta):

  <img src="gridlayout.gif" width="425" height="150">

  Columns 0, 2 and 4 in this dialog fragment are made up of a QLabel,
  a QLineEdit and a QListBox.  Columns 1 and 2 are placeholders, made
  with setColSpacing().  Row 0 consists of three QLabel objects, row 1
  of three QLineEdit objects and row 2 of three QListBox objects.

  Since we did not want any space between the rows, we had to use
  placeholder columns to get the right amount of space between the
  columns.

  Note that the columns and rows are not equally wide/tall: If you
  want two columns to be equally wide, you must set the columns'
  minimum widths and stretch factors to be the same yourself.  You do
  this using addColSpacing() and setStretch().

  If the QGridLayout is not the top-level layout (ie. is not managing
  all of the widget's area and children), you must add it to its
  parent layout when you have created it, but before you can do
  anything with it.  The normal way to add a layout is by calling
  parentLayout->addLayout().

  Once you have done that, you can start putting widgets and other
  layouts in the cells of your grid layout using addWidget(),
  addLayout() and addMultiCellWidget().

  Finally, if the grid is the top-level layout, you activate() it.

  QGridLayout also includes two margin widths: The border width and
  the inter-box width.  The border width is the width of the reserved
  space along each of the QGridLayout's four sides.  The intra-widget
  width is the width of the automatically allocated spacing between
  neighbouring boxes.

  The border width defaults to 0, and the intra-widget width defaults
  to the same as the border width.  Both are set using arguments to
  the constructor.
*/


/*! \base64 gridlayout.gif

  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

*/

/*!
  Constructs a new QGridLayout with \a nRows rows, \a nCols columns
   and main widget \a  parent.	\a parent may not be 0.

  \a border is the number of pixels between the edge of the widget and
  the managed children.	 \a autoBorder is the default number of pixels
  between cells.  If \a autoBorder is -1 the value
  of \a border is used.

  \a name is the internal object name.
*/

QGridLayout::QGridLayout( QWidget *parent, int nRows, int nCols, int border ,
			  int autoBorder , const char *name )
    : QLayout( parent, border, autoBorder, name )
{
    init( nRows, nCols );
}


/*!
  Constructs a new grid with \a nRows rows and \a  nCols columns,
  If \a autoBorder is -1, this QGridLayout will inherits its parent's
  defaultBorder(), otherwise \a autoBorder is used.

  You have to insert this grid into another layout before using it.
*/

QGridLayout::QGridLayout( int nRows, int nCols,
			  int autoBorder, const char *name )
     : QLayout( autoBorder, name )
{
    init( nRows, nCols );
}


/*!
  Deletes this grid. Geometry management is terminated if
  this is a top-level grid.
*/

QGridLayout::~QGridLayout()
{
}

/*!
  Returns the number of rows in this grid.
  */
int QGridLayout::numRows() const
{
    return array->numRows();
}

/*!
  Returns the number of columns in this grid.
  */
int QGridLayout::numCols() const
{
    return array->numCols();
}


/*!
  Returns the minimum size needed by this grid.
*/

QSize QGridLayout::minSize()
{
    QSize s =  array->minSize( defaultBorder() );
    if ( isTopLevel() )
	s += QSize( 2*margin(), 2*margin() );
    return s;
}
/*!
  Removes \a w from geometry management.
 */
bool QGridLayout::removeWidget( QWidget *w )
{
    return array->removeWidget( w );
}

/*!
  Resizes child widgets within the rectangle \a s.
 */
void QGridLayout::setGeometry( const QRect &s )
{
    QLayout::setGeometry( s );
    array->distribute( s, defaultBorder() );
}

/*!
  Expands this grid so that it will have \a nRows rows and \a nCols columns.
  Will not shrink the grid.
 */
void QGridLayout::expand( int nRows, int nCols )
{
    array->expand( nRows, nCols );
}

/*!
  Sets up the table and other internal stuff
*/

void QGridLayout::init( int nRows, int nCols )
{
    array = new QLayoutArray( nRows, nCols );
    expand( nRows, nCols );
}





/*!
  Adds \a box at position \a row, \a col. The layout takes over ownership
  of \a box.
*/

void QGridLayout::add( QLayoutBox *box, int row, int col )
{
    array->add( box, row, col );
}


/*!
  Adds the widget \a w to the cell grid at \a row, \a col.
  The top left position is (0,0)

  Alignment is specified by \a align which takes the same arguments as
  QLabel::setAlignment().  Note that widgets take all the space they
  can get; alignment has no effect unless you have set
  QWidget::maximumSize().

*/

void QGridLayout::addWidget( QWidget *w, int row, int col, int align )
{
    QLayoutBox *b = new QLayoutBox( w );
    b->setAlignment( align );
    add( b, row, col );
}

/*!
  Adds the widget \a w to the cell grid, spanning multiple rows/columns.

  Note that multicell widgets do not influence the minimum or maximum
  size of columns/rows they span. Use addColSpacing() or addRowSpacing()
  to set minimum sizes explicitly.

  Alignment is specified by \a align which takes the same arguments as
  QLabel::setAlignment(), alignment has no effect unless you have set
  QWidget::maximumSize().
*/

void QGridLayout::addMultiCellWidget( QWidget *w, int fromRow, int toRow,
				      int fromCol, int toCol, int align	 )
{
    QLayoutBox *b = new QLayoutBox( w );
    b->setAlignment( align );
    array->add( b, fromRow, toRow, fromCol, toCol );
}


/*!
  Places another layout at position (\a row, \a col) in the grid.
  The top left position is (0,0)
*/

void QGridLayout::addLayout( QLayout *layout, int row, int col)
{
    addChildLayout( layout );
    QLayoutBox *b = new QLayoutBox( layout );
    add( b, row, col );
}


/*!
  Sets the stretch factor of row \a row to \a stretch.
  The first row is number 0.

  The stretch factor  is relative to the other rows in this grid.
  Rows with higher stretch factor take more of the available space.

  The default stretch factor is 0.
  If the stretch factor is 0 and no other row in this table can
  grow at all, the row may still grow.
*/

void QGridLayout::setRowStretch( int row, int stretch )
{
    array->setRowStretch( row, stretch );
}


/*!
  Sets the stretch factor of column \a col to \a stretch.
  The first column is number 0.

  The stretch factor  is relative to the other columns in this grid.
  Columns with higher stretch factor take more of the available space.

  The default stretch factor is 0.
  If the stretch factor is 0 and no other column in this table can
  grow at all, the column may still grow.
*/

void QGridLayout::setColStretch( int col, int stretch )
{
    array->setColStretch( col, stretch );
}


/*!
  Sets the minimum height of \a row to \a minsize pixels.
 */
void QGridLayout::addRowSpacing( int row, int minsize )
{
    QLayoutBox *b = new QLayoutBox( 0, minsize );
    //b.setAlignment( align );
    add( b, row, 0 );
}

/*!
  Sets the minimum width of \a col to \a minsize pixels.
 */
void QGridLayout::addColSpacing( int col, int minsize )
{
    QLayoutBox *b = new QLayoutBox( minsize, 0 );
    //b.setAlignment( align );
    add( b, 0, col );
}


/*!
  Returns TRUE if this layout has a fixed width.
*/

bool QGridLayout::fixedWidth()
{
    return array->fixedWidth();
}

/*!
  Returns TRUE if this layout has a fixed height.
*/

bool QGridLayout::fixedHeight()
{
    return array->fixedHeight();
}

/*!
  Sets which of the four corners of the grid corresponds to (0,0).
*/

void QGridLayout::setOrigin( Corner c )
{
    array->setReversed( c == BottomLeft || c == BottomRight,
			c == TopRight || c == BottomRight );
}

#if 0
/*!
  Resets cached information.
*/

void QGridLayout::clearCache()
{

}
#endif



/*!
  \class QBoxLayout qlayout.h

  \brief The QBoxLayout class lines up child widgets horizontally or
  vertically.

  \ingroup geomanagement

  QBoxLayout takes the space it gets (from its parent layout or from
  the mainWidget()), divides it up into a row of boxes and makes each
  managed widget fill one box.

  If the QBoxLayout is \c Horizontal, the boxes are beside each other,
  with suitable sizes.  Each widget (or other box) will get at least
  its minimum sizes and at most its maximum size, and any excess space
  is shared according to the stretch factors (more about that below).

  If the QBoxLayout is \c Vertical, the boxes are above and below each
  other, again with suitable sizes.

  The easiest way to create a QBoxLayout is to use one of the
  convenience classes QHBoxLayout (for \c Horizontal boxes) or
  QVBoxLayout (for \c Vertical boxes). You can also use the QBoxLayout
  constuctor directly, specifying its direction as \c LeftToRight, \c
  Down, \c RightToLeft or \c Up.

  If the QBoxLayout is not the top-level layout (ie. is not managing
  all of the widget's area and children), you must add it to its
  parent layout before you can do anything with it.  The normal way to
  add a layout is by calling parentLayout->addLayout().

  Once you have done that, you can add boxes to the QBoxLayout using
  one of four functions: <ul>

  <li> addWidget() to add a widget to the QBoxLayout and set the
  widget's stretch factor.  (The stretch factor is along the row of
  boxes.)

  <li> addSpacing() to create an empty box; this is one of the
  functions you use to create nice and spacious dialogs.  See below
  for ways to set margins.

  <li> addStretch() to create an empty, stretchable box.

  <li> addLayout() to add a box containing another QLayout to the row
  and set that layout's stretch factor.

  </ul>

  Finally, if the layout is a top-level one, you activate() it.

  QBoxLayout also includes two margin widths: The border width and the
  inter-box width.  The border width is the width of the reserved
  space along each of the QBoxLayout's four sides.  The intra-widget
  width is the width of the automatically allocated spacing between
  neighbouring boxes.  (You can use addSpacing() to get more space.)

  The border width defaults to 0, and the intra-widget width defaults
  to the same as the border width.  Both are set using arguments to
  the constructor.

  You will almost always want to use the convenience classes for
  QBoxLayout: QVBoxLayout and QHBoxLayout, because of their simpler
  constructors.
*/

static inline bool horz( QBoxLayout::Direction dir )
{
    return dir == QBoxLayout::RightToLeft || dir == QBoxLayout::LeftToRight;
}

/*!
  Creates a new QBoxLayout with direction \a d and main widget \a
  parent.  \a parent may not be 0.

  \a border is the number of pixels between the edge of the widget and
  the managed children.	 \a autoBorder is the default number of pixels
  between neighbouring children.  If \a autoBorder is -1 the value
  of \a border is used.

  \a name is the internal object name

  \sa direction()
*/

QBoxLayout::QBoxLayout( QWidget *parent, Direction d,
			int border, int autoBorder, const char *name )
    : QGridLayout( parent, 0, 0, border, autoBorder, name )
{
    dir = d;
    if ( d == RightToLeft || d == BottomToTop )
	setOrigin( BottomRight );
}

/*!
  If \a autoBorder is -1, this QBoxLayout will inherit its parent's
  defaultBorder(), otherwise \a autoBorder is used.

  You have to insert this box into another layout before using it.
*/

QBoxLayout::QBoxLayout( Direction d,
			int autoBorder, const char *name )
    : QGridLayout( 0, 0, autoBorder, name )
{
    dir = d;
    if ( d == RightToLeft || d == BottomToTop )
	setOrigin( BottomRight );
}


/*!
  Destroys this box.
*/

QBoxLayout::~QBoxLayout()
{
}

/*!
  Adds \a layout to the box, with serial stretch factor \a stretch.

  \sa addWidget(), addSpacing()
*/

void QBoxLayout::addLayout( QLayout *layout, int stretch )
{
    if ( horz( dir ) ) {
	int n = numCols();
	QGridLayout::addLayout( layout, 0, n ) ;
	setColStretch( n, stretch );
    } else {
	int n = numRows();
	QGridLayout::addLayout( layout, n, 0 ) ;
	setRowStretch( n, stretch );
    }
}

/*!
  Adds a non-stretchable space with size \a size.  QBoxLayout gives
  default border and spacing. This function adds additional space.

  \sa addStretch()
*/
void QBoxLayout::addSpacing( int size )
{
    //################ not correct: extra insideSpacing

    if ( horz( dir ) ) {
	int n = numCols();
	expand( 1, n+1 );
	QGridLayout::addColSpacing( n, size ) ;
    } else {
	int n = numRows();
	expand( n+1, 1 );
	QGridLayout::addRowSpacing( n, size ) ;
    }
}

/*!
  Adds a stretchable space with zero minimum size
  and stretch factor \a stretch.

  \sa addSpacing()
*/
void QBoxLayout::addStretch( int stretch )
{
    //################ not correct: extra insideSpacing
    if ( horz( dir ) ) {
	int n = numCols();
	expand( 1, n+1 );
	QLayoutBox *b = new QLayoutBox(0,0,TRUE,FALSE);
	add( b, 0, n ) ;
	setColStretch( n, stretch );
    } else {
	int n = numRows();
	expand( n+1, 1 );
	QLayoutBox *b = new QLayoutBox(0,0,FALSE,TRUE);
	add( b, n, 0 ) ;
	//	QGridLayout::addRowSpacing( n, 0 ) ;
	setRowStretch( n, stretch );
    }
}

/*!
  Limits the perpendicular dimension of the box (e.g. height if the
  box is LeftToRight) to a minimum of \a size. Other constraints may
  increase the limit.
*/

void QBoxLayout::addStrut( int size )
{
    warning( "QBoxLayout::addStrut( %d ), not yet implemented", size );
}

/*!
  Adds \a widget to the box, with stretch factor \a stretch and
  alignment \a align.

  The stretch factor applies only in the \link direction() direction
  \endlink of the QBoxLayout, and is relative to the other boxes and
  widgets in this QBoxLayout.  Widgets and boxes with higher stretch
  factor grow more.

  If the stretch factor is 0 and nothing else in the QBoxLayout can
  grow at all, the widget may still grow up to its \link
  QWidget::setMaximumSize() maximum size. \endlink

  Alignment is perpendicular to direction(), alignment in the
  serial direction is done with addStretch().

  For horizontal boxes,	 the possible alignments are
  <ul>
  <li> \c AlignCenter centers vertically in the box.
  <li> \c AlignTop aligns to the top border of the box.
  <li> \c AlignBottom aligns to the bottom border of the box.
  </ul>

  For vertical boxes, the possible alignments are
  <ul>
  <li> \c AlignCenter centers horizontally in the box.
  <li> \c AlignLeft aligns to the left border of the box.
  <li> \c AlignRight aligns to the right border of the box.
  </ul>

  Alignment only has effect if the size of the box is greater than the
  widget's maximum size.

  \sa addLayout(), addSpacing()
*/

void QBoxLayout::addWidget( QWidget *widget, int stretch, int align )
{
    if ( horz( dir ) ) {
	int n = numCols();
	QGridLayout::addWidget( widget, 0, n, align ) ;
	setColStretch( n, stretch );
    } else {
	int n = numRows();
	QGridLayout::addWidget( widget, n, 0, align ) ;
	setRowStretch( n, stretch );
    }
}


/*!
  \fn QBoxLayout::Direction QBoxLayout::direction() const

  Returns the (serial) direction of the box. addWidget(), addBox()
  and addSpacing() works in this direction; the stretch stretches
  in this direction. \link QBoxLayout::addWidget Alignment \endlink
  works perpendicular to this direction.

  The directions are \c LeftToRight, \c RightToLeft, \c TopToBottom
  and \c BottomToTop. For the last two, the shorter aliases \c Down and
  \c Up are also available.

  \sa addWidget(), addBox(), addSpacing()
*/




/*!
  \class QHBoxLayout qlayout.h

  \brief The QHBoxLayout class lines up child widgets horizontally.

  \ingroup geomanagement

  This class provides an easier way to construct horizontal box layout
  objects.  See \l QBoxLayout for more details.

  The simplest way to use this class is:

  \code
     QBoxLayout * l = new QHBoxLayout( widget );
     l->addWidget( aWidget );
     l->addWidget( anotherWidget );
     l->activate()
  \endcode

  \sa QVBoxLayout QGridLayout
*/


/*!
  Creates a new top-level horizontal box.
 */
QHBoxLayout::QHBoxLayout( QWidget *parent, int border,
			  int autoBorder, const char *name )
    : QBoxLayout( parent, LeftToRight, border, autoBorder, name )
{

}

/*!
  Creates a new horizontal box. You have to add it to another
  layout before using it.
 */
QHBoxLayout::QHBoxLayout( int autoBorder, const char *name )
    :QBoxLayout( LeftToRight, autoBorder, name )
{
}


/*!
  Destroys this box.
*/

QHBoxLayout::~QHBoxLayout()
{
}



/*!
  \class QVBoxLayout qlayout.h

  \brief The QVBoxLayout class lines up child widgets vertically.

  \ingroup geomanagement

  This class provides an easier way to construct vertical box layout
  objects.  See \l QBoxLayout for more details.

  The simplest way to use this class is:

  \code
     QBoxLayout * l = new QVBoxLayout( widget );
     l->addWidget( aWidget );
     l->addWidget( anotherWidget );
     l->activate()
  \endcode

  \sa QHBoxLayout QGridLayout
*/

/*!
  Creates a new top-level vertical box.
 */
QVBoxLayout::QVBoxLayout( QWidget *parent, int border,
			  int autoBorder, const char *name )
    : QBoxLayout( parent, TopToBottom, border, autoBorder, name )
{

}

/*!
  Creates a new vertical box. You have to add it to another
  layout before using it.
 */
QVBoxLayout::QVBoxLayout( int autoBorder, const char *name )
    :QBoxLayout( TopToBottom, autoBorder, name )
{
}

/*!
  Destroys this box.
*/

QVBoxLayout::~QVBoxLayout()
{
}

