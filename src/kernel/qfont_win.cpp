/****************************************************************************
** $Id: //depot/qt/main/src/kernel/qfont_win.cpp#67 $
**
** Implementation of QFont, QFontMetrics and QFontInfo classes for Win32
**
** Created : 940630
**
** Copyright (C) 1992-1998 Troll Tech AS.  All rights reserved.
**
** This file is part of Troll Tech's internal development tree for Qt.
**
** This header text will be replaced by an appropriate text by the
** mkdist script which generates external distributions.
**
** If you are using the Qt Professional Edition or the Qt Free Edition,
** please notify Troll Tech at <info@troll.no> if you see this text.
**
** To Troll Tech developers: This header was generated by the script
** fixcopyright-int. It has the same number of text lines as the free
** and professional editions to avoid line number inconsistency.
**
*****************************************************************************/

#include "qfont.h"
#include "qfontdata.h"
#include "qfontmetrics.h"
#include "qfontinfo.h"
#include "qwidget.h"
#include "qpainter.h"
#include "qcache.h"
#include "qdict.h"
#include <limits.h>

#if defined(_CC_BOOL_DEF_)
#undef	bool
#include <windows.h>
#define bool int
#else
#include <windows.h>
#endif

extern WindowsVersion qt_winver;		// defined in qapplication_win.cpp

#if defined(Q_SHARED_FONTDC)
static HANDLE shared_dc	     = 0;		// common dc for all fonts
static HANDLE shared_dc_font = 0;
#endif
static HANDLE stock_sysfont  = 0;

static inline HANDLE systemFont()
{
    if ( stock_sysfont == 0 )
	stock_sysfont = GetStockObject(SYSTEM_FONT);
    return stock_sysfont;
}


/*****************************************************************************
  QFontInternal definition and implementation
 *****************************************************************************/

class QFontInternal
{
public:
   ~QFontInternal();
    bool	    dirty()      const;
    const char	   *key()	 const;
    HANDLE	    dc()	 const;
    HANDLE	    font()	 const;
    TEXTMETRICA	   *textMetricA() const;
    TEXTMETRICW	   *textMetricW() const;
    const QFontDef *spec()	 const;
    int		    lineWidth()  const;
    void	    reset();
private:
    QFontInternal( const QString & );
    QString	k;
#if !defined(Q_SHARED_FONTDC)
    HANDLE	hdc;
#endif
    HANDLE	hfont;
    bool	stockFont;
    union {
	TEXTMETRICW	w;
	TEXTMETRICA	a;
    } tm;
    QFontDef	s;
    int		lw;
    friend void QFont::load(HANDLE) const;
    friend void QFont::initFontInfo() const;
};

inline QFontInternal::QFontInternal( const QString &key )
#if defined(Q_SHARED_FONTDC)
    : k(key), hfont(0)
#else
    : k(key), hdc(0), hfont(0)
#endif
{
    s.dirty = TRUE;
}

inline bool QFontInternal::dirty() const
{
    return hfont == 0;
}

inline const char* QFontInternal::key() const
{
    return k;
}

inline HANDLE QFontInternal::dc() const
{
#if defined(Q_SHARED_FONTDC)
    ASSERT( shared_dc != 0 && hfont != 0 );
    if ( shared_dc_font != hfont ) {
	SelectObject( shared_dc, hfont );
	shared_dc_font = hfont;
    }
    return shared_dc;
#else
    return hdc;
#endif
}

inline HANDLE QFontInternal::font() const
{
    return hfont;
}

inline TEXTMETRICA *QFontInternal::textMetricA() const
{
    QFontInternal *that = (QFontInternal *)this;
    return &that->tm.a;
}

inline TEXTMETRICW *QFontInternal::textMetricW() const
{
    QFontInternal *that = (QFontInternal *)this;
    return &that->tm.w;
}

inline const QFontDef *QFontInternal::spec() const
{
    return &s;
}

inline int QFontInternal::lineWidth() const
{
    return lw;
}

void QFontInternal::reset()
{
#if defined(Q_SHARED_FONTDC)
    if ( hfont ) {
	if ( shared_dc_font == hfont ) {	// this is the current font
	    ASSERT( shared_dc != 0 );
	    SelectObject( shared_dc, systemFont() );
	    shared_dc_font = 0;
	}
	if ( !stockFont )
	    DeleteObject( hfont );
	hfont = 0;
    }
#else
    if ( hdc ) {
	SelectObject( hdc, systemFont() );
	if ( !stockFont )
	    DeleteObject( hfont );
	DeleteDC( hdc );
	hdc = hfont = 0;
    }
#endif
}

inline QFontInternal::~QFontInternal()
{
    reset();
}


static const int fontCacheSize = 120;		// max number of loaded fonts


Q_DECLARE(QCacheM,QFontInternal);		// inherited by QFontCache
typedef Q_DECLARE(QCacheIteratorM,QFontInternal) QFontCacheIt;
typedef Q_DECLARE(QDictM,QFontInternal)		 QFontDict;
typedef Q_DECLARE(QDictIteratorM,QFontInternal)  QFontDictIt;


class QFontCache : public QCacheM(QFontInternal)
{
public:
    QFontCache( int maxCost, int size=17, bool cs=TRUE, bool ck=TRUE )
	: QCacheM(QFontInternal)(maxCost,size,cs,ck) {}
    void deleteItem( GCI );
};

void QFontCache::deleteItem( GCI d )
{
    QFontInternal *fin = (QFontInternal *)d;
    fin->reset();
}


static QFontCache    *fontCache	     = 0;	// cache of loaded fonts
static QFontDict     *fontDict	     = 0;	// dict of all loaded fonts
QFont		     *QFont::defFont = 0;	// default font


/*****************************************************************************
  QFont member functions
 *****************************************************************************/

void QFont::initialize()
{
    if ( fontCache )
	return;
#if defined(Q_SHARED_FONTDC)
    shared_dc = CreateCompatibleDC( qt_display_dc() );
    shared_dc_font = 0;
#endif
    fontCache = new QFontCache( fontCacheSize, 29, TRUE, FALSE );
    CHECK_PTR( fontCache );
    fontDict  = new QFontDict( 29, TRUE, FALSE );
    CHECK_PTR( fontDict );
    if ( !defFont )
	defFont = new QFont( TRUE );		// create the default font
}

void QFont::cleanup()
{
    delete defFont;
    defFont = 0;
    delete fontCache;
    fontCache = 0;
    fontDict->setAutoDelete( TRUE );
    delete fontDict;
#if defined(Q_SHARED_FONTDC)
    ASSERT( shared_dc_font == 0 );
    DeleteDC( shared_dc );
    shared_dc = 0;
#endif
}

void QFont::cacheStatistics()
{
#if defined(DEBUG)
    fontCache->statistics();
    QFontCacheIt it(*fontCache);
    QFontInternal *fin;
    debug( "{" );
    while ( (fin = it.current()) ) {
	++it;
	debug( "   [%s]", fin->key() );
    }
    debug( "}" );
#endif
}


QFont::QFont( Internal )
{
    init();
    d->req.family    = "MS Sans Serif";		// default font
    d->req.pointSize = 8*10;
    d->req.weight    = QFont::Normal;
}


// If d->req.dirty is not TRUE the font must have been loaded
// and we can safely assume that d->fin is a valid pointer:

#define DIRTY_FONT (d->req.dirty || d->fin->dirty())


HANDLE QFont::handle( HANDLE output_hdc ) const
{
    static HANDLE last = 0;
    if ( DIRTY_FONT ) {
	load( output_hdc );
    } else {
	if ( d->fin->font() != last )
	    fontCache->find( d->fin->key() );
    }
    last = d->fin->font();
    return last;
}

QString QFont::rawName() const
{
    return family();
} 


bool QFont::dirty() const
{
    return DIRTY_FONT;
}


QString QFont::defaultFamily() const
{
    switch( d->req.styleHint ) {
	case Times:
	    return "times";
	case Courier:
	    return "courier";
	case Decorative:
	    return "old english";
	case Helvetica:
	case System:
	default:
	    return "helvetica";
    }
}


QString QFont::lastResortFamily() const
{
    return "helvetica";
}

QString QFont::lastResortFont() const
{
    return "arial";
}


void QFont::initFontInfo() const
{
    QFontInternal *f = d->fin;
    if ( !f->s.dirty )				// already initialized
	return;
    f->lw = 1;
    f->s = d->req;				// most settings are equal
    char n[64];
    GetTextFace( f->dc(), 64, n );
    if ( stricmp(f->s.family,n) != 0 )
	f->s.family = n;
    f->s.dirty = FALSE;
}


void QFont::load( HANDLE ) const
{
    if ( !fontCache )				// not initialized
	return;

    QString k = key();
    d->fin = fontCache->find( k );
    if ( !d->fin ) {				// font not loaded
	d->fin = fontDict->find( k );
	if ( !d->fin ) {			// font was never loaded
	    d->fin = new QFontInternal( k );
	    CHECK_PTR( d->fin );
	    fontDict->insert( d->fin->key(), d->fin );
	}
    }
    if ( !d->fin->font() ) {			// font not loaded
#if !defined(Q_SHARED_FONTDC)
	d->fin->hdc = GetDC(0);
#endif
	d->fin->hfont = create( &d->fin->stockFont, 0 );
	SelectObject( d->fin->dc(), d->fin->hfont );
	if ( qt_winver == WV_NT ) {
	    GetTextMetricsW( d->fin->dc(), &d->fin->tm.w );
	} else {
	    GetTextMetricsA( d->fin->dc(), &d->fin->tm.a );
	}
	fontCache->insert( d->fin->key(), d->fin, 1 );
	initFontInfo();
    }
    d->exactMatch = TRUE;
    d->req.dirty = FALSE;
}


#if !defined(DEFAULT_GUI_FONT)
#define DEFAULT_GUI_FONT 17
#endif


HANDLE QFont::create( bool *stockFont, HANDLE hdc ) const
{
    QString fam = QFont::substitute( d->req.family );
    if ( d->req.rawMode ) {			// will choose a stock font
	int f, deffnt;
	if ( qt_winver == WV_NT || qt_winver == WV_32s )
	    deffnt = SYSTEM_FONT;		// Windows NT or Win32s
	else
	    deffnt = DEFAULT_GUI_FONT;		// Windows 95
	fam = fam.lower();
	if ( fam == "default" )
	    f = deffnt;
	else if ( fam == "system" )
	    f = SYSTEM_FONT;
	else if ( fam == "system_fixed" )
	    f = SYSTEM_FIXED_FONT;
	else if ( fam == "ansi_fixed" )
	    f = ANSI_FIXED_FONT;
	else if ( fam == "ansi_var" )
	    f = ANSI_VAR_FONT;
	else if ( fam == "device_default" )
	    f = DEVICE_DEFAULT_FONT;
	else if ( fam == "oem_fixed" )
	    f = OEM_FIXED_FONT;
	else if ( fam[0] == '#' )
	    f = fam.right(fam.length()-1).toInt();
	else
	    f = deffnt;
	if ( stockFont )
	    *stockFont = TRUE;
	HANDLE hfont = GetStockObject( f );
	if ( !hfont )
	    hfont = systemFont();
	return hfont;
    }

    int hint = FF_DONTCARE;
    switch ( styleHint() ) {
	case Helvetica:
	    hint = FF_SWISS;
	    break;
	case Times:
	    hint = FF_ROMAN;
	    break;
	case Courier:
	    hint = FF_MODERN;
	    break;
	case OldEnglish:
	    hint = FF_DECORATIVE;
	    break;
	case System:
	    hint = FF_MODERN;
	    break;
	default:
	    break;
    }

    LOGFONT lf;
    memset( &lf, 0, sizeof(LOGFONT) );
    if ( hdc )
	lf.lfHeight = -(d->req.pointSize*GetDeviceCaps(hdc,LOGPIXELSY)/720);
    else
	lf.lfHeight = -(d->req.pointSize/10);
    lf.lfWidth		= 0;
    lf.lfEscapement	= 0;
    lf.lfOrientation	= 0;
    if ( d->req.weight == 50 )
	lf.lfWeight = FW_DONTCARE;
    else
	lf.lfWeight = (d->req.weight*900)/99;
    lf.lfItalic		= d->req.italic;
    lf.lfUnderline	= d->req.underline;
    lf.lfStrikeOut	= d->req.strikeOut;
    int cs;
    switch ( charSet() ) {
	case AnyCharSet:
	case Latin1:
	    cs = ANSI_CHARSET;
	    break;
	case Latin2:
	    cs = EASTEUROPE_CHARSET;
	    break;
	case Latin5:
	    cs = TURKISH_CHARSET;
	    break;
	case Latin7:
	    cs = GREEK_CHARSET;
	    break;
	default:
	    cs = ANSI_CHARSET;
	    break;
    }
    lf.lfCharSet	= cs;
    lf.lfOutPrecision   = OUT_DEFAULT_PRECIS;
    lf.lfClipPrecision  = CLIP_DEFAULT_PRECIS;
    lf.lfQuality	= DEFAULT_QUALITY;
    lf.lfPitchAndFamily = DEFAULT_PITCH | hint;
    strcpy( lf.lfFaceName, fam );

    HANDLE hfont = CreateFontIndirect( &lf );
    if ( stockFont )
	*stockFont = hfont == 0;
    if ( hfont == 0 )
	hfont = GetStockObject( ANSI_VAR_FONT );
    return hfont;
}


void *QFont::textMetric() const
{
    if ( DIRTY_FONT ) {
	load();
#if defined(DEBUG)
	ASSERT( d->fin && d->fin->font() );
#endif
    }
    if ( qt_winver == WV_NT )
	return d->fin->textMetricW();
    else
	return d->fin->textMetricA();
}


/*****************************************************************************
  QFontMetrics member functions
 *****************************************************************************/

class QPainter_Protected : public QPainter	// access to textMetric()
{
public:
    void *tm() { return textMetric(); }
};


const QFontDef *QFontMetrics::spec() const
{
    const QFontDef *s;
    if ( type() == FontInternal ) {
	s = u.f->spec();
    } else if ( type() == Widget && u.w ) {
	QFont *f = (QFont *)&u.w->font();
	f->handle();
	s = f->d->fin->spec();
    } else if ( type() == Painter && u.p ) {
	QFont *f = (QFont *)&u.p->font();
	f->handle();
	s = f->d->fin->spec();
    } else {
	s = 0;
    }
#if defined(CHECK_NULL)
    if ( !s )
	warning( "QFontMetrics: Invalid font metrics" );
#endif
    return s;
}

void *QFontMetrics::textMetric() const
{
    if ( type() == FontInternal ) {
	if ( qt_winver == WV_NT )
	    return u.f->textMetricW();
	else
	    return u.f->textMetricA();
    } else if ( type() == Widget && u.w ) {
	QFont *f = (QFont *)&u.w->font();
	f->handle();
	if ( qt_winver == WV_NT )
	    return f->d->fin->textMetricW();
	else
	    return f->d->fin->textMetricA();
    } else if ( type() == Painter && u.p ) {
	return ((QPainter_Protected*)u.p)->tm();
    } else {
#if defined(CHECK_NULL)
	warning( "QFontMetrics: Invalid font metrics" );
#endif
	return 0;
    }
}

#undef  TM
#undef  TMX
#undef  TMA
#undef  TMW
#define TMA (type() == FontInternal ? u.f->textMetricA() : (TEXTMETRICA*)textMetric())
#define TMW (type() == FontInternal ? u.f->textMetricW() : (TEXTMETRICW*)textMetric())
#define TM(F) ( qt_winver == WV_NT ? TMW->F : TMA->F )
#define TMX TMA // Initial metrix align


int QFontMetrics::ascent() const
{
    return TMX->tmAscent;
}

int QFontMetrics::descent() const
{
    return TMX->tmDescent;
}


bool QFontMetrics::inFont(QChar ch) const
{
    if ( qt_winver == WV_NT ) {
	TEXTMETRICW *f = TMW;
	uint ch16 = ch.cell+256*ch.row;
	return ch16 >= f->tmFirstChar
	    && ch16 <= f->tmLastChar;
    } else {
	TEXTMETRICA *f = TMA;
	if ( ch.row )
	    return FALSE;
	return ch.cell >= (uint)f->tmFirstChar
	    && ch.cell <= (uint)f->tmLastChar;
    }
}


int QFontMetrics::leftBearing(QChar ch) const
{
    if (TM(tmPitchAndFamily) & TMPF_TRUETYPE ) {
	if ( qt_winver == WV_NT ) {
	    uint ch16 = ch.cell+256*ch.row;
	    ABC abc;
	    GetCharABCWidthsW(hdc(),ch16,ch16,&abc);
	    return abc.abcA;
	} else {
	    if ( ch.row )
		return 0;
	    ABC abc;
	    GetCharABCWidths(hdc(),ch.cell,ch.cell,&abc);
	    return abc.abcA;
	}
    } else {
	if ( qt_winver == WV_NT ) {
	    uint ch16 = ch.cell+256*ch.row;
	    ABCFLOAT abc;
	    GetCharABCWidthsFloatW(hdc(),ch16,ch16,&abc);
	    return int(abc.abcfA);
	} else {
	    return 0;
	}
    }
}


int QFontMetrics::rightBearing(QChar ch) const
{
    if (TM(tmPitchAndFamily) & TMPF_TRUETYPE ) {
	if ( qt_winver == WV_NT ) {
	    uint ch16 = ch.cell+256*ch.row;
	    ABC abc;
	    GetCharABCWidthsW(hdc(),ch16,ch16,&abc);
	    return abc.abcC;
	} else {
	    if ( ch.row )
		return 0;
	    ABC abc;
	    GetCharABCWidths(hdc(),ch.cell,ch.cell,&abc);
	    return abc.abcC;
	}
    } else {
	if ( qt_winver == WV_NT ) {
	    uint ch16 = ch.cell+256*ch.row;
	    ABCFLOAT abc;
	    GetCharABCWidthsFloatW(hdc(),ch16,ch16,&abc);
	    return int(abc.abcfA);
	} else {
	    return 0;
	}
    }
}


int QFontMetrics::minLeftBearing() const
{
    // Safely cast away const, as we cache rbearing there.
    QFontDef* def = (QFontDef*)spec();

    if ( def->lbearing == SHRT_MIN ) {
	minRightBearing(); // calculates both
    }

    return def->lbearing;
}


int QFontMetrics::minRightBearing() const
{
    // Safely cast away const, as we cache rbearing there.
    QFontDef* def = (QFontDef*)spec();

    if ( def->rbearing == SHRT_MIN ) {
	int ml;
	int mr;
	if (TM(tmPitchAndFamily) & TMPF_TRUETYPE ) {
	    ABC *abc;
	    int n;
	    if ( qt_winver == WV_NT ) {
		TEXTMETRICW *tm = TMW;
		n = tm->tmLastChar - tm->tmFirstChar+1;
		abc = new ABC[n];
		GetCharABCWidthsW(hdc(),tm->tmFirstChar,tm->tmLastChar,abc);
	    } else {
		TEXTMETRICA *tm = TMA;
		n = tm->tmLastChar - tm->tmFirstChar+1;
		abc = new ABC[n];
		GetCharABCWidths(hdc(),tm->tmFirstChar,tm->tmLastChar,abc);
	    }
	    ml = abc[0].abcA;
	    mr = abc[0].abcC;
	    for (int i=1; i<n; i++) {
		ml = QMIN(ml,abc[i].abcA);
		mr = QMIN(mr,abc[i].abcC);
	    }
	    delete [] abc;
	} else {
	    if ( qt_winver == WV_NT ) {
		TEXTMETRICW *tm = TMW;
		int n = tm->tmLastChar - tm->tmFirstChar+1;
		ABCFLOAT *abc = new ABCFLOAT[n];
		GetCharABCWidthsFloatW(hdc(),tm->tmFirstChar,tm->tmLastChar,abc);
		float fml = abc[0].abcfA;
		float fmr = abc[0].abcfC;
		for (int i=1; i<n; i++) {
		    fml = QMIN(fml,abc[i].abcfA);
		    fmr = QMIN(fmr,abc[i].abcfC);
		}
		ml = int(fml-0.9999);
		mr = int(fmr-0.9999);
		delete [] abc;
	    } else {
		ml = mr = 0;
	    }
	}
	def->lbearing = ml;
	def->rbearing = mr;
    }

    return def->rbearing;
}


int QFontMetrics::height() const
{
    return TMX->tmHeight;
}

int QFontMetrics::leading() const
{
    return TMX->tmExternalLeading;
}

int QFontMetrics::lineSpacing() const
{
    return TMX->tmHeight + TMX->tmExternalLeading;
}

int QFontMetrics::width( QChar ch ) const
{
    QString s;
    s += ch;
    if (TM(tmPitchAndFamily) & TMPF_TRUETYPE ) {
        return width(s,1);
    } else {
        return width(s,1)-TMX->tmOverhang;
    }
}


int QFontMetrics::width( const QString &str, int len ) const
{
    if ( len < 0 )
	len = str.length();
    SIZE s;
    HDC h = hdc();
    if ( qt_winver == WV_NT ) {
	const QChar* uc = str.unicode();
	if ( sizeof(WCHAR)==sizeof(QChar) && *((WCHAR*)(&QChar(0,1))) == 0x0100 ) {
	    // Same endianness of WCHAR
	    GetTextExtentPoint32W( h, (WCHAR*)uc, len, &s );
	} else if ( len < 256 ) {
	    WCHAR buf[256];
	    for ( int i=len; i--; )
		buf[i] = uc[i].row << 8 | uc[i].cell;
	    GetTextExtentPoint32W( h, buf, len, &s );
	} else {
	    WCHAR *buf = new WCHAR[len];
	    for ( int i=len; i--; )
		buf[i] = uc[i].row << 8 | uc[i].cell;
	    GetTextExtentPoint32W( h, buf, len, &s );
	    delete [] buf;
	}
    } else {
	GetTextExtentPoint32( h, str.ascii(), len, &s );
    }
    return s.cx;
}

QRect QFontMetrics::boundingRect( const QString &str, int len ) const
{
    int cx = width(str,len);

    int l = len ? leftBearing(str[0]) : 0;
    int r = len ? -rightBearing(str[len-1]) : 0;
    // To be safer, check bearings of next-to-end characters too.
    if (len > 1 ) {
	int newl = width(str[0])+leftBearing(str[1]);
	int newr = -width(str[len-1])-rightBearing(str[len-2]);
	if ( newl < l ) l = newl;
	if ( newr > r ) r = newr;
    }

    TEXTMETRICA *tm = TMX;
    return QRect(l, -tm->tmAscent, cx+r-l, tm->tmAscent+tm->tmDescent);
}


HDC QFontMetrics::hdc() const
{
    if ( type() == FontInternal ) {
	return u.f->dc();
    } else {
	if ( type() == Widget && u.w ) {
	    QFont *f = (QFont *)&u.w->font();
	    f->handle();	
	    return f->d->fin->dc();
	} else if ( type() == Painter && u.p ) {
	    return u.p->handle();
	} else {
#if defined(CHECK_NULL)
	    warning( "QFontMetrics: Invalid font metrics" );
#endif
	    return 0;
	}
    }
}

int QFontMetrics::maxWidth() const
{
    return TMX->tmMaxCharWidth;
}

int QFontMetrics::underlinePos() const
{
    int pos = (lineWidth()*2 + 3)/6;
    return pos ? pos : 1;
}

int QFontMetrics::strikeOutPos() const
{
    int pos = TMX->tmAscent/3;
    return pos ? pos : 1;
}

int QFontMetrics::lineWidth() const
{
    if ( type() == FontInternal ) {
	return u.f->lineWidth();
    } else {
	QFont f = font();
	f.handle();
	return f.d->fin->lineWidth();
    }
}


/*****************************************************************************
  QFontInfo member functions
 *****************************************************************************/

const QFontDef *QFontInfo::spec() const
{
    const QFontDef *s;
    if ( type() == FontInternal ) {
	s = u.f->spec();
    } else if ( type() == Widget && u.w ) {
	QFont *f = (QFont *)&u.w->font();
	f->handle();
	s = f->d->fin->spec();
    } else if ( type() == Painter && u.p ) {
	QFont *f = (QFont *)&u.p->font();
	f->handle();
	s = f->d->fin->spec();
    } else {
	s = 0;
    }
#if defined(CHECK_NULL)
    if ( !s )
	warning( "QFontInfo: Invalid font info" );
#endif
    return s;
}
