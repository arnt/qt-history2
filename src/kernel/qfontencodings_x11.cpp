#include "qfontencodings_p.h"

#ifndef QT_NO_CODECS

#include <qjpunicode.h>


int QFontJis0208Codec::heuristicContentMatch(const char *, int) const
{
    return 0;
}

const QJpUnicodeConv * QFontJis0208Codec::convJP;

QFontJis0208Codec::QFontJis0208Codec()
{
    if ( !convJP )
	convJP = QJpUnicodeConv::newConverter(JU_Default);
}

const char* QFontJis0208Codec::name() const
{
    return "jisx0208.1983-0";
}

int QFontJis0208Codec::mibEnum() const
{
    return 63;
}

QString QFontJis0208Codec::toUnicode(const char* /*chars*/, int /*len*/) const
{
    return QString(); //###
}

QCString QFontJis0208Codec::fromUnicode(const QString& uc, int& lenInOut ) const
{
    QCString result(lenInOut * 2 + 1);
    uchar *rdata = (uchar *) result.data();
    const QChar *ucp = uc.unicode();

    for ( int i = 0; i < lenInOut; i++ ) {
	QChar ch(*ucp++);

	if ( ch.row() == 0) {
	    if ( ch.cell() == ' ' )
		ch = QChar( 0x3000 );
	    else if ( ch.cell() == '"' )
		ch = QChar( 0x2033 );
	    else if ( ch.cell() == '\'' )
		ch = QChar( 0x2032 );
	    else if ( ch.cell() == '-' )
		ch = QChar( 0x2212 );
	    else if ( ch.cell() == '~' )
		ch = QChar( 0x301c );
	    else if ( ch.cell() > ' ' && ch.cell() < 127 )
		ch = QChar( ch.cell()-' ', 255 );
	}

	ch = convJP->UnicodeToJisx0208(ch.unicode());

	if ( ! ch.isNull() ) {
	    *rdata++ = ch.row();
	    *rdata++ = ch.cell();
	} else {
	    //white square
	    *rdata++ = 0x22;
	    *rdata++ = 0x22;
	}
    }
    
    lenInOut *= 2;

    return result;
}


// ----------------------------------------------------------

extern unsigned int qt_UnicodeToKsc5601(unsigned int unicode);

int QFontKsc5601Codec::heuristicContentMatch(const char *, int) const
{
    return 0;
}

QFontKsc5601Codec::QFontKsc5601Codec()
{
}

const char* QFontKsc5601Codec::name() const
{
    return "ksc5601.1987-0";
}

int QFontKsc5601Codec::mibEnum() const
{
    return 63;
}

QString QFontKsc5601Codec::toUnicode(const char* /*chars*/, int /*len*/) const
{
    return QString(); //###
}

QCString QFontKsc5601Codec::fromUnicode(const QString& uc, int& lenInOut ) const
{
    QCString result(lenInOut * 2 + 1);
    uchar *rdata = (uchar *) result.data();
    const QChar *ucp = uc.unicode();
    
    for ( int i = 0; i < lenInOut; i++ ) {
	QChar ch(*ucp++);
	
	if ( ch.row() == 0) {
	    if ( ch.cell() == ' ' )
		ch = QChar( 0x3000 );
	    else if ( ch.cell() > ' ' && ch.cell() < 127 )
		ch = QChar( ch.cell()-' ', 255 );
	}
	
	ch = qt_UnicodeToKsc5601(ch.unicode());

	if ( ! ch.isNull() ) {
	    *rdata++ = ch.row() & 0x7f ;
	    *rdata++ = ch.cell() & 0x7f;
	} else {
	    //white square
	    *rdata++ = 0x21;
	    *rdata++ = 0x60;
	}
    }
    
    lenInOut *= 2;
    
    return result;
}


/********


Name: GB_2312-80                                        [RFC1345,KXS2]
MIBenum: 57
Source: ECMA registry
Alias: iso-ir-58
Alias: chinese
Alias: csISO58GB231280

*/


extern unsigned int qt_UnicodeToGBK(unsigned int code);


int QFontGB2312Codec::heuristicContentMatch(const char *, int) const
{
    return 0;
}

QFontGB2312Codec::QFontGB2312Codec()
{
}

const char* QFontGB2312Codec::name() const
{
    return "gb2312.1980-0";
}

int QFontGB2312Codec::mibEnum() const
{
    return 57;
}

QString QFontGB2312Codec::toUnicode(const char* /*chars*/, int /*len*/) const
{
    return QString(); //###
}

QCString QFontGB2312Codec::fromUnicode(const QString& uc, int& lenInOut ) const
{
    QCString result(lenInOut * 2 + 1);
    uchar *rdata = (uchar *) result.data();
    const QChar *ucp = uc.unicode();
    
    for ( int i = 0; i < lenInOut; i++ ) {
	QChar ch(*ucp++);
	
	if ( ch.row() == 0) {
	    if ( ch.cell() == ' ' )
		ch = QChar( 0x3000 );
	    else if ( ch.cell() > ' ' && ch.cell() < 127 )
		ch = QChar( ch.cell()-' ', 255 );
	}
	
	ch = qt_UnicodeToGBK(ch.unicode());
	
	if ( ch.row() > 0xa0 && ch.cell() > 0xa0  ) {
	    *rdata++ = ch.row() & 0x7f ;
	    *rdata++ = ch.cell() & 0x7f;
	} else {
	    //white square
	    *rdata++ = 0x21;
	    *rdata++ = 0x75;
	}
    }
    
    lenInOut *= 2;
    
    return result;
}

// ----------------------------------------------------------------

extern unsigned int qt_UnicodeToBig5(unsigned int unicode);

int QFontBig5Codec::heuristicContentMatch(const char *, int) const
{
    return 0;
}

QFontBig5Codec::QFontBig5Codec()
{
}

const char* QFontBig5Codec::name() const
{
    return "big5-0";
}

int QFontBig5Codec::mibEnum() const
{
    return -1;
}

QString QFontBig5Codec::toUnicode(const char* /*chars*/, int /*len*/) const
{
    return QString(); //###
}

QCString QFontBig5Codec::fromUnicode(const QString& uc, int& lenInOut ) const
{
    QCString result(lenInOut * 2 + 1);
    uchar *rdata = (uchar *) result.data();
    const QChar *ucp = uc.unicode();
    
    for ( int i = 0; i < lenInOut; i++ ) {
	QChar ch(*ucp++);
	
	if ( ch.row() == 0) {
	    if ( ch.cell() == ' ' )
		ch = QChar( 0x3000 );
	    else if ( ch.cell() > ' ' && ch.cell() < 127 )
		ch = QChar( ch.cell()-' ', 255 );
	}
	
	ch = QChar( qt_UnicodeToBig5(ch.unicode()) );

	if ( ch.row() > 0xa0 && ch.cell() >= 0x40  ) {
	    *rdata++ = ch.row();
	    *rdata++ = ch.cell();
	} else {
	    //white square
	    *rdata++ = 0xa1;
	    *rdata++ = 0xbc;
	}
    }
    lenInOut *=2;
    return result;
}

// -----------------------------------------------------

/*
   Arabic shaping obeys a number of rules according to the joining classes (see Unicode book, section on
   arabic).

   Each unicode char has a joining class (right, dual (left&right), center (joincausing) or transparent).
   transparent joining is not encoded in QChar::joining(), but applies to all combining marks and format marks.

   Right join-causing: dual + center
   Left join-causing: dual + right + center

   Rules are as follows (for a string already in visual order, as we have it here):

   R1 Transparent characters do not affect joining behaviour.
   R2 A right joining character, that has a right join-causing char on the right will get form XRight
   (R3 A left joining character, that has a left join-causing char on the left will get form XLeft)
   Note: the above rule is meaningless, as there are no pure left joining characters defined in Unicode
   R4 A dual joining character, that has a left join-causing char on the left and a right join-causing char on
             the right will get form XMedial
   R5  A dual joining character, that has a right join causing char on the right, and no left join causing char on the left
         will get form XRight
   R6 A dual joining character, that has a  left join causing char on the left, and no right join causing char on the right
         will get form XLeft
   R7 Otherwise the character will get form XIsolated

   Additionally we have to do the minimal ligature support for lam-alef ligatures:

   L1 Transparent characters do not affect ligature behaviour.
   L2 Any sequence of Alef(XRight) + Lam(XMedial) will form the ligature Alef.Lam(XLeft)
   L3 Any sequence of Alef(XRight) + Lam(XLeft) will form the ligature Alef.Lam(XIsolated)

   The two functions defined in this class do shaping in visual and logical order. For logical order just replace right with
   previous and left with next in the above rules ;-)
*/

/*
  Two small helper functions for arabic shaping. They get the next shape causing character on either
  side of the char in question. Implements rule R1.

  leftChar() returns true if the char to the left is a left join-causing char
  rightChar() returns true if the char to the right is a right join-causing char
*/
static inline const QChar *prevChar( const QString &str, int pos )
{
    //qDebug("leftChar: pos=%d", pos);
    pos--;
    const QChar *ch = str.unicode() + pos;
    while( pos > -1 ) {
	if( !ch->isMark() )
	    return ch;
	pos--;
	ch--;
    }
    return &QChar::replacement;
}

static inline const QChar *nextChar( const QString &str, int pos)
{
    pos++;
    int len = str.length();
    const QChar *ch = str.unicode() + pos;
    while( pos < len ) {
	//qDebug("rightChar: %d isLetter=%d, joining=%d", pos, ch.isLetter(), ch.joining());
	if( !ch->isMark() )
	    return ch;
	// assume it's a transparent char, this might not be 100% correct
	pos++;
	ch++;
    }
    return &QChar::replacement;
}

static inline bool prevVisualCharJoins( const QString &str, int pos)
{
    return (	 prevChar( str, pos )->joining() != QChar::OtherJoining );
}

static inline bool nextVisualCharJoins( const QString &str, int pos)
{
    QChar::Joining join = nextChar( str, pos )->joining();
    return ( join == QChar::Dual || join == QChar::Center );
}


QArabicShaping::Shape QArabicShaping::glyphVariant( const QString &str, int pos)
{
    // ignores L1 - L3, done in the codec
    QChar::Joining joining = str[pos].joining();
    //qDebug("checking %x, joining=%d", str[pos].unicode(), joining);
    switch ( joining ) {
	case QChar::OtherJoining:
	case QChar::Center:
	    // these don't change shape
	    return XIsolated;
	case QChar::Right:
	    // only rule R2 applies
	    if( nextVisualCharJoins( str, pos ) )
		return XRight;
	    return XIsolated;
	case QChar::Dual:
	    bool right = nextVisualCharJoins( str, pos );
	    bool left = prevVisualCharJoins( str, pos );
	    //qDebug("dual: right=%d, left=%d", right, left);
	    if( right && left )
		return XMedial;
	    else if ( right )
		return XRight;
	    else if ( left )
		return XLeft;
	    else
		return XIsolated;
    }
    return XIsolated;
}

/* and the same thing for logical ordering :)
 */
static inline bool prevLogicalCharJoins( const QString &str, int pos)
{
    return (	 nextChar( str, pos )->joining() != QChar::OtherJoining );
}

static inline bool nextLogicalCharJoins( const QString &str, int pos)
{
    QChar::Joining join = prevChar( str, pos )->joining();
    return ( join == QChar::Dual || join == QChar::Center );
}


QArabicShaping::Shape QArabicShaping::glyphVariantLogical( const QString &str, int pos)
{
    // ignores L1 - L3, ligatures are job of the codec
    QChar::Joining joining = str[pos].joining();
    //qDebug("checking %x, joining=%d", str[pos].unicode(), joining);
    switch ( joining ) {
	case QChar::OtherJoining:
	case QChar::Center:
	    // these don't change shape
	    return XIsolated;
	case QChar::Right:
	    // only rule R2 applies
	    if( nextLogicalCharJoins( str, pos ) )
		return XRight;
	    return XIsolated;
	case QChar::Dual:
	    bool right = nextLogicalCharJoins( str, pos );
	    bool left = prevLogicalCharJoins( str, pos );
	    //qDebug("dual: right=%d, left=%d", right, left);
	    if( right && left )
		return XMedial;
	    else if ( right )
		return XRight;
	    else if ( left )
		return XLeft;
	    else
		return XIsolated;
    }
    return XIsolated;
}


// ---------------------------------------------------------------

// this table covers basic arabic letter, not the extensions used in various other languages.
static const uchar arabic68Mapping[112][4] = {
    // Isolated, left, right, medial forms or:
    // Isolated, Initial, Final, Medial
    { 0xff, 0xff, 0xff, 0xff }, // 0x600
    { 0xff, 0xff, 0xff, 0xff }, // 0x601
    { 0xff, 0xff, 0xff, 0xff }, // 0x602
    { 0xff, 0xff, 0xff, 0xff }, // 0x603
    { 0xff, 0xff, 0xff, 0xff }, // 0x604
    { 0xff, 0xff, 0xff, 0xff }, // 0x605
    { 0xff, 0xff, 0xff, 0xff }, // 0x606
    { 0xff, 0xff, 0xff, 0xff }, // 0x607
    { 0xff, 0xff, 0xff, 0xff }, // 0x608
    { 0xff, 0xff, 0xff, 0xff }, // 0x609
    { 0xff, 0xff, 0xff, 0xff }, // 0x60a
    { 0xff, 0xff, 0xff, 0xff }, // 0x60b
    { 0xac, 0xff, 0xff, 0xff }, // 0x60c 		Arabic comma
    { 0xff, 0xff, 0xff, 0xff }, // 0x60d
    { 0xff, 0xff, 0xff, 0xff }, // 0x60e
    { 0xff, 0xff, 0xff, 0xff }, // 0x60f

    { 0xff, 0xff, 0xff, 0xff }, // 0x610
    { 0xff, 0xff, 0xff, 0xff }, // 0x611
    { 0xff, 0xff, 0xff, 0xff }, // 0x612
    { 0xff, 0xff, 0xff, 0xff }, // 0x613
    { 0xff, 0xff, 0xff, 0xff }, // 0x614
    { 0xff, 0xff, 0xff, 0xff }, // 0x615
    { 0xff, 0xff, 0xff, 0xff }, // 0x616
    { 0xff, 0xff, 0xff, 0xff }, // 0x617
    { 0xff, 0xff, 0xff, 0xff }, // 0x618
    { 0xff, 0xff, 0xff, 0xff }, // 0x619
    { 0xff, 0xff, 0xff, 0xff }, // 0x61a
    { 0xbb, 0xff, 0xff, 0xff }, // 0x61b  		Arabic semicolon
    { 0xff, 0xff, 0xff, 0xff }, // 0x61c
    { 0xff, 0xff, 0xff, 0xff }, // 0x61d
    { 0xff, 0xff, 0xff, 0xff }, // 0x61e
    { 0xbf, 0xff, 0xff, 0xff }, // 0x61f  		Arabic question mark

    { 0xff, 0xff, 0xff, 0xff }, // 0x620
    { 0xc1, 0xff, 0xff, 0xff }, // 0x621 	 	Hamza
    { 0xc2, 0xff, 0xc2, 0xff }, // 0x622 	R 	Alef with Madda above
    { 0xc3, 0xff, 0xc3, 0xff }, // 0x623 	R	Alef with Hamza above
    { 0xc4, 0xff, 0xc4, 0xff }, // 0x624 	R	Waw with Hamza above
    { 0xc5, 0xff, 0xc5, 0xff }, // 0x625 	R	Alef with Hamza below
    { 0xc6, 0xc0, 0xc6, 0xc0 }, // 0x626 	D	Yeh with Hamza above
    { 0xc7, 0xff, 0xc7, 0xff }, // 0x627 	R	Alef
    { 0xc8, 0xeb, 0xc8, 0xeb }, // 0x628 	D	Beh
    { 0xc9, 0xff, 0x8e, 0xff }, // 0x629 	R	Teh Marbuta
    { 0xca, 0xec, 0xc1, 0xec }, // 0x62a 	D	Teh
    { 0xcb, 0xed, 0xcb, 0xed }, // 0x62b 	D 	Theh
    { 0xcc, 0xee, 0xcc, 0xee }, // 0x62c 	D 	Jeem
    { 0xcd, 0xef, 0xcd, 0xef }, // 0x62d 	D 	Hah
    { 0xce, 0xf0, 0xce, 0xf0 }, // 0x62e 	D 	Khah
    { 0xcf, 0xff, 0xcf, 0xff }, // 0x62f 	R 	Dal

    { 0xd0, 0xff, 0xd0, 0xff }, // 0x630 	R 	Thal
    { 0xd1, 0xff, 0xd1, 0xff }, // 0x631 	R 	Reh
    { 0xd2, 0xff, 0xd2, 0xff }, // 0x632 	R 	Zain
    { 0xd3, 0xf1, 0x8f, 0xf1 }, // 0x633 	D 	Seen
    { 0xd4, 0xf2, 0x90, 0xf2 }, // 0x634 	D 	Sheen
    { 0xd5, 0xf3, 0x91, 0xf3 }, // 0x635 	D 	Sad
    { 0xd6, 0xf4, 0x92, 0xf4 }, // 0x636 	D 	Dad
    { 0xd7, 0xd7, 0x93, 0x93 }, // 0x637 	D 	Tah
    { 0xd8, 0xd8, 0x94, 0x94 }, // 0x638 	D 	Zah
    { 0xd9, 0xf5, 0x96, 0x95 }, // 0x639 	D 	Ain
    { 0xda, 0xf6, 0x98, 0x97 }, // 0x63a 	D	Ghain
    { 0xff, 0xff, 0xff, 0xff }, // 0x63b
    { 0xff, 0xff, 0xff, 0xff }, // 0x63c
    { 0xff, 0xff, 0xff, 0xff }, // 0x63d
    { 0xff, 0xff, 0xff, 0xff }, // 0x63e
    { 0xff, 0xff, 0xff, 0xff }, // 0x63f

    { 0xe0, 0xff, 0xff, 0xff }, // 0x640 		Tatweel
    { 0xe1, 0xf7, 0xe1, 0x99 }, // 0x641 	D 	Feh
    { 0xe2, 0xf8, 0xe2, 0x9a }, // 0x642 	D 	Qaf
    { 0xe3, 0xf9, 0xe3, 0x9b }, // 0x643 	D 	Kaf
    { 0xe4, 0xfa, 0xe4, 0xfa }, // 0x644 	D 	Lam
    { 0xe5, 0xfb, 0xe5, 0xfb }, // 0x645 	D 	Meem
    { 0xe6, 0xfc, 0xe6, 0xfc }, // 0x646 	D 	Noon
    { 0xe7, 0xfd, 0xe7, 0xfd }, // 0x647 	D 	Heh
    { 0xe8, 0xff, 0xe8, 0xff }, // 0x648 	R 	Waw
    { 0x8d, 0x9f, 0x9f, 0x9f }, // 0x649 	D 	Alef Maksura 	### this looks strange, the font only has isolated and final forms, still dual joining?
    { 0xea, 0xfe, 0xea, 0xfe }, // 0x64a 	D 	Yeh
    { 0xeb, 0xff, 0xff, 0xff }, // 0x64b 	Mark Fathatan
    { 0xec, 0xff, 0xff, 0xff }, // 0x64c 	Mark Dammatan
    { 0xed, 0xff, 0xff, 0xff }, // 0x64d 	Mark Kasratan
    { 0xee, 0xff, 0xff, 0xff }, // 0x64e 	Mark Fatha
    { 0xef, 0xff, 0xff, 0xff }, // 0x64f 	Mark Damma

    { 0xf0, 0xff, 0xff, 0xff }, // 0x650 	Mark Kasra
    { 0xf1, 0xff, 0xff, 0xff }, // 0x651 	Mark Shadda
    { 0xf2, 0xff, 0xff, 0xff }, // 0x652 	Mark Sukan
    // these do not exist in latin6 anymore:
    { 0xff, 0xff, 0xff, 0xff }, // 0x653 	Mark Maddah above
    { 0xff, 0xff, 0xff, 0xff }, // 0x654 	Mark Hamza above
    { 0xff, 0xff, 0xff, 0xff }, // 0x655 	Mark Hamza below
    { 0xff, 0xff, 0xff, 0xff }, // 0x656
    { 0xff, 0xff, 0xff, 0xff }, // 0x657
    { 0xff, 0xff, 0xff, 0xff }, // 0x658
    { 0xff, 0xff, 0xff, 0xff }, // 0x659
    { 0xff, 0xff, 0xff, 0xff }, // 0x65a
    { 0xff, 0xff, 0xff, 0xff }, // 0x65b
    { 0xff, 0xff, 0xff, 0xff }, // 0x65c
    { 0xff, 0xff, 0xff, 0xff }, // 0x65d
    { 0xff, 0xff, 0xff, 0xff }, // 0x65e
    { 0xff, 0xff, 0xff, 0xff }, // 0x65f

    { 0xb0, 0xff, 0xff, 0xff }, // 0x660 	Arabic 0
    { 0xb1, 0xff, 0xff, 0xff }, // 0x661 	Arabic 1
    { 0xb2, 0xff, 0xff, 0xff }, // 0x662 	Arabic 2
    { 0xb3, 0xff, 0xff, 0xff }, // 0x663 	Arabic 3
    { 0xb4, 0xff, 0xff, 0xff }, // 0x664 	Arabic 4
    { 0xb5, 0xff, 0xff, 0xff }, // 0x665 	Arabic 5
    { 0xb6, 0xff, 0xff, 0xff }, // 0x666 	Arabic 6
    { 0xb7, 0xff, 0xff, 0xff }, // 0x667 	Arabic 7
    { 0xb8, 0xff, 0xff, 0xff }, // 0x668 	Arabic 8
    { 0xb9, 0xff, 0xff, 0xff }, // 0x669 	Arabic 9
    { 0x25, 0xff, 0xff, 0xff }, // 0x66a 	Arabic % sign
    { 0x2c, 0xff, 0xff, 0xff }, // 0x66b 	Arabic decimal separator
    { 0x2c, 0xff, 0xff, 0xff }, // 0x66c 	Arabic thousands separator
    { 0x2a, 0xff, 0xff, 0xff }, // 0x66d 	Arabic five pointed star
    { 0xff, 0xff, 0xff, 0xff }, // 0x66e
    { 0xff, 0xff, 0xff, 0xff } // 0x66f
};

static const uchar arabic68AlefMapping[6][5] = {
    { 0xc2, 0xff, 0xc2, 0xff, 0xa2 }, // 0x622 	R 	Alef with Madda above
    { 0xc3, 0xff, 0xc3, 0xff, 0xa3 }, // 0x623 	R	Alef with Hamza above
    { 0xc4, 0xff, 0xc4, 0xff, 0xff}, // 0x624 	R	Waw with Hamza above
    { 0xc5, 0xff, 0xc5, 0xff, 0xa4 }, // 0x625 	R	Alef with Hamza below
    { 0xc6, 0xc0, 0xc6, 0xc0, 0xff }, // 0x626 	D	Yeh with Hamza above
    { 0xc7, 0xff, 0xc7, 0xff, 0xa1 } // 0x627 	R	Alef
};

static const uchar arabic68LamLigature[8] = {
    0xff, 0xa5, 0xff, 0xa6
};

int QFontArabic68Codec::heuristicContentMatch(const char *, int) const
{
    return 0;
}

QFontArabic68Codec::QFontArabic68Codec()
{
}

const char* QFontArabic68Codec::name() const
{
    return "iso8859-6.8x";
}

int QFontArabic68Codec::mibEnum() const
{
    return -1;
}

QString QFontArabic68Codec::toUnicode(const char* /*chars*/, int /*len*/) const
{
    return QString(); //###
}

QCString QFontArabic68Codec::fromUnicode(const QString& , int&  ) const
{
    return QCString();
}

QByteArray QFontArabic68Codec::fromUnicode(const QString& uc, int from, int len ) const
{
    if( len < 0 )
	len = uc.length() - from;
    if( len == 0 )
	return QByteArray();

    QByteArray result( len );
    uchar *data = (uchar *)result.data();
    const QChar *ch = uc.unicode() + from;
    for ( int i = 0; i < len; i++ ) {
	uchar r = ch->row();
	uchar c = ch->cell();
	if ( r == 0 && c < 0x80 ) {
	    *data = c;
	} else if ( r != 0x06 || c > 0x6f )
	    *data = 0xff; // undefined char in iso8859-6.8x
	else {
	    int shape = QArabicShaping::glyphVariant( uc, i+from );
	    //qDebug("mapping U+%x to shape %d glyph=0x%x", ch->unicode(), shape, arabic68Mapping[ch->cell()][shape]);

	    // take care of lam-alef ligatures (lam right of alef)
	    switch ( c ) {
		case 0x22: // alef with madda
		case 0x23: // alef with hamza above
		case 0x25: // alef with hamza below
		case 0x27: // alef
		    if ( nextChar( uc, i+from )->unicode() == 0x0644 ) {
			// have a lam alef ligature
			shape = 4; // ligating shape
			//qDebug(" alef of lam-alef ligature");
		    }
		    *data = arabic68AlefMapping[c - 0x22][shape];
		    break;
		case 0x44: { // lam
		    const QChar *pch = prevChar( uc, i+from );
		    if ( pch->row() == 0x06 ) {
			switch ( pch->cell() ) {
			    case 0x22:
			    case 0x23:
			    case 0x25:
			    case 0x27:
				//qDebug(" lam of lam-alef ligature");
				*data = arabic68LamLigature[shape];
				goto next;
			    default:
				break;
			}
		    }
		}
		default:
		    *data = arabic68Mapping[c][shape];
	    }
	}
    next:
	ch++;
	data++;
    }
    return result;
}

ushort QFontArabic68Codec::characterFromUnicode( const QString &str, int pos ) const
{
    const QChar *ch = str.unicode() + pos;
    uchar r = ch->row();
    uchar c = ch->cell();
    if ( r == 0 && c < 0x80 ) {
	return c;
    }
    if ( r != 0x06 || c > 0x6f )
	return 0xff; // undefined char in iso8859-6.8x
    else {
	int shape = QArabicShaping::glyphVariantLogical( str, pos );
	//qDebug("mapping U+%x to shape %d glyph=0x%x", ch->unicode(), shape, arabic68Mapping[ch->cell()][shape]);

	// lam aleph ligatures
	switch ( c ) {
	    case 0x22: // alef with madda
	    case 0x23: // alef with hamza above
	    case 0x25: // alef with hamza below
	    case 0x27: // alef
		if ( prevChar( str, pos )->unicode() == 0x0644 )
		    // have a lam alef ligature
		    shape = 4; // ligating shape
		return arabic68AlefMapping[c - 0x22][shape];
	    case 0x44: { // lam
		const QChar *nch = nextChar( str, pos );
		if ( nch->row() == 0x06 ) {
		    switch ( nch->cell() ) {
			case 0x22:
			case 0x23:
			case 0x25:
			case 0x27:
			    return arabic68LamLigature[shape];
			default:
			    break;
		    }
		}
	    }
	    default:
		break;
	}
	return arabic68Mapping[c][shape];
    }
}

// -------------------------------------------------------------

// The unicode to unicode shaping codec.
// does only presentation forms B at the moment, but that should be enough for
// simple display
static const ushort arabicUnicodeMapping[256][4] = {
    // base of shaped forms, and number-1 of them ( 0 for non shaping,
    // 1 for right binding and 3 for dual binding
    { 0x0600, 0 }, // 0x600
    { 0x0601, 0 }, // 0x601
    { 0x0602, 0 }, // 0x602
    { 0x0603, 0 }, // 0x603
    { 0x0604, 0 }, // 0x604
    { 0x0605, 0 }, // 0x605
    { 0x0606, 0 }, // 0x606
    { 0x0607, 0 }, // 0x607
    { 0x0608, 0 }, // 0x608
    { 0x0609, 0 }, // 0x609
    { 0x060a, 0 }, // 0x60a
    { 0x060b, 0 }, // 0x60b
    { 0x060c, 0 }, // 0x60c 	Arabic comma
    { 0x060d, 0 }, // 0x60d
    { 0x060e, 0 }, // 0x60e
    { 0x060f, 0xfffd, 0xfffd, 0xfffd }, // 0x60f

    { 0x0610, 0 }, // 0x610
    { 0x0611, 0 }, // 0x611
    { 0x0612, 0 }, // 0x612
    { 0x0613, 0 }, // 0x613
    { 0x0614, 0 }, // 0x614
    { 0x0615, 0 }, // 0x615
    { 0x0616, 0 }, // 0x616
    { 0x0617, 0 }, // 0x617
    { 0x0618, 0 }, // 0x618
    { 0x0619, 0 }, // 0x619
    { 0x061a, 0 }, // 0x61a
    { 0x061b, 0 }, // 0x61b  	Arabic semicolon
    { 0x061c, 0 }, // 0x61c
    { 0x061d, 0 }, // 0x61d
    { 0x061e, 0 }, // 0x61e
    { 0x061f, 0 }, // 0x61f  	Arabic question mark

    { 0x0620, 0 }, // 0x620
    { 0xfe80, 0 }, // 0x621 	Hamza
    { 0xfe81, 1 }, // 0x622 	R 	Alef with Madda above
    { 0xfe83, 1 }, // 0x623 	R 	Alef with Hamza above
    { 0xfe85, 1 }, // 0x624 	R 	Waw with Hamza above
    { 0xfe87, 1 }, // 0x625 	R 	Alef with Hamza below
    { 0xfe89, 3 }, // 0x626 	D 	Yeh with Hamza above
    { 0xfe8d, 1 }, // 0x627 	R 	Alef
    { 0xfe8f, 3 }, // 0x628 	D 	Beh
    { 0xfe93, 1 }, // 0x629 	R 	Teh Marbuta
    { 0xfe95, 3 }, // 0x62a 	D 	Teh
    { 0xfe99, 3 }, // 0x62b 	D 	Theh
    { 0xfe9d, 3 }, // 0x62c 	D 	Jeem
    { 0xfea1, 3 }, // 0x62d 	D 	Hah
    { 0xfea5, 3 }, // 0x62e 	D 	Khah
    { 0xfea9, 1 }, // 0x62f 	R 	Dal

    { 0xfeab, 1 }, // 0x630 	R 	Thal
    { 0xfead, 1 }, // 0x631 	R 	Reh
    { 0xfeaf, 1 }, // 0x632 	R 	Zain
    { 0xfeb1, 1 }, // 0x633 	D 	Seen
    { 0xfeb5, 3 }, // 0x634 	D 	Sheen
    { 0xfeb9, 3 }, // 0x635 	D 	Sad
    { 0xfebd, 3 }, // 0x636 	D 	Dad
    { 0xfec1, 3 }, // 0x637 	D 	Tah
    { 0xfec5, 3 }, // 0x638 	D 	Zah
    { 0xfec9, 3 }, // 0x639 	D 	Ain
    { 0xfecd, 3 }, // 0x63a 	D 	Ghain
    { 0x063b, 0 }, // 0x63b
    { 0x063c, 0 }, // 0x63c
    { 0x063d, 0 }, // 0x63d
    { 0x063e, 0 }, // 0x63e
    { 0x063f, 0 }, // 0x63f

    { 0x0640, 0 }, // 0x640 	C 	Tatweel
    { 0xfed1, 3 }, // 0x641 	D 	Feh
    { 0xfed5, 3 }, // 0x642 	D 	Qaf
    { 0xfed9, 3 }, // 0x643 	D 	Kaf
    { 0xfedd, 3 }, // 0x644 	D 	Lam
    { 0xfee1, 3 }, // 0x645 	D 	Meem
    { 0xfee5, 3 }, // 0x646 	D 	Noon
    { 0xfee9, 3 }, // 0x647 	D 	Heh
    { 0xfeed, 1 }, // 0x648 	R 	Waw
    { 0xfeef, 1 }, // 0x649 	R 	Alef Maksura
    { 0xfef1, 3 }, // 0x64a 	D 	Yeh
    { 0x064b, 0 }, // 0x64b 	Mark Fathatan
    { 0x064c, 0 }, // 0x64c 	Mark Dammatan
    { 0x064d, 0 }, // 0x64d 	Mark Kasratan
    { 0x064e, 0 }, // 0x64e 	Mark Fatha
    { 0x064f, 0 }, // 0x64f 	Mark Damma

    { 0x0650, 0 }, // 0x650 	Mark Kasra
    { 0x0651, 0 }, // 0x651 	Mark Shadda
    { 0x0652, 0 }, // 0x652 	Mark Sukan
    // these do not exist in latin6 anymore:
    { 0x0653, 0 }, // 0x653 	Mark Maddah above
    { 0x0654, 0 }, // 0x654 	Mark Hamza above
    { 0x0655, 0 }, // 0x655 	Mark Hamza below
    { 0x0656, 0 }, // 0x656
    { 0x0657, 0 }, // 0x657
    { 0x0658, 0 }, // 0x658
    { 0x0659, 0 }, // 0x659
    { 0x065a, 0 }, // 0x65a
    { 0x065b, 0 }, // 0x65b
    { 0x065c, 0 }, // 0x65c
    { 0x065d, 0 }, // 0x65d
    { 0x065e, 0 }, // 0x65e
    { 0x065f, 0 }, // 0x65f

    { 0x0660, 0 }, // 0x660 	Arabic 0
    { 0x0661, 0 }, // 0x661 	Arabic 1
    { 0x0662, 0 }, // 0x662 	Arabic 2
    { 0x0663, 0 }, // 0x663 	Arabic 3
    { 0x0664, 0 }, // 0x664 	Arabic 4
    { 0x0665, 0 }, // 0x665 	Arabic 5
    { 0x0666, 0 }, // 0x666 	Arabic 6
    { 0x0667, 0 }, // 0x667 	Arabic 7
    { 0x0668, 0 }, // 0x668 	Arabic 8
    { 0x0669, 0 }, // 0x669 	Arabic 9
    { 0x066a, 0 }, // 0x66a 	Arabic % sign
    { 0x066b, 0 }, // 0x66b 	Arabic decimal separator
    { 0x066c, 0 }, // 0x66c 	Arabic thousands separator
    { 0x066d, 0 }, // 0x66d 	Arabic five pointed star
    { 0x066e, 0 }, // 0x66e
    { 0x066f, 0 }, // 0x66f

    { 0x0670, 0 }, // 0x670
    { 0x0671, 0 }, // 0x671 R
    { 0x0672, 0 }, // 0x672 R
    { 0x0673, 0 }, // 0x673 R
    { 0x0674, 0 }, // 0x674 U
    { 0x0675, 0 }, // 0x675 R
    { 0x0676, 0 }, // 0x676 R
    { 0x0677, 0 }, // 0x677 R
    { 0x0678, 0 }, // 0x678 D
    { 0x0679, 0 }, // 0x679 D
    { 0x067a, 0 }, // 0x67a D
    { 0x067b, 0 }, // 0x67b D
    { 0x067c, 0 }, // 0x67cD
    { 0x067d, 0 }, // 0x67d D
    { 0x067e, 0 }, // 0x67e D
    { 0x067f, 0 }, // 0x67f D

    { 0x0680, 0 }, // 0x680 D
    { 0x0681, 0 }, // 0x681 D
    { 0x0682, 0 }, // 0x682 D
    { 0x0683, 0 }, // 0x683 D
    { 0x0684, 0 }, // 0x684 D
    { 0x0685, 0 }, // 0x685 D
    { 0x0686, 0 }, // 0x686 D
    { 0x0687, 0 }, // 0x687 D
    { 0x0688, 0 }, // 0x688 R
    { 0x0689, 0 }, // 0x689 R
    { 0x068a, 0 }, // 0x68a R
    { 0x068b, 0 }, // 0x68b R
    { 0x068c, 0 }, // 0x68cR
    { 0x068d, 0 }, // 0x68d R
    { 0x068e, 0 }, // 0x68e R
    { 0x068f, 0 }, // 0x68f R

    { 0x0690, 0 }, // 0x690 R
    { 0x0691, 0 }, // 0x691 R
    { 0x0692, 0 }, // 0x692 R
    { 0x0693, 0 }, // 0x693 R
    { 0x0694, 0 }, // 0x694 R
    { 0x0695, 0 }, // 0x695 R
    { 0x0696, 0 }, // 0x696 R
    { 0x0697, 0 }, // 0x697 R
    { 0x0698, 0 }, // 0x698 R
    { 0x0699, 0 }, // 0x699 R
    { 0x069a, 0 }, // 0x69a D
    { 0x069b, 0 }, // 0x69b D
    { 0x069c, 0 }, // 0x69cD
    { 0x069d, 0 }, // 0x69d D
    { 0x069e, 0 }, // 0x69e D
    { 0x069f, 0 }, // 0x69f D

    { 0x06a0, 0 }, // 0x6a0 D
    { 0x06a1, 0 }, // 0x6a1 D
    { 0x06a2, 0 }, // 0x6a2 D
    { 0x06a3, 0 }, // 0x6a3 D
    { 0x06a4, 0 }, // 0x6a4 D
    { 0x06a5, 0 }, // 0x6a5 D
    { 0x06a6, 0 }, // 0x6a6 D
    { 0x06a7, 0 }, // 0x6a7 D
    { 0x06a8, 0 }, // 0x6a8 D
    { 0x06a9, 0 }, // 0x6a9 D
    { 0x06aa, 0 }, // 0x6aa D
    { 0x06ab, 0 }, // 0x6ab D
    { 0x06ac, 0 }, // 0x6acD
    { 0x06ad, 0 }, // 0x6ad D
    { 0x06ae, 0 }, // 0x6ae D
    { 0x06af, 0 }, // 0x6af D

    { 0x06b0, 0 }, // 0x6b0 D
    { 0x06b1, 0 }, // 0x6b1 D
    { 0x06b2, 0 }, // 0x6b2 D
    { 0x06b3, 0 }, // 0x6b3 D
    { 0x06b4, 0 }, // 0x6b4 D
    { 0x06b5, 0 }, // 0x6b5 D
    { 0x06b6, 0 }, // 0x6b6 D
    { 0x06b7, 0 }, // 0x6b7 D
    { 0x06b8, 0 }, // 0x6b8 D
    { 0x06b9, 0 }, // 0x6b9 D
    { 0x06ba, 0 }, // 0x6ba D
    { 0x06bb, 0 }, // 0x6bb D
    { 0x06bc, 0 }, // 0x6bcD
    { 0x06bd, 0 }, // 0x6bd D
    { 0x06be, 0 }, // 0x6be D
    { 0x06bf, 0 }, // 0x6bf D

    { 0x06c0, 0 }, // 0x6c0 R
    { 0x06c1, 0 }, // 0x6c1 D
    { 0x06c2, 0 }, // 0x6c2 R
    { 0x06c3, 0 }, // 0x6c3 R
    { 0x06c4, 0 }, // 0x6c4 R
    { 0x06c5, 0 }, // 0x6c5 R
    { 0x06c6, 0 }, // 0x6c6 R
    { 0x06c7, 0 }, // 0x6c7 R
    { 0x06c8, 0 }, // 0x6c8 R
    { 0x06c9, 0 }, // 0x6c9 R
    { 0x06ca, 0 }, // 0x6ca R
    { 0x06cb, 0 }, // 0x6cb R
    { 0x06cc, 0 }, // 0x6cc D
    { 0x06cd, 0 }, // 0x6cd R
    { 0x06ce, 0 }, // 0x6ce D
    { 0x06cf, 0 }, // 0x6cf R

    { 0x06d0, 0 }, // 0x6d0 D
    { 0x06d1, 0 }, // 0x6d1 D
    { 0x06d2, 0 }, // 0x6d2 R
    { 0x06d3, 0 }, // 0x6d3 R
    { 0x06d4, 0 }, // 0x6d4 U
    { 0x06d5, 0 }, // 0x6d5 D
    { 0x06d6, 0 }, // 0x6d6
    { 0x06d7, 0 }, // 0x6d7
    { 0x06d8, 0 }, // 0x6d8
    { 0x06d9, 0 }, // 0x6d9
    { 0x06da, 0 }, // 0x6da
    { 0x06db, 0 }, // 0x6db
    { 0x06dc, 0 }, // 0x6dc
    { 0x06dd, 0 }, // 0x6dd
    { 0x06de, 0 }, // 0x6de
    { 0x06df, 0 }, // 0x6df

    { 0x06e0, 0 }, // 0x6e0
    { 0x06e1, 0 }, // 0x6e1
    { 0x06e2, 0 }, // 0x6e2
    { 0x06e3, 0 }, // 0x6e3
    { 0x06e4, 0 }, // 0x6e4
    { 0x06e5, 0 }, // 0x6e5
    { 0x06e6, 0 }, // 0x6e6
    { 0x06e7, 0 }, // 0x6e7
    { 0x06e8, 0 }, // 0x6e8
    { 0x06e9, 0 }, // 0x6e9
    { 0x06ea, 0 }, // 0x6ea
    { 0x06eb, 0 }, // 0x6eb
    { 0x06ec, 0 }, // 0x6ec
    { 0x06ed, 0 }, // 0x6ed
    { 0x06ee, 0 }, // 0x6ee
    { 0x06ef, 0 }, // 0x6ef

    { 0x06f0, 0 }, // 0x6f0
    { 0x06f1, 0 }, // 0x6f1
    { 0x06f2, 0 }, // 0x6f2
    { 0x06f3, 0 }, // 0x6f3
    { 0x06f4, 0 }, // 0x6f4
    { 0x06f5, 0 }, // 0x6f5
    { 0x06f6, 0 }, // 0x6f6
    { 0x06f7, 0 }, // 0x6f7
    { 0x06f8, 0 }, // 0x6f8
    { 0x06f9, 0 }, // 0x6f9
    { 0x06fa, 0 }, // 0x6fa D
    { 0x06fb, 0 }, // 0x6fb D
    { 0x06fc, 0 }, // 0x6fc D
    { 0x06fd, 0 }, // 0x6fd
    { 0x06fe, 0 }, // 0x6fe
    { 0x06ff, 0 }, // 0x6ff

};

// this is a bit tricky. Alef always binds to the right, so the second parameter descibing the shape
// of the lam can be either initial of medial. So initial maps to the isolated form of the ligature,
// medial to the final form
static const ushort arabicUnicodeLamAlefMapping[6][4] = {
    { 0xfffd, 0xfef5, 0xfffd, 0xfef6 }, // 0x622 	R 	Alef with Madda above
    { 0xfffd, 0xfef7, 0xfffd, 0xfef8 }, // 0x623 	R	Alef with Hamza above
    { 0xfffd, 0xfffd, 0xfffd, 0xfffd }, // 0x624 	R	Waw with Hamza above
    { 0xfffd, 0xfef9, 0xfffd, 0xfefa }, // 0x625 	R	Alef with Hamza below
    { 0xfffd, 0xfffd, 0xfffd, 0xfffd }, // 0x626 	D	Yeh with Hamza above
    { 0xfffd, 0xfefb, 0xfffd, 0xfefc } // 0x627 	R	Alef
};

int QFontArabicUnicodeCodec::heuristicContentMatch(const char *, int) const
{
    return 0;
}

QFontArabicUnicodeCodec::QFontArabicUnicodeCodec()
{
}

const char* QFontArabicUnicodeCodec::name() const
{
    return "ArabicUnicode";
}

int QFontArabicUnicodeCodec::mibEnum() const
{
    return -1;
}

QString QFontArabicUnicodeCodec::toUnicode(const char* /*chars*/, int /*len*/) const
{
    return QString(); //###
}

QCString QFontArabicUnicodeCodec::fromUnicode(const QString&, int& ) const
{
    return QCString();
}

QByteArray QFontArabicUnicodeCodec::fromUnicode(const QString& uc, int from, int len ) const
{
    if( len < 0 )
	len = uc.length() - from;
    if( len == 0 )
	return QByteArray();

    QByteArray result( len*2 );
    uchar *data = (uchar *)result.data();
    const QChar *ch = uc.unicode() + from;
    int skipped = 0;
    for ( int i = 0; i < len; i++ ) {
	uchar r = ch->row();
	uchar c = ch->cell();
	if ( r != 0x06 || c > 0x6f ) {
	    *data++ = r;
	    *data++ = c;
	} else {
	    int shape = QArabicShaping::glyphVariant( uc, i+from );
	    //qDebug("mapping U+%x to shape %d glyph=0x%x", ch->unicode(), shape, arabicUnicodeMapping[ch->cell()][shape]);
	    // take care of lam-alef ligatures (lam right of alef)
	    ushort map;
	    switch ( c ) {
		case 0x44: { // lam
		    const QChar *pch = prevChar( uc, i+from );
		    if ( pch->row() == 0x06 ) {
			switch ( pch->cell() ) {
			    case 0x22:
			    case 0x23:
			    case 0x25:
			    case 0x27:
				//qDebug(" lam of lam-alef ligature");
				map = arabicUnicodeLamAlefMapping[pch->cell() - 0x22][shape];
				goto next;
			    default:
				break;
			}
		    }
		    break;
		}
		case 0x22: // alef with madda
		case 0x23: // alef with hamza above
		case 0x25: // alef with hamza below
		case 0x27: // alef
		    if ( nextChar( uc, i+from )->unicode() == 0x0644 ) {
			// have a lam alef ligature
			//qDebug(" alef of lam-alef ligature");
			skipped += 2;
			goto skip;
		    }
		default:
		    break;
	    }
	    map = arabicUnicodeMapping[c][0] + shape;
	next:
	    *data++ = (map >> 8);
	    *data++ = map & 0xff;
	}
    skip:
	ch++;
    }
    len *= 2;
    len -= skipped;
    result.resize( len );
    return result;
}

ushort QFontArabicUnicodeCodec::characterFromUnicode( const QString &str, int pos ) const
{
    const QChar *ch = str.unicode() + pos;
    if ( ch->row() != 0x06 || ch->cell() > 0x6f )
	return ch->unicode();
    else {
	int shape = QArabicShaping::glyphVariantLogical( str, pos );
	//qDebug("mapping U+%x to shape %d glyph=0x%x", ch->unicode(), shape, arabicUnicodeMapping[ch->cell()][shape]);
	// lam aleph ligatures
	switch ( ch->cell() ) {
	    case 0x44: { // lam
		const QChar *nch = nextChar( str, pos );
		if ( nch->row() == 0x06 ) {
		    switch ( nch->cell() ) {
			case 0x22:
			case 0x23:
			case 0x25:
			case 0x27:
			    return arabicUnicodeLamAlefMapping[nch->cell() - 0x22][shape];
			default:
			    break;
		    }
		}
		break;
	    }
	    case 0x22: // alef with madda
	    case 0x23: // alef with hamza above
	    case 0x25: // alef with hamza below
	    case 0x27: // alef
		if ( prevChar( str, pos )->unicode() == 0x0644 )
		    // have a lam alef ligature
		    return 0;
	    default:
		break;
	}
	return arabicUnicodeMapping[ch->cell()][0] + shape;
    }
}



#if 0
static ushort arabicMapping[256][4] {
    // Isolated, left, right, medial forms
    { 0x0600, 0xfffd, 0xfffd, 0xfffd }, // 0x600
    { 0x0601, 0xfffd, 0xfffd, 0xfffd }, // 0x601
    { 0x0602, 0xfffd, 0xfffd, 0xfffd }, // 0x602
    { 0x0603, 0xfffd, 0xfffd, 0xfffd }, // 0x603
    { 0x0604, 0xfffd, 0xfffd, 0xfffd }, // 0x604
    { 0x0605, 0xfffd, 0xfffd, 0xfffd }, // 0x605
    { 0x0606, 0xfffd, 0xfffd, 0xfffd }, // 0x606
    { 0x0607, 0xfffd, 0xfffd, 0xfffd }, // 0x607
    { 0x0608, 0xfffd, 0xfffd, 0xfffd }, // 0x608
    { 0x0609, 0xfffd, 0xfffd, 0xfffd }, // 0x609
    { 0x060a, 0xfffd, 0xfffd, 0xfffd }, // 0x60a
    { 0x060b, 0xfffd, 0xfffd, 0xfffd }, // 0x60b
    { 0x060c, 0xfffd, 0xfffd, 0xfffd }, // 0x60c 	Arabic comma
    { 0x060d, 0xfffd, 0xfffd, 0xfffd }, // 0x60d
    { 0x060e, 0xfffd, 0xfffd, 0xfffd }, // 0x60e
    { 0x060f, 0xfffd, 0xfffd, 0xfffd }, // 0x60f

    { 0x0610, 0xfffd, 0xfffd, 0xfffd }, // 0x610
    { 0x0611, 0xfffd, 0xfffd, 0xfffd }, // 0x611
    { 0x0612, 0xfffd, 0xfffd, 0xfffd }, // 0x612
    { 0x0613, 0xfffd, 0xfffd, 0xfffd }, // 0x613
    { 0x0614, 0xfffd, 0xfffd, 0xfffd }, // 0x614
    { 0x0615, 0xfffd, 0xfffd, 0xfffd }, // 0x615
    { 0x0616, 0xfffd, 0xfffd, 0xfffd }, // 0x616
    { 0x0617, 0xfffd, 0xfffd, 0xfffd }, // 0x617
    { 0x0618, 0xfffd, 0xfffd, 0xfffd }, // 0x618
    { 0x0619, 0xfffd, 0xfffd, 0xfffd }, // 0x619
    { 0x061a, 0xfffd, 0xfffd, 0xfffd }, // 0x61a
    { 0x061b, 0xfffd, 0xfffd, 0xfffd }, // 0x61b  	Arabic semicolon
    { 0x061c, 0xfffd, 0xfffd, 0xfffd }, // 0x61c
    { 0x061d, 0xfffd, 0xfffd, 0xfffd }, // 0x61d
    { 0x061e, 0xfffd, 0xfffd, 0xfffd }, // 0x61e
    { 0x061f, 0xfffd, 0xfffd, 0xfffd }, // 0x61f  	Arabic question mark

    { 0x0620, 0xfffd, 0xfffd, 0xfffd }, // 0x620
    { 0x0621, 0xfffd, 0xfffd, 0xfffd }, // 0x621 	Hamza
    { 0x0622, 0xfffd, 0xfffd, 0xfffd }, // 0x622 	R 	Alef with Madda above
    { 0x0623, 0xfffd, 0xfffd, 0xfffd }, // 0x623 	R 	Alef with Hamza above
    { 0x0624, 0xfffd, 0xfffd, 0xfffd }, // 0x624 	R 	Waw with Hamza above
    { 0x0625, 0xfffd, 0xfffd, 0xfffd }, // 0x625 	R 	Alef with Hamza below
    { 0x0626, 0xfffd, 0xfffd, 0xfffd }, // 0x626 	D 	Yeh with Hamza above
    { 0x0627, 0xfffd, 0xfffd, 0xfffd }, // 0x627 	R 	Alef
    { 0x0628, 0xfffd, 0xfffd, 0xfffd }, // 0x628 	D 	Beh
    { 0x0629, 0xfffd, 0xfffd, 0xfffd }, // 0x629 	R 	Teh Marbuta
    { 0x062a, 0xfffd, 0xfffd, 0xfffd }, // 0x62a 	D 	Teh
    { 0x062b, 0xfffd, 0xfffd, 0xfffd }, // 0x62b 	D 	Theh
    { 0x062c, 0xfffd, 0xfffd, 0xfffd }, // 0x62c 	D 	Jeem
    { 0x062d, 0xfffd, 0xfffd, 0xfffd }, // 0x62d 	D 	Hah
    { 0x062e, 0xfffd, 0xfffd, 0xfffd }, // 0x62e 	D 	Khah
    { 0x062f, 0xfffd, 0xfffd, 0xfffd }, // 0x62f 	R 	Dal

    { 0x0630, 0xfffd, 0xfffd, 0xfffd }, // 0x630 	R 	Thal
    { 0x0631, 0xfffd, 0xfffd, 0xfffd }, // 0x631 	R 	Reh
    { 0x0632, 0xfffd, 0xfffd, 0xfffd }, // 0x632 	R 	Zain
    { 0x0633, 0xfffd, 0xfffd, 0xfffd }, // 0x633 	D 	Seen
    { 0x0634, 0xfffd, 0xfffd, 0xfffd }, // 0x634 	D 	Sheen
    { 0x0635, 0xfffd, 0xfffd, 0xfffd }, // 0x635 	D 	Sad
    { 0x0636, 0xfffd, 0xfffd, 0xfffd }, // 0x636 	D 	Dad
    { 0x0637, 0xfffd, 0xfffd, 0xfffd }, // 0x637 	D 	Tah
    { 0x0638, 0xfffd, 0xfffd, 0xfffd }, // 0x638 	D 	Zah
    { 0x0639, 0xfffd, 0xfffd, 0xfffd }, // 0x639 	D 	Ain
    { 0x063a, 0xfffd, 0xfffd, 0xfffd }, // 0x63a 	D 	Ghain
    { 0x063b, 0xfffd, 0xfffd, 0xfffd }, // 0x63b
    { 0x063c, 0xfffd, 0xfffd, 0xfffd }, // 0x63c
    { 0x063d, 0xfffd, 0xfffd, 0xfffd }, // 0x63d
    { 0x063e, 0xfffd, 0xfffd, 0xfffd }, // 0x63e
    { 0x063f, 0xfffd, 0xfffd, 0xfffd }, // 0x63f

    { 0x0640, 0xfffd, 0xfffd, 0xfffd }, // 0x640 	C 	Tatweel
    { 0x0641, 0xfffd, 0xfffd, 0xfffd }, // 0x641 	D 	Feh
    { 0x0642, 0xfffd, 0xfffd, 0xfffd }, // 0x642 	D 	Qaf
    { 0x0643, 0xfffd, 0xfffd, 0xfffd }, // 0x643 	D 	Kaf
    { 0x0644, 0xfffd, 0xfffd, 0xfffd }, // 0x644 	D 	Lam
    { 0x0645, 0xfffd, 0xfffd, 0xfffd }, // 0x645 	D 	Meem
    { 0x0646, 0xfffd, 0xfffd, 0xfffd }, // 0x646 	D 	Noon
    { 0x0647, 0xfffd, 0xfffd, 0xfffd }, // 0x647 	D 	Heh
    { 0x0648, 0xfffd, 0xfffd, 0xfffd }, // 0x648 	R 	Waw
    { 0x0649, 0xfffd, 0xfffd, 0xfffd }, // 0x649 	D 	Alef Maksura
    { 0x064a, 0xfffd, 0xfffd, 0xfffd }, // 0x64a 	D 	Yeh
    { 0x064b, 0xfffd, 0xfffd, 0xfffd }, // 0x64b 	Mark Fathatan
    { 0x064c, 0xfffd, 0xfffd, 0xfffd }, // 0x64c 	Mark Dammatan
    { 0x064d, 0xfffd, 0xfffd, 0xfffd }, // 0x64d 	Mark Kasratan
    { 0x064e, 0xfffd, 0xfffd, 0xfffd }, // 0x64e 	Mark Fatha
    { 0x064f, 0xfffd, 0xfffd, 0xfffd }, // 0x64f 	Mark Damma

    { 0x0650, 0xfffd, 0xfffd, 0xfffd }, // 0x650 	Mark Kasra
    { 0x0651, 0xfffd, 0xfffd, 0xfffd }, // 0x651 	Mark Shadda
    { 0x0652, 0xfffd, 0xfffd, 0xfffd }, // 0x652 	Mark Sukan
    // these do not exist in latin6 anymore:
    { 0x0653, 0xfffd, 0xfffd, 0xfffd }, // 0x653 	Mark Maddah above
    { 0x0654, 0xfffd, 0xfffd, 0xfffd }, // 0x654 	Mark Hamza above
    { 0x0655, 0xfffd, 0xfffd, 0xfffd }, // 0x655 	Mark Hamza below
    { 0x0656, 0xfffd, 0xfffd, 0xfffd }, // 0x656
    { 0x0657, 0xfffd, 0xfffd, 0xfffd }, // 0x657
    { 0x0658, 0xfffd, 0xfffd, 0xfffd }, // 0x658
    { 0x0659, 0xfffd, 0xfffd, 0xfffd }, // 0x659
    { 0x065a, 0xfffd, 0xfffd, 0xfffd }, // 0x65a
    { 0x065b, 0xfffd, 0xfffd, 0xfffd }, // 0x65b
    { 0x065c, 0xfffd, 0xfffd, 0xfffd }, // 0x65c
    { 0x065d, 0xfffd, 0xfffd, 0xfffd }, // 0x65d
    { 0x065e, 0xfffd, 0xfffd, 0xfffd }, // 0x65e
    { 0x065f, 0xfffd, 0xfffd, 0xfffd }, // 0x65f

    { 0x0660, 0xfffd, 0xfffd, 0xfffd }, // 0x660 	Arabic 0
    { 0x0661, 0xfffd, 0xfffd, 0xfffd }, // 0x661 	Arabic 1
    { 0x0662, 0xfffd, 0xfffd, 0xfffd }, // 0x662 	Arabic 2
    { 0x0663, 0xfffd, 0xfffd, 0xfffd }, // 0x663 	Arabic 3
    { 0x0664, 0xfffd, 0xfffd, 0xfffd }, // 0x664 	Arabic 4
    { 0x0665, 0xfffd, 0xfffd, 0xfffd }, // 0x665 	Arabic 5
    { 0x0666, 0xfffd, 0xfffd, 0xfffd }, // 0x666 	Arabic 6
    { 0x0667, 0xfffd, 0xfffd, 0xfffd }, // 0x667 	Arabic 7
    { 0x0668, 0xfffd, 0xfffd, 0xfffd }, // 0x668 	Arabic 8
    { 0x0669, 0xfffd, 0xfffd, 0xfffd }, // 0x669 	Arabic 9
    { 0x066a, 0xfffd, 0xfffd, 0xfffd }, // 0x66a 	Arabic % sign
    { 0x066b, 0xfffd, 0xfffd, 0xfffd }, // 0x66b 	Arabic decimal separator
    { 0x066c, 0xfffd, 0xfffd, 0xfffd }, // 0x66c 	Arabic thousands separator
    { 0x066d, 0xfffd, 0xfffd, 0xfffd }, // 0x66d 	Arabic five pointed star
    { 0x066e, 0xfffd, 0xfffd, 0xfffd }, // 0x66e
    { 0x066f, 0xfffd, 0xfffd, 0xfffd }, // 0x66f

    { 0x0670, 0xfffd, 0xfffd, 0xfffd }, // 0x670
    { 0x0671, 0xfffd, 0xfffd, 0xfffd }, // 0x671 R
    { 0x0672, 0xfffd, 0xfffd, 0xfffd }, // 0x672 R
    { 0x0673, 0xfffd, 0xfffd, 0xfffd }, // 0x673 R
    { 0x0674, 0xfffd, 0xfffd, 0xfffd }, // 0x674 U
    { 0x0675, 0xfffd, 0xfffd, 0xfffd }, // 0x675 R
    { 0x0676, 0xfffd, 0xfffd, 0xfffd }, // 0x676 R
    { 0x0677, 0xfffd, 0xfffd, 0xfffd }, // 0x677 R
    { 0x0678, 0xfffd, 0xfffd, 0xfffd }, // 0x678 D
    { 0x0679, 0xfffd, 0xfffd, 0xfffd }, // 0x679 D
    { 0x067a, 0xfffd, 0xfffd, 0xfffd }, // 0x67a D
    { 0x067b, 0xfffd, 0xfffd, 0xfffd }, // 0x67b D
    { 0x067c, 0xfffd, 0xfffd, 0xfffd }, // 0x67cD
    { 0x067d, 0xfffd, 0xfffd, 0xfffd }, // 0x67d D
    { 0x067e, 0xfffd, 0xfffd, 0xfffd }, // 0x67e D
    { 0x067f, 0xfffd, 0xfffd, 0xfffd }, // 0x67f D

    { 0x0680, 0xfffd, 0xfffd, 0xfffd }, // 0x680 D
    { 0x0681, 0xfffd, 0xfffd, 0xfffd }, // 0x681 D
    { 0x0682, 0xfffd, 0xfffd, 0xfffd }, // 0x682 D
    { 0x0683, 0xfffd, 0xfffd, 0xfffd }, // 0x683 D
    { 0x0684, 0xfffd, 0xfffd, 0xfffd }, // 0x684 D
    { 0x0685, 0xfffd, 0xfffd, 0xfffd }, // 0x685 D
    { 0x0686, 0xfffd, 0xfffd, 0xfffd }, // 0x686 D
    { 0x0687, 0xfffd, 0xfffd, 0xfffd }, // 0x687 D
    { 0x0688, 0xfffd, 0xfffd, 0xfffd }, // 0x688 R
    { 0x0689, 0xfffd, 0xfffd, 0xfffd }, // 0x689 R
    { 0x068a, 0xfffd, 0xfffd, 0xfffd }, // 0x68a R
    { 0x068b, 0xfffd, 0xfffd, 0xfffd }, // 0x68b R
    { 0x068c, 0xfffd, 0xfffd, 0xfffd }, // 0x68cR
    { 0x068d, 0xfffd, 0xfffd, 0xfffd }, // 0x68d R
    { 0x068e, 0xfffd, 0xfffd, 0xfffd }, // 0x68e R
    { 0x068f, 0xfffd, 0xfffd, 0xfffd }, // 0x68f R

    { 0x0690, 0xfffd, 0xfffd, 0xfffd }, // 0x690 R
    { 0x0691, 0xfffd, 0xfffd, 0xfffd }, // 0x691 R
    { 0x0692, 0xfffd, 0xfffd, 0xfffd }, // 0x692 R
    { 0x0693, 0xfffd, 0xfffd, 0xfffd }, // 0x693 R
    { 0x0694, 0xfffd, 0xfffd, 0xfffd }, // 0x694 R
    { 0x0695, 0xfffd, 0xfffd, 0xfffd }, // 0x695 R
    { 0x0696, 0xfffd, 0xfffd, 0xfffd }, // 0x696 R
    { 0x0697, 0xfffd, 0xfffd, 0xfffd }, // 0x697 R
    { 0x0698, 0xfffd, 0xfffd, 0xfffd }, // 0x698 R
    { 0x0699, 0xfffd, 0xfffd, 0xfffd }, // 0x699 R
    { 0x069a, 0xfffd, 0xfffd, 0xfffd }, // 0x69a D
    { 0x069b, 0xfffd, 0xfffd, 0xfffd }, // 0x69b D
    { 0x069c, 0xfffd, 0xfffd, 0xfffd }, // 0x69cD
    { 0x069d, 0xfffd, 0xfffd, 0xfffd }, // 0x69d D
    { 0x069e, 0xfffd, 0xfffd, 0xfffd }, // 0x69e D
    { 0x069f, 0xfffd, 0xfffd, 0xfffd }, // 0x69f D

    { 0x06a0, 0xfffd, 0xfffd, 0xfffd }, // 0x6a0 D
    { 0x06a1, 0xfffd, 0xfffd, 0xfffd }, // 0x6a1 D
    { 0x06a2, 0xfffd, 0xfffd, 0xfffd }, // 0x6a2 D
    { 0x06a3, 0xfffd, 0xfffd, 0xfffd }, // 0x6a3 D
    { 0x06a4, 0xfffd, 0xfffd, 0xfffd }, // 0x6a4 D
    { 0x06a5, 0xfffd, 0xfffd, 0xfffd }, // 0x6a5 D
    { 0x06a6, 0xfffd, 0xfffd, 0xfffd }, // 0x6a6 D
    { 0x06a7, 0xfffd, 0xfffd, 0xfffd }, // 0x6a7 D
    { 0x06a8, 0xfffd, 0xfffd, 0xfffd }, // 0x6a8 D
    { 0x06a9, 0xfffd, 0xfffd, 0xfffd }, // 0x6a9 D
    { 0x06aa, 0xfffd, 0xfffd, 0xfffd }, // 0x6aa D
    { 0x06ab, 0xfffd, 0xfffd, 0xfffd }, // 0x6ab D
    { 0x06ac, 0xfffd, 0xfffd, 0xfffd }, // 0x6acD
    { 0x06ad, 0xfffd, 0xfffd, 0xfffd }, // 0x6ad D
    { 0x06ae, 0xfffd, 0xfffd, 0xfffd }, // 0x6ae D
    { 0x06af, 0xfffd, 0xfffd, 0xfffd }, // 0x6af D

    { 0x06b0, 0xfffd, 0xfffd, 0xfffd }, // 0x6b0 D
    { 0x06b1, 0xfffd, 0xfffd, 0xfffd }, // 0x6b1 D
    { 0x06b2, 0xfffd, 0xfffd, 0xfffd }, // 0x6b2 D
    { 0x06b3, 0xfffd, 0xfffd, 0xfffd }, // 0x6b3 D
    { 0x06b4, 0xfffd, 0xfffd, 0xfffd }, // 0x6b4 D
    { 0x06b5, 0xfffd, 0xfffd, 0xfffd }, // 0x6b5 D
    { 0x06b6, 0xfffd, 0xfffd, 0xfffd }, // 0x6b6 D
    { 0x06b7, 0xfffd, 0xfffd, 0xfffd }, // 0x6b7 D
    { 0x06b8, 0xfffd, 0xfffd, 0xfffd }, // 0x6b8 D
    { 0x06b9, 0xfffd, 0xfffd, 0xfffd }, // 0x6b9 D
    { 0x06ba, 0xfffd, 0xfffd, 0xfffd }, // 0x6ba D
    { 0x06bb, 0xfffd, 0xfffd, 0xfffd }, // 0x6bb D
    { 0x06bc, 0xfffd, 0xfffd, 0xfffd }, // 0x6bcD
    { 0x06bd, 0xfffd, 0xfffd, 0xfffd }, // 0x6bd D
    { 0x06be, 0xfffd, 0xfffd, 0xfffd }, // 0x6be D
    { 0x06bf, 0xfffd, 0xfffd, 0xfffd }, // 0x6bf D

    { 0x06c0, 0xfffd, 0xfffd, 0xfffd }, // 0x6c0 R
    { 0x06c1, 0xfffd, 0xfffd, 0xfffd }, // 0x6c1 D
    { 0x06c2, 0xfffd, 0xfffd, 0xfffd }, // 0x6c2 R
    { 0x06c3, 0xfffd, 0xfffd, 0xfffd }, // 0x6c3 R
    { 0x06c4, 0xfffd, 0xfffd, 0xfffd }, // 0x6c4 R
    { 0x06c5, 0xfffd, 0xfffd, 0xfffd }, // 0x6c5 R
    { 0x06c6, 0xfffd, 0xfffd, 0xfffd }, // 0x6c6 R
    { 0x06c7, 0xfffd, 0xfffd, 0xfffd }, // 0x6c7 R
    { 0x06c8, 0xfffd, 0xfffd, 0xfffd }, // 0x6c8 R
    { 0x06c9, 0xfffd, 0xfffd, 0xfffd }, // 0x6c9 R
    { 0x06ca, 0xfffd, 0xfffd, 0xfffd }, // 0x6ca R
    { 0x06cb, 0xfffd, 0xfffd, 0xfffd }, // 0x6cb R
    { 0x06cc, 0xfffd, 0xfffd, 0xfffd }, // 0x6cc D
    { 0x06cd, 0xfffd, 0xfffd, 0xfffd }, // 0x6cd R
    { 0x06ce, 0xfffd, 0xfffd, 0xfffd }, // 0x6ce D
    { 0x06cf, 0xfffd, 0xfffd, 0xfffd }, // 0x6cf R

    { 0x06d0, 0xfffd, 0xfffd, 0xfffd }, // 0x6d0 D
    { 0x06d1, 0xfffd, 0xfffd, 0xfffd }, // 0x6d1 D
    { 0x06d2, 0xfffd, 0xfffd, 0xfffd }, // 0x6d2 R
    { 0x06d3, 0xfffd, 0xfffd, 0xfffd }, // 0x6d3 R
    { 0x06d4, 0xfffd, 0xfffd, 0xfffd }, // 0x6d4 U
    { 0x06d5, 0xfffd, 0xfffd, 0xfffd }, // 0x6d5 D
    { 0x06d6, 0xfffd, 0xfffd, 0xfffd }, // 0x6d6
    { 0x06d7, 0xfffd, 0xfffd, 0xfffd }, // 0x6d7
    { 0x06d8, 0xfffd, 0xfffd, 0xfffd }, // 0x6d8
    { 0x06d9, 0xfffd, 0xfffd, 0xfffd }, // 0x6d9
    { 0x06da, 0xfffd, 0xfffd, 0xfffd }, // 0x6da
    { 0x06db, 0xfffd, 0xfffd, 0xfffd }, // 0x6db
    { 0x06dc, 0xfffd, 0xfffd, 0xfffd }, // 0x6dc
    { 0x06dd, 0xfffd, 0xfffd, 0xfffd }, // 0x6dd
    { 0x06de, 0xfffd, 0xfffd, 0xfffd }, // 0x6de
    { 0x06df, 0xfffd, 0xfffd, 0xfffd }, // 0x6df

    { 0x06e0, 0xfffd, 0xfffd, 0xfffd }, // 0x6e0
    { 0x06e1, 0xfffd, 0xfffd, 0xfffd }, // 0x6e1
    { 0x06e2, 0xfffd, 0xfffd, 0xfffd }, // 0x6e2
    { 0x06e3, 0xfffd, 0xfffd, 0xfffd }, // 0x6e3
    { 0x06e4, 0xfffd, 0xfffd, 0xfffd }, // 0x6e4
    { 0x06e5, 0xfffd, 0xfffd, 0xfffd }, // 0x6e5
    { 0x06e6, 0xfffd, 0xfffd, 0xfffd }, // 0x6e6
    { 0x06e7, 0xfffd, 0xfffd, 0xfffd }, // 0x6e7
    { 0x06e8, 0xfffd, 0xfffd, 0xfffd }, // 0x6e8
    { 0x06e9, 0xfffd, 0xfffd, 0xfffd }, // 0x6e9
    { 0x06ea, 0xfffd, 0xfffd, 0xfffd }, // 0x6ea
    { 0x06eb, 0xfffd, 0xfffd, 0xfffd }, // 0x6eb
    { 0x06ec, 0xfffd, 0xfffd, 0xfffd }, // 0x6ec
    { 0x06ed, 0xfffd, 0xfffd, 0xfffd }, // 0x6ed
    { 0x06ee, 0xfffd, 0xfffd, 0xfffd }, // 0x6ee
    { 0x06ef, 0xfffd, 0xfffd, 0xfffd }, // 0x6ef

    { 0x06f0, 0xfffd, 0xfffd, 0xfffd }, // 0x6f0
    { 0x06f1, 0xfffd, 0xfffd, 0xfffd }, // 0x6f1
    { 0x06f2, 0xfffd, 0xfffd, 0xfffd }, // 0x6f2
    { 0x06f3, 0xfffd, 0xfffd, 0xfffd }, // 0x6f3
    { 0x06f4, 0xfffd, 0xfffd, 0xfffd }, // 0x6f4
    { 0x06f5, 0xfffd, 0xfffd, 0xfffd }, // 0x6f5
    { 0x06f6, 0xfffd, 0xfffd, 0xfffd }, // 0x6f6
    { 0x06f7, 0xfffd, 0xfffd, 0xfffd }, // 0x6f7
    { 0x06f8, 0xfffd, 0xfffd, 0xfffd }, // 0x6f8
    { 0x06f9, 0xfffd, 0xfffd, 0xfffd }, // 0x6f9
    { 0x06fa, 0xfffd, 0xfffd, 0xfffd }, // 0x6fa D
    { 0x06fb, 0xfffd, 0xfffd, 0xfffd }, // 0x6fb D
    { 0x06fc, 0xfffd, 0xfffd, 0xfffd }, // 0x6fc D
    { 0x06fd, 0xfffd, 0xfffd, 0xfffd }, // 0x6fd
    { 0x06fe, 0xfffd, 0xfffd, 0xfffd }, // 0x6fe
    { 0x06ff, 0xfffd, 0xfffd, 0xfffd }, // 0x6ff

};
#endif

#endif //QT_NO_CODECS
