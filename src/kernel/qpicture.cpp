/****************************************************************************
**
** Implementation of QPicture class.
**
** Copyright (C) 1992-2003 Trolltech AS. All rights reserved.
**
** This file is part of the kernel module of the Qt GUI Toolkit.
** EDITIONS: FREE, PROFESSIONAL, ENTERPRISE
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
****************************************************************************/

#include "qpicture.h"

#ifndef QT_NO_PICTURE

#include "qpainter.h"
#include "qpixmap.h"
#include "qimage.h"
#include "qfile.h"
#include "qdatastream.h"
#include "qpaintdevicemetrics.h"
#include "qregion.h"

/*!
    \class QPicture qpicture.h
    \brief The QPicture class is a paint device that records and
    replays QPainter commands.

    \ingroup graphics
    \ingroup images
    \ingroup shared

    A picture serializes painter commands to an IO device in a
    platform-independent format. For example, a picture created under
    Windows can be read on a Sun SPARC.

    Pictures are called meta-files on some platforms.

    Qt pictures use a proprietary binary format. Unlike native picture
    (meta-file) formats on many window systems, Qt pictures have no
    limitations regarding their contents. Everything that can be
    painted can also be stored in a picture, e.g. fonts, pixmaps,
    regions, transformed graphics, etc.

    QPicture is an \link shclass.html implicitly shared\endlink class.

    Example of how to record a picture:
    \code
    QPicture  pic;
    QPainter  p;
    p.begin( &pic );               // paint in picture
    p.drawEllipse( 10,20, 80,70 ); // draw an ellipse
    p.end();                       // painting done
    pic.save( "drawing.pic" );     // save picture
    \endcode

    Example of how to replay a picture:
    \code
    QPicture  pic;
    pic.load( "drawing.pic" );     // load picture
    QPainter  p;
    p.begin( &myWidget );          // paint in myWidget
    p.drawPicture( pic );          // draw the picture
    p.end();                       // painting done
    \endcode

    Pictures can also be drawn using play(). Some basic data about a
    picture is available, for example, size(), isNull() and
    boundingRect().

*/


static const char  *mfhdr_tag = "QPIC";		// header tag
static const Q_UINT16 mfhdr_maj = 5;		// major version #
static const Q_UINT16 mfhdr_min = 0;		// minor version #


/*!
    Constructs an empty picture.

    The \a formatVersion parameter may be used to \e create a QPicture
    that can be read by applications that are compiled with earlier
    versions of Qt.
    \list
    \i \a formatVersion == 1 is binary compatible with Qt 1.x and later.
    \i \a formatVersion == 2 is binary compatible with Qt 2.0.x and later.
    \i \a formatVersion == 3 is binary compatible with Qt 2.1.x and later.
    \i \a formatVersion == 4 is binary compatible with Qt 3.0.x and later.
    \i \a formatVersion == 5 is binary compatible with Qt 3.1.
    \endlist

    Note that the default formatVersion is -1 which signifies the
    current release, i.e. for Qt 3.1 a formatVersion of 5 is the same
    as the default formatVersion of -1.

    Reading pictures generated by earlier versions of Qt is supported
    and needs no special coding; the format is automatically detected.
*/

QPicture::QPicture( int formatVersion )
    : QPaintDevice( QInternal::Picture | QInternal::ExternalDevice )
    // set device type
{
    d = new QPicturePrivate;

    if ( formatVersion == 0 )
	qWarning( "QPicture: invalid format version 0" );

    // still accept the 0 default from before Qt 3.0.
    if ( formatVersion > 0 && formatVersion != (int)mfhdr_maj ) {
	d->formatMajor = formatVersion;
	d->formatMinor = 0;
	d->formatOk = FALSE;
    }
    else {
	d->resetFormat();
    }
}

/*!
    Constructs a \link shclass.html shallow copy\endlink of \a pic.
*/

QPicture::QPicture( const QPicture &pic )
    : QPaintDevice( QInternal::Picture | QInternal::ExternalDevice )
{
    d = pic.d;
    d->ref();
}

/*!
    Destroys the picture.
*/
QPicture::~QPicture()
{
    if ( d->deref() )
	delete d;
}


/*!
    \fn bool QPicture::isNull() const

    Returns TRUE if the picture contains no data; otherwise returns
    FALSE.
*/

/*!
    \fn uint QPicture::size() const

    Returns the size of the picture data.

    \sa data()
*/

/*!
    \fn const char* QPicture::data() const

    Returns a pointer to the picture data. The pointer is only valid
    until the next non-const function is called on this picture. The
    returned pointer is 0 if the picture contains no data.

    \sa size(), isNull()
*/

/*!
    Sets the picture data directly from \a data and \a size. This
    function copies the input data.

    \sa data(), size()
*/

void QPicture::setData( const char* data, uint size )
{
    detach();
    QByteArray a(data, size);
    d->pictb.setBuffer( a );			// set byte array in buffer
    d->resetFormat();				// we'll have to check
}


/*!
    Loads a picture from the file specified by \a fileName and returns
    TRUE if successful; otherwise returns FALSE.

    By default, the file will be interpreted as being in the native
    QPicture format. Specifying the \a format string is optional and
    is only needed for importing picture data stored in a different
    format.

    Currently, the only external format supported is the \link
    http://www.w3.org/Graphics/SVG/ W3C SVG \endlink format which
    requires the \link xml.html Qt XML module \endlink. The
    corresponding \a format string is "svg".

    \sa save()
*/

bool QPicture::load( const QString &fileName, const char *format )
{
    QFile f( fileName );
    if ( !f.open(IO_ReadOnly) )
	return FALSE;
    return load( &f, format );
}

/*!
    \overload

    \a dev is the device to use for loading.
*/

bool QPicture::load( QIODevice *dev, const char *format )
{
    if(format) {
#ifndef QT_NO_PICTUREIO
	QPictureIO io( dev, format );
	bool result = io.read();
	if ( result ) {
	    operator=( io.picture() );
	} else if ( format )
#else
	bool result = FALSE;
#endif
	{
		qWarning( "QPicture::load: No such picture format: %s", format );
	}
	return result;
    }

    detach();
    QByteArray a = dev->readAll();
    d->pictb.setBuffer( a );			// set byte array in buffer
    return d->checkFormat();
}

/*!
    Saves a picture to the file specified by \a fileName and returns
    TRUE if successful; otherwise returns FALSE.

    Specifying the file \a format string is optional. It's not
    recommended unless you intend to export the picture data for
    use by a third party reader. By default the data will be saved in
    the native QPicture file format.

    Currently, the only external format supported is the \link
    http://www.w3.org/Graphics/SVG/ W3C SVG \endlink format which
    requires the \link xml.html Qt XML module \endlink. The
    corresponding \a format string is "svg".

    \sa load()
*/

bool QPicture::save( const QString &fileName, const char *format )
{
    if ( paintingActive() ) {
	qWarning( "QPicture::save: still being painted on. "
		  "Call QPainter::end() first" );
	return FALSE;
    }


    if(format) {
#ifndef QT_NO_PICTUREIO
	QPictureIO io( fileName, format );
	bool result = io.write();
	if ( result ) {
	    operator=( io.picture() );
	} else if ( format )
#else
	bool result = FALSE;
#endif
	{
	    qWarning( "QPicture::save: No such picture format: %s", format );
	}
	return result;
    }

    QFile f( fileName );
    if ( !f.open(IO_WriteOnly) )
	return FALSE;
    return save( &f, format );
}

/*!
    \overload

    \a dev is the device to use for saving.
*/

bool QPicture::save( QIODevice *dev, const char *format )
{
    if ( paintingActive() ) {
	qWarning( "QPicture::save: still being painted on. "
		  "Call QPainter::end() first" );
	return FALSE;
    }

    if(format) {
#ifndef QT_NO_PICTUREIO
	QPictureIO io( dev, format );
	bool result = io.write();
	if ( result ) {
	    operator=( io.picture() );
	} else if ( format )
#else
	bool result = FALSE;
#endif
	{
	    qWarning( "QPicture::save: No such picture format: %s", format );
	}
	return result;
    }

    dev->writeBlock( d->pictb.buffer(), d->pictb.buffer().size() );
    return TRUE;
}

/*!
    Returns the picture's bounding rectangle or an invalid rectangle
    if the picture contains no data.
*/

QRect QPicture::boundingRect() const
{
    if ( !d->formatOk )
        d->checkFormat();
    return d->brect;
}

/*!
    Sets the picture's bounding rectangle to \a r. The automatically
    calculated value is overridden.
*/

void QPicture::setBoundingRect( const QRect &r )
{
    if ( !d->formatOk )
        d->checkFormat();
    d->brect = r;
}

/*!
    Replays the picture using \a painter, and returns TRUE if
    successful; otherwise returns FALSE.

    This function does exactly the same as QPainter::drawPicture()
    with (x, y) = (0, 0).
*/

bool QPicture::play( QPainter *painter )
{
    if ( d->pictb.size() == 0 )			// nothing recorded
	return TRUE;

    if ( !d->formatOk && !d->checkFormat() )
	return FALSE;

    d->pictb.open( IO_ReadOnly );		// open buffer device
    QDataStream s;
    s.setDevice( &d->pictb );			// attach data stream to buffer
    s.device()->at( 10 );			// go directly to the data
    s.setVersion( d->formatMajor == 4 ? 3 : d->formatMajor );

    Q_UINT8  c, clen;
    Q_UINT32 nrecords;
    s >> c >> clen;
    Q_ASSERT( c == PdcBegin );
    // bounding rect was introduced in ver 4. Read in checkFormat().
    if ( d->formatMajor >= 4 ) {
	Q_INT32 dummy;
	s >> dummy >> dummy >> dummy >> dummy;
    }
    s >> nrecords;
    if ( !exec( painter, s, nrecords ) ) {
	qWarning( "QPicture::play: Format error" );
	d->pictb.close();
	return FALSE;
    }
    d->pictb.close();
    return TRUE;				// no end-command
}


/*!
  \internal
  Iterates over the internal picture data and draws the picture using
  \a painter.
*/

bool QPicture::exec( QPainter *painter, QDataStream &s, int nrecords )
{
#if defined(QT_DEBUG)
    int		strm_pos;
#endif
    Q_UINT8	c;				// command id
    Q_UINT8	tiny_len;			// 8-bit length descriptor
    Q_INT32	len;				// 32-bit length descriptor
    Q_INT16	i_16, i1_16, i2_16;		// parameters...
    Q_INT8	i_8;
    Q_UINT32	ul;
    QByteArray	str1;
    QString	str;
    QPoint	p, p1, p2;
    QRect	r;
    QPointArray a;
    QColor	color;
    QFont	font;
    QPen	pen;
    QBrush	brush;
    QRegion	rgn;
#ifndef QT_NO_TRANSFORMATIONS
    QWMatrix	matrix;
#endif

    while ( nrecords-- && !s.eof() ) {
	s >> c;					// read cmd
	s >> tiny_len;				// read param length
	if ( tiny_len == 255 )			// longer than 254 bytes
	    s >> len;
	else
	    len = tiny_len;
#if defined(QT_DEBUG)
	strm_pos = s.device()->at();
#endif
	switch ( c ) {				// exec cmd
	    case PdcNOP:
		break;
	    case PdcDrawPoint:
		s >> p;
		painter->drawPoint( p );
		break;
#ifdef Q_Q3PAINTER
	    case PdcMoveTo:
		s >> p;
		painter->moveTo( p );
		break;
	    case PdcLineTo:
		s >> p;
		painter->lineTo( p );
		break;
#endif
	    case PdcDrawLine:
		s >> p1 >> p2;
		painter->drawLine( p1, p2 );
		break;
	    case PdcDrawRect:
		s >> r;
		painter->drawRect( r );
		break;
	    case PdcDrawRoundRect:
		s >> r >> i1_16 >> i2_16;
		painter->drawRoundRect( r, i1_16, i2_16 );
		break;
	    case PdcDrawEllipse:
		s >> r;
		painter->drawEllipse( r );
		break;
	    case PdcDrawArc:
		s >> r >> i1_16 >> i2_16;
		painter->drawArc( r, i1_16, i2_16 );
		break;
	    case PdcDrawPie:
		s >> r >> i1_16 >> i2_16;
		painter->drawPie( r, i1_16, i2_16 );
		break;
	    case PdcDrawChord:
		s >> r >> i1_16 >> i2_16;
		painter->drawChord( r, i1_16, i2_16 );
		break;
	    case PdcDrawLineSegments:
		s >> a;
		painter->drawLineSegments( a );
		break;
	    case PdcDrawPolyline:
		s >> a;
		painter->drawPolyline( a );
		break;
	    case PdcDrawPolygon:
		s >> a >> i_8;
		painter->drawPolygon( a, i_8 );
		break;
	    case PdcDrawCubicBezier:
		s >> a;
#ifndef QT_NO_BEZIER
		painter->drawCubicBezier( a );
#endif
		break;
	    case PdcDrawText:
		s >> p >> str1;
		painter->drawText( p, str1 );
		break;
	    case PdcDrawTextFormatted:
		s >> r >> i_16 >> str1;
		painter->drawText( r, i_16, str1 );
		break;
	    case PdcDrawText2:
		s >> p >> str;
		painter->drawText( p, str );
		break;
	    case PdcDrawText2Formatted:
		s >> r >> i_16 >> str;
		painter->drawText( r, i_16, str );
		break;
	    case PdcDrawPixmap: {
		QPixmap pixmap;
		if ( d->formatMajor < 4 ) {
		    s >> p >> pixmap;
		    painter->drawPixmap( p, pixmap );
		} else {
		    s >> r >> pixmap;
		    painter->drawPixmap( r, pixmap );
		}
	                }
		break;
	    case PdcDrawImage: {
		QImage image;
		if ( d->formatMajor < 4 ) {
		    s >> p >> image;
		    painter->drawImage( p, image );
		} else {
		    s >> r >> image;
		    painter->drawImage( r, image );
		}
		}
		break;
	    case PdcBegin:
		s >> ul;			// number of records
		if ( !exec( painter, s, ul ) )
		    return FALSE;
		break;
	    case PdcEnd:
		if ( nrecords == 0 )
		    return TRUE;
		break;
	    case PdcSave:
		painter->save();
		break;
	    case PdcRestore:
		painter->restore();
		break;
	    case PdcSetBkColor:
		s >> color;
		painter->setBackgroundColor( color );
		break;
	    case PdcSetBkMode:
		s >> i_8;
		painter->setBackgroundMode( (Qt::BGMode)i_8 );
		break;
	    case PdcSetROP:
		s >> i_8;
		painter->setRasterOp( (Qt::RasterOp)i_8 );
		break;
	    case PdcSetBrushOrigin:
		s >> p;
		painter->setBrushOrigin( p );
		break;
	    case PdcSetFont:
		s >> font;
		painter->setFont( font );
		break;
	    case PdcSetPen:
		s >> pen;
		painter->setPen( pen );
		break;
	    case PdcSetBrush:
		s >> brush;
		painter->setBrush( brush );
		break;
#ifdef Q_Q3PAINTER
	case PdcSetTabStops:
		s >> i_16;
		painter->setTabStops( i_16 );
		break;
	    case PdcSetTabArray:
		s >> i_16;
		if ( i_16 == 0 ) {
		    painter->setTabArray( 0 );
		} else {
		    int *ta = new int[i_16];
		    for ( int i=0; i<i_16; i++ ) {
			s >> i1_16;
			ta[i] = i1_16;
		    }
		    painter->setTabArray( ta );
		    delete [] ta;
		}
		break;
#endif
	    case PdcSetVXform:
		s >> i_8;
#ifndef QT_NO_TRANSFORMATIONS
		painter->setViewXForm( i_8 );
#endif
		break;
	    case PdcSetWindow:
		s >> r;
#ifndef QT_NO_TRANSFORMATIONS
		painter->setWindow( r );
#endif
		break;
	    case PdcSetViewport:
		s >> r;
#ifndef QT_NO_TRANSFORMATIONS
		painter->setViewport( r );
#endif
		break;
	    case PdcSetWXform:
		s >> i_8;
#ifndef QT_NO_TRANSFORMATIONS
		painter->setWorldXForm( i_8 );
#endif
		break;
	    case PdcSetWMatrix:
#ifndef QT_NO_TRANSFORMATIONS	// #### fix me!
		s >> matrix >> i_8;
		painter->setWorldMatrix( matrix, i_8 );
#endif
		break;
#ifndef QT_NO_TRANSFORMATIONS
#ifdef Q_Q3PAINTER
	    case PdcSaveWMatrix:
		painter->saveWorldMatrix();
		break;
	    case PdcRestoreWMatrix:
		painter->restoreWorldMatrix();
		break;
#endif
#endif
	    case PdcSetClip:
		s >> i_8;
		painter->setClipping( i_8 );
		break;
	    case PdcSetClipRegion:
		s >> rgn >> i_8;
		painter->setClipRegion( rgn, (QPainter::CoordinateMode)i_8 );
		break;
	    default:
		qWarning( "QPicture::play: Invalid command %d", c );
		if ( len )			// skip unknown command
		    s.device()->at( s.device()->at()+len );
	}
#if defined(QT_DEBUG)
	//qDebug( "device->at(): %i, strm_pos: %i len: %i", s.device()->at(), strm_pos, len );
	Q_ASSERT( Q_INT32(s.device()->at() - strm_pos) == len );
#endif
    }
    return FALSE;
}


/*!
  \internal
  Records painter commands and stores them in the pictb buffer.
*/

bool QPicture::cmd( int c, QPainter *pt, QPDevCmdParam *p )
{
    detach();
    return d->cmd( c, pt, p );
}

/*!
  \internal
  Implementation of the function forwarded above to the internal data struct.
*/

bool QPicture::QPicturePrivate::cmd( int c, QPainter *pt, QPDevCmdParam *p )
{
    QDataStream s;
    s.setDevice( &pictb );
    // when moving up to 4 the QDataStream version remained at 3
    s.setVersion( formatMajor != 4 ? formatMajor : 3 );
    if ( c ==  PdcBegin ) {			// begin; write header
	QByteArray empty;
	pictb.setBuffer( empty );		// reset byte array in buffer
	pictb.open( IO_WriteOnly );
	s.writeRawBytes( mfhdr_tag, 4 );
	s << (Q_UINT16)0 << (Q_UINT16)formatMajor << (Q_UINT16)formatMinor;
	s << (Q_UINT8)c << (Q_UINT8)sizeof(Q_INT32);
	brect = QRect();
	if ( formatMajor >= 4 ) {
	    s << (Q_INT32)brect.left() << (Q_INT32)brect.top()
	      << (Q_INT32)brect.width() << (Q_INT32)brect.height();
	}
	trecs = 0;
	s << (Q_UINT32)trecs;			// total number of records
	formatOk = FALSE;
	return TRUE;
    } else if ( c == PdcEnd ) {		// end; calc checksum and close
	trecs++;
	s << (Q_UINT8)c << (Q_UINT8)0;
	QByteArray buf = pictb.buffer();
	int cs_start = sizeof(Q_UINT32);		// pos of checksum word
	int data_start = cs_start + sizeof(Q_UINT16);
	int brect_start = data_start + 2*sizeof(Q_INT16) + 2*sizeof(Q_UINT8);
	int pos = pictb.at();
	pictb.at( brect_start );
	if ( formatMajor >= 4 ) { // bounding rectangle
	    s << (Q_INT32)brect.left() << (Q_INT32)brect.top()
	      << (Q_INT32)brect.width() << (Q_INT32)brect.height();
	}
	s << (Q_UINT32)trecs;			// write number of records
	pictb.at( cs_start );
	Q_UINT16 cs = (Q_UINT16)qChecksum( buf.constData()+data_start, pos-data_start );
	s << cs;				// write checksum
	pictb.close();
	return TRUE;
    }
    trecs++;
    s << (Q_UINT8)c;				// write cmd to stream
    s << (Q_UINT8)0;				// write dummy length info
    int pos = (int)pictb.at();			// save position
    QRect br;					// bounding rect addition
    bool corr = FALSE;				// correction for pen width

    switch ( c ) {
	case PdcDrawPoint:
	case PdcMoveTo:
	case PdcLineTo:
	case PdcSetBrushOrigin:
	    s << *p[0].point;
	    br = QRect( *p[0].point, QSize( 1, 1 ) );
	    corr = TRUE;
	    break;
	case PdcDrawLine:
	    s << *p[0].point << *p[1].point;
	    br = QRect( *p[0].point, *p[1].point ).normalize();
	    corr = TRUE;
	    break;
	case PdcDrawRect:
	case PdcDrawEllipse:
	    s << *p[0].rect;
	    br = *p[0].rect;
	    corr = TRUE;
	    break;
	case PdcDrawRoundRect:
	case PdcDrawArc:
	case PdcDrawPie:
	case PdcDrawChord:
	    s << *p[0].rect << (Q_INT16)p[1].ival << (Q_INT16)p[2].ival;
	    br = *p[0].rect;
	    corr = TRUE;
	    break;
	case PdcDrawLineSegments:
	case PdcDrawPolyline:
	    s << *p[0].ptarr;
	    br = p[0].ptarr->boundingRect();
	    corr = TRUE;
	    break;
#ifndef QT_NO_BEZIER
	case PdcDrawCubicBezier:
	    s << *p[0].ptarr;
	    br = p[0].ptarr->cubicBezier().boundingRect();
	    corr = TRUE;
	    break;
#endif
	case PdcDrawPolygon:
	    s << *p[0].ptarr << (Q_INT8)p[1].ival;
	    br = p[0].ptarr->boundingRect();
	    corr = TRUE;
	    break;
	case PdcDrawText2:
	    if ( formatMajor == 1 ) {
		pictb.at( pos - 2 );
		s << (Q_UINT8)PdcDrawText << (Q_UINT8)0;
		s << *p[0].point << (*p[1].str).toLatin1();
	    }
	    else {
		s << *p[0].point << *p[1].str;
	    }
	    br = pt->fontMetrics().boundingRect( *p[1].str );
	    br.moveBy( p[0].point->x(), p[0].point->y() );
	    break;
	case PdcDrawText2Formatted:
	    if ( formatMajor == 1 ) {
		pictb.at( pos - 2 );
		s << (Q_UINT8)PdcDrawTextFormatted << (Q_UINT8)0;
		s << *p[0].rect << (Q_INT16)p[1].ival << (*p[2].str).toLatin1();
	    }
	    else {
		s << *p[0].rect << (Q_INT16)p[1].ival << *p[2].str;
	    }
	    br = *p[0].rect;
	    break;
	case PdcDrawPixmap:
	    if ( formatMajor < 4 ) {
		s << *p[0].point;
		s << *p[1].pixmap;
		br = QRect( *p[0].point, p[1].pixmap->size() );
	    } else {
		s << *p[0].rect;
		s << *p[1].pixmap;
		br = *p[0].rect;
	    }
	    break;
	case PdcDrawImage:
	    if ( formatMajor < 4 ) {
		QPoint pt( p[0].point->x(), p[0].point->y() );
		s << pt;
		s << *p[1].image;
		br = QRect( *p[0].point, p[1].image->size() );
	    } else {
		s << *p[0].rect;
		s << *p[1].image;
		br = *p[0].rect;
	    }
	    break;
	case PdcSave:
	case PdcRestore:
	    break;
	case PdcSetBkColor:
	    s << *p[0].color;
	    break;
	case PdcSetBkMode:
	case PdcSetROP:
	    s << (Q_INT8)p[0].ival;
	    break;
	case PdcSetFont:
	    s << *p[0].font;
	    break;
	case PdcSetPen:
	    s << *p[0].pen;
	    break;
	case PdcSetBrush:
	    s << *p[0].brush;
	    break;
	case PdcSetTabStops:
	    s << (Q_INT16)p[0].ival;
	    break;
	case PdcSetTabArray:
	    s << (Q_INT16)p[0].ival;
	    if ( p[0].ival ) {
		int *ta = p[1].ivec;
		for ( int i=0; i<p[0].ival; i++ )
		    s << (Q_INT16)ta[i];
	    }
	    break;
	case PdcSetUnit:
	case PdcSetVXform:
	case PdcSetWXform:
	case PdcSetClip:
	    s << (Q_INT8)p[0].ival;
	    break;
#ifndef QT_NO_TRANSFORMATIONS
	case PdcSetWindow:
	case PdcSetViewport:
	    s << *p[0].rect;
	    break;
	case PdcSetWMatrix:
	    s << *p[0].matrix << (Q_INT8)p[1].ival;
	    break;
#endif
	case PdcSetClipRegion:
	    s << *p[0].rgn;
	    s << (Q_INT8)p[1].ival;
	    break;
	default:
	    qWarning( "QPicture::cmd: Command %d not recognized", c );
    }
    int newpos = (int)pictb.at();		// new position
    int length = newpos - pos;
    if ( length < 255 ) {			// write 8-bit length
	pictb.at(pos - 1);			// position to right index
	s << (Q_UINT8)length;
    } else {					// write 32-bit length
	s << (Q_UINT32)0;				// extend the buffer
	pictb.at(pos - 1);			// position to right index
	s << (Q_UINT8)255;			// indicate 32-bit length
	char *p = pictb.buffer().data();
	memmove( p+pos+4, p+pos, length );	// make room for 4 byte
	s << (Q_UINT32)length;
	newpos += 4;
    }
    pictb.at( newpos );				// set to new position

    if ( br.isValid() ) {
	if ( corr ) {				// widen bounding rect
	    int w2 = pt->pen().width() / 2;
	    br.setCoords( br.left() - w2, br.top() - w2,
			  br.right() + w2, br.bottom() + w2 );
	}
#ifndef QT_NO_TRANSFORMATIONS
	br = pt->worldMatrix().map( br );
#endif
	if ( pt->hasClipping() ) {
	    QRect cr = pt->clipRegion().boundingRect();
	    br &= cr;
	}
	if ( br.isValid() )
	    brect |= br;		     	// merge with existing rect
    }

    return TRUE;
}


/*!
    Internal implementation of the virtual QPaintDevice::metric()
    function.

    Use the QPaintDeviceMetrics class instead.

    A picture has the following hard-coded values: dpi=72,
    numcolors=16777216 and depth=24.

    \a m is the metric to get.
*/

int QPicture::metric( int m ) const
{
    int val;
    switch ( m ) {
	// ### hard coded dpi and color depth values !
	case QPaintDeviceMetrics::PdmWidth:
	    val = d->brect.width();
	    break;
	case QPaintDeviceMetrics::PdmHeight:
	    val = d->brect.height();
	    break;
	case QPaintDeviceMetrics::PdmWidthMM:
	    val = int(25.4/72.0*d->brect.width());
	    break;
	case QPaintDeviceMetrics::PdmHeightMM:
	    val = int(25.4/72.0*d->brect.height());
	    break;
	case QPaintDeviceMetrics::PdmDpiX:
	case QPaintDeviceMetrics::PdmPhysicalDpiX:
	    val = 72;
	    break;
	case QPaintDeviceMetrics::PdmDpiY:
	case QPaintDeviceMetrics::PdmPhysicalDpiY:
	    val = 72;
	    break;
	case QPaintDeviceMetrics::PdmNumColors:
	    val = 16777216;
	    break;
	case QPaintDeviceMetrics::PdmDepth:
	    val = 24;
	    break;
	default:
	    val = 0;
	    qWarning( "QPicture::metric: Invalid metric command" );
    }
    return val;
}

/*!
    Detaches from shared picture data and makes sure that this picture
    is the only one referring to the data.

    If multiple pictures share common data, this picture makes a copy
    of the data and detaches itself from the sharing mechanism.
    Nothing is done if there is just a single reference.
*/

void QPicture::detach()
{
    if ( d->count != 1 )
	*this = copy();
}

/*!
    Returns a \link shclass.html deep copy\endlink of the picture.
*/

QPicture QPicture::copy() const
{
    QPicture p;
    QByteArray a;
    a.resize(size());
    memcpy( a.data(), data(), size() );
    p.d->pictb.setBuffer( a );			// set byte array in buffer
    if ( d->pictb.isOpen() ) {			// copy buffer state
	p.d->pictb.open( d->pictb.mode() );
	p.d->pictb.at( d->pictb.at() );
    }
    p.d->trecs = d->trecs;
    p.d->formatOk = d->formatOk;
    p.d->formatMinor = d->formatMajor;
    p.d->brect = boundingRect();
    return p;
}

/*****************************************************************************
  QPainter member functions
 *****************************************************************************/

#ifdef Q_Q3PAINTER
/*!
    Replays the picture \a pic translated by (\a x, \a y).

    This function does exactly the same as QPicture::play() when
    called with (\a x, \a y) = (0, 0).
*/

void QPainter::drawPicture( int x, int y, const QPicture &pic )
{
    save();
    translate( x, y );
    ((QPicture*)&pic)->play( (QPainter*)this );
    restore();
}

/*!
    \overload void QPainter::drawPicture( const QPoint &p, const QPicture &pic )

    Draws picture \a pic at point \a p.
*/

void QPainter::drawPicture( const QPoint &p, const QPicture &pic )
{
    drawPicture( p.x(), p.y(), pic );
}

/*!
  \obsolete

  Use one of the other QPainter::drawPicture() functions with a (0, 0)
  offset instead.
*/

void QPainter::drawPicture( const QPicture &pic )
{
    drawPicture( 0, 0, pic );
}
#endif
/*!
    Assigns a \link shclass.html shallow copy\endlink of \a p to this
    picture and returns a reference to this picture.
*/

QPicture& QPicture::operator= (const QPicture& p)
{
    p.d->ref();				// avoid 'x = x'
    if ( d->deref() )
	delete d;
    d = p.d;
    return *this;
}


/*!
  \internal

  Sets formatOk to FALSE and resets the format version numbers to default
*/

void QPicture::QPicturePrivate::resetFormat()
{
    formatOk = FALSE;
    formatMajor = mfhdr_maj;
    formatMinor = mfhdr_min;
}

/*!
  \internal

  Checks data integrity and format version number. Set formatOk to TRUE
  on success, to FALSE otherwise. Returns the resulting formatOk value.
*/

bool QPicture::QPicturePrivate::checkFormat()
{
    resetFormat();

    // can't check anything in an empty buffer
    if ( pictb.size() == 0 )
	return FALSE;

    pictb.open( IO_ReadOnly );			// open buffer device
    QDataStream s;
    s.setDevice( &pictb );			// attach data stream to buffer

    char mf_id[4];				// picture header tag
    s.readRawBytes( mf_id, 4 );			// read actual tag
    if ( memcmp(mf_id, mfhdr_tag, 4) != 0 ) { 	// wrong header id
	qWarning( "QPicture::checkFormat: Incorrect header" );
	pictb.close();
	return FALSE;
    }

    int cs_start = sizeof(Q_UINT32);		// pos of checksum word
    int data_start = cs_start + sizeof(Q_UINT16);
    Q_UINT16 cs,ccs;
    QByteArray buf = pictb.buffer();	// pointer to data
    s >> cs;				// read checksum
    ccs = qChecksum( buf.constData() + data_start, buf.size() - data_start );
    if ( ccs != cs ) {
	qWarning( "QPicture::checkFormat: Invalid checksum %x, %x expected",
		  ccs, cs );
	pictb.close();
	return FALSE;
    }

    Q_UINT16 major, minor;
    s >> major >> minor;			// read version number
    if ( major > mfhdr_maj ) {		// new, incompatible version
	qWarning( "QPicture::checkFormat: Incompatible version %d.%d",
		  major, minor);
	pictb.close();
	return FALSE;
    }
    s.setVersion( major != 4 ? major : 3 );

    Q_UINT8  c, clen;
    s >> c >> clen;
    if ( c == PdcBegin ) {
	if ( !( major >= 1 && major <= 3 )) {
	    Q_INT32 l, t, w, h;
	    s >> l >> t >> w >> h;
	    brect = QRect( l, t, w, h );
	}
    } else {
	qWarning( "QPicture::checkFormat: Format error" );
	pictb.close();
	return FALSE;
    }
    pictb.close();

    formatOk = TRUE;			// picture seems to be ok
    formatMajor = major;
    formatMinor = minor;
    return TRUE;
}

/*****************************************************************************
  QPicture stream functions
 *****************************************************************************/

/*!
    \relates QPicture

    Writes picture \a r to the stream \a s and returns a reference to
    the stream.
*/

QDataStream &operator<<( QDataStream &s, const QPicture &r )
{
    Q_UINT32 size = r.d->pictb.buffer().size();
    s << size;
    // null picture ?
    if ( size == 0 )
	return s;
    // just write the whole buffer to the stream
    return s.writeRawBytes ( r.d->pictb.buffer(), r.d->pictb.buffer().size() );
}

/*!
    \relates QPicture

    Reads a picture from the stream \a s into picture \a r and returns
    a reference to the stream.
*/

QDataStream &operator>>( QDataStream &s, QPicture &r )
{
    QDataStream sr;

    // "init"; this code is similar to the beginning of QPicture::cmd()
    sr.setDevice( &r.d->pictb );
    sr.setVersion( r.d->formatMajor );
    Q_UINT32 len;
    s >> len;
    QByteArray data;
    if ( len > 0 ) {
	data.resize(len);
	s.readRawBytes( data.data(), len );
    }

    r.d->pictb.setBuffer( data );
    r.d->resetFormat();

    return s;
}

#ifndef QT_NO_PICTUREIO
#include "qregexp.h"
#include "qapplication.h"
#include "qpictureformatinterface_p.h"
#include "private/qpluginmanager_p.h"
#include "qfile.h"

/*!
    Returns a string that specifies the picture format of the file \a
    fileName, or 0 if the file cannot be read or if the format is not
    recognized.

    The QPictureIO documentation lists the guaranteed supported picture
    formats, or use QPicture::inputFormats() and QPicture::outputFormats()
    to get lists that include the installed formats.

    \sa load() save()
*/

const char* QPicture::pictureFormat( const QString &fileName )
{
    return QPictureIO::pictureFormat( fileName );
}

/*!
    Returns a list of picture formats that are supported for picture
    input.

    \sa outputFormats() inputFormatList() QPictureIO
*/
QList<QByteArray> QPicture::inputFormats()
{
    return QPictureIO::inputFormats();
}

#ifndef QT_NO_STRINGLIST
static QStringList qToStringList(const QList<QByteArray> arr)
{
    QStringList list;
    for (int i = 0; i < arr.count(); ++i)
	list.append(QString(arr.at(i)));
    return list;
}

/*!
    Returns a list of picture formats that are supported for picture
    input.

    Note that if you want to iterate over the list, you should iterate
    over a copy, e.g.
    \code
    QStringList list = myPicture.inputFormatList();
    QStringList::Iterator it = list.begin();
    while( it != list.end() ) {
	myProcessing( *it );
	++it;
    }
    \endcode

    \sa outputFormatList() inputFormats() QPictureIO
*/
QStringList QPicture::inputFormatList()
{
    return qToStringList(QPictureIO::inputFormats());
}


/*!
    Returns a list of picture formats that are supported for picture
    output.

    Note that if you want to iterate over the list, you should iterate
    over a copy, e.g.
    \code
    QStringList list = myPicture.outputFormatList();
    QStringList::Iterator it = list.begin();
    while( it != list.end() ) {
	myProcessing( *it );
	++it;
    }
    \endcode

    \sa inputFormatList() outputFormats() QPictureIO
*/
QStringList QPicture::outputFormatList()
{
    return qToStringList(QPictureIO::outputFormats());
}
#endif //QT_NO_STRINGLIST

/*!
    Returns a list of picture formats that are supported for picture
    output.

    \sa inputFormats() outputFormatList() QPictureIO
*/
QList<QByteArray> QPicture::outputFormats()
{
    return QPictureIO::outputFormats();
}

/*****************************************************************************
  QPictureIO member functions
 *****************************************************************************/

/*!
    \class QPictureIO qpicture.h

    \brief The QPictureIO class contains parameters for loading and
    saving pictures.

    \ingroup images
    \ingroup graphics
    \ingroup io

    QPictureIO contains a QIODevice object that is used for picture data
    I/O. The programmer can install new picture file formats in addition
    to those that Qt provides.

    Qt currently supports only SVG picture file formats.

    You don't normally need to use this class; QPicture::load(),
    QPiicture::save().

    \sa QPicture QPixmap QFile
*/

struct QPictureIOData
{
    QPicture	pi;				// picture
    int		iostat;				// IO status
    QByteArray	frmt;				// picture format
    QIODevice  *iodev;				// IO device
    QString	fname;				// file name
    QString     descr;				// picture description
    const char *parameters;
    int quality;
    float gamma;
};

/*!
    Constructs a QPictureIO object with all parameters set to zero.
*/

QPictureIO::QPictureIO()
{
    init();
}

/*!
    Constructs a QPictureIO object with the I/O device \a ioDevice and a
    \a format tag.
*/

QPictureIO::QPictureIO( QIODevice *ioDevice, const char *format )
{
    init();
    d->iodev = ioDevice;
    d->frmt = format;
}

/*!
    Constructs a QPictureIO object with the file name \a fileName and a
    \a format tag.
*/

QPictureIO::QPictureIO( const QString &fileName, const char* format )
{
    init();
    d->frmt = format;
    d->fname = fileName;
}

/*!
    Contains initialization common to all QPictureIO constructors.
*/

void QPictureIO::init()
{
    d = new QPictureIOData();
    d->parameters = 0;
    d->quality = -1; // default quality of the current format
    d->gamma=0.0f;
    d->iostat = 0;
    d->iodev  = 0;
}

/*!
    Destroys the object and all related data.
*/

QPictureIO::~QPictureIO()
{
    if ( d->parameters )
	delete [] (char*)d->parameters;
    delete d;
}


/*****************************************************************************
  QPictureIO picture handler functions
 *****************************************************************************/

class QPictureHandler
{
public:
    QPictureHandler( const char *f, const char *h, const QByteArray& fl,
		     picture_io_handler r, picture_io_handler w );
    QByteArray	      format;			// picture format
    QRegExp	      header;			// picture header pattern
    enum TMode { Untranslated=0, TranslateIn, TranslateInOut } text_mode;
    picture_io_handler  read_picture;		// picture read function
    picture_io_handler  write_picture;		// picture write function
    bool	      obsolete;			// support not "published"
};

QPictureHandler::QPictureHandler( const char *f, const char *h, const QByteArray& fl,
			      picture_io_handler r, picture_io_handler w )
    : format(f), header(QString::fromLatin1(h))
{
    text_mode = Untranslated;
    if ( fl.contains('t') )
	text_mode = TranslateIn;
    else if ( fl.contains('T') )
	text_mode = TranslateInOut;
    obsolete = fl.contains('O');
    read_picture  = r;
    write_picture = w;
}

typedef QList<QPictureHandler*> QPHList;// list of picture handlers
static QPHList *pictureHandlers = 0;
#ifndef QT_NO_COMPONENT
static QPluginManager<QPictureFormatInterface> *plugin_manager = 0;
#else
static void *plugin_manager = 0;
#endif

void qt_init_picture_plugins()
{
#ifndef QT_NO_COMPONENT
    if ( plugin_manager )
	return;

    plugin_manager = new QPluginManager<QPictureFormatInterface>( IID_QPictureFormat, QApplication::libraryPaths(), "/pictureformats" );

    QStringList features = plugin_manager->featureList();
    QStringList::Iterator it = features.begin();
    while ( it != features.end() ) {
	QString str = *it;
	++it;
	QInterfacePtr<QPictureFormatInterface> iface;
	plugin_manager->queryInterface( str, &iface );
	if ( iface )
	    iface->installIOHandler( str );
    }
#endif
}

static void cleanup()
{
    // make sure that picture handlers are delete before plugin manager
    delete pictureHandlers;
    pictureHandlers = 0;
#ifndef QT_NO_COMPONENT
    delete plugin_manager;
    plugin_manager = 0;
#endif
}

void qt_init_picture_handlers()		// initialize picture handlers
{
    if ( !pictureHandlers ) {
	pictureHandlers = new QPHList;
	pictureHandlers->setAutoDelete( TRUE );
	qAddPostRoutine( cleanup );
    }
}

static QPictureHandler *get_picture_handler( const char *format )
{						// get pointer to handler
    qt_init_picture_handlers();
    qt_init_picture_plugins();
    for(QPHList::Iterator it = pictureHandlers->begin(); it != pictureHandlers->end(); ++it) {
	if ( (*it)->format == format )
	    return (*it);
    }
    return 0;					// no such handler
}


/*!
    Defines a picture I/O handler for the picture format called \a
    format, which is recognized using the \link qregexp.html#details
    regular expression\endlink \a header, read using \a readPicture and
    written using \a writePicture.

    \a flags is a string of single-character flags for this format.
    The only flag defined currently is T (upper case), so the only
    legal value for \a flags are "T" and the empty string. The "T"
    flag means that the picture file is a text file, and Qt should treat
    all newline conventions as equivalent. (XPM files and some PPM
    files are text files for example.)

    \a format is used to select a handler to write a QPicture; \a header
    is used to select a handler to read an picture file.

    If \a readPicture is a null pointer, the QPictureIO will not be able
    to read pictures in \a format. If \a writePicture is a null pointer,
    the QPictureIO will not be able to write pictures in \a format. If
    both are null, the QPictureIO object is valid but useless.

    Example:
    \code
	void readSVG( QPictureIO *picture )
	{
	// read the picture using the picture->ioDevice()
	}

	void writeSVG( QPictureIO *picture )
	{
	// write the picture using the picture->ioDevice()
	}

	// add the GIF picture handler

	QPictureIO::defineIOHandler( "SVG",
				   0, 0,
				   readSVG, writeSVG );
    \endcode

    Before the regex test, all the 0 bytes in the file header are
    converted to 1 bytes. This is done because when Qt was
    ASCII-based, QRegExp could not handle 0 bytes in strings.

    The regexp is only applied on the first 14 bytes of the file.

    (Note that if one handlerIO supports writing a format and another
    supports reading it, Qt supports both reading and writing. If two
    handlers support the same operation, Qt chooses one arbitrarily.)
*/

void QPictureIO::defineIOHandler( const char *format,
				const char *header,
				const char *flags,
				picture_io_handler readPicture,
				picture_io_handler writePicture )
{
    qt_init_picture_handlers();
    QPictureHandler *p;
    p = new QPictureHandler( format, header, QByteArray(flags),
			     readPicture, writePicture );
    pictureHandlers->insert( 0, p );
}


/*****************************************************************************
  QPictureIO normal member functions
 *****************************************************************************/

/*!
    Returns the picture currently set.

    \sa setPicture()
*/
const QPicture &QPictureIO::picture() const { return d->pi; }

/*!
    Returns the picture's IO status. A non-zero value indicates an
    error, whereas 0 means that the IO operation was successful.

    \sa setStatus()
*/
int QPictureIO::status() const { return d->iostat; }

/*!
    Returns the picture format string or 0 if no format has been
    explicitly set.
*/
const char *QPictureIO::format() const { return d->frmt; }

/*!
    Returns the IO device currently set.

    \sa setIODevice()
*/
QIODevice *QPictureIO::ioDevice() const { return d->iodev; }

/*!
    Returns the file name currently set.

    \sa setFileName()
*/
QString QPictureIO::fileName() const { return d->fname; }


/*!
    Returns the picture description string.

    \sa setDescription()
*/
QString QPictureIO::description() const { return d->descr; }

/*!
    Sets the picture to \a picture.

    \sa picture()
*/
void QPictureIO::setPicture( const QPicture &picture )
{
    d->pi = picture;
}

/*!
    Sets the picture IO status to \a status. A non-zero value indicates
    an error, whereas 0 means that the IO operation was successful.

    \sa status()
*/
void QPictureIO::setStatus( int status )
{
    d->iostat = status;
}

/*!
    Sets the picture format to \a format for the picture to be read or
    written.

    It is necessary to specify a format before writing an picture, but
    it is not necessary to specify a format before reading an picture.

    If no format has been set, Qt guesses the picture format before
    reading it. If a format is set the picture will only be read if it
    has that format.

    \sa read() write() format()
*/
void QPictureIO::setFormat( const char *format )
{
    d->frmt = format;
}

/*!
    Sets the IO device to be used for reading or writing an picture.

    Setting the IO device allows pictures to be read/written to any
    block-oriented QIODevice.

    If \a ioDevice is not null, this IO device will override file name
    settings.

    \sa setFileName()
*/
void QPictureIO::setIODevice( QIODevice *ioDevice )
{
    d->iodev = ioDevice;
}

/*!
    Sets the name of the file to read or write an picture from to \a
    fileName.

    \sa setIODevice()
*/
void QPictureIO::setFileName( const QString &fileName )
{
    d->fname = fileName;
}

/*!
    Returns the quality of the written picture, related to the
    compression ratio.

    \sa setQuality() QPicture::save()
*/
int QPictureIO::quality() const
{
    return d->quality;
}

/*!
    Sets the quality of the written picture to \a q, related to the
    compression ratio.

    \a q must be in the range -1..100. Specify 0 to obtain small
    compressed files, 100 for large uncompressed files. (-1 signifies
    the default compression.)

    \sa quality() QPicture::save()
*/

void QPictureIO::setQuality( int q )
{
    d->quality = q;
}

/*!
    Returns the picture's parameters string.

    \sa setParameters()
*/

const char *QPictureIO::parameters() const
{
    return d->parameters;
}

/*!
    Sets the picture's parameter string to \a parameters. This is for
    picture handlers that require special parameters.

    Although the current picture formats supported by Qt ignore the
    parameters string, it may be used in future extensions or by
    contributions (for example, JPEG).

    \sa parameters()
*/

void QPictureIO::setParameters( const char *parameters )
{
    if ( d && d->parameters )
	delete [] (char*)d->parameters;
    d->parameters = qstrdup( parameters );
}

/*!
    Sets the gamma value at which the picture will be viewed to \a
    gamma. If the picture format stores a gamma value for which the
    picture is intended to be used, then this setting will be used to
    modify the picture. Setting to 0.0 will disable gamma correction
    (i.e. any specification in the file will be ignored).

    The default value is 0.0.

    \sa gamma()
*/
void QPictureIO::setGamma( float gamma )
{
    d->gamma=gamma;
}

/*!
    Returns the gamma value at which the picture will be viewed.

    \sa setGamma()
*/
float QPictureIO::gamma() const
{
    return d->gamma;
}

/*!
    Sets the picture description string for picture handlers that support
    picture descriptions to \a description.

    Currently, no picture format supported by Qt uses the description
    string.
*/

void QPictureIO::setDescription( const QString &description )
{
    d->descr = description;
}


/*!
    Returns a string that specifies the picture format of the file \a
    fileName, or null if the file cannot be read or if the format is
    not recognized.
*/

QByteArray QPictureIO::pictureFormat( const QString &fileName )
{
    QFile file( fileName );
    QByteArray format;
    if ( !file.open(IO_ReadOnly) )
	return format;
    format = pictureFormat( &file );
    file.close();
    return format;
}

/*!
    \overload

    Returns a string that specifies the picture format of the picture read
    from IO device \a d, or 0 if the device cannot be read or if the
    format is not recognized.

    Make sure that \a d is at the right position in the device (for
    example, at the beginning of the file).

    \sa QIODevice::at()
*/

QByteArray QPictureIO::pictureFormat( QIODevice *d )
{
    // if you change this change the documentation for defineIOHandler()
    const int buflen = 14;

    char buf[buflen];
    char buf2[buflen];
    qt_init_picture_handlers();
    qt_init_picture_plugins();
    int pos = d->at();			// save position
    int rdlen = d->readBlock( buf, buflen );	// read a few bytes

    QByteArray format;
    if ( rdlen != buflen )
	return format;

    strncpy( buf2, buf, buflen );

    for ( int n = 0; n < rdlen; n++ )
	if ( buf[n] == '\0' )
	    buf[n] = '\001';
    if ( d->status() == IO_Ok && rdlen > 0 ) {
	buf[rdlen - 1] = '\0';
	QString bufStr = QString::fromLatin1(buf);
	for(QPHList::Iterator it = pictureHandlers->begin(); it != pictureHandlers->end(); ++it) {
	    if ( (*it)->header.search(bufStr) != -1 ) { // try match with headers
		format = (*it)->format;
		break;
	    }
	}
    }
    d->at( pos );				// restore position
    return format;
}

/*!
    Returns a sorted list of picture formats that are supported for
    picture input.
*/
QList<QByteArray> QPictureIO::inputFormats()
{
    QList<QByteArray> result;

    qt_init_picture_handlers();
    qt_init_picture_plugins();

    for(QPHList::Iterator it = pictureHandlers->begin(); it != pictureHandlers->end(); ++it) {
	if ( (*it)->read_picture && !(*it)->obsolete  && !result.contains((*it)->format) )
	    result.append((*it)->format);
    }
    qHeapSort(result);

    return result;
}

/*!
    Returns a sorted list of picture formats that are supported for
    picture output.
*/
QList<QByteArray> QPictureIO::outputFormats()
{
    qt_init_picture_handlers();
    qt_init_picture_plugins();

    QList<QByteArray> result;
    for(QPHList::Iterator it = pictureHandlers->begin(); it != pictureHandlers->end(); ++it) {
	if ( (*it)->write_picture && !(*it)->obsolete && !result.contains((*it)->format) )
	    result.append((*it)->format);
    }
    return result;
}



/*!
    Reads an picture into memory and returns TRUE if the picture was
    successfully read; otherwise returns FALSE.

    Before reading an picture you must set an IO device or a file name.
    If both an IO device and a file name have been set, the IO device
    will be used.

    Setting the picture file format string is optional.

    Note that this function does \e not set the \link format()
    format\endlink used to read the picture. If you need that
    information, use the pictureFormat() static functions.

    Example:

    \code
	QPictureIO iio;
	QPixmap  pixmap;
	iio.setFileName( "vegeburger.bmp" );
	if ( picture.read() )        // ok
	    pixmap = iio.picture();  // convert to pixmap
    \endcode

    \sa setIODevice() setFileName() setFormat() write() QPixmap::load()
*/
bool QPictureIO::read()
{
    QFile	   file;
    const char	  *picture_format;
    QPictureHandler *h;

    if ( d->iodev ) {				// read from io device
	// ok, already open
    } else if ( !d->fname.isEmpty() ) {		// read from file
	file.setName( d->fname );
	if ( !file.open(IO_ReadOnly) )
	    return FALSE;			// cannot open file
	d->iodev = &file;
    } else {					// no file name or io device
	return FALSE;
    }
    if (d->frmt.isEmpty()) {
	// Try to guess format
	picture_format = pictureFormat( d->iodev );	// get picture format
	if ( !picture_format ) {
	    if ( file.isOpen() ) {			// unknown format
		file.close();
		d->iodev = 0;
	    }
	    return FALSE;
	}
    } else {
	picture_format = d->frmt;
    }

    h = get_picture_handler( picture_format );
    if ( file.isOpen() ) {
#if !defined(Q_OS_UNIX)
	if ( h && h->text_mode ) {		// reopen in translated mode
	    file.close();
	    file.open( IO_ReadOnly | IO_Translate );
	}
	else
#endif
	    file.at( 0 );			// position to start
    }
    d->iostat = 1;					// assume error

    if ( h && h->read_picture )
	(*h->read_picture)( this );

    if ( file.isOpen() ) {			// picture was read using file
	file.close();
	d->iodev = 0;
    }
    return d->iostat == 0;				// picture successfully read?
}


/*!
    Writes an picture to an IO device and returns TRUE if the picture was
    successfully written; otherwise returns FALSE.

    Before writing an picture you must set an IO device or a file name.
    If both an IO device and a file name have been set, the IO device
    will be used.

    The picture will be written using the specified picture format.

    Example:
    \code
	QPictureIO iio;
	QPicture   im;
	im = pixmap; // convert to picture
	iio.setPicture( im );
	iio.setFileName( "vegeburger.bmp" );
	iio.setFormat( "BMP" );
	if ( iio.write() )
	    // returned TRUE if written successfully
    \endcode

    \sa setIODevice() setFileName() setFormat() read() QPixmap::save()
*/
bool QPictureIO::write()
{
    if ( d->frmt.isEmpty() )
	return FALSE;
    QPictureHandler *h = get_picture_handler( d->frmt );
    if ( !h && !plugin_manager) {
	qt_init_picture_plugins();
	h = get_picture_handler( d->frmt );
    }
    if ( !h || !h->write_picture ) {
	qWarning( "QPictureIO::write: No such picture format handler: %s",
		 format() );
	return FALSE;
    }
    QFile file;
    if ( !d->iodev && !d->fname.isEmpty() ) {
	file.setName( d->fname );
	bool translate = h->text_mode==QPictureHandler::TranslateInOut;
	int fmode = translate ? IO_WriteOnly|IO_Translate : IO_WriteOnly;
	if ( !file.open(fmode) )		// couldn't create file
	    return FALSE;
	d->iodev = &file;
    }
    d->iostat = 1;
    (*h->write_picture)( this );
    if ( file.isOpen() ) {			// picture was written using file
	file.close();
	d->iodev = 0;
    }
    return d->iostat == 0;				// picture successfully written?
}

#endif //QT_NO_PICTUREIO

#endif // QT_NO_PICTURE

