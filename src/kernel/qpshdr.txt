%!PS-Adobe-1.0
%%Creator: Qt
%%Title: This is Qt postscript
%%CreationDate: 1994 BC
%%Pages: (atend)
%%DocumentFonts: (atend)
%%EndComments

%
% $Id: //depot/qt/main/src/kernel/qpshdr.txt#1 $
%
% Postscript routines for QInternalPrinter class
%
% Author  : Eirik Eng
% Created : 940920
%
% Copyright (C) 1994 by Troll Tech AS.  All rights reserved.
%

/D  {bind def} bind def
/ED {exch def} D
/LT {lineto} D
/MT {moveto} D
/S  {stroke} D
/SW {setlinewidth} D
/CP {closepath} D
/RL {rlineto} D
/NP {newpath} D
/CM {currentmatrix} D
/SM {setmatrix} D
/TR {translate} D
/SC {aload pop setrgbcolor} D
/GS {gsave} D
/GR {grestore} D


/BSt 0 def		% brush style
/LWi 1 def		% line width
/PSt 1 def		% pen style
/Cx  0 def		% current x position
/Cy  0 def		% current y position
/WFi true def		% winding fill
/OMo false def		% opaque mode (not transparent)

/BCol  [ 1 1 1 ] def	% brush color
/PCol  [ 0 0 0 ] def	% pen color
/BkCol [ 1 1 1 ] def	% background color

/QtStroke {
    PSt 0 ne			% != NO_PEN
    { LWi SW			% set line width
      GS
      PCol SC  % set pen color
      true GPS 0 setdash S	  % draw line pattern
      OMo PSt 1 ne and		% opaque mode and not solid line?
      { GR BkCol SC
	false GPS dup 0 get setdash S	% fill in opaque pattern
      }
      { GR } ifelse
    } if
} D

/QtFill {
    GS
    BSt 7 ge BSt 12 le and	% fill pattern?
    { BF } if
    BSt 1 eq			% solid brush?
    { BCol SC WFi { fill } { eofill } ifelse } if
    GR
} D 

/ArcDict 6 dict def
ArcDict begin
    /tmp matrix def
end
/ARC{     % Generic ARC function   X Y W H ang1 ang2 
    ArcDict begin
    /ang2 ED /ang1 ED /h ED /w ED /y ED /x ED
    tmp CM pop
    x w 2 div add y h 2 div sub TR
    1 h w div scale
    ang2 0 ge 
    {0 0 w 2 div ang1 ang1 ang2 add arc }
    {0 0 w 2 div ang1 ang1 ang2 add arcn} ifelse
    tmp SM
    end
} D
    
/QtInit {
    GS
    /Courier findfont 12 scalefont setfont
    clippath pathbbox
    3 index /PageX ED
    0 index /PageY ED
    3 2 roll
    exch
    sub neg /PageH ED
    sub neg /PageW ED
%    PageX ==
%    PageY ==
%    PageW ==
%    PageH ==

    PageX PageY 1000 sub translate
} D

/QtFinish {
    GR
    showpage
} D

/P {        % PDC_DRAWPOINT        X Y
    NP
    MT
    -0.5 0.5 rmoveto
    0 -1 RL
    1  0 RL
    0  1 RL
    CP
    PCol SC
    fill
} D

/M {        % PDC_MOVETO           X Y
    /Cy ED /Cx ED
} D

/L {        % PDC_LINETO           X Y
    NP
    Cx Cy MT
    /Cy ED /Cx ED
    Cx Cy LT
    QtStroke
} D

/DL {        % PDC_DRAWLINE        X0 Y0 X1 Y1
    4 2 roll
    NP
    MT
    LT
    QtStroke
} D

/RDict 4 dict def
/R {        % PDC_DRAWRECT         X Y W H
    RDict begin
    /h ED /w ED /y ED /x ED
    NP
    x y MT
    0 h neg RL
    w 0 RL
    0 h RL
    CP
    QtFill
    QtStroke
    end
} D

/RRDict 6 dict def
/RR {        % PDC_DRAWROUNDRECT   X Y W H XR YR
    RRDict begin
    /yr ED /xr ED /h ED /w ED /y ED /x ED    
    xr 0 le yr 0 le or
    {x y w h R}      % Do rectangle if one of rounding values is less than 0.
    {xr 100 ge yr 100 ge or
        {x y w h E}  % Do ellipse if both rounding values are larger than 100
        {
         /rx xr w mul 200 div def
         /ry yr h mul 200 div def
         /rx2 rx 2 mul def
         /ry2 ry 2 mul def
         NP
         x rx add y MT
         x w add rx2 sub y               rx2 ry2 90  -90 ARC 
         x w add rx2 sub y h sub ry2 add rx2 ry2 0   -90 ARC 
         x               y h sub ry2 add rx2 ry2 270 -90 ARC 
         x               y               rx2 ry2 180 -90 ARC 
         CP
         QtFill
         QtStroke
        } ifelse
    } ifelse
    end
} D
       

/EDict 5 dict def
EDict begin
/tmp matrix def
end
/E {        % PDC_DRAWELLIPSE    X Y W H
    EDict begin
    /h ED /w ED /y ED /x ED
    tmp CM pop
    x w 2 div add y h 2 div sub translate
    1 h w div scale
    NP
    0 0 w 2 div 0 360 arc
    tmp SM
    QtFill
    QtStroke
    end
} D
 

/A {        % PDC_DRAWARC    X Y W H ang1 ang2
    16 div exch 16 div exch
    NP
    ARC
    QtStroke
} D


/PieDict 6 dict def
/PIE {        % PDC_DRAWPIE    X Y W H ang1 ang2
    PieDict begin
    /ang2 ED /ang1 ED /h ED /w ED /y ED /x ED
    NP
    x w 2 div add y h 2 div sub MT
    x y w h ang1 16 div ang2 16 div ARC
    CP
    QtFill
    QtStroke
    end
} D

/CH {        % PDC_DRAWCHORD    X Y W H ang1 ang2
    16 div exch 16 div exch
    NP
    ARC
    CP
    QtFill
    QtStroke
} D


/CRGB {     % Compute RGB    R G B => R/255 G/255 B/255
    255 div 3 1 roll
    255 div 3 1 roll
    255 div 3 1 roll
} D

/BC {       % PDC_SETBKCOLOR  R G B
    CRGB
    BkCol astore pop
} D

/B {        % PDC_SETBRUSH  style R G B
    CRGB
    BCol astore pop
    /BSt ED
} D

/PE {       % PDC_SETPEN  style width R G B
    CRGB
    PCol astore pop
    /LWi ED
    /PSt ED
} D

/T {        % PDC_DRAWTEXT    X Y string
    3 1 roll
    MT				% !!!! Uff
    show
} D


/BFDict 2 dict def
/BF {       % brush fill
    BSt 7 ge BSt 12 le and      % valid brush pattern?
    {
     BFDict begin
     GS
     WFi { clip } { eoclip } ifelse
     pathbbox			% left lower right upper
     3 index 1 index translate
     4 2 roll                    % right upper left lower
     3 2 roll                    % right left lower upper
     exch			% left right upper lower
     sub /h ED
     sub /w ED
     OMo {
          NP
          0 0 MT
          0 h neg RL
          w 0 RL
          0 h RL
          CP
          BkCol SC
          fill
     } if
     BCol SC
     0.3 SW
     BSt 7 eq BSt 9 eq or 	% horiz or cross pattern
     { 0 -4 h neg		% draw horiz lines !!! alignment
       { NP dup 0 exch MT w exch LT S } for
     } if
     BSt 8 eq BSt 9 eq or 	% vert or cross pattern
     { 0 4 w			% draw vert lines !!! alignment
       { NP dup 0 MT h neg LT S } for
     } if
     BSt 10 eq BSt 12 eq or	% F-diag or diag cross
     { w h gt
       { 0 6 w h add
 	{ NP dup h neg MT h sub 0 LT S } for }
       { 0 -6 w h add neg
 	 { NP dup w exch MT w add 0 exch LT S } for } ifelse
     } if
     BSt 11 eq BSt 12 eq or
     { w h gt
       { 0 6 w h add
 	 { NP dup 0 MT h sub h neg LT S } for }
       { 0 -6 w h add neg
	 { NP dup 0 exch MT w add w exch LT S } for } ifelse
     } if
     GR
     end
    } if
} D


/LArr[					% Pen styles:
    []		     []			%   solid line
    [ 10 3 ]	     [ 3 10 ]		%   dash line
    [ 3 3 ]	     [ 3 3 ]		%   dot line
    [ 5 3 3 3 ]	     [ 3 5 3 3 ]	%   dash dot line
    [ 5 3 3 3 3 3 ]  [ 3 5 3 3 3 3 ]	%   dash dot dot line
] def

/GPS { 		% get penstyle	BOOL => dash_pattern
		% arg BOOL: true=draw pattern,  false=fill pattern
    PSt 1 ge PSt 5 le and			% valid pen pattern?
    { { LArr PSt 1 sub 2 mul get }		% draw pattern
      { LArr PSt 2 mul 1 sub get } ifelse	% opaque pattern
    }
    { [] } ifelse				% out of range => solid line
} D

%/ {        % PDC_DRAWPOINT    X Y

%%EndProlog

QtInit

%%Page: "1" 
    initgraphics
    QtInit


