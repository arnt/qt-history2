%
% $Id: //depot/qt/main/src/kernel/qpshdr.txt#8 $
%
% Postscript routines for QPSPrinter class
%
% Author  : Eirik Eng
% Created : 940920
%
% Copyright (C) 1994,1995 by Troll Tech AS.  All rights reserved.
%

/D  {bind def} bind def
/ED {exch def} D
/LT {lineto} D
/MT {moveto} D
/S  {stroke} D
/SW {setlinewidth} D
/CP {closepath} D
/RL {rlineto} D
/NP {newpath} D
/CM {currentmatrix} D
/SM {setmatrix} D
/TR {translate} D
/SRGB {setrgbcolor} D
/SC {aload pop SRGB} D
/GS {gsave} D
/GR {grestore} D


/BSt 0 def			% brush style
/LWi 1 def			% line width
/PSt 1 def			% pen style
/Cx  0 def			% current x position
/Cy  0 def			% current y position
/WFi true def			% winding fill
/OMo false def			% opaque mode (not transparent)

/BCol  [ 1 1 1 ] def		% brush color
/PCol  [ 0 0 0 ] def		% pen color
/BkCol [ 1 1 1 ] def		% background color

/nS 0 def			% number of saved painter states


/QS {
    PSt 0 ne			% != NO_PEN
    { LWi SW			% set line width
      GS
      PCol SC			% set pen color
      true GPS 0 setdash S	% draw line pattern
      OMo PSt 1 ne and		% opaque mode and not solid line?
      { GR BkCol SC
	false GPS dup 0 get setdash S	% fill in opaque pattern
      }
      { GR } ifelse
    } if
} D

/QF {
    GS
    BSt 2 ge BSt 8 le and	% dense pattern?
    { BDArr BSt 2 sub get setgray WFi { fill } { eofill } ifelse } if
    BSt 9 ge BSt 14 le and	% fill pattern?
    { BF } if
    BSt 1 eq			% solid brush?
    { BCol SC WFi { fill } { eofill } ifelse } if
    GR
} D

/BDArr[				% Brush dense patterns:
    0.94 0.88 0.63 0.50 0.37 0.12 0.6
] def

/ArcDict 6 dict def
ArcDict begin
    /tmp matrix def
end

/ARC {				% Generic ARC function [ X Y W H ang1 ang2 ]
    ArcDict begin
    /ang2 ED /ang1 ED /h ED /w ED /y ED /x ED
    tmp CM pop
    x w 2 div add y h 2 div add TR
    1 h w div neg scale
    ang2 0 ge
    {0 0 w 2 div ang1 ang1 ang2 add arc }
    {0 0 w 2 div ang1 ang1 ang2 add arcn} ifelse
    tmp SM
    end
} D


/QI {
    GS
    /Courier findfont [ 12 0 0 -12 0 0 ] makefont setfont
    clippath pathbbox
    3 index /PageX ED
    0 index /PageY ED
    3 2 roll
    exch
    sub neg /PageH ED
    sub neg /PageW ED

    PageX PageY TR
    1 -1 scale
    /defM matrix CM def		% default transformation matrix
} D

/QP {				% show page
    GR
    showpage
} D

/P {				% PDC_DRAWPOINT [x y]
    NP
    MT
    0.5 0.5 rmoveto
    0  -1 RL
    -1	0 RL
    0	1 RL
    CP
    PCol SC
    fill
} D

/M {				% PDC_MOVETO [x y]
    /Cy ED /Cx ED
} D

/L {				% PDC_LINETO [x y]
    NP
    Cx Cy MT
    /Cy ED /Cx ED
    Cx Cy LT
    QS
} D

/DL {				% PDC_DRAWLINE [x0 y0 x1 y1]
    4 2 roll
    NP
    MT
    LT
    QS
} D

/RDict 4 dict def
/R {				% PDC_DRAWRECT [x y w h]
    RDict begin
    /h ED /w ED /y ED /x ED
    NP
    x y MT
    0 h RL
    w 0 RL
    0 h neg RL
    CP
    QF
    QS
    end
} D

/RRDict 6 dict def
/RR {				% PDC_DRAWROUNDRECT [x y w h xr yr]
    RRDict begin
    /yr ED /xr ED /h ED /w ED /y ED /x ED
    xr 0 le yr 0 le or
    {x y w h R}	     % Do rectangle if one of rounding values is less than 0.
    {xr 100 ge yr 100 ge or
	{x y w h E}  % Do ellipse if both rounding values are larger than 100
	{
	 /rx xr w mul 200 div def
	 /ry yr h mul 200 div def
	 /rx2 rx 2 mul def
	 /ry2 ry 2 mul def
	 NP
	 x rx add y MT
	 x w add rx2 sub y		 rx2 ry2 90  -90 ARC
	 x w add rx2 sub y h add ry2 sub rx2 ry2 0   -90 ARC
	 x		 y h add ry2 sub rx2 ry2 270 -90 ARC
	 x		 y		 rx2 ry2 180 -90 ARC
	 CP
	 QF
	 QS
	} ifelse
    } ifelse
    end
} D


/EDict 5 dict def
EDict begin
/tmp matrix def
end
/E {				% PDC_DRAWELLIPSE [x y w h]
    EDict begin
    /h ED /w ED /y ED /x ED
    tmp CM pop
    x w 2 div add y h 2 div add translate
    1 h w div scale
    NP
    0 0 w 2 div 0 360 arc
    tmp SM
    QF
    QS
    end
} D


/A {				% PDC_DRAWARC [x y w h ang1 ang2]
    16 div exch 16 div exch
    NP
    ARC
    QS
} D


/PieDict 6 dict def
/PIE {				% PDC_DRAWPIE [x y w h ang1 ang2]
    PieDict begin
    /ang2 ED /ang1 ED /h ED /w ED /y ED /x ED
    NP
    x w 2 div add y h 2 div add MT
    x y w h ang1 16 div ang2 16 div ARC
    CP
    QF
    QS
    end
} D

/CH {				% PDC_DRAWCHORD [x y w h ang1 ang2]
    16 div exch 16 div exch
    NP
    ARC
    CP
    QF
    QS
} D


/BZ {				% PDC_DRAWBEZIER [3 points]
    curveto
    QS
} D


/CRGB {				% Compute RGB [R G B] => R/255 G/255 B/255
    255 div 3 1 roll
    255 div 3 1 roll
    255 div 3 1 roll
} D


/SV {				% Save painter state
    BSt LWi PSt Cx Cy WFi OMo BCol PCol BkCol
    /nS nS 1 add def
    GS
} D

/RS {				% Restore painter state
    nS 0 gt
    { GR
      /BkCol ED /PCol ED /BCol ED /OMo ED /WFi ED
      /Cy ED /Cx ED /PSt ED /LWi ED /BSt ED
      /nS nS 1 sub def
    } if

} D

/BC {				% PDC_SETBKCOLOR [R G B]
    CRGB
    BkCol astore pop
} D

/B {				% PDC_SETBRUSH [style R G B]
    CRGB
    BCol astore pop
    /BSt ED
} D

/PE {				% PDC_SETPEN [style width R G B]
    CRGB
    PCol astore pop
    /LWi ED
    /PSt ED
} D

/ST {				% SET TRANSFORM [matrix]
    defM setmatrix
    concat
} D

/T {				% PDC_DRAWTEXT [x y string]
    3 1 roll
    MT				% !!!! Uff
    PCol SC			% set pen/text color
    show
} D

/BFDict 2 dict def
/BF {				% brush fill
    BSt 9 ge BSt 14 le and	% valid brush pattern?
    {
     BFDict begin
     GS
     WFi { clip } { eoclip } ifelse
     defM SM
     pathbbox			% left upper right lower
     3 index 3 index translate
     4 2 roll			% right lower left upper
     3 2 roll			% right left upper lower
     exch			% left right lower upper
     sub /h ED
     sub /w ED
     OMo {
	  NP
	  0 0 MT
	  0 h RL
	  w 0 RL
	  0 h neg RL
	  CP
	  BkCol SC
	  fill
     } if
     BCol SC
     0.3 SW
     BSt 9 eq BSt 11 eq or		% horiz or cross pattern
     { 0 4 h				% draw horiz lines !!! alignment
       { NP dup 0 exch MT w exch LT S } for
     } if
     BSt 10 eq BSt 11 eq or		% vert or cross pattern
     { 0 4 w				% draw vert lines !!! alignment
       { NP dup 0 MT h LT S } for
     } if
     BSt 12 eq BSt 14 eq or		% F-diag or diag cross
     { w h gt
       { 0 6 w h add
	{ NP dup h MT h sub 0 LT S } for }
       { 0 6 w h add
	 { NP dup w exch MT w add 0 exch LT S } for } ifelse
     } if
     BSt 13 eq BSt 14 eq or		% B-diag or diag cross
     { w h gt
       { 0 6 w h add
	 { NP dup 0 MT h sub h LT S } for }
       { 0 6 w h add
	 { NP dup 0 exch MT w add w exch LT S } for } ifelse
     } if
     GR
     end
    } if
} D

/LArr[					% Pen styles:
    []		     []			%   solid line
    [ 10 3 ]	     [ 3 10 ]		%   dash line
    [ 3 3 ]	     [ 3 3 ]		%   dot line
    [ 5 3 3 3 ]	     [ 3 5 3 3 ]	%   dash dot line
    [ 5 3 3 3 3 3 ]  [ 3 5 3 3 3 3 ]	%   dash dot dot line
] def

/GPS {			% get penstyle	BOOL => dash_pattern
			% arg BOOL: true=draw pattern,	false=fill pattern
    PSt 1 ge PSt 5 le and			% valid pen pattern?
    { { LArr PSt 1 sub 2 mul get }		% draw pattern
      { LArr PSt 2 mul 1 sub get } ifelse	% opaque pattern
    }
    { [] } ifelse				% out of range => solid line
} D

QI

%%EndProlog
