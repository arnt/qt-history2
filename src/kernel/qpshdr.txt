%
% $Id: //depot/qt/main/src/kernel/qpshdr.txt#14 $
%
% Postscript routines for QPSPrinter class
%
% Author  : Eirik Eng
% Created : 940920
%
% Copyright (C) 1994,1995 by Troll Tech AS.  All rights reserved.
%

/D  {bind def} bind def
/ED {exch def} D
/LT {lineto} D
/MT {moveto} D
/S  {stroke} D
/SW {setlinewidth} D
/CP {closepath} D
/RL {rlineto} D
/NP {newpath} D
/CM {currentmatrix} D
/SM {setmatrix} D
/TR {translate} D
/SRGB {setrgbcolor} D
/SC {aload pop SRGB} D
/GS {gsave} D
/GR {grestore} D

[ % iso 8859-1
 /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
 /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
 /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
 /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
 /space /exclam /quotedbl /numbersign /dollar /percent /ampersand /quoteright
 /parenleft /parenright /asterisk /plus /comma /hyphen /period /slash
 /zero /one /two /three /four /five /six /seven
 /eight /nine /colon /semicolon /less /equal /greater /question
 /at /A /B /C /D /E /F /G
 /H /I /J /K /L /M /N /O
 /P /Q /R /S /T /U /V /W
 /X /Y /Z /bracketleft /backslash /bracketright /asciicircum /underscore
 /quoteleft /a /b /c /d /e /f /g
 /h /i /j /k /l /m /n /o
 /p /q /r /s /t /u /v /w
 /x /y /z /braceleft /bar /braceright /asciitilde /.notdef
 /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
 /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
 /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
 /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
 /space /exclamdown /cent /sterling /currency /yen /brokenbar /section
 % switch to four per line starting with 0250
 /dieresis /copyright /ordfeminine /guillemotleft
 /logicalnot /hyphen /registered /macron
 /degree /plusminus /twosuperior /threesuperior
 /acute /mu /paragraph /periodcentered
 /cedilla /onesuperior /ordmasculine /guillemotright
 /onequarter /onehalf /threequarters /questiondown
 % 0300 here
 /Agrave /Aacute /Acircumflex /Atilde
 /Adieresis /Aring /AE /Ccedilla
 /Egrave /Eacute /Ecircumflex /Edieresis
 /Igrave /Iacute /Icircumflex /Idieresis
 /Eth /Ntilde /Ograve /Oacute
 /Ocircumflex /Otilde /Odieresis /multiply
 /Oslash /Ugrave /Uacute /Ucircumflex
 /Udieresis /Yacute /Thorn /germandbls
 % 0340
 /agrave /aacute /acircumflex /atilde
 /adieresis /aring /ae /ccedilla
 /egrave /eacute /ecircumflex /edieresis
 /igrave /iacute /icircumflex /idieresis
 /eth /ntilde /ograve /oacute
 /ocircumflex /otilde /odieresis /divide
 /oslash /ugrave /uacute /ucircumflex
 /udieresis /yacute /thorn /ydieresis
] /iso88591 exch def

/BSt 0 def			% brush style
/LWi 1 def			% line width
/PSt 1 def			% pen style
/Cx  0 def			% current x position
/Cy  0 def			% current y position
/WFi false def			% winding fill
/OMo false def			% opaque mode (not transparent)

/BCol  [ 1 1 1 ] def		% brush color
/PCol  [ 0 0 0 ] def		% pen color
/BkCol [ 1 1 1 ] def		% background color

/nS 0 def			% number of saved painter states


/QS {				% stroke command
    PSt 0 ne			% != NO_PEN
    { LWi SW			% set line width
      GS
      PCol SC			% set pen color
      true GPS 0 setdash S	% draw line pattern
      OMo PSt 1 ne and		% opaque mode and not solid line?
      { GR BkCol SC
	false GPS dup 0 get setdash S	% fill in opaque pattern
      }
      { GR } ifelse
    } if
} D

/QF {				% fill command
    GS
    BSt 2 ge BSt 8 le and	% dense pattern?
    { BDArr BSt 2 sub get setgray fill } if
    BSt 9 ge BSt 14 le and	% fill pattern?
    { BF } if
    BSt 1 eq			% solid brush?
    { BCol SC WFi { fill } { eofill } ifelse } if
    GR
} D

/PF {				% polygon fill command
    GS
    BSt 2 ge BSt 8 le and	% dense pattern?
    { BDArr BSt 2 sub get setgray WFi { fill } { eofill } ifelse } if
    BSt 9 ge BSt 14 le and	% fill pattern?
    { BF } if
    BSt 1 eq			% solid brush?
    { BCol SC WFi { fill } { eofill } ifelse } if
    GR
} D

/BDArr[				% Brush dense patterns:
    0.94 0.88 0.63 0.50 0.37 0.12 0.6
] def

/ArcDict 6 dict def
ArcDict begin
    /tmp matrix def
end

/ARC {				% Generic ARC function [ X Y W H ang1 ang2 ]
    ArcDict begin
    /ang2 ED /ang1 ED /h ED /w ED /y ED /x ED
    tmp CM pop
    x w 2 div add y h 2 div add TR
    1 h w div neg scale
    ang2 0 ge
    {0 0 w 2 div ang1 ang1 ang2 add arc }
    {0 0 w 2 div ang1 ang1 ang2 add arcn} ifelse
    tmp SM
    end
} D


/QI {
    /savedContext save def
    clippath pathbbox
    3 index /PageX ED
    0 index /PageY ED
    3 2 roll
    exch
    sub neg /PageH ED
    sub neg /PageW ED

    PageX PageY TR
    1 -1 scale
    /defM matrix CM def		% default transformation matrix
    /Cx  0 def			% reset current x position
    /Cy  0 def			% reset current y position
    255 255 255 BC
    /OMo false def
    1 0 0 0 0 PE
    0 0 0 0 B
} D

/QP {				% show page
    savedContext restore
    showpage
} D


/P {				% PDC_DRAWPOINT [x y]
    NP
    MT
    0.5 0.5 rmoveto
    0  -1 RL
    -1	0 RL
    0	1 RL
    CP
    PCol SC
    fill
} D

/M {				% PDC_MOVETO [x y]
    /Cy ED /Cx ED
} D

/L {				% PDC_LINETO [x y]
    NP
    Cx Cy MT
    /Cy ED /Cx ED
    Cx Cy LT
    QS
} D

/DL {				% PDC_DRAWLINE [x0 y0 x1 y1]
    4 2 roll
    NP
    MT
    LT
    QS
} D

/RDict 4 dict def
/R {				% PDC_DRAWRECT [x y w h]
    RDict begin
    /h ED /w ED /y ED /x ED
    NP
    x y MT
    0 h RL
    w 0 RL
    0 h neg RL
    CP
    QF
    QS
    end
} D

/RRDict 6 dict def
/RR {				% PDC_DRAWROUNDRECT [x y w h xr yr]
    RRDict begin
    /yr ED /xr ED /h ED /w ED /y ED /x ED
    xr 0 le yr 0 le or
    {x y w h R}	     % Do rectangle if one of rounding values is less than 0.
    {xr 100 ge yr 100 ge or
	{x y w h E}  % Do ellipse if both rounding values are larger than 100
	{
	 /rx xr w mul 200 div def
	 /ry yr h mul 200 div def
	 /rx2 rx 2 mul def
	 /ry2 ry 2 mul def
	 NP
	 x rx add y MT
	 x w add rx2 sub y		 rx2 ry2 90  -90 ARC
	 x w add rx2 sub y h add ry2 sub rx2 ry2 0   -90 ARC
	 x		 y h add ry2 sub rx2 ry2 270 -90 ARC
	 x		 y		 rx2 ry2 180 -90 ARC
	 CP
	 QF
	 QS
	} ifelse
    } ifelse
    end
} D


/EDict 5 dict def
EDict begin
/tmp matrix def
end
/E {				% PDC_DRAWELLIPSE [x y w h]
    EDict begin
    /h ED /w ED /y ED /x ED
    tmp CM pop
    x w 2 div add y h 2 div add translate
    1 h w div scale
    NP
    0 0 w 2 div 0 360 arc
    tmp SM
    QF
    QS
    end
} D


/A {				% PDC_DRAWARC [x y w h ang1 ang2]
    16 div exch 16 div exch
    NP
    ARC
    QS
} D


/PieDict 6 dict def
/PIE {				% PDC_DRAWPIE [x y w h ang1 ang2]
    PieDict begin
    /ang2 ED /ang1 ED /h ED /w ED /y ED /x ED
    NP
    x w 2 div add y h 2 div add MT
    x y w h ang1 16 div ang2 16 div ARC
    CP
    QF
    QS
    end
} D

/CH {				% PDC_DRAWCHORD [x y w h ang1 ang2]
    16 div exch 16 div exch
    NP
    ARC
    CP
    QF
    QS
} D


/BZ {				% PDC_DRAWQUADBEZIER [3 points]
    curveto
    QS
} D


/CRGB {				% Compute RGB [R G B] => R/255 G/255 B/255
    255 div 3 1 roll
    255 div 3 1 roll
    255 div 3 1 roll
} D


/SV {				% Save painter state
    BSt LWi PSt Cx Cy WFi OMo BCol PCol BkCol
    /nS nS 1 add def
    GS
} D

/RS {				% Restore painter state
    nS 0 gt
    { GR
      /BkCol ED /PCol ED /BCol ED /OMo ED /WFi ED
      /Cy ED /Cx ED /PSt ED /LWi ED /BSt ED
      /nS nS 1 sub def
    } if

} D

/BC {				% PDC_SETBKCOLOR [R G B]
    CRGB
    BkCol astore pop
} D

/B {				% PDC_SETBRUSH [style R G B]
    CRGB
    BCol astore pop
    /BSt ED
} D

/PE {				% PDC_SETPEN [style width R G B]
    CRGB
    PCol astore pop
    /LWi ED
    /PSt ED
    LWi 0 eq { 0.3 /LWi ED } if
} D

/ST {				% SET TRANSFORM [matrix]
    defM setmatrix
    concat
} D


% use MF like this make /F114 a 12 point font, preferably Univers, but
% Helvetica if Univers is not available and Courier if all else fails:
%
% /114 [ 12 0 0 -12 0 0 ] [ /Univers /Helvetica ] MF

/F /Courier def
/MF {				% make font [ newname matrix fontlist ]
  /F /Courier def
  {
    dup FontDirectory exch known
    {
      /F exch def
      exit
    } {
      pop
    } ifelse
  } forall
  F findfont dup length dict begin {
    1 index /FID ne {
      def
    } {
      pop pop
    } ifelse
  } forall
  /Encoding iso88591 def
  currentdict
  end
  2 index exch definefont
  exch makefont
  definefont pop
} D


/SF {				% PDC_SETFONT [ fontname ]
  findfont setfont
} D


% isn't this important enough to try to avoid the SC?

/T {				% PDC_DRAWTEXT [x y string]
    3 1 roll
    MT				% !!!! Uff
    PCol SC			% set pen/text color
    show
} D


/BFDict 2 dict def
/BF {				% brush fill
    BSt 9 ge BSt 14 le and	% valid brush pattern?
    {
     BFDict begin
     GS
     WFi { clip } { eoclip } ifelse
     defM SM
     pathbbox			% left upper right lower
     3 index 3 index translate
     4 2 roll			% right lower left upper
     3 2 roll			% right left upper lower
     exch			% left right lower upper
     sub /h ED
     sub /w ED
     OMo {
	  NP
	  0 0 MT
	  0 h RL
	  w 0 RL
	  0 h neg RL
	  CP
	  BkCol SC
	  fill
     } if
     BCol SC
     0.3 SW
     BSt 9 eq BSt 11 eq or	% horiz or cross pattern
     { 0 4 h			% draw horiz lines !!! alignment
       { NP dup 0 exch MT w exch LT S } for
     } if
     BSt 10 eq BSt 11 eq or	% vert or cross pattern
     { 0 4 w			% draw vert lines !!! alignment
       { NP dup 0 MT h LT S } for
     } if
     BSt 12 eq BSt 14 eq or	% F-diag or diag cross
     { w h gt
       { 0 6 w h add
	{ NP dup h MT h sub 0 LT S } for }
       { 0 6 w h add
	 { NP dup w exch MT w add 0 exch LT S } for } ifelse
     } if
     BSt 13 eq BSt 14 eq or	% B-diag or diag cross
     { w h gt
       { 0 6 w h add
	 { NP dup 0 MT h sub h LT S } for }
       { 0 6 w h add
	 { NP dup 0 exch MT w add w exch LT S } for } ifelse
     } if
     GR
     end
    } if
} D

/LArr[					% Pen styles:
    []		     []			%   solid line
    [ 10 3 ]	     [ 3 10 ]		%   dash line
    [ 3 3 ]	     [ 3 3 ]		%   dot line
    [ 5 3 3 3 ]	     [ 3 5 3 3 ]	%   dash dot line
    [ 5 3 3 3 3 3 ]  [ 3 5 3 3 3 3 ]	%   dash dot dot line
] def

%
% Returns the line pattern (from pen style PSt).
%
% Argument:
%   bool pattern
%	true : draw pattern
%	false: fill pattern
%

/GPS {
  PSt 1 ge PSt 5 le and			% valid pen pattern?
    { { LArr PSt 1 sub 2 mul get }	% draw pattern
      { LArr PSt 2 mul 1 sub get } ifelse   % opaque pattern
    }
    { [] } ifelse			% out of range => solid line
} D

%%EndProlog
