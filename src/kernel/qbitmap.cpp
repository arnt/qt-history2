/****************************************************************************
** $Id: //depot/qt/main/src/kernel/qbitmap.cpp#13 $
**
** Implementation of QBitmap class
**
** Author  : Haavard Nord
** Created : 941020
**
** Copyright (C) 1994,1995 by Troll Tech AS.  All rights reserved.
**
*****************************************************************************/

#include "qbitmap.h"
#include "qimage.h"

#if defined(DEBUG)
static char ident[] = "$Id: //depot/qt/main/src/kernel/qbitmap.cpp#13 $";
#endif


/*!
  \class QBitmap qbitmap.h
  \brief The QBitmap class provides monochrome (1 bit depth) pixmaps.

  The QBitmap class is normally used for creating custom mouse
  \link QCursor cursors \endlink or creating a special
  \link QBrush brush\endlink.
*/

/*!
  Constructs a null bitmap.
  \sa QPixmap::isNull()
*/

QBitmap::QBitmap()
{
    data->bitmap = TRUE;
}

/*!
  Constructs a bitmap with \e w width and \e h height.

  The contents of the bitmap is uninitialized if \e clear is FALSE, otherwise
  it is filled with pixel value 0.
*/

QBitmap::QBitmap( int w, int h, bool clear )
    : QPixmap( w, h, 1 )
{
    data->bitmap = TRUE;
    if ( clear )
	fill( color0 );
}

/*!
  Overloaded constructor; takes a QSize parameter instead of \e (w,h).
*/

QBitmap::QBitmap( const QSize &size, bool clear )
    : QPixmap( size, 1 )
{
    data->bitmap = TRUE;
    if ( clear )
	fill( color0 );
}

/*!
  Constructs a bitmap with \e w width and \e h height and sets the contents
  to \e bits.

  The \e isXbitmap should be TRUE if \e bits was generated by the
  X-Windows bitmap program.  The X bitmap bit order is little endian.
  The QImage documentation discusses bit order of monochrome images.

  This example creates an arrow bitmap:
  \code
    char arrow_bits[] = { 0x3f, 0x1f, 0x0f, 0x1f, 0x3b, 0x71, 0xe0, 0xc0 };
    QBitmap bm( 8, 8, arrow_bits, TRUE );
  \endcode
*/

QBitmap::QBitmap( int w, int h, const char *bits, bool isXbitmap )
    : QPixmap( w, h, bits, isXbitmap )
{
    data->bitmap = TRUE;
}

/*!
  Overloaded constructor; takes a QSize parameter instead of \e (w,h).
*/

QBitmap::QBitmap( const QSize &size, const char *bits, bool isXbitmap )
    : QPixmap( size.width(), size.height(), bits, isXbitmap )
{
    data->bitmap = TRUE;
}

/*!
  Constructs a bitmap which is a copy of \e bitmap.
*/

QBitmap::QBitmap( const QBitmap &bitmap )
    : QPixmap( bitmap )
{
}


/*!
  Assigns the bitmap \e bitmap to this bitmap and returns a reference to this
  bitmap.
*/

QBitmap &QBitmap::operator=( const QBitmap &bitmap )
{
    QPixmap::operator=(bitmap);
    return *this;
}



/*!
  Assigns the pixmap \e pixmap to this bitmap and returns a reference to this
  bitmap.

  Dithering will be performed if the pixmap has a depth > 1.
*/

QBitmap &QBitmap::operator=( const QPixmap &pixmap )
{
    if ( pixmap.depth() == 1 ) {		// 1-bit pixmap
	if ( pixmap.isQBitmap() ) {		// another QBitmap
	    QPixmap::operator=(pixmap);		// shallow assignment
	}
        else {					// not a QBitmap, but 1-bit
	    QBitmap bm( pixmap.size() );
	    bitBlt( &bm, 0,0, &pixmap, 0,0,-1,-1 );
	    bm.data->optim = data->optim;
	    QPixmap::operator=(bm);
	}
    }
    else {					// n-bit depth pixmap
	QImage image;
	image = pixmap;				// convert pixmap to image
	*this = image;				// will dither image
    }
    return *this;
}

/*!
  Converts the image \e image to a bitmap that is assigned to this bitmap.
  Returns a reference to the bitmap.

  Dithering will be performed if the image has a depth > 1.
*/

QBitmap &QBitmap::operator=( const QImage &image )
{
    convertFromImage( image );
    return *this;
}
