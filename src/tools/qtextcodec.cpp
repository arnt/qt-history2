/****************************************************************************
** $Id: //depot/qt/main/src/tools/qtextcodec.cpp#15 $
**
** Implementation of QTextCodec class
**
** Created : 981015
**
** Copyright (C) 1998 Troll Tech AS.  All rights reserved.
**
** This file is part of Troll Tech's internal development tree for Qt.
**
** This header text will be replaced by an appropriate text by the
** mkdist script which generates external distributions.
**
** If you are using the Qt Professional Edition or the Qt Free Edition,
** please notify Troll Tech at <info@troll.no> if you see this text.
**
** To Troll Tech developers: This header was generated by the script
** fixcopyright-int. It has the same number of text lines as the free
** and professional editions to avoid line number inconsistency.
**
*****************************************************************************/

#include "qlist.h"
#include "qtextcodec.h"
#include "qfile.h"
#include "qstrlist.h"
#include <stdlib.h>
#include <ctype.h>

static QList<QTextCodec> all;


class QTextStatelessEncoder : public QTextEncoder {
    const QTextCodec* codec;
public:
    QTextStatelessEncoder(const QTextCodec*);
    char* fromUnicode(const QString& uc, int& len_in_out);
};

class QTextStatelessDecoder : public QTextDecoder {
    const QTextCodec* codec;
public:
    QTextStatelessDecoder(const QTextCodec*);
    QString toUnicode(const char* chars, int len);
};

QTextStatelessEncoder::QTextStatelessEncoder(const QTextCodec* c) :
    codec(c)
{
}

char* QTextStatelessEncoder::fromUnicode(const QString& uc, int& len_in_out)
{
    return codec->fromUnicode(uc,len_in_out);
}

QTextStatelessDecoder::QTextStatelessDecoder(const QTextCodec* c) :
    codec(c)
{
}

QString QTextStatelessDecoder::toUnicode(const char* chars, int len)
{
    return codec->toUnicode(chars,len);
}



/*!
  \class QTextCodec qtextcodec.h
  \brief Provides conversion between text encodings.

  By making objects of subclasses of QTextCodec, support for
  new text encodings can be added to Qt.

  The abstract virtual functions describe the encoder to the
  system and the coder is used as required in the different
  text formats supported QTextStream and, under X11 for the
  locale-specific character input and output (under Windows NT
  codecs are not needed for user I/O since the system works
  with Unicode already).

  More recently created QTextCodec objects take precedence
  over earlier ones.
*/

/*!
  Constructs a QTextCodec, making it of highest precedence.
  The QTextCodec should always be constructed on the heap
  (with new), and once constructed it becomes the responsibility
  of Qt to delete it (which is done at QApplication destruction).
*/
QTextCodec::QTextCodec()
{
    all.insert(0,this);
}

/*!
  Destructs the QTextCodec.  Note that you should not delete
  codecs yourself - once created they become the responsibility
  of Qt to delete.
*/
QTextCodec::~QTextCodec()
{
    all.remove(this);
}

/*!
  Returns a value indicating how likely this decoder is
  for decoding some format that has the given name.

  A good match returns a positive number around the length of
  the string.  A bad match is negative.

  The default implementation calls simpleHeuristicNameMatch()
  with the name of the codec.
*/
int QTextCodec::heuristicNameMatch(const char* hint) const
{
    return simpleHeuristicNameMatch(name(),hint);
}

/*!
  A simple utility function for heuristicNameMatch() - it
  does some very minor character-skipping
  so that almost-exact matches score high.
*/
int QTextCodec::simpleHeuristicNameMatch(const char* name, const char* hint)
{
    // ######## Too complicated.

    int bestr = -10;
    while ( name[1] && !isalnum(*name) )
	name++;
    while ( hint[1] && !isalnum(*hint) )
	hint++;
    while ( *hint ) {
	int r = -10;
	int toggle = 0;
	const char* approx = hint;
	const char* actual = name;
	while ( *approx && *actual ) {
	    // Skip punctuation
	    while ( approx[1] && !isalnum(*approx) )
		approx++;
	    while ( actual[1] && !isalnum(*actual) )
		actual++;

	    if ( tolower(*approx) == tolower(*actual) ) {
		approx++;
		actual++;
		r+=3;
	    } else if ( tolower(approx[1]) == tolower(*actual) ) {
		approx++;
		r+=1;
	    } else if ( tolower(*approx) == tolower(actual[1]) ) {
		actual++;
		r+=1;
	    } else {
		if ( toggle ) {
		    actual++;
		    r--;
		} else {
		    approx++;
		    r--;
		}
		toggle = !toggle;
	    }
	}
	if ( r > bestr )
	    bestr = r;
	hint++;
	while (*hint && toupper(*hint) != toupper(*name)) // find next plausible
	    hint++;
    }
    return bestr;
}

/*!
  Returns the QTextCodec \a i places from the more recently
  inserted, or NULL if there is no such QTextCodec.  Thus,
  codecForIndex(0) returns the most recently created QTextCodec.
*/
QTextCodec* QTextCodec::codecForIndex(int i)
{
    return (uint)i >= all.count() ? 0 : all.at(i);
}

/*!
  Returns the QTextCodec which matches the MIBenum \a mib.
*/
QTextCodec* QTextCodec::codecForMib(int mib)
{
    QListIterator<QTextCodec> i(all);
    QTextCodec* result;
    for ( ; (result=i); ++i ) {
	if ( result->mib()==mib )
	    break;
    }
    return result;
}

/*!
  Searches all installed QTextCodec objects, returning the one
  which best matches given name.  May return NULL.

  \sa heuristicNameMatch()
*/
QTextCodec* QTextCodec::codecForName(const char* hint)
{
    QListIterator<QTextCodec> i(all);
    QTextCodec* result = 0;
    int best=0;
    for ( QTextCodec* cursor; (cursor=i); ++i ) {
	int s = cursor->heuristicNameMatch(hint);
	if ( s > best ) {
	    best = s;
	    result = cursor;
	}
    }
    return result;
}

/*!
  Searches all installed QTextCodec objects, returning the one
  which most recognizes the given content.  May return NULL.

  \sa heuristicContentMatch()
*/
QTextCodec* QTextCodec::codecForContent(const char* chars, int len)
{
    QListIterator<QTextCodec> i(all);
    QTextCodec* result;
    int best=0;
    for ( QTextCodec* cursor; (cursor=i); ++i ) {
	int s = cursor->heuristicContentMatch(chars,len);
	if ( s > best ) {
	    best = s;
	    result = cursor;
	}
    }
    return result;
}

/*!
  \fn const char* QTextCodec::name() const
  Subclasses of QTextCodec must override this function.  It returns
  the name of the encoding supported by the subclass.

  Note that this name, with "text/" prepended is a potential
  encoding for \link QTextDrag text Drag and Drop.\endlink
*/

/*!
  \fn int QTextCodec::mib() const
  Subclasses of QTextCodec must override this function.  It returns
  the MIBenum (see IANA######) for this encoding.
*/

/*!
  \fn int QTextCodec::heuristicContentMatch(const char* chars, int len) const

  Subclasses of QTextCodec must override this function.  It examines
  the first \a len bytes of \a chars and returns a value indicating how
  likely it is that the string is a prefix of text encoded in the
  encoding of the subclass.  Any negative return value indicates that the text
  is detectably not in the encoding (eg. it contains undefined characters).
  A return value of 0 indicates that the text should be decoded with this
  codec rather than as ASCII, but there
  is no particular evidence.  The value should range up to \a len.  Thus,
  most decoders will return -1, 0, or -\a len.

  The characters are not null terminated.

  \sa codecForContent().
*/


/*!
  Creates a QTextToUnicode which stores enough state to decode chunks
  of char* data to create chunks of Unicode data.  The default implementation
  creates a stateless decoder, which is sufficient for only the simplest
  encodings where each byte corresponds to exactly one Unicode character.

  The caller is responsible for deleting the returned object.
*/
QTextDecoder* QTextCodec::makeDecoder() const
{
    return new QTextStatelessDecoder(this);
}

/*!
  Creates a QTextToUnicode which stores enough state to encode chunks
  of Unicode data as char* data.  The default implementation
  creates a stateless encoder, which is sufficient for only the simplest
  encodings where each Unicode character corresponds to exactly one char.

  The caller is responsible for deleting the returned object.
*/
QTextEncoder* QTextCodec::makeEncoder() const
{
    return new QTextStatelessEncoder(this);
}

/*!
  Subclasses of QTextCodec must override this function or
  makeDecoder().  It converts
  the first \a len characters of \a chars to Unicode.

  The default implementation makes an encoder with makeDecoder() and
  converts the input with that.  Note that the default makeDecoder()
  implementation makes a decoder that simply calls
  this function, hence subclasses \e must reimplement one function or
  the other to avoid infinite recursion.
*/
QString QTextCodec::toUnicode(const char* chars, int len) const
{
    QTextDecoder* i = makeDecoder();
    QString result = i->toUnicode(chars,len);
    delete i;
    return result;
}

/*!
  Subclasses of QTextCodec must override either this function or
  makeEncoder().  It converts
  the first \a len_in_out characters of \a uc from Unicode to
  the encoding of the subclass.  The value returns is the property
  of the caller, which is responsible for deleting it with "delete []".
  The length of the resulting character sequence is returned in \a len_in_out.

  The default implementation makes an encoder with makeEncoder() and
  converts the input with that.  Note that the default makeEncoder()
  implementation makes an encoder that simply calls
  this function, hence subclasses \e must reimplement one function or
  the other to avoid infinite recursion.
*/
char* QTextCodec::fromUnicode(const QString& uc, int& len_in_out) const
{
    QTextEncoder* i = makeEncoder();
    char* result = i->fromUnicode(uc, len_in_out);
    delete i;
    return result;
}

/*!
  \overload
*/
char* QTextCodec::fromUnicode(const QString& uc) const
{
    int l = uc.length();
    return fromUnicode(uc,l);
}

/*!
  \overload
*/
QString QTextCodec::toUnicode(const QByteArray& a, int len) const
{
    return toUnicode(a.data(),len);
}

/*!
  \overload
*/
QString QTextCodec::toUnicode(const QByteArray& a) const
{
    return toUnicode(a.data(),a.size());
}

/*!
  \overload
*/
QString QTextCodec::toUnicode(const char* chars) const
{
    return toUnicode(chars,strlen(chars));
}



/*!
  Destroys the encoder.
*/
QTextEncoder::~QTextEncoder()
{
}

/*!
  Destroys the decoder.
*/
QTextDecoder::~QTextDecoder()
{
}

#define CHAINED 0xffff

struct QMultiByteUnicodeTable {
    // If multibyte, ignore unicode and index into multibyte
    //  with the next character.
    QMultiByteUnicodeTable() : unicode(0xfffd), multibyte(0) { }

    ~QMultiByteUnicodeTable()
    {
	if ( multibyte )
	    delete [] multibyte;
    }

    ushort unicode;
    QMultiByteUnicodeTable* multibyte;
};

static int getByte(char* &cursor)
{
    int byte = 0;
    if ( *cursor ) {
	if ( cursor[1] == 'x' )
	    byte = strtol(cursor+2,&cursor,16);
	else if ( cursor[1] == 'd' )
	    byte = strtol(cursor+2,&cursor,10);
	else
	    byte = strtol(cursor+2,&cursor,8);
    }
    return byte&0xff;
}

class QTextCodecFromIOD;

class QTextCodecFromIODDecoder : public QTextDecoder {
    const QTextCodecFromIOD* codec;
    QMultiByteUnicodeTable* mb;
public:
    QTextCodecFromIODDecoder(const QTextCodecFromIOD* c);
    QString toUnicode(const char* chars, int len);
};

class QTextCodecFromIOD : public QTextCodec {
    friend QTextCodecFromIODDecoder;

    Q1String n;

    // If from_unicode_page[row][cell] is 0 and from_unicode_page_multibyte,
    //  use from_unicode_page_multibyte[row][cell] as string.
    char** from_unicode_page;
    char*** from_unicode_page_multibyte;
    char unkn;

    // Only one of these is used
    ushort* to_unicode;
    QMultiByteUnicodeTable* to_unicode_multibyte;
    int max_bytes_per_char;
    QStrList aliases;

    bool stateless() const { return !to_unicode_multibyte; }

public:
    QTextCodecFromIOD(QIODevice* iod)
    {
	from_unicode_page = 0;
	to_unicode_multibyte = 0;
	to_unicode = 0;
	from_unicode_page_multibyte = 0;
	max_bytes_per_char = 1;

	const int maxlen=100;
	char line[maxlen];
	char esc='\\';
	bool incmap = FALSE;
	while (iod->readLine(line,maxlen) > 0) {
	    if (0==strnicmp(line,"<code_set_name>",15))
		n = line+15;
	    else if (0==strnicmp(line,"<escape_char>",13))
		esc = line[14];
	    else if (0==strnicmp(line,"% alias ",8)) {
		aliases.append(line+8);
	    } else if (0==strnicmp(line,"CHARMAP",7)) {
		if (!from_unicode_page) {
		    from_unicode_page = new char*[256];
		    for (int i=0; i<256; i++)
			from_unicode_page[i]=0;
		}
		if (!to_unicode) {
		    to_unicode = new ushort[256];
		}
		incmap = TRUE;
	    } else if (0==strnicmp(line,"END CHARMAP",11))
		break;
	    else if (incmap) {
		char* cursor = line;
		int byte,unicode=-1;
		ushort* mb_unicode=0;
		const int maxmb=8; // more -> we'll need to improve datastructures
		char mb[maxmb+1];
		int nmb=0;

		while (*cursor && *cursor!=' ')
		    cursor++;
		while (*cursor && *cursor!=esc)
		    cursor++;
		byte = getByte(cursor);

		if ( *cursor == esc ) {
		    if ( !to_unicode_multibyte ) {
			to_unicode_multibyte = new QMultiByteUnicodeTable[256];
			for (int i=0; i<256; i++) {
			    to_unicode_multibyte[i].unicode = to_unicode[i];
			    to_unicode_multibyte[i].multibyte = 0;
			}
			delete [] to_unicode;
			to_unicode = 0;
		    }
		    QMultiByteUnicodeTable* mbut = to_unicode_multibyte+byte;
		    mb[nmb++] = byte;
		    while ( nmb < maxmb && *cursor == esc ) {
			// Always at least once

			mbut->unicode = CHAINED;
			byte = getByte(cursor);
			mb[nmb++] = byte;
			if (!mbut->multibyte) {
			    mbut->multibyte =
				new QMultiByteUnicodeTable[256];
			}
			mbut = mbut->multibyte+byte;
			mb_unicode = & mbut->unicode;
		    }

		    if ( nmb > max_bytes_per_char )
			max_bytes_per_char = nmb;
		}
		while (*cursor && (*cursor!='<' || cursor[1]!='U'))
		    cursor++;
		if ( *cursor )
		    unicode = strtol(cursor+2,&cursor,16);
		if (unicode >= 0 && unicode <= 0xffff)
		{
		    QChar ch((ushort)unicode);
		    if (!from_unicode_page[ch.row]) {
			from_unicode_page[ch.row] = new char[256];
			for (int i=0; i<256; i++)
			    from_unicode_page[ch.row][i]=0;
		    }
		    if ( mb_unicode ) {
			from_unicode_page[ch.row][ch.cell] = 0;
			if (!from_unicode_page_multibyte) {
			    from_unicode_page_multibyte = new char**[256];
			    for (int i=0; i<256; i++)
				from_unicode_page_multibyte[i]=0;
			}
			if (!from_unicode_page_multibyte[ch.row]) {
			    from_unicode_page_multibyte[ch.row] = new char*[256];
			    for (int i=0; i<256; i++)
				from_unicode_page_multibyte[ch.row][i] = 0;
			}
			mb[nmb++] = 0;
			from_unicode_page_multibyte[ch.row][ch.cell]
			    = qstrdup(mb);
			*mb_unicode = unicode;
		    } else {
			from_unicode_page[ch.row][ch.cell] = (char)byte;
			if ( to_unicode )
			    to_unicode[byte] = unicode;
			else
			    to_unicode_multibyte[byte].unicode = unicode;
		    }
		} else {
		}
	    }
	}
	n = n.stripWhiteSpace();

	unkn = '?'; // ##### Might be a bad choice.
    }

    ~QTextCodecFromIOD()
    {
	if ( from_unicode_page ) {
	    for (int i=0; i<256; i++)
		if (from_unicode_page[i])
		    delete [] from_unicode_page[i];
	}
	if ( from_unicode_page_multibyte ) {
	    for (int i=0; i<256; i++)
		if (from_unicode_page_multibyte[i])
		    for (int j=0; j<256; i++)
			if (from_unicode_page_multibyte[i][j])
			    delete [] from_unicode_page_multibyte[i][j];
	}
	if ( to_unicode )
	    delete [] to_unicode;
	if ( to_unicode_multibyte )
	    delete [] to_unicode_multibyte;
    }

    bool ok() const
    {
	return !!from_unicode_page;
    }

    QTextDecoder* makeDecoder() const
    {
	if ( stateless() )
	    return QTextCodec::makeDecoder();
	else
	    return new QTextCodecFromIODDecoder(this);
    }

    const char* name() const
    {
	return n;
    }

    int mib() const
    {
	return 0; // #### Unknown.
    }

    int heuristicContentMatch(const char*, int) const
    {
	return 0;
    }

    int heuristicNameMatch(const char* hint) const
    {
	int bestr = QTextCodec::heuristicNameMatch(hint);
	QStrListIterator it(aliases);
	char* a;
	while ((a=it.current())) {
	    ++it;
	    int r = simpleHeuristicNameMatch(a,hint);
	    if (r > bestr)
		bestr = r;
	}
	return bestr;
    }

    QString toUnicode(const char* chars, int len) const
    {
	const uchar* uchars = (const uchar*)chars;
	QString result;
	QMultiByteUnicodeTable* multibyte=to_unicode_multibyte;
	if ( multibyte ) {
	    while (len--) {
		QMultiByteUnicodeTable& mb = multibyte[*uchars];
		if ( mb.multibyte ) {
		    // Chained multi-byte
		    multibyte = mb.multibyte;
		} else {
		    result += QChar(mb.unicode);
		    multibyte=to_unicode_multibyte;
		}
		uchars++;
	    }
	} else {
	    while (len--)
		result += QChar(to_unicode[*uchars++]);
	}
	return result;
    }

    char* fromUnicode(const QString& uc, int& len_in_out) const
    {
	if (len_in_out > (int)uc.length())
	    len_in_out = uc.length();
	char* result = new char[len_in_out*max_bytes_per_char];
	char* cursor = result;
	char* s;
	int l = len_in_out;
	int lout = 0;
	for (int i=0; i<l; i++) {
	    QChar ch = uc[i];
	    if ( from_unicode_page[ch.row] &&
		from_unicode_page[ch.row][ch.cell] )
	    {
		*cursor++ = from_unicode_page[ch.row][ch.cell];
		lout++;
	    } else if ( from_unicode_page_multibyte &&
		      from_unicode_page_multibyte[ch.row] &&
		      (s=from_unicode_page_multibyte[ch.row][ch.cell]) )
	    {
		while (*s) {
		    *cursor++ = *s++;
		    lout++;
		}
	    } else {
		*cursor++ = unkn;
		lout++;
	    }
	}
	len_in_out = lout;
	return result;
    }
};

QTextCodecFromIODDecoder::QTextCodecFromIODDecoder(const QTextCodecFromIOD* c) :
    codec(c)
{
    mb = codec->to_unicode_multibyte;
}

QString QTextCodecFromIODDecoder::toUnicode(const char* chars, int len)
{
    const uchar* uchars = (const uchar*)chars;
    QString result;
    while (len--) {
	QMultiByteUnicodeTable& t = mb[*uchars];
	if ( t.multibyte ) {
	    // Chained multi-byte
	    mb = t.multibyte;
	} else {
	    result += QChar(t.unicode);
	    mb=codec->to_unicode_multibyte;
	}
	uchars++;
    }
    return result;
}

/*!
  Reads a POSIX2 charmap definition from \a iod.
  The parser recognises the following lines:
\code
   &lt;code_set_name&gt; <i>name</i>
   &lt;escape_char&gt; <i>character</i>
   % alias <i>alias</i>
   CHARMAP
   &lt;<i>token</i>&gt; /x<i>hexbyte</i> &lt;U<i>unicode</i>&gt; ...
   &lt;<i>token</i>&gt; /d<i>decbyte</i> &lt;U<i>unicode</i>&gt; ...
   &lt;<i>token</i>&gt; /<i>octbyte</i> &lt;U<i>unicode</i>&gt; ...
   &lt;<i>token</i>&gt; /<i>any</i>/<i>any</i>... &lt;U<i>unicode</i>&gt; ...
   END CHARMAP
\endcode
  The resulting QTextCodec is returned (and also added to the
  global list of codecs).  The name() of the result is taken
  from the code_set_name.

  Note that a codec constructed in this way uses more memory
  and is slower than a hand-written QTextCodec subclass.

  \sa loadCharmapFile()
*/
QTextCodec* QTextCodec::loadCharmap(QIODevice* iod)
{
    QTextCodecFromIOD* r = new QTextCodecFromIOD(iod);
    if ( !r->ok() ) {
	delete r;
	r = 0;
    }
    return r;
}

/*!
  A convenience function for QTextCodec::loadCharmap().
*/
QTextCodec* QTextCodec::loadCharmapFile(QString filename)
{
    QFile f(filename);
    if (f.open(IO_ReadOnly)) {
	QTextCodecFromIOD* r = new QTextCodecFromIOD(&f);
	if ( !r->ok() )
	    delete r;
    }
    return 0;
}



/*!
  Returns a string representing the current language. 
*/

const char* QTextCodec::locale()
{
    static Q1String lang;
    if ( lang.isEmpty() ) {
	lang = getenv( "LANG" ); //########Windows??
	if ( lang.isEmpty() )
	    lang = "C";
    }
    return lang;
}
