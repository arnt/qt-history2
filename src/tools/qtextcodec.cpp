/****************************************************************************
** $Id: //depot/qt/main/src/tools/qtextcodec.cpp#2 $
**
** Implementation of QTextCodec class
**
** Created : 981015
**
** Copyright (C) 1998 Troll Tech AS.  All rights reserved.
**
** This file is part of Troll Tech's internal development tree for Qt.
**
** This header text will be replaced by an appropriate text by the
** mkdist script which generates external distributions.
**
** If you are using the Qt Professional Edition or the Qt Free Edition,
** please notify Troll Tech at <info@troll.no> if you see this text.
**
** To Troll Tech developers: This header was generated by the script
** fixcopyright-int. It has the same number of text lines as the free
** and professional editions to avoid line number inconsistency.
**
*****************************************************************************/

#include "qlist.h"
#include "qtextcodec.h"
#include <stdlib.h>
#include <ctype.h>

static QList<QTextCodec> all;

/*!
  \class QTextCodec
  \brief Provides conversion between text encodings.

  By making objects of subclasses of QTextCodec, support for
  new text encodings can be added to Qt.

  The abstract virtual functions describe the encoder to the
  system and the coder is used as required in the different
  text formats supported QTextStream and, under X11 for the
  locale-specific character input and output (under Windows NT
  codecs are not needed for user I/O since the system works
  with Unicode already).

  More recently created QTextCodec objects take precedence
  over earlier ones.
*/

/*!
  Constructs a QTextCodec, making it of highest precedence.
  The QTextCodec should always be constructed on the heap
  (with new), and once constructed it becomes the responsibility
  of Qt to delete it (which is done at QApplication destruction).
*/
QTextCodec::QTextCodec()
{
    all.insert(0,this);
}

/*!
  Destructs the QTextCodec.  Note that you should not delete
  codecs yourself - once created they become the responsibility
  of Qt to delete.
*/
QTextCodec::~QTextCodec()
{
    all.remove(this);
}

/*!
  Returns a value indicating how likely this decoder is
  for decoding some format that has the given name.  The
  default implementation does some very minor character-skipping
  so that almost-extact matches score high.

  A good match returns a positive number around the length of
  the string.  A bad match is negative.
*/
int QTextCodec::heuristicNameMatch(const char* hint) const
{
    int r = -10;
    int toggle = 0;
    while ( *hint ) {
	const char* approx = hint++;
	const char* actual = name();
	while ( *approx && *actual ) {
	    // Skip punctuation
	    while ( approx[1] && !isalnum(*approx) )
		approx++;
	    while ( actual[1] && !isalnum(*actual) )
		actual++;

	    if ( tolower(*approx) == tolower(*actual) ) {
		approx++;
		actual++;
		r+=3;
	    } else if ( tolower(approx[1]) == tolower(*actual) ) {
		approx++;
		r+=1;
	    } else if ( tolower(*approx) == tolower(actual[1]) ) {
		actual++;
		r+=1;
	    } else {
		if ( toggle ) {
		    actual++;
		    r--;
		} else {
		    approx++;
		    r--;
		}
		toggle = !toggle;
	    }
	}
    }
    return r;
}

/*!
  Returns the QTextCodec \a i places from the more recently
  inserted, or NULL if there is no such QTextCodec.  Thus,
  codecForIndex(0) returns the most recently created QTextCodec.
*/
QTextCodec* QTextCodec::codecForIndex(int i)
{
    return all.at(i);
}

/*!
  Returns the QTextCodec which matches the MIBenum \a mib.
*/
QTextCodec* QTextCodec::codecForMib(int mib)
{
    QListIterator<QTextCodec> i(all);
    QTextCodec* result;
    for ( ; (result=i); ++i ) {
	if ( result->mib()==mib )
	    break;
    }
    return result;
}

/*!
  Searches all installed QTextCodec objects, returning the one
  which best matches given name.  May return NULL.

  \sa heuristicNameMatch()
*/
QTextCodec* QTextCodec::codecForName(const char* hint)
{
    QListIterator<QTextCodec> i(all);
    QTextCodec* result = 0;
    int best=0;
    for ( QTextCodec* cursor; (cursor=i); ++i ) {
	int s = cursor->heuristicNameMatch(hint);
	if ( s > best ) {
	    best = s;
	    result = cursor;
	}
    }
    return result;
}

/*!
  Searches all installed QTextCodec objects, returning the one
  which most recognizes the given content.  May return NULL.

  \sa heuristicContentMatch()
*/
QTextCodec* QTextCodec::codecForContent(const char* chars, int len)
{
    QListIterator<QTextCodec> i(all);
    QTextCodec* result;
    int best=0;
    for ( QTextCodec* cursor; (cursor=i); ++i ) {
	int s = cursor->heuristicContentMatch(chars,len);
	if ( s > best ) {
	    best = s;
	    result = cursor;
	}
    }
    return result;
}

/*!
  \fn const char* QTextCodec::name() const
  Subclasses of QTextCodec must override this function.  It returns
  the name of the encoding supported by the subclass.
*/

/*!
  \fn int QTextCodec::mib() const
  Subclasses of QTextCodec must override this function.  It returns
  the MIBenum (see IANA######) for this encoding.
*/

/*!
  \fn QString QTextCodec::toUnicode(const char* chars, int len) const
  Subclasses of QTextCodec must override this function.  It converts
  the first \a len characters of \a chars to Unicode.
*/

/*!
  \fn char* QTextCodec::fromUnicode(const QString& uc, int& len_in_out) const
  Subclasses of QTextCodec must override this function.  It converts
  the first \a len_in_out characters of \a uc from Unicode to
  the encoding of the subclass.  The value returns is the property
  of the caller, which is responsible for deleting it with "delete []".
  The length of the resulting character sequence is returned in \a len_in_out.
*/

/*!
  \fn int QTextCodec::heuristicContentMatch(const char* chars, int len) const

  Subclasses of QTextCodec must override this function.  It examines
  the first \a len bytes of \a chars and returns a value indicating how
  likely it is that the string is a prefix of text encoded in the
  encoding of the subclass.  Any negative return value indicates that the text
  is detectably not in the encoding (eg. it contains undefined characters).
  A return value of 0 indicates that the text should be decoded with this
  mapper rather than as ASCII, but there
  is no particular evidence.  The value should range up to \a len.  Thus,
  most decoders will return -1, 0, or -\a len.

  The characters are not null terminated.

  \sa codecForContent().
*/

