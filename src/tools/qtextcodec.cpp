/****************************************************************************
** $Id: //depot/qt/main/src/tools/qtextcodec.cpp#3 $
**
** Implementation of QTextCodec class
**
** Created : 981015
**
** Copyright (C) 1998 Troll Tech AS.  All rights reserved.
**
** This file is part of Troll Tech's internal development tree for Qt.
**
** This header text will be replaced by an appropriate text by the
** mkdist script which generates external distributions.
**
** If you are using the Qt Professional Edition or the Qt Free Edition,
** please notify Troll Tech at <info@troll.no> if you see this text.
**
** To Troll Tech developers: This header was generated by the script
** fixcopyright-int. It has the same number of text lines as the free
** and professional editions to avoid line number inconsistency.
**
*****************************************************************************/

#include "qlist.h"
#include "qtextcodec.h"
#include <stdlib.h>
#include <ctype.h>

static QList<QTextCodec> all;


class QTextStatelessEncoder : public QTextEncoder {
    const QTextCodec* codec;
public:
    QTextStatelessEncoder(const QTextCodec*);
    char* fromUnicode(const QString& uc, int& len_in_out);
};

class QTextStatelessDecoder : public QTextDecoder {
    const QTextCodec* codec;
public:
    QTextStatelessDecoder(const QTextCodec*);
    QString toUnicode(const char* chars, int len);
};

QTextStatelessEncoder::QTextStatelessEncoder(const QTextCodec* c) :
    codec(c)
{
}

char* QTextStatelessEncoder::fromUnicode(const QString& uc, int& len_in_out)
{
    return codec->fromUnicode(uc,len_in_out);
}

QTextStatelessDecoder::QTextStatelessDecoder(const QTextCodec* c) :
    codec(c)
{
}

QString QTextStatelessDecoder::toUnicode(const char* chars, int len)
{
    return codec->toUnicode(chars,len);
}



/*!
  \class QTextCodec
  \brief Provides conversion between text encodings.

  By making objects of subclasses of QTextCodec, support for
  new text encodings can be added to Qt.

  The abstract virtual functions describe the encoder to the
  system and the coder is used as required in the different
  text formats supported QTextStream and, under X11 for the
  locale-specific character input and output (under Windows NT
  codecs are not needed for user I/O since the system works
  with Unicode already).

  More recently created QTextCodec objects take precedence
  over earlier ones.
*/

/*!
  Constructs a QTextCodec, making it of highest precedence.
  The QTextCodec should always be constructed on the heap
  (with new), and once constructed it becomes the responsibility
  of Qt to delete it (which is done at QApplication destruction).
*/
QTextCodec::QTextCodec()
{
    all.insert(0,this);
}

/*!
  Destructs the QTextCodec.  Note that you should not delete
  codecs yourself - once created they become the responsibility
  of Qt to delete.
*/
QTextCodec::~QTextCodec()
{
    all.remove(this);
}

/*!
  Returns a value indicating how likely this decoder is
  for decoding some format that has the given name.

  A good match returns a positive number around the length of
  the string.  A bad match is negative.

  The default implementation calls simpleHeuristicNameMatch()
  with the name of the codec.
*/
int QTextCodec::heuristicNameMatch(const char* hint) const
{
    return simpleHeuristicNameMatch(name(),hint);
}

/*!
  A simple utility function for heuristicNameMatch() - it
  does some very minor character-skipping
  so that almost-exact matches score high.
*/
int QTextCodec::simpleHeuristicNameMatch(const char* name, const char* hint)
{
    int r = -10;
    int toggle = 0;
    while ( *hint ) {
	const char* approx = hint++;
	const char* actual = name;
	while ( *approx && *actual ) {
	    // Skip punctuation
	    while ( approx[1] && !isalnum(*approx) )
		approx++;
	    while ( actual[1] && !isalnum(*actual) )
		actual++;

	    if ( tolower(*approx) == tolower(*actual) ) {
		approx++;
		actual++;
		r+=3;
	    } else if ( tolower(approx[1]) == tolower(*actual) ) {
		approx++;
		r+=1;
	    } else if ( tolower(*approx) == tolower(actual[1]) ) {
		actual++;
		r+=1;
	    } else {
		if ( toggle ) {
		    actual++;
		    r--;
		} else {
		    approx++;
		    r--;
		}
		toggle = !toggle;
	    }
	}
    }
    return r;
}

/*!
  Returns the QTextCodec \a i places from the more recently
  inserted, or NULL if there is no such QTextCodec.  Thus,
  codecForIndex(0) returns the most recently created QTextCodec.
*/
QTextCodec* QTextCodec::codecForIndex(int i)
{
    return all.at(i);
}

/*!
  Returns the QTextCodec which matches the MIBenum \a mib.
*/
QTextCodec* QTextCodec::codecForMib(int mib)
{
    QListIterator<QTextCodec> i(all);
    QTextCodec* result;
    for ( ; (result=i); ++i ) {
	if ( result->mib()==mib )
	    break;
    }
    return result;
}

/*!
  Searches all installed QTextCodec objects, returning the one
  which best matches given name.  May return NULL.

  \sa heuristicNameMatch()
*/
QTextCodec* QTextCodec::codecForName(const char* hint)
{
    QListIterator<QTextCodec> i(all);
    QTextCodec* result = 0;
    int best=0;
    for ( QTextCodec* cursor; (cursor=i); ++i ) {
	int s = cursor->heuristicNameMatch(hint);
	if ( s > best ) {
	    best = s;
	    result = cursor;
	}
    }
    return result;
}

/*!
  Searches all installed QTextCodec objects, returning the one
  which most recognizes the given content.  May return NULL.

  \sa heuristicContentMatch()
*/
QTextCodec* QTextCodec::codecForContent(const char* chars, int len)
{
    QListIterator<QTextCodec> i(all);
    QTextCodec* result;
    int best=0;
    for ( QTextCodec* cursor; (cursor=i); ++i ) {
	int s = cursor->heuristicContentMatch(chars,len);
	if ( s > best ) {
	    best = s;
	    result = cursor;
	}
    }
    return result;
}

/*!
  \fn const char* QTextCodec::name() const
  Subclasses of QTextCodec must override this function.  It returns
  the name of the encoding supported by the subclass.
*/

/*!
  \fn int QTextCodec::mib() const
  Subclasses of QTextCodec must override this function.  It returns
  the MIBenum (see IANA######) for this encoding.
*/

/*!
  \fn int QTextCodec::heuristicContentMatch(const char* chars, int len) const

  Subclasses of QTextCodec must override this function.  It examines
  the first \a len bytes of \a chars and returns a value indicating how
  likely it is that the string is a prefix of text encoded in the
  encoding of the subclass.  Any negative return value indicates that the text
  is detectably not in the encoding (eg. it contains undefined characters).
  A return value of 0 indicates that the text should be decoded with this
  codec rather than as ASCII, but there
  is no particular evidence.  The value should range up to \a len.  Thus,
  most decoders will return -1, 0, or -\a len.

  The characters are not null terminated.

  \sa codecForContent().
*/


/*!
  Creates a QTextToUnicode which stores enough state to decode chunks
  of char* data to create chunks of Unicode data.  The default implementation
  creates a stateless decoder, which is sufficient for only the simplest
  encodings where each byte corresponds to exactly one Unicode character.

  The caller is responsible for deleting the returned object.
*/
QTextDecoder* QTextCodec::makeDecoder() const
{
    return new QTextStatelessDecoder(this);
}

/*!
  Creates a QTextToUnicode which stores enough state to encode chunks
  of Unicode data as char* data.  The default implementation
  creates a stateless encoder, which is sufficient for only the simplest
  encodings where each Unicode character corresponds to exactly one char.

  The caller is responsible for deleting the returned object.
*/
QTextEncoder* QTextCodec::makeEncoder() const
{
    return new QTextStatelessEncoder(this);
}

/*!
  Subclasses of QTextCodec must override this function or
  makeDecoder().  It converts
  the first \a len characters of \a chars to Unicode.

  The default implementation makes an encoder with makeDecoder() and
  converts the input with that.  Note that the default makeDecoder()
  implementation makes a decoder that simply calls
  this function, hence subclasses \e must reimplement one function or
  the other to avoid infinite recursion.
*/
QString QTextCodec::toUnicode(const char* chars, int len) const
{
    QTextDecoder* i = makeDecoder();
    QString result = i->toUnicode(chars,len);
    delete i;
    return result;
}

/*!
  Subclasses of QTextCodec must override either this function or
  makeEncoder().  It converts
  the first \a len_in_out characters of \a uc from Unicode to
  the encoding of the subclass.  The value returns is the property
  of the caller, which is responsible for deleting it with "delete []".
  The length of the resulting character sequence is returned in \a len_in_out.

  The default implementation makes an encoder with makeEncoder() and
  converts the input with that.  Note that the default makeEncoder()
  implementation makes an encoder that simply calls
  this function, hence subclasses \e must reimplement one function or
  the other to avoid infinite recursion.
*/
char* QTextCodec::fromUnicode(const QString& uc, int& len_in_out) const
{
    QTextEncoder* i = makeEncoder();
    char* result = i->fromUnicode(uc, len_in_out);
    delete i;
    return result;
}


/*!
  Destroys the encoder.
*/
QTextEncoder::~QTextEncoder()
{
}

/*!
  Destroys the decoder.
*/
QTextDecoder::~QTextDecoder()
{
}




