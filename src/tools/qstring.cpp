/****************************************************************************
** $Id: //depot/qt/main/src/tools/qstring.cpp#132 $
**
** Implementation of extended char array operations, and QByteArray and
** Q1String classes
**
** Created : 920722
**
** Copyright (C) 1992-1998 Troll Tech AS.  All rights reserved.
**
** This file is part of Troll Tech's internal development tree for Qt.
**
** This header text will be replaced by an appropriate text by the
** mkdist script which generates external distributions.
**
** If you are using the Qt Professional Edition or the Qt Free Edition,
** please notify Troll Tech at <info@troll.no> if you see this text.
**
** To Troll Tech developers: This header was generated by the script
** fixcopyright-int. It has the same number of text lines as the free
** and professional editions to avoid line number inconsistency.
**
*****************************************************************************/

#define	 QSTRING_C
#include "qstring.h"
#include "qdatastream.h"
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <ctype.h>

/*****************************************************************************
  Safe and portable C string functions; extensions to standard string.h
 *****************************************************************************/

/*!
  \fn void *memmove( void *dst, const void *src, uint len )
  \relates Q1String

  This function is normally part of the C library. Qt implements
  memmove() for platforms that do not have it.

  memmove() copies \e len bytes from \e src into \e dst.  The data is
  copied correctly even if \e src and \e dst overlap.
*/

void *qmemmove( void *dst, const void *src, uint len )
{
    register char *d;
    register char *s;
    if ( dst > src ) {
	d = (char *)dst + len - 1;
	s = (char *)src + len - 1;
	while ( len-- )
	    *d-- = *s--;
    } else if ( dst < src ) {
	d = (char *)dst;
	s = (char *)src;
	while ( len-- )
	    *d++ = *s++;
    }
    return dst;
}

/*!
  \relates Q1String

  Returns a duplicate string.

  Allocates space for a copy of \e str (using \c new), copies it, and returns
  a pointer to the copy.
  If \e src is null, it immediately returns 0.
*/

char *qstrdup( const char *str )
{
    if ( !str )
	return 0;
    char *dst = new char[strlen(str)+1];
    CHECK_PTR( dst );
    return cstrcpy( dst, str );
}

/*!
  \fn uint strlen( const char *str )
  \relates Q1String

  A safe strlen() function that overrides the one defined by the C library.
  The original strlen() function has been renamed cstrlen().

  Returns the number of characters in \e str, or 0 if \e str is null.
*/

/*!
  \fn char *strcpy( char *dst, const char *str )
  \relates Q1String

  A safe strcpy() function that overrides the one defined by the C library.
  The original strcpy() function has been renamed cstrcpy().

  Copies all characters (including \0) from \e str into \e dst and returns
  a pointer to \e dst.
  If \e src is null, it immediately returns 0.

  \sa qstrncpy()
*/

/*!
  \relates Q1String

  A safe strncpy() function.

  Copies all characters up to \e len bytes from \e str into \e dst and returns
  a pointer to \e dst.	Guarantees that \e dst is \0-terminated.
  If \e src is null, it immediately returns 0.

  \sa strcpy()
*/

char *qstrncpy( char *dst, const char *src, uint len )
{
    if ( !src )
	return 0;
    strncpy( dst, src, len );
    if ( len > 0 )
	dst[len-1] = '\0';
    return dst;
}

/*!
  \fn int strcmp( const char *str1, const char *str2 )
  \relates Q1String

  A safe strcmp() function that overrides the one defined by the C library.
  The original strcmp() function has been renamed cstrcmp().

  Compares \e str1 and \e str2.	 Returns a negative value if \e str1
  is less than \e str2, 0 if \e str1 is equal to \e str2 or a positive
  value if \e str1 is greater than \e str2.

  Special case I: Returns 0 if \e str1 and \e str2 are both null.

  Special case II: Returns a random nonzero value if \e str1 is null
  or \e str2 is null (but not both).

  \sa strncmp(), stricmp(), strnicmp()
*/

/*!
  \fn int strncmp( const char *str1, const char *str2, uint len )
  \relates Q1String

  A safe strncmp() function that overrides the one defined by the C library.
  The original strncmp() function has been renamed cstrncmp().

  Compares \e str1 and \e str2 up to \e len bytes.

  Returns a negative value if \e str1 is less than \e str2, 0 if \e str1
  is equal to \e str2 or a positive value if \e str1 is greater than \e
  str2.

  Special case I: Returns 0 if \e str1 and \e str2 are both null.

  Special case II: Returns a random nonzero value if \e str1 is null
  or \e str2 is null (but not both).

  \sa strcmp(), stricmp(), strnicmp()
*/

/*!
  \fn int stricmp( const char *str1, const char *str2 )
  \relates Q1String

  A safe stricmp() function that overrides the one defined by the C library,
  if the C library has one.

  Compares \e str1 and \e str2 ignoring the case.

  Returns a negative value if \e str1 is less than \e str2, 0 if \e str1
  is equal to \e str2 or a positive value if \e str1 is greater than \e
  str2.

  Special case I: Returns 0 if \e str1 and \e str2 are both null.

  Special case II: Returns a random nonzero value if \e str1 is null
  or \e str2 is null (but not both).

  \sa strcmp(), strncmp(), strnicmp()
*/

int qstricmp( const char *str1, const char *str2 )
{
    register const uchar *s1 = (const uchar *)str1;
    register const uchar *s2 = (const uchar *)str2;
    int res;
    uchar c;
    if ( !s1 || !s2 )
	return s1 == s1 ? 0 : (int)((long)s2 - (long)s1);
    for ( ; !(res = (c=tolower(*s1)) - tolower(*s2)); s1++, s2++ )
	if ( !c )				// strings are equal
	    break;
    return res;
}

/*!
  \fn int strnicmp( const char *str1, const char *str2, uint len )
  \relates Q1String

  A safe strnicmp() function that overrides the one defined by the C library,
  if the C library has one.

  Compares \e str1 and \e str2 up to \e len bytes ignoring the case.

  Returns a negative value if \e str1 is less than \e str2, 0 if \e str1
  is equal to \e str2 or a positive value if \e str1 is greater than \e
  str2.

  Special case I: Returns 0 if \e str1 and \e str2 are both null.

  Special case II: Returns a random nonzero value if \e str1 is null
  or \e str2 is null (but not both).

  \sa strcmp(), strncmp() stricmp()
*/

int qstrnicmp( const char *str1, const char *str2, uint len )
{
    register const uchar *s1 = (const uchar *)str1;
    register const uchar *s2 = (const uchar *)str2;
    int res;
    uchar c;
    if ( !s1 || !s2 )
	return (int)((long)s2 - (long)s1);
    for ( ; len--; s1++, s2++ ) {
	if ( (res = (c=tolower(*s1)) - tolower(*s2)) )
	    return res;
	if ( !c )				// strings are equal
	    break;
    }
    return 0;
}


static Q_UINT16 crc_tbl[16];
static bool   crc_tbl_init = FALSE;

static void createCRC16Table()			// build CRC16 lookup table
{
    register uint i;
    register uint j;
    uint v0, v1, v2, v3;
    for ( i=0; i<16; i++ ) {
	v0 = i & 1;
	v1 = (i >> 1) & 1;
	v2 = (i >> 2) & 1;
	v3 = (i >> 3) & 1;
	j = 0;
#undef	SET_BIT
#define SET_BIT(x,b,v)	x |= v << b
	SET_BIT(j, 0,v0);
	SET_BIT(j, 7,v0);
	SET_BIT(j,12,v0);
	SET_BIT(j, 1,v1);
	SET_BIT(j, 8,v1);
	SET_BIT(j,13,v1);
	SET_BIT(j, 2,v2);
	SET_BIT(j, 9,v2);
	SET_BIT(j,14,v2);
	SET_BIT(j, 3,v3);
	SET_BIT(j,10,v3);
	SET_BIT(j,15,v3);
	crc_tbl[i] = j;
    }
}

/*!
  \relates QByteArray
  Returns the CRC-16 checksum of \e len bytes starting at \e data.

  The checksum is independent of the byte order (endianness).
*/

Q_UINT16 qChecksum( const char *data, uint len )
{
    if ( !crc_tbl_init ) {			// create lookup table
	createCRC16Table();
	crc_tbl_init = TRUE;
    }
    register Q_UINT16 crc = 0xffff;
    uchar c;
    uchar *p = (uchar *)data;
    while ( len-- ) {
	c = *p++;
	crc = ((crc >> 4) & 0x0fff) ^ crc_tbl[((crc ^ c) & 15)];
	c >>= 4;
	crc = ((crc >> 4) & 0x0fff) ^ crc_tbl[((crc ^ c) & 15)];
    }
    return (~crc & 0xffff);
}

/*!
  \relates QByteArray

  Please use qChecksum; this function is provided only for
  upward compatibility.
*/

UINT16 qchecksum( const char *data, uint len )
{
    if ( !crc_tbl_init ) {			// create lookup table
	createCRC16Table();
	crc_tbl_init = TRUE;
    }
    register Q_UINT16 crc = 0xffff;
    uchar c;
    uchar *p = (uchar *)data;
    while ( len-- ) {
	c = *p++;
	crc = ((crc >> 4) & 0x0fff) ^ crc_tbl[((crc ^ c) & 15)];
	c >>= 4;
	crc = ((crc >> 4) & 0x0fff) ^ crc_tbl[((crc ^ c) & 15)];
    }
    return (~crc & 0xffff);
}


/*****************************************************************************
  QByteArray member functions
 *****************************************************************************/

/*!
  \class QByteArray qstring.h
  \brief The QByteArray class provides an array of bytes.

  \inherit QArray
  \ingroup tools
  \ingroup shared

  QByteArray is defined as QArray\<char\>.
*/


/*****************************************************************************
  QByteArray stream functions
 *****************************************************************************/

/*!
  \relates QByteArray
  Writes a byte array to a stream and returns a reference to the stream.

  The serialization format is the byte array size (\c Q_UINT32) followed by
  this number of bytes.
*/

QDataStream &operator<<( QDataStream &s, const QByteArray &a )
{
    return s.writeBytes( a.data(), a.size() );
}

/*!
  \relates QByteArray
  Reads a byte array from a stream and returns a reference to the stream.
*/

QDataStream &operator>>( QDataStream &s, QByteArray &a )
{
    Q_UINT32 len;
    s >> len;					// read size of array
    if ( len == 0 || s.eof() ) {		// end of file reached
	a.resize( 0 );
	return s;
    }
    if ( !a.resize( (uint)len ) ) {		// resize array
#if defined(CHECK_NULL)
	warning( "QDataStream: Not enough memory to read QByteArray" );
#endif
	len = 0;
    }
    if ( len > 0 )				// not null array
	s.readRawBytes( a.data(), (uint)len );
    return s;
}

// ##### Unicode fns need to ifdef UNICODE (if we go that way)
QChar uctolower(QChar c)
{
    return c.row ? c : QChar(tolower(c.cell));
}
QChar uctoupper(QChar c)
{
    return c.row ? c : QChar(toupper(c.cell));
}
bool ucisspace(QChar c)
{
    return c.row ? FALSE : isspace(c.cell);
}
bool ucisdigit(QChar c)
{
    return c.row ? FALSE : isdigit(c.cell);
}
int ucstrcmp( const QString &as, const QString &bs )
{
    if ( as.d == bs.d )
	return 0;
    const QChar *a = as.unicode();
    const QChar *b = bs.unicode();
    int l=QMIN(as.length(),bs.length());
    while ( l-- && *a == *b )
	a++,b++;
    if ( l==-1 )
	return ( as.length()-bs.length() );
    return a->row == b->row ? a->cell - b->cell : a->row - b->row;
}
int ucstrncmp( const QChar *a, const QChar *b, int l )
{
    while ( l-- && *a == *b )
	a++,b++;
    if ( l==-1 )
	return 0;
    return *a - *b;
}
int ucstrnicmp( const QChar *a, const QChar *b, int l )
{
    while ( l-- && uctolower(*a) == uctolower(*b) )
	a++,b++;
    if ( l==-1 )
	return 0;
    QChar al = uctolower(*a);
    QChar bl = uctolower(*b);
    return al.row == bl.row ? al.cell - bl.cell : al.row - bl.row;
}

/*!
  This utility function converts the 8-bit string
  \a ba to Unicode, returning the result.

  The caller is responsible for deleting the return value with delete[].
*/
QChar* QString::asciiToUnicode( const QByteArray& ba, uint& len )
{
    int l = 0;
    while ( l < (int)ba.size() && ba[l] )
	l++;
    char* str = ba.data();
    QChar *uc = new QChar[l];
    QChar *result = uc;
    len = l;
    while (l--)
	*uc++ = *str++;
    return result;
}

/*!
  This utility function converts the NUL-terminated 8-bit string
  \a str to Unicode, returning the result and setting \a l to
  the length of the Unicode string.

  The caller is responsible for deleting the return value with delete[].
*/
QChar* QString::asciiToUnicode(const char *str, uint& l)
{
    if (!str) {
	l = 0;
	return 0;
    }
    l = strlen(str);
    QChar *uc = new QChar[l];
    QChar *result = uc;
    while (*str)
	*uc++ = *str++;
    return result;
}

/*!
  This utility function converts \a l 16-bit characters from
  \a uc to ASCII, returning a NUL-terminated string.

  The caller is responsible for deleting the string with delete[].
*/
char* QString::unicodeToAscii(const QChar *uc, uint l)
{
    if (!uc) {
	return 0;
    }
    char *a = new char[l+1];
    char *result = a;
    while (l--)
	*a++ = *uc++;
    *a++ = '\0';
    return result;
}

/*****************************************************************************
  QString member functions
 *****************************************************************************/

/*!
  \class QString qstring.h

  \brief The QString class provides an abstraction of Unicode text and
          the classic C zero-terminated char array (<var>char*</var>).

  \ingroup tools
  \ingroup shared

  QString uses implicit
  \link shclass.html sharing\endlink, and so it is very efficient
  and easy to use.

  Note that for the QString methods that take a <var>const char *</var>
  parameter the results are undefined if the QString is not
  zero-terminated.  It is legal for the <var>const char *</var> parameter
  to be 0.

  A QString that has not been assigned to anything is \e null, i.e. both
  the length and data pointer is 0. A QString that references the empty
  string ("", a single '\0' char) is \e empty.	Both null and empty
  QStrings are legal parameters to the methods. Assigning <var>const char
  * 0</var> to QString gives a null QString.

  \sa \link shclass.html Shared classes\endlink
*/

QString::Data *QString::shared_null = 0;
const QString QString::null;
const QChar QChar::null;

#define Q2HELPER(x) x
#ifdef Q2HELPER
static int stat_construct_charstar=0;
static int stat_construct_charstar_size=0;
static int stat_construct_null=0;
static int stat_construct_int=0;
static int stat_construct_int_size=0;
static int stat_construct_ba=0;
static int stat_get_ascii=0;
static int stat_get_ascii_size=0;
static int stat_copy_on_write=0;
static int stat_copy_on_write_size=0;
static int stat_fast_copy=0;
void qt_qstring_stats()
{
	debug("construct_charstar = %d (%d chars)", stat_construct_charstar, stat_construct_charstar_size);
	debug("construct_null = %d", stat_construct_null);
	debug("construct_int = %d (%d chars)", stat_construct_int, stat_construct_int_size);
	debug("construct_ba = %d", stat_construct_ba);
	debug("get_ascii = %d (%d chars)", stat_get_ascii, stat_get_ascii_size);
	debug("copy_on_write = %d (%d chars)", stat_copy_on_write, stat_copy_on_write_size);
	debug("fast_copy = %d", stat_fast_copy);
}
#endif

/*!
  Constructs a null string.
  \sa isNull()
*/
QString::QString() :
    d(shared_null ? shared_null : shared_null=new Data)
{
    Q2HELPER(stat_construct_null++);
    d->ref();
}

/*!
  Constructs a string containing the one character \a ch.
*/
QString::QString( const QChar& ch ) :
    d(shared_null ? shared_null : shared_null=new Data)
{
    d = new Data(new QChar[1],0,1);
    d->unicode[0] = ch;
}

/*!
  Constructs an implicitly-shared copy of \e s.
*/
QString::QString( const QString &s ) :
    d(s.d)
{
    Q2HELPER(stat_fast_copy++);
    d->ref();
}

/*!
  Constructs a string with room for \e size characters, including the
  '\0'-terminator.  Makes a null string if \e size == 0.

  If \e size \> 0, then the first and last characters in the string are
  initialized to '\0'.	All other characters are uninitialized.

  \sa resize(), isNull()
*/

QString::QString( int size )
{
    if ( size ) {
	Q2HELPER(stat_construct_int++);
	int l = size-1;
	Q2HELPER(stat_construct_int_size+=l);
	d = new Data(new QChar[l],0,l);
    } else {
	Q2HELPER(stat_construct_null++);
	d = shared_null ? shared_null : shared_null=new Data;
	d->ref();
    }
}

/*!
  Constructs a string that is a deep copy of \e ba
  interpretted as ASCII.
*/

QString::QString( const QByteArray& ba )
{
    Q2HELPER(stat_construct_ba++);
    uint l;
    QChar *uc = asciiToUnicode(ba,l);
    d = new Data(uc,l,l);
}

/*!
  Constructs a string that is a deep copy of \e str,
  interpretted as ASCII.

  If \a str is 0 a null string is created.

  \sa isNull()
*/

QString::QString( const char *str )
{
    Q2HELPER(stat_construct_charstar++);
    uint l;
    QChar *uc = asciiToUnicode(str,l);
    Q2HELPER(stat_construct_charstar_size+=l);
    d = new Data(uc,l,l);
}


/*!
  Constructs a string that is a deep copy of \e str, that is at most
  \a maxlen characters long.

  Example:
  \code
    QString str("helloworld",6); // Assigns "hellow" to str.
  \endcode

  If \a str contains a 0 byte within the first \a maxlen bytes, the
  resulting QString will be terminated by the 0.  If \a str is 0 a
  null string is created.

  \sa isNull()
*/

QString::QString( const char *str, uint maxlen )
{
    Q2HELPER(stat_construct_charstar++);
    uint l;
    QChar *uc = asciiToUnicode(str,l);
    d = new Data(uc,l,l);
    if ( l >= maxlen )
	truncate( maxlen );
}

/*!
  Deallocates any space reserved solely by this QString.
*/
QString::~QString()
{
    deref();
}

void QString::real_detach()
{
    if ( d->count != 1 ) {
	Q2HELPER(stat_copy_on_write++);
	Q2HELPER(stat_copy_on_write_size+=d->len);
	int newlen = d->len;
	QChar * nd;
	if ( newlen ) {
	    nd = new QChar[newlen];
	    memcpy( nd, d->unicode, sizeof(QChar)*newlen );
	} else {
	    nd = 0;
	}
	deref();
	d = new Data(nd,newlen,newlen);
    } else {
	d->dirtyascii = 1;
    }
}

void QString::deref()
{
    if ( d->deref() ) {
	delete d;
	d = 0; // helps debugging
    }
}

/*!
  Assigns a copy of \e s to this string and returns a reference to
  this string.
*/
QString &QString::operator=( const QString &s )
{
    Q2HELPER(stat_fast_copy++);
    s.d->ref();
    deref();
    d = s.d;
    return *this;
}

/*!
  Assigns a deep copy of \a ba, interpretted as ASCII
  to this string and returns a reference to this string.
*/
QString &QString::operator=( const QByteArray& ba )
{
    deref();
    uint l;
    QChar *uc = asciiToUnicode(ba,l);
    d = new Data(uc,l,l);
    return *this;
}

/*!
  Assigns a deep copy of \a str, interpretted as ASCII
  to this string and returns a reference to this string.

  If \a str is 0 a null string is created.

  \sa isNull()
*/
QString &QString::operator=( const char *str )
{
    deref();
    uint l;
    QChar *uc = asciiToUnicode(str,l);
    d = new Data(uc,l,l);
    return *this;
}

/*!
  \fn bool QString::isNull() const

  Returns TRUE if the string is null.
  A null string is also an empty string.

  Example:
  \code
    QString a;		// a.unicode() == 0,  a.length() == 0
    QString b == "";	// b.unicode() == "", b.length() == 0
    a.isNull();		// TRUE, because a.unicode() == 0
    a.isEmpty();	// TRUE, because a.length() == 0
    b.isNull();		// FALSE, because b.unicode() != 0
    b.isEmpty();	// TRUE, because b.length() == 0
  \endcode

  \sa isEmpty(), length(), size()
*/

/*!
  \fn bool QString::isEmpty() const

  Returns TRUE if the string is empty, i.e. if length() == 0.
  An empty string is not always a null string.

  See example in isNull().

  \sa isNull(), length(), size()
*/

/*!
  \fn uint QString::length() const

  Returns the length of the string.

  Null strings and empty strings have zero length.

  \sa size(), isNull(), isEmpty()
*/

/*!
  Truncates the string at position \e pos.

  Example:
  \code
    QString s = "truncate this string";
    s.truncate( 5 );				// s == "trunc"
  \endcode

  \sa resize()
*/
void QString::truncate( uint newlen )
{
    if ( newlen != d->len || d->maxl != newlen ) {
	QChar * nd;
	if ( newlen ) {
	    nd = new QChar[newlen];
	    memcpy( nd, d->unicode, sizeof(QChar)*QMIN(newlen,d->len) );
	} else {
	    nd = 0;
	}
	deref();
	d = new Data(nd,newlen,newlen);
    }
}

/*!
  Equivalent to truncate(newlenp1-1).  This is for backward compatibility.
  If newlenp1 is 0, truncate(0).
*/
void QString::resize( uint newlenp1 )
{
    truncate(newlenp1 ? newlenp1-1 : 0);
}

/*!
  Ensures that at least \a len characters are allocated, and
  sets the length to \a len.  New space is \e not defined and
  it only detach if necessary.
*/
void QString::setLength( uint len )
{
    if ( d->len != len ) {
	real_detach();
	if ( len > d->maxl ) {
	    uint newmax = QMAX(d->maxl,4);
	    while ( newmax < len )
		newmax *= 2;
	    truncate( newmax );
	}
	d->len = len;
    }
}

/*!
  Implemented as a call to the native vsprintf() (see your C-library
  manual).

  If your string is shorter than 256 characters, this sprintf() calls
  resize(256) to decrease the chance of memory corruption.  The string is
  resized back to its natural length before sprintf() returns.

  Example:
  \code
    QString s;
    s.sprintf( "%d - %s", 1, "first" );		// result < 256 chars

    QString big( 25000 );			// very long string
    big.sprintf( "%d - %s", 2, longString );	// result < 25000 chars
  \endcode

  \warning All vsprintf() implementations will write past the end of
  the target string (*this) if the format specification and arguments
  happen to be longer than the target string, and some will also fail
  if the target string is longer than some arbitrary implementation
  limit.

  Giving user-supplied arguments to sprintf() is begging for trouble.
  Sooner or later someone \e will paste a 3000-character line into
  your application.
*/

QString &QString::sprintf( const char *format, ... )
{
    va_list ap;
    va_start( ap, format );
    uint alen = QMAX(256,length());
    char* ascii = new char[alen];
    vsprintf( ascii, format, ap );
    *this = ascii;
    delete [] ascii;
    va_end( ap );
    return *this;
}


/*!
  Fills the string with \e len characters of value \e c.

  If \e len is negative, then the current string length is used.
*/

void QString::fill( QChar c, int len )
{
    if ( len < 0 )
	len = length();
    deref();
    QChar * nd = new QChar[len];
    d = new Data(nd,len,len);
    while (len--) *nd++ = c;
}


/*!
  \fn QString QString::copy() const
  \obsolete
  Returns a deep copy of this string.
*/

/*!
  Finds the first occurrence of the character \e c, starting at
  position \e index.

  The search is case sensitive if \e cs is TRUE, or case insensitive if \e
  cs is FALSE.

  Returns the position of \e c, or -1 if \e c could not be found.
*/

int QString::find( QChar c, int index, bool cs ) const
{
    if ( (uint)index >= length() )		// index outside string
	return -1;
    register const QChar *uc;
    uc = unicode()+index;
    int n = length()-index;
    if ( cs ) {
	while ( n-- && *uc != c )
	    uc++;
    } else {
	c = uctolower( c );
	while ( n-- && uctolower(*uc) != c )
	    uc++;
    }
    if ( n==-1 )
	return -1;
    return (int)(uc - unicode());
}

/*!
  Finds the first occurrence of the string \e str, starting at position
  \e index.

  The search is case sensitive if \e cs is TRUE, or case insensitive if \e
  cs is FALSE.

  Returns the position of \e str, or -1 if \e str could not be found.
*/

int QString::find( const QString& str, int index, bool cs ) const
{
    if ( (uint)index >= length() )		// index outside string
	return -1;
    register const QChar *uc;
    uc = unicode()+index;
    uint n = length()-index;
    uint strl = str.length();
    if ( cs ) {
	while ( n-- >= strl && ucstrncmp(uc,str.d->unicode,strl) )
	    uc++;
    } else {
	while ( n-- >= strl && ucstrnicmp(uc,str.d->unicode,strl) )
	    uc++;
    }
    return n>=strl ? (int)(uc - unicode()) : -1;
}

/*!
  \fn int QString::findRev( const char* str, int index ) const

  Equivalent to findRev(QString(str), index).
*/

/*!
  \fn int QString::find( const char* str, int index ) const

  Equivalent to find(QString(str), index).
*/

/*!
  Finds the first occurrence of the character \e c, starting at
  position \e index and searching backwards.

  The search is case sensitive if \e cs is TRUE, or case insensitive if \e
  cs is FALSE.

  Returns the position of \e c, or -1 if \e c could not be found.
*/

int QString::findRev( QChar c, int index, bool cs ) const
{
    QString t(2);
    t[0] = c;
    return findRev( t, index, cs );
}

/*!
  Finds the first occurrence of the string \e str, starting at
  position \e index and searching backwards.

  The search is case sensitive if \e cs is TRUE, or case insensitive if \e
  cs is FALSE.

  Returns the position of \e str, or -1 if \e str could not be found.
*/

int QString::findRev( const QString& str, int index, bool cs ) const
{
    uint slen = str.length();
    if ( !slen )
	return index;
    if ( index < 0 )				// neg index ==> start from end
	index = length()-slen;
    else if ( (uint)index > length() )		// bad index
	return -1;
    else if ( (uint)index == length() )		// bad index, but accept it
	index--;
    else if ( (uint)(index + slen) > length() ) // str would be too long
	index = length() - slen;
    if ( index < 0 )
	return -1;

    register const QChar *uc = unicode() + index;
    if ( cs ) {					// case sensitive
	for ( int i=index; i>=0; i-- )
	    if ( ucstrncmp(uc--,str.unicode(),slen)==0 )
		return i;
    } else {					// case insensitive
	for ( int i=index; i>=0; i-- )
	    if ( ucstrnicmp(uc--,str.unicode(),slen)==0 )
		return i;
    }
    return -1;
}


/*!
  Returns the number of times the character \e c occurs in the string.

  The match is case sensitive if \e cs is TRUE, or case insensitive if \e cs
  if FALSE.
*/

int QString::contains( QChar c, bool cs ) const
{
    int count = 0;
    const QChar *uc = unicode();
    if ( !uc )
	return 0;
    int n = length();
    if ( cs ) {					// case sensitive
	while ( n-- )
	    if ( *uc++ == c )
		count++;
    } else {					// case insensitive
	c = uctolower( c );
	while ( n-- ) {
	    if ( uctolower(*uc) == c )
		count++;
	    uc++;
	}
    }
    return count;
}

/*!
  \overload
*/
int QString::contains( const char* str, bool cs ) const
{
    return contains(QString(str),cs);
}

/*!
  \fn int QString::contains (char c, bool cs=TRUE) const
  \overload
*/

/*!
  \fn int QString::find (char c, int index=0, bool cs=TRUE) const
  \overload
*/

/*!
  \fn int QString::findRev (char c, int index=-1, bool cs=TRUE) const
  \overload
*/

/*!
  Returns the number of times \e str occurs in the string.

  The match is case sensitive if \e cs is TRUE, or case insensitive if \e
  cs if FALSE.

  This function counts overlapping substrings, for example, "banana"
  contains two occurrences of "ana".

  \sa findRev()
*/

int QString::contains( const QString &str, bool cs ) const
{
    int count = 0;
    const QChar *uc = unicode();
    if ( !uc )
	return 0;
    int len = str.length();
    int n = length();
    while ( n-- ) {				// counts overlapping strings
	// ### Doesn't account for length of this - searches over "end"
	if ( cs ) {
	    if ( ucstrncmp( uc, str.unicode(), len ) == 0 )
		count++;
	} else {
	    if ( ucstrnicmp(uc, str.unicode(), len) == 0 )
		count++;
	}
	uc++;
    }
    return count;
}

/*!
  Returns a substring that contains the \e len leftmost characters
  of the string.

  The whole string is returned if \e len exceeds the length of the string.

  Example:
  \code
    QString s = "Pineapple";
    QString t = s.left( 4 );			// t == "Pine"
  \endcode

  \sa right(), mid()
*/

QString QString::left( uint len ) const
{
    if ( isNull() )
	return QString();
    if ( isEmpty() || len <= 0 ) {
	QString empty="";
	return empty;
    } else if ( len > length() ) {
	return *this;
    } else {
	QString s( len+1 );
	memcpy( s.d->unicode, d->unicode, len*sizeof(QChar) );
	s.d->len = len;
	return s;
    }
}

/*!
  Returns a substring that contains the \e len rightmost characters
  of the string.

  The whole string is returned if \e len exceeds the length of the string.

  Example:
  \code
    QString s = "Pineapple";
    QString t = s.right( 5 );			// t == "apple"
  \endcode

  \sa left(), mid()
*/

QString QString::right( uint len ) const
{
    if ( isEmpty() || len <= 0 ) {
	QString empty;
	return empty;
    } else {
	uint l = length();
	if ( len > l )
	    len = l;
	QString s( len+1 );
	memcpy( s.d->unicode, d->unicode+(l-len), len*sizeof(QChar) );
	s.d->len = len;
	return s;
    }
}

/*!
  Returns a substring that contains the \e len characters of this
  string, starting at position \e index.

  Returns a null string if the string is empty or \e index is out
  of range.  Returns the whole string from \e index if \e index+len exceeds
  the length of the string.

  Example:
  \code
    QString s = "Two pineapples";
    QString t = s.mid( 4, 4 );			// t == "pine"
  \endcode

  \sa left(), right()
*/

QString QString::mid( uint index, uint len ) const
{
    uint slen = length();
    if ( isEmpty() || index >= slen || len == 0 ) {
	QString empty;
	return empty;
    } else {
	if ( len > slen-index )
	    len = slen - index;
	register const QChar *p = unicode()+index;
	QString s( len+1 );
	memcpy( s.d->unicode, p, len*sizeof(QChar) );
	s.d->len = len;
	return s;
    }
}

/*!
  Returns a string of length \e width that contains this
  string and padded by the \e fill character.

  If the length of the string exceeds \e width and \e truncate is FALSE,
  then the returned string is a copy of the string.
  If the length of the string exceeds \e width and \e truncate is TRUE,
  then the returned string is a left(\e width).

  Example:
  \code
    QString s("apple");
    QString t = s.leftJustify(8, '.');		// t == "apple..."
  \endcode

  \sa rightJustify()
*/

QString QString::leftJustify( uint width, QChar fill, bool truncate ) const
{
    QString result;
    int len = length();
    int padlen = width - len;
    if ( padlen > 0 ) {
	result.setLength(len+padlen);
	if ( len )
	    memcpy( result.d->unicode, unicode(), sizeof(QChar)*len );
	QChar* uc = result.d->unicode + len;
	while (padlen--)
	    *uc++ = fill;
    } else {
	if ( truncate )
	    result = left( width );
	else
	    result = *this;
    }
    return result;
}

/*!
  Returns a string of length \e width that contains pad
  characters followed by the string.

  If the length of the string exceeds \e width and \e truncate is FALSE,
  then the returned string is a copy of the string.
  If the length of the string exceeds \e width and \e truncate is TRUE,
  then the returned string is a right(\e width).

  Example:
  \code
    QString s("pie");
    QString t = s.rightJustify(8, '.');		// t == ".....pie"
  \endcode

  \sa leftJustify()
*/

QString QString::rightJustify( uint width, QChar fill, bool truncate ) const
{
    QString result;
    int len = length();
    int padlen = width - len;
    if ( padlen > 0 ) {
	result.setLength( len+padlen );
	QChar* uc = result.d->unicode;
	while (padlen--)
	    *uc++ = fill;
	if ( len )
	    memcpy( uc, unicode(), sizeof(QChar)*len );
    } else {
	if ( truncate )
	    result = left( width );
	else
	    result = *this;
    }
    return result;
}

/*!
  Returns a new string that is the string converted to lower case.

  Example:
  \code
    QString s("TeX");
    QString t = s.lower();			// t == "tex"
  \endcode

  \sa upper()
*/

QString QString::lower() const
{
    QString s(*this);
    int l=length();
    s.real_detach(); // could do this only when we find a change
    register QChar *p=s.d->unicode;
    if ( p ) {
	while ( l-- ) {
	    *p = uctolower(*p);
	    p++;
	}
    }
    return s;
}

/*!
  Returns a new string that is the string converted to upper case.

  Example:
  \code
    QString s("TeX");
    QString t = s.upper();			// t == "TEX"
  \endcode

  \sa lower()
*/

QString QString::upper() const
{
    QString s(*this);
    int l=length();
    s.real_detach(); // could do this only when we find a change
    register QChar *p=s.d->unicode;
    if ( p ) {
	while ( l-- ) {
	    *p = uctoupper(*p);
	    p++;
	}
    }
    return s;
}


/*!
  Returns a new string that has white space removed from the start and the end.

  White space means any ASCII code 9, 10, 11, 12, 13 or 32.

  Example:
  \code
    QString s = " space ";
    QString t = s.stripWhiteSpace();		// t == "space"
  \endcode

  \sa simplifyWhiteSpace()
*/

QString QString::stripWhiteSpace() const
{
    if ( isEmpty() )				// nothing to do
	return *this;
    if ( !ucisspace(at(0)) && !ucisspace(at(length()-1)) )
	return *this;

    register const QChar *s = unicode();
    QString result;

    int start = 0;
    int end = length() - 1;
    while ( ucisspace(s[start]) && start<=end )	// skip white space from start
	start++;
    if ( start > end ) {			// only white space
	return result;
    }
    while ( end && ucisspace(s[end]) )		// skip white space from end
	end--;
    int l = end - start + 1;
    result.setLength( l );
    if ( l )
	memcpy( result.d->unicode, &s[start], sizeof(QChar)*l );
    return result;
}


/*!
  Returns a new string that has white space removed from the start and the end,
  plus any sequence of internal white space replaced with a single space
  (ASCII 32).

  White space means any ASCII code 9, 10, 11, 12, 13 or 32.

  \code
    QString s = "  lots\t of\nwhite    space ";
    QString t = s.simplifyWhiteSpace();		// t == "lots of white space"
  \endcode

  \sa stripWhiteSpace()
*/

QString QString::simplifyWhiteSpace() const
{
    if ( isEmpty() )				// nothing to do
	return *this;
    QString result;
    result.setLength( length() );
    const QChar *from = unicode();
    const QChar *fromend = from+length();
    int outc=0;
    QChar *to	= result.d->unicode;
    while ( TRUE ) {
	while ( from!=fromend && ucisspace(*from) )
	    from++;
	while ( from!=fromend && !ucisspace(*from) )
	    to[outc++] = *from++;
	if ( from!=fromend )
	    to[outc++] = ' ';
	else
	    break;
    }
    if ( outc > 0 && to[outc-1] == ' ' )
	outc--;
    result.truncate( outc );
    return result;
}


/*!
  Insert \e s into the string before position \e index.

  If \e index is beyond the end of the string, the string is extended with
  spaces (ASCII 32) to length \e index and \e s is then appended.

  \code
    QString s = "I like fish";
    s.insert( 2, "don't ");			// s == "I don't like fish"
    s = "x";
    s.insert( 3, "yz" );			// s == "x  yz"
  \endcode
*/

QString &QString::insert( uint index, const QString &s )
{
    int len = s.length();
    if ( len == 0 )
	return *this;
    uint olen = length();
    int nlen = olen + len;
    real_detach();
    if ( index >= olen ) {			// insert after end of string
	setLength( nlen+index-olen );
	int n = index-olen;
	QChar* uc = d->unicode+olen;
	while (n--)
	    *uc++ = ' ';
	memcpy( d->unicode+index, s.unicode(), sizeof(QChar)*len );
    } else {					// normal insert
	setLength( nlen );
	memmove( d->unicode+index+len, unicode()+index, sizeof(QChar)*(olen-index+1) );
	memcpy( d->unicode+index, s.unicode(), sizeof(QChar)*len );
    }
    return *this;
}

/*!
  Insert \e c into the string at (before) position \e index and returns
  a reference to the string.

  If \e index is beyond the end of the string, the string is extended with
  spaces (ASCII 32) to length \e index and \e c is then appended.

  Example:
  \code
    QString s = "Yes";
    s.insert( 3, '!');				// s == "Yes!"
  \endcode

  \sa remove(), replace()
*/

QString &QString::insert( uint index, QChar c )	// insert char
{
    QString buf;
    buf.setLength(1);
    buf[0] = c;
    return insert( index, buf );
}

/*!
  \fn QString& QString::insert( uint index, char c )
  \overload
*/

/*!
  \fn QString &QString::prepend( const QString &s )

  Prepend \s to the string. Equivalent to insert(0,s).

  \sa insert()
*/

/*!
  Removes \e len characters starting at position \e index from the
  string and returns a reference to the string.

  If \e index is too big, nothing happens.  If \e index is valid, but
  \e len is too large, the rest of the string is removed.

  \code
    QString s = "Montreal";
    s.remove( 1, 4 );
    // s == "Meal"
  \endcode

  \sa insert(), replace()
*/

QString &QString::remove( uint index, uint len )
{
    uint olen = length();
    if ( index + len >= olen ) {		// range problems
	if ( index < olen ) {			// index ok
	    setLength(index);
	}
    } else if ( len != 0 ) {
	real_detach();
	memmove( d->unicode+index, unicode()+index+len,
	    sizeof(QChar)*(olen-index-len+1) );
	setLength( olen-len );
    }
    return *this;
}

/*!
  Replaces \e len characters starting at position \e index from the
  string with \e s, and returns a reference to the string.

  If \e index is too big, nothing is deleted and \e s is inserted at the
  end of the string.  If \e index is valid, but \e len is too large, \e
  str replaces the rest of the string.

  \code
    QString s = "Say yes!";
    s.replace( 4, 3, "NO" );			// s == "Say NO!"
  \endcode

  \sa insert(), remove()
*/

QString &QString::replace( uint index, uint len, const QString &s )
{
    remove( index, len );
    insert( index, s );
    return *this;
}


/*!
  Returns the string converted to a <code>long</code> value.

  If \e ok is non-null, \e *ok is set to TRUE if there are no
  conceivable errors, and FALSE if the string is not a number at all, or if
  it has trailing garbage.
*/

long QString::toLong( bool *ok ) const
{
    const QChar *p = unicode();
    long val=0;
    int l = length();
    const long max_mult = 214748364;
    bool is_ok = FALSE;
    int neg = 0;
    if ( !p )
	goto bye;
    while ( l && ucisspace(*p) )			// skip leading space
	l--,p++;
    if ( l && *p == '-' ) {
	l--;
	p++;
	neg = 1;
    } else if ( *p == '+' ) {
	l--;
	p++;
    }
    if ( !l || !ucisdigit(*p) )
	goto bye;
    while ( l && ucisdigit(*p) ) {
	l--;
	if ( val > max_mult || (val == max_mult && (*p-'0') > 7+neg) )
	    goto bye;
	val = 10*val + (*p++ - '0');
    }
    if ( neg )
	val = -val;
    while ( l && ucisspace(*p) )			// skip trailing space
	l--,p++;
    if ( !l )
	is_ok = TRUE;
bye:
    if ( ok )
	*ok = is_ok;
    return is_ok ? val : 0;
}

/*!
  Returns the string converted to an <code>unsigned long</code>
  value.

  If \e ok is non-null, \e *ok is set to TRUE if there are no
  conceivable errors, and FALSE if the string is not a number at all,
  or if it has trailing garbage.
*/

ulong QString::toULong( bool *ok ) const
{
    const QChar *p = unicode();
    ulong val=0;
    int l = length();
    const ulong max_mult = 429496729;
    bool is_ok = FALSE;
    if ( !p )
	goto bye;
    while ( l && ucisspace(*p) )			// skip leading space
	l--,p++;
    if ( *p == '+' )
	l--,p++;
    if ( !l || !ucisdigit(*p) )
	goto bye;
    while ( l && ucisdigit(*p) ) {
	l--;
	if ( val > max_mult || (val == max_mult && (*p-'0') > 5) )
	    goto bye;
	val = 10*val + (*p++ - '0');
    }
    while ( l && ucisspace(*p) )			// skip trailing space
	l--,p++;
    if ( !l )
	is_ok = TRUE;
bye:
    if ( ok )
	*ok = is_ok;
    return is_ok ? val : 0;
}

/*!
  Returns the string converted to a <code>short</code> value.

  If \e ok is non-null, \e *ok is set to TRUE if there are no
  conceivable errors, and FALSE if the string is not a number at all, or if
  it has trailing garbage.
*/

short QString::toShort( bool *ok ) const
{
    long v = toLong( ok );
    if ( ok && *ok && (v < -32768 || v > 32767) ) {
	*ok = FALSE;
	v = 0;
    }
    return (short)v;
}

/*!
  Returns the string converted to an <code>unsigned short</code> value.

  If \e ok is non-null, \e *ok is set to TRUE if there are no
  conceivable errors, and FALSE if the string is not a number at all, or if
  it has trailing garbage.
*/

ushort QString::toUShort( bool *ok ) const
{
    ulong v = toULong( ok );
    if ( ok && *ok && (v > 65535) ) {
	*ok = FALSE;
	v = 0;
    }
    return (QChar)v;
}


/*!
  Returns the string converted to a <code>int</code> value.

  If \e ok is non-null, \e *ok is set to TRUE if there are no
  conceivable errors, and FALSE if the string is not a number at all,
  or if it has trailing garbage.
*/

int QString::toInt( bool *ok ) const
{
    return (int)toLong( ok );
}

/*!
  Returns the string converted to an <code>unsigned int</code> value.

  If \e ok is non-null, \e *ok is set to TRUE if there are no
  conceivable errors, and FALSE if the string is not a number at all,
  or if it has trailing garbage.
*/

uint QString::toUInt( bool *ok ) const
{
    return (uint)toULong( ok );
}

/*!
  Returns the string converted to a <code>double</code> value.

  If \e ok is non-null, \e *ok is set to TRUE if there are no conceivable
  errors, and FALSE if the string is not a number at all, or if it has
  trailing garbage.
*/

double QString::toDouble( bool *ok ) const
{
    char *end;
    const char *a = ascii();
    double val = strtod( a ? a : "", &end );
    if ( ok )
	*ok = ( a && *a && ( end == 0 || *end == '\0' ) );
    return val;
}

/*!
  Returns the string converted to a <code>float</code> value.

  If \e ok is non-null, \e *ok is set to TRUE if there are no
  conceivable errors, and FALSE if the string is not a number at all,
  or if it has trailing garbage.
*/

float QString::toFloat( bool *ok ) const
{
    return (float)toDouble( ok );
}


/*!
  \obsolete because old implementation was very explicitly shared.
*/

QString &QString::setStr( const char *str )
{
    warning("QString::setStr is no longer support - using plain assignment");
    return *this = str;
}

/*!
  Sets the string to the printed value of \e n and returns a
  reference to the string.
*/

QString &QString::setNum( long n )
{
    char buf[20];
    register char *p = &buf[19];
    bool neg;
    if ( n < 0 ) {
	neg = TRUE;
	n = -n;
    } else {
	neg = FALSE;
    }
    *p = '\0';
    do {
	*--p = ((int)(n%10)) + '0';
	n /= 10;
    } while ( n );
    if ( neg )
	*--p = '-';
    return *this = p;
}

/*!
  Sets the string to the printed unsigned value of \e n and
  returns a reference to the string.
*/

QString &QString::setNum( ulong n )
{
    char buf[20];
    register char *p = &buf[19];
    *p = '\0';
    do {
	*--p = ((int)(n%10)) + '0';
	n /= 10;
    } while ( n );
    return *this = p;
}

/*!
  \fn QString &QString::setNum( int n )
  Sets the string to the printed value of \e n and returns a reference
  to the string.
*/

/*!
  \fn QString &QString::setNum( uint n )
  Sets the string to the printed unsigned value of \e n and returns a
  reference to the string.
*/

/*!
  \fn QString &QString::setNum( short n )
  Sets the string to the printed value of \e n and returns a reference
  to the string.
*/

/*!
  \fn QString &QString::setNum( ushort n )
  Sets the string to the printed unsigned value of \e n and returns a
  reference to the string.
*/

/*!
  Sets the string to the printed value of \e n.

  \arg \e f is the format specifier: 'f', 'F', 'e', 'E', 'g', 'G' (same
  as sprintf()).
  \arg \e prec is the precision.

  Returns a reference to the string.
*/

QString &QString::setNum( double n, char f, int prec )
{
#if defined(CHECK_RANGE)
    if ( !(f=='f' || f=='F' || f=='e' || f=='E' || f=='g' || f=='G') )
	warning( "QString::setNum: Invalid format char '%c'", f );
#endif
    char format[20];
    register char *fs = format;			// generate format string
    *fs++ = '%';				//   "%.<prec>l<f>"
    if ( prec > 99 )
	prec = 99;
    *fs++ = '.';
    if ( prec >= 10 ) {
	*fs++ = prec / 10 + '0';
	*fs++ = prec % 10 + '0';
    } else {
	*fs++ = prec + '0';
    }
    *fs++ = 'l';
    *fs++ = f;
    *fs = '\0';
    return sprintf( format, n );
}

/*!
  \fn QString &QString::setNum( float n, char f, int prec )
  Sets the string to the printed value of \e n.

  \arg \e f is the format specifier: 'f', 'F', 'e', 'E', 'g', 'G' (same
  as sprintf()).
  \arg \e prec is the precision.

  Returns a reference to the string.
*/


/*!
  \obsolete because at() now auto-expands anyway.

  Sets the character at position \e index to \e c and expands the
  string if necessary, filling with spaces.
*/
void QString::setExpand( uint index, QChar c )
{
    int spaces = index - d->len;
    at(index) = c;
    while (spaces-->0)
	d->unicode[--index]=' ';
}


/*!
  \fn void QString::detach()

  Obsolete.  This method is provided to aide porting to Qt 2.0.

  In Qt 1.x, QString was explicitly shared.  Now it
  is implicitly shared.  This function is a no-op.
*/

/*!
  \fn const char* QString::data() const

  Obsolete.  This method is provided to aide porting to Qt 2.0.

  In Qt 1.x, this returned a char* allowing direct manipulation of the
  string as a sequence of bytes.  Now that QString is a Unicode
  string, char* conversion constructs a temporary string, and hence
  direct character operations are meaningless.
*/

/*!
  \fn uint QString::size() const

  Obsolete.  This method is provided to aide porting to Qt 2.0.

  In Qt 1.x, QString was a QByteArray subclass, and so it had
  a size() method which was usually equivalent length()+1.
*/


/*!
  \fn bool QString::operator!() const
  Returns TRUE if it is a null string, otherwise FALSE.
*/


/*!
  \fn QString& QString::append( const QString& str )
  Appends \e str to the string and returns a reference to the result.
  Equivalent to operator+=().
 */

/*!
  Appends \e str to the string and returns a reference to the string.
*/
QString& QString::operator+=( const QString &str )
{
    uint len1 = length();
    uint len2 = str.length();
    if ( len2 ) {
	setLength(len1+len2);
	memcpy( d->unicode+len1, str.unicode(), sizeof(QChar)*len2 );
    }
    return *this;
}

/*!
  Appends \e c to the string and returns a reference to the string.
*/

QString &QString::operator+=( QChar c )
{
    setLength(length()+1);
    d->unicode[length()-1] = c;
    return *this;
}

/*!
  Appends \e c to the string and returns a reference to the string.
*/

QString &QString::operator+=( char c )
{
    setLength(length()+1);
    d->unicode[length()-1] = c;
    return *this;
}

/*!
  Result remains valid so long as one unmodified
  copy of the string exists, or the function is not called again.
*/
const char* QString::ascii() const
{
    if ( d->ascii ) {
	if ( d->dirtyascii )
	    delete [] d->ascii;
	else
	    return d->ascii;
    }
    Q2HELPER(stat_get_ascii++);
    Q2HELPER(stat_get_ascii_size+=d->len);
    d->ascii = unicodeToAscii( d->unicode, d->len );
    Q2HELPER(ASSERT( strlen(d->ascii) == d->len ));
    d->dirtyascii = 0;
    return d->ascii;
}

/*!
  \fn const QChar* QString::unicode() const

  Returns the Unicode representation of the string.  The result
  remains valid until the string is modified.
*/

/*!
  \fn QString::operator const char *() const

  Returns ascii().
*/

/*!
  \fn const QChar& QString::at( uint ) const

  Returns the character at \a i, or 0 if \a i is beyond the length
  of the string.
*/

/*!
  \fn const QChar& QString::operator[](int) const

  Returns the character at \a i, or 0 if \a i is beyond the length
  of the string.
*/

/*!
  \fn QChar& QString::operator[](int)

  Returns a reference to the character at \a i, expanding
  the string with character-0 if necessary.  The resulting reference
  can then be assigned to, or otherwise used immediately, but
  becomes invalid once further modifications are made to the string.
*/

/*!
  Returns a reference to the character at \a i, expanding
  the string with character-0 if necessary.  The resulting reference
  can then be assigned to, or otherwise used immediately, but
  becomes invalid once further modifications are made to the string.
*/
QChar& QString::at( uint i )
{
    real_detach();

    if ( d->len <= i ) {
	int ol = d->len;
	if ( i >= d->maxl ) {
	    uint newmax = QMAX(d->maxl,4);
	    while ( newmax <= i )
		newmax *= 2;
	    truncate( newmax );
	}
	for ( uint j=ol; j<=i; j++ )
	    d->unicode[j]=0;
	d->len = i+1;
    }

    return d->unicode[i];
}


/*****************************************************************************
  QString stream functions
 *****************************************************************************/

/*!
  \relates QString
  Writes a string to the stream.

  Output format: [length (Q_UINT32) data...]
*/

QDataStream &operator<<( QDataStream &s, const QString &str )
{
    return s.writeBytes( (const char*)str.unicode(),
			 sizeof(QChar)*str.length() );
}

/*!
  \relates QString
  Reads a string from the stream.
*/

QDataStream &operator>>( QDataStream &s, QString &str )
{
    str.real_detach();
    Q_UINT32 bytes;
    s >> bytes;					// read size of string
    str.setLength( bytes/2 );
    if ( bytes > 0 )				// not null array
	s.readRawBytes( (char*)str.d->unicode, bytes );
    return s;
}

/*!
  \fn int QString::compare (const QString & s1, const QString & s2)

  Compare \a s1 to \a s2 returning an integer less than, equal to, or
  greater than zero if s1 is, respectively, lexically less than, equal to,
  or greater than s2.
*/

/*!
  Compares this string to \a s, returning an integer less than, equal to, or
  greater than zero if it is, respectively, lexically less than, equal to,
  or greater than \a s.

*/
int QString::compare( const QString& s ) const
{
    return ucstrcmp(*this,s);
}

bool operator==( const QString &s1, const QString &s2 )
{ return s1.length()==s2.length() && ucstrcmp(s1,s2) == 0; }

bool operator==( const QString &s1, const char *s2 )
{ return s1==QString(s2); }

bool operator==( const char *s1, const QString &s2 )
{ return QString(s1)==s2; }

bool operator!=( const QString &s1, const QString &s2 )
{ return !(s1==s2); }

bool operator!=( const QString &s1, const char *s2 )
{ return !(s1==s2); }

bool operator!=( const char *s1, const QString &s2 )
{ return !(s1==s2); }

bool operator<( const QString &s1, const QString &s2 )
{ return ucstrcmp(s1,s2) < 0; }

bool operator<( const QString &s1, const char *s2 )
{ return ucstrcmp(s1,s2) < 0; }

bool operator<( const char *s1, const QString &s2 )
{ return ucstrcmp(s1,s2) < 0; }

bool operator<=( const QString &s1, const QString &s2 )
{ return ucstrcmp(s1,s2) <= 0; }

bool operator<=( const QString &s1, const char *s2 )
{ return ucstrcmp(s1,s2) <= 0; }

bool operator<=( const char *s1, const QString &s2 )
{ return ucstrcmp(s1,s2) <= 0; }

bool operator>( const QString &s1, const QString &s2 )
{ return ucstrcmp(s1,s2) > 0; }

bool operator>( const QString &s1, const char *s2 )
{ return ucstrcmp(s1,s2) > 0; }

bool operator>( const char *s1, const QString &s2 )
{ return ucstrcmp(s1,s2) > 0; }

bool operator>=( const QString &s1, const QString &s2 )
{ return ucstrcmp(s1,s2) >= 0; }

bool operator>=( const QString &s1, const char *s2 )
{ return ucstrcmp(s1,s2) >= 0; }

bool operator>=( const char *s1, const QString &s2 )
{ return ucstrcmp(s1,s2) >= 0; }

/*****************************************************************************
  Documentation for related functions
 *****************************************************************************/

/*!
  \fn bool operator==( const QString &s1, const QString &s2 )
  \relates QString
  Returns TRUE if the two strings are equal, or FALSE if they are different.

  Equivalent to <code>strcmp(s1,s2) == 0</code>.
*/

/*!
  \fn bool operator==( const QString &s1, const char *s2 )
  \relates QString
  Returns TRUE if the two strings are equal, or FALSE if they are different.

  Equivalent to <code>strcmp(s1,s2) == 0</code>.
*/

/*!
  \fn bool operator==( const char *s1, const QString &s2 )
  \relates QString
  Returns TRUE if the two strings are equal, or FALSE if they are different.

  Equivalent to <code>strcmp(s1,s2) == 0</code>.
*/

/*!
  \fn bool operator!=( const QString &s1, const QString &s2 )
  \relates QString
  Returns TRUE if the two strings are different, or FALSE if they are equal.

  Equivalent to <code>strcmp(s1,s2) != 0</code>.
*/

/*!
  \fn bool operator!=( const QString &s1, const char *s2 )
  \relates QString
  Returns TRUE if the two strings are different, or FALSE if they are equal.

  Equivalent to <code>strcmp(s1,s2) != 0</code>.
*/

/*!
  \fn bool operator!=( const char *s1, const QString &s2 )
  \relates QString
  Returns TRUE if the two strings are different, or FALSE if they are equal.

  Equivalent to <code>strcmp(s1,s2) != 0</code>.
*/

/*!
  \fn bool operator<( const QString &s1, const char *s2 )
  \relates QString
  Returns TRUE if \e s1 is alphabetically less than \e s2, otherwise FALSE.

  Equivalent to <code>strcmp(s1,s2) \< 0</code>.
*/

/*!
  \fn bool operator<( const char *s1, const QString &s2 )
  \relates QString
  Returns TRUE if \e s1 is alphabetically less than \e s2, otherwise FALSE.

  Equivalent to <code>strcmp(s1,s2) \< 0</code>.
*/

/*!
  \fn bool operator<=( const QString &s1, const char *s2 )
  \relates QString
  Returns TRUE if \e s1 is alphabetically less than or equal to \e s2,
  otherwise FALSE.

  Equivalent to <code>strcmp(s1,s2) \<= 0</code>.
*/

/*!
  \fn bool operator<=( const char *s1, const QString &s2 )
  \relates QString
  Returns TRUE if \e s1 is alphabetically less than or equal to \e s2,
  otherwise FALSE.

  Equivalent to <code>strcmp(s1,s2) \<= 0</code>.
*/

/*!
  \fn bool operator>( const QString &s1, const char *s2 )
  \relates QString
  Returns TRUE if \e s1 is alphabetically greater than \e s2, otherwise FALSE.

  Equivalent to <code>strcmp(s1,s2) \> 0</code>.
*/

/*!
  \fn bool operator>( const char *s1, const QString &s2 )
  \relates QString
  Returns TRUE if \e s1 is alphabetically greater than \e s2, otherwise FALSE.

  Equivalent to <code>strcmp(s1,s2) \> 0</code>.
*/

/*!
  \fn bool operator>=( const QString &s1, const char *s2 )
  \relates QString
  Returns TRUE if \e s1 is alphabetically greater than or equal to \e s2,
  otherwise FALSE.

  Equivalent to <code>strcmp(s1,s2) \>= 0</code>.
*/

/*!
  \fn bool operator>=( const char *s1, const QString &s2 )
  \relates QString
  Returns TRUE if \e s1 is alphabetically greater than or equal to \e s2,
  otherwise FALSE.

  Equivalent to <code>strcmp(s1,s2) \>= 0</code>.
*/

/*!
  \fn QString operator+( const QString &s1, const QString &s2 )
  \relates QString
  Returns the concatenated string of s1 and s2.
*/

/*!
  \fn QString operator+( const QString &s1, const char *s2 )
  \relates QString
  Returns the concatenated string of s1 and s2.
*/

/*!
  \fn QString operator+( const char *s1, const QString &s2 )
  \relates QString
  Returns the concatenated string of s1 and s2.
*/

/*!
  \fn QString operator+( const QString &s, char c )
  \relates QString
  Returns the concatenated string of s and c.
*/

/*!
  \fn QString operator+( char c, const QString &s )
  \relates QString
  Returns the concatenated string of c and s.
*/



/*****************************************************************************
  Q1String member functions
 *****************************************************************************/

/*!
  \class Q1String qstring.h

  \brief The Q1String class provides an abstraction of the classic C
  zero-terminated char array (<var>char*</var>).

  \ingroup tools
  \ingroup shared

  Q1String inherits QByteArray, which is defined as QArray\<char\>.

  Since Q1String is a QArray, it uses \e explicit
  \link shclass.html sharing\endlink with a reference count.

  You might use Q1String for text that is never exposed to the user,
  but for text the user sees, you should use QString (which provides
  implicit sharing, Unicode and other internationalization support).

  Note that for the Q1String methods that take a <var>const char *</var>
  parameter the results are undefined if the Q1String is not
  zero-terminated.  It is legal for the <var>const char *</var> parameter
  to be 0.

  A Q1String that has not been assigned to anything is \e null, i.e. both
  the length and data pointer is 0. A Q1String that references the empty
  string ("", a single '\0' char) is \e empty.	Both null and empty
  Q1Strings are legal parameters to the methods. Assigning <var>const char
  * 0</var> to Q1String gives a null Q1String.

  \sa \link shclass.html Shared classes\endlink
*/


/*!
  \fn Q1String::Q1String()
  Constructs a null string.
  \sa isNull()
*/

/*!
  \fn Q1String::Q1String( const Q1String &s )
  Constructs a shallow copy \e s.
  \sa assign()
*/

/*!
  Constructs a string with room for \e size characters, including the
  '\0'-terminator.  Makes a null string if \e size == 0.

  If \e size \> 0, then the first and last characters in the string are
  initialized to '\0'.	All other characters are uninitialized.

  \sa resize(), isNull()
*/

Q1String::Q1String( int size )
    : QByteArray( size )
{
    if ( size > 0 ) {
	*data() = '\0';				// set terminator
	*(data()+(size-1)) = '\0';
    }
}

/*!
  Constructs a string that is a deep copy of \e str.

  If \a str is 0 a null string is created.

  \sa isNull()
*/

Q1String::Q1String( const char *str )
{
    duplicate( str, strlen(str)+1 );
}


/*!
  Constructs a string that is a deep copy of \e str, that is no more
  than \a maxlen bytes long including the '\0'-terminator.

  Example:
  \code
    Q1String str("helloworld",6); // Assigns "hello" to str.
  \endcode

  If \a str contains a 0 byte within the first \a maxlen bytes, the
  resulting Q1String will be terminated by the 0.  If \a str is 0 a
  null string is created.

  \sa isNull()
*/

Q1String::Q1String( const char *str, uint maxlen )
{
    uint len; // index of last nul character
    // cannot use memchr - we need the *index*, not void*
    for (len=0; len<maxlen-1; len++) {
	if (!str[len]) break;
    }
    duplicate( str, len+1 );
    data()[len] = 0;
}

/*!
  \fn Q1String &Q1String::operator=( const Q1String &s )
  Assigns a shallow copy of \e s to this string and returns a reference to
  this string.
*/

/*!
  \fn Q1String &Q1String::operator=( const char *str )
  Assigns a deep copy of \a str to this string and returns a reference to
  this string.

  If \a str is 0 a null string is created.

  \sa isNull()
*/

/*!
  \fn bool Q1String::isNull() const
  Returns TRUE if the string is null, i.e. if data() == 0.
  A null string is also an empty string.

  Example:
  \code
    Q1String a;		// a.data() == 0,  a.size() == 0, a.length() == 0
    Q1String b == "";	// b.data() == "", b.size() == 1, b.length() == 0
    a.isNull();		// TRUE, because a.data() == 0
    a.isEmpty();	// TRUE, because a.length() == 0
    b.isNull();		// FALSE, because b.data() == ""
    b.isEmpty();	// TRUE, because b.length() == 0
  \endcode

  \sa isEmpty(), length(), size()
*/

/*!
  \fn bool Q1String::isEmpty() const

  Returns TRUE if the string is empty, i.e. if length() == 0.
  An empty string is not always a null string.

  See example in isNull().

  \sa isNull(), length(), size()
*/

/*!
  \fn uint Q1String::length() const
  Returns the length of the string, excluding the '\0'-terminator.
  Equivalent to calling \c strlen(data()).

  Null strings and empty strings have zero length.

  \sa size(), isNull(), isEmpty()
*/

/*!
  \fn bool Q1String::truncate( uint pos )
  Truncates the string at position \e pos.

  Equivalent to calling \c resize(pos+1).

  Example:
  \code
    Q1String s = "truncate this string";
    s.truncate( 5 );				// s == "trunc"
  \endcode

  \sa resize()
*/

/*!
  Extends or shrinks the string to \e len bytes, including the
  '\0'-terminator.

  A \0-terminator is set at position <code>len - 1</code> unless
  <code>len == 0</code>.

  Example:
  \code
    Q1String s = "resize this string";
    s.resize( 7 );				// s == "resize"
  \endcode

  \sa truncate()
*/

bool Q1String::resize( uint len )
{
    // **SHOULD DETACH**
    if ( !QByteArray::resize(len) )
	return FALSE;
    if ( len )
	*(data()+len-1) = '\0';
    return TRUE;
}


/*!
  Implemented as a call to the native vsprintf() (see your C-library
  manual).

  If your string is shorter than 256 characters, this sprintf() calls
  resize(256) to decrease the chance of memory corruption.  The string is
  resized back to its natural length before sprintf() returns.

  Example:
  \code
    Q1String s;
    s.sprintf( "%d - %s", 1, "first" );		// result < 256 chars

    Q1String big( 25000 );			// very long string
    big.sprintf( "%d - %s", 2, longString );	// result < 25000 chars
  \endcode

  \warning All vsprintf() implementations will write past the end of
  the target string (*this) if the format specification and arguments
  happen to be longer than the target string, and some will also fail
  if the target string is longer than some arbitrary implementation
  limit.

  Giving user-supplied arguments to sprintf() is begging for trouble.
  Sooner or later someone \e will paste a 3000-character line into
  your application.
*/

Q1String &Q1String::sprintf( const char *format, ... )
{
    // **SHOULD DETACH**
    va_list ap;
    va_start( ap, format );
    if ( size() < 256 )
	QByteArray::resize( 256 );		// make string big enough
    vsprintf( data(), format, ap );
    resize( strlen(data()) + 1 );		// truncate
    va_end( ap );
    return *this;
}


/*!
  Fills the string with \e len bytes of value \e c, followed by a
  '\0'-terminator.

  If \e len is negative, then the current string length is used.

  Returns FALSE is \e len is nonnegative and there is no memory to
  resize the string, otherwise TRUE is returned.
*/

bool Q1String::fill( char c, int len )
{
    // **SHOULD DETACH**
    if ( len < 0 )
	len = length();
    if ( !QByteArray::fill(c,len+1) )
	return FALSE;
    *(data()+len) = '\0';
    return TRUE;
}


/*!
  \fn Q1String Q1String::copy() const
  Returns a deep copy of this string.
  \sa detach()
*/


/*!
  Finds the first occurrence of the character \e c, starting at
  position \e index.

  The search is case sensitive if \e cs is TRUE, or case insensitive if \e
  cs is FALSE.

  Returns the position of \e c, or -1 if \e c could not be found.
*/

int Q1String::find( char c, int index, bool cs ) const
{
    if ( (uint)index >= size() )		// index outside string
	return -1;
    register const char *d;
    if ( cs ) {					// case sensitive
	d = strchr( data()+index, c );
    } else {
	d = data()+index;
	c = tolower( c );
	while ( *d && tolower(*d) != c )
	    d++;
	if ( !*d && c )				// not found
	    d = 0;
    }
    return d ? (int)(d - data()) : -1;
}

/*!
  Finds the first occurrence of the string \e str, starting at position
  \e index.

  The search is case sensitive if \e cs is TRUE, or case insensitive if \e
  cs is FALSE.

  Returns the position of \e str, or -1 if \e str could not be found.
*/

int Q1String::find( const char *str, int index, bool cs ) const
{
    if ( (uint)index >= size() )		// index outside string
	return -1;
    register const char *d;
    if ( cs ) {					// case sensitive
	d = strstr( data()+index, str );
    } else {					// case insensitive
	d = data()+index;
	int len = strlen( str );
	while ( *d ) {
	    if ( strnicmp(d, str, len) == 0 )
		break;
	    d++;
	}
	if ( !*d )				// not found
	    d = 0;
    }
    return d ? (int)(d - data()) : -1;
}

/*!
  Finds the first occurrence of the character \e c, starting at
  position \e index and searching backwards.

  The search is case sensitive if \e cs is TRUE, or case insensitive if \e
  cs is FALSE.

  Returns the position of \e c, or -1 if \e c could not be found.
*/

int Q1String::findRev( char c, int index, bool cs ) const
{
    const char *b = data();
    const char *d;
    if ( index < 0 ) {				// neg index ==> start from end
	if ( size() == 0 )
	    return -1;
	if ( cs ) {
	    d = strrchr( b, c );
	    return d ? (int)(d - b) : -1;
	}
	index = length();
    } else if ( (uint)index >= size() ) {	// bad index
	return -1;
    }
    d = b+index;
    if ( cs ) {					// case sensitive
	while ( d >= b && *d != c )
	    d--;
    } else {					// case insensitive
	c = tolower( c );
	while ( d >= b && tolower(*d) != c )
	    d--;
    }
    return d >= b ? (int)(d - b) : -1;
}

/*!
  Finds the first occurrence of the string \e str, starting at
  position \e index and searching backwards.

  The search is case sensitive if \e cs is TRUE, or case insensitive if \e
  cs is FALSE.

  Returns the position of \e str, or -1 if \e str could not be found.
*/

int Q1String::findRev( const char *str, int index, bool cs ) const
{
    int slen = strlen(str);
    if ( index < 0 )				// neg index ==> start from end
	index = length()-slen;
    else if ( (uint)index >= size() )		// bad index
	return -1;
    else if ( (uint)(index + slen) > length() ) // str would be too long
	index = length() - slen;
    if ( index < 0 )
	return -1;

    register char *d = data() + index;
    if ( cs ) {					// case sensitive
	for ( int i=index; i>=0; i-- )
	    if ( strncmp(d--,str,slen)==0 )
		return i;
    } else {					// case insensitive
	for ( int i=index; i>=0; i-- )
	    if ( strnicmp(d--,str,slen)==0 )
		return i;
    }
    return -1;
}


/*!
  Returns the number of times the character \e c occurs in the string.

  The match is case sensitive if \e cs is TRUE, or case insensitive if \e cs
  if FALSE.
*/

int Q1String::contains( char c, bool cs ) const
{
    int count = 0;
    char *d = data();
    if ( !d )
	return 0;
    if ( cs ) {					// case sensitive
	while ( *d )
	    if ( *d++ == c )
		count++;
    } else {					// case insensitive
	c = tolower( c );
	while ( *d ) {
	    if ( tolower(*d) == c )
		count++;
	    d++;
	}
    }
    return count;
}

/*!
  Returns the number of times \e str occurs in the string.

  The match is case sensitive if \e cs is TRUE, or case insensitive if \e
  cs if FALSE.

  This function counts overlapping substrings, for example, "banana"
  contains two occurrences of "ana".

  \sa findRev()
*/

int Q1String::contains( const char *str, bool cs ) const
{
    int count = 0;
    char *d = data();
    if ( !d )
	return 0;
    int len = strlen( str );
    while ( *d ) {				// counts overlapping strings
	if ( cs ) {
	    if ( strncmp( d, str, len ) == 0 )
		count++;
	} else {
	    if ( strnicmp(d, str, len) == 0 )
		count++;
	}
	d++;
    }
    return count;
}

/*!
  Returns a substring that contains the \e len leftmost characters
  of the string.

  The whole string is returned if \e len exceeds the length of the string.

  Example:
  \code
    Q1String s = "Pineapple";
    Q1String t = s.left( 4 );			// t == "Pine"
  \endcode

  \sa right(), mid()
*/

Q1String Q1String::left( uint len ) const
{
    if ( isEmpty() ) {
	Q1String empty;
	return empty;
    } else if ( len >= size() ) {
	Q1String same( data() );
	return same;
    } else {
	Q1String s( len+1 );
	strncpy( s.data(), data(), len );
	*(s.data()+len) = '\0';
	return s;
    }
}

/*!
  Returns a substring that contains the \e len rightmost characters
  of the string.

  The whole string is returned if \e len exceeds the length of the string.

  Example:
  \code
    Q1String s = "Pineapple";
    Q1String t = s.right( 5 );			// t == "apple"
  \endcode

  \sa left(), mid()
*/

Q1String Q1String::right( uint len ) const
{
    if ( isEmpty() ) {
	Q1String empty;
	return empty;
    } else {
	uint l = length();
	if ( len > l )
	    len = l;
	char *p = data() + (l - len);
	return Q1String( p );
    }
}

/*!
  Returns a substring that contains the \e len characters of this
  string, starting at position \e index.

  Returns a null string if the string is empty or \e index is out
  of range.  Returns the whole string from \e index if \e index+len exceeds
  the length of the string.

  Example:
  \code
    Q1String s = "Two pineapples";
    Q1String t = s.mid( 4, 4 );			// t == "pine"
  \endcode

  \sa left(), right()
*/

Q1String Q1String::mid( uint index, uint len ) const
{
    uint slen = strlen( data() );
    if ( isEmpty() || index >= slen ) {
	Q1String empty;
	return empty;
    } else {
	register char *p = data()+index;
	Q1String s( len+1 );
	strncpy( s.data(), p, len );
	*(s.data()+len) = '\0';
	return s;
    }
}

/*!
  Returns a string of length \e width (plus '\0') that contains this
  string and padded by the \e fill character.

  If the length of the string exceeds \e width and \e truncate is FALSE,
  then the returned string is a copy of the string.
  If the length of the string exceeds \e width and \e truncate is TRUE,
  then the returned string is a left(\e width).

  Example:
  \code
    Q1String s("apple");
    Q1String t = s.leftJustify(8, '.');		// t == "apple..."
  \endcode

  \sa rightJustify()
*/

Q1String Q1String::leftJustify( uint width, char fill, bool truncate ) const
{
    Q1String result;
    int len = strlen(data());
    int padlen = width - len;
    if ( padlen > 0 ) {
	result.QByteArray::resize( len+padlen+1 );
	memcpy( result.data(), data(), len );
	memset( result.data()+len, fill, padlen );
	result[len+padlen] = '\0';
    } else {
	if ( truncate )
	    result = left( width );
	else
	    result = copy();
    }
    return result;
}

/*!
  Returns a string of length \e width (plus '\0') that contains pad
  characters followed by the string.

  If the length of the string exceeds \e width and \e truncate is FALSE,
  then the returned string is a copy of the string.
  If the length of the string exceeds \e width and \e truncate is TRUE,
  then the returned string is a right(\e width).

  Example:
  \code
    Q1String s("pie");
    Q1String t = s.rightJustify(8, '.');		// t == ".....pie"
  \endcode

  \sa leftJustify()
*/

Q1String Q1String::rightJustify( uint width, char fill, bool truncate ) const
{
    Q1String result;
    int len = strlen(data());
    int padlen = width - len;
    if ( padlen > 0 ) {
	result.QByteArray::resize( len+padlen+1 );
	memset( result.data(), fill, padlen );
	memcpy( result.data()+padlen, data(), len );
	result[len+padlen] = '\0';
    } else {
	if ( truncate )
	    result = left( width );
	else
	    result = copy();
    }
    return result;
}

/*!
  Returns a new string that is the string converted to lower case.

  Presently it only handles 7-bit ASCII, or whatever tolower()
  handles (if $LC_CTYPE is set, most UNIX systems do the Right Thing).

  Example:
  \code
    Q1String s("TeX");
    Q1String t = s.lower();			// t == "tex"
  \endcode

  \sa upper()
*/

Q1String Q1String::lower() const
{
    Q1String s( data() );
    register char *p = s.data();
    if ( p ) {
	while ( *p ) {
	    *p = tolower(*p);
	    p++;
	}
    }
    return s;
}

/*!
  Returns a new string that is the string converted to upper case.

  Presently it only handles 7-bit ASCII, or whatever toupper()
  handles (if $LC_CTYPE is set, most UNIX systems do the Right Thing).

  Example:
  \code
    Q1String s("TeX");
    Q1String t = s.upper();			// t == "TEX"
  \endcode

  \sa lower()
*/

Q1String Q1String::upper() const
{
    Q1String s( data() );
    register char *p = s.data();
    if ( p ) {
	while ( *p ) {
	    *p = toupper(*p);
	    p++;
	}
    }
    return s;
}


/*!
  Returns a new string that has white space removed from the start and the end.

  White space means any ASCII code 9, 10, 11, 12, 13 or 32.

  Example:
  \code
    Q1String s = " space ";
    Q1String t = s.stripWhiteSpace();		// t == "space"
  \endcode

  \sa simplifyWhiteSpace()
*/

Q1String Q1String::stripWhiteSpace() const
{
    if ( isEmpty() )				// nothing to do
	return copy();

    register char *s = data();
    Q1String result = s;
    int reslen = result.length();
    if ( !isspace(s[0]) && !isspace(s[reslen-1]) )
	return result;				// returns a copy

    s = result.data();
    int start = 0;
    int end = reslen - 1;
    while ( isspace(s[start]) )			// skip white space from start
	start++;
    if ( s[start] == '\0' ) {			// only white space
	result.resize( 1 );
	return result;
    }
    while ( end && isspace(s[end]) )		// skip white space from end
	end--;
    end -= start - 1;
    memmove( result.data(), &s[start], end );
    result.resize( end + 1 );
    return result;
}


/*!
  Returns a new string that has white space removed from the start and the end,
  plus any sequence of internal white space replaced with a single space
  (ASCII 32).

  White space means any ASCII code 9, 10, 11, 12, 13 or 32.

  \code
    Q1String s = "  lots\t of\nwhite    space ";
    Q1String t = s.simplifyWhiteSpace();		// t == "lots of white space"
  \endcode

  \sa stripWhiteSpace()
*/

Q1String Q1String::simplifyWhiteSpace() const
{
    if ( isEmpty() )				// nothing to do
	return copy();
    Q1String result( size() );
    char *from	= data();
    char *to	= result.data();
    char *first = to;
    while ( TRUE ) {
	while ( *from && isspace(*from) )
	    from++;
	while ( *from && !isspace(*from) )
	    *to++ = *from++;
	if ( *from )
	    *to++ = 0x20;			// ' '
	else
	    break;
    }
    if ( to > first && *(to-1) == 0x20 )
	to--;
    *to = '\0';
    result.resize( (int)((long)to - (long)result.data()) + 1 );
    return result;
}


/*!
  Insert \e s into the string before position \e index.

  If \e index is beyond the end of the string, the string is extended with
  spaces (ASCII 32) to length \e index and \e s is then appended.

  \code
    Q1String s = "I like fish";
    s.insert( 2, "don't ");			// s == "I don't like fish"
    s = "x";
    s.insert( 3, "yz" );			// s == "x  yz"
  \endcode
*/

Q1String &Q1String::insert( uint index, const char *s )
{
    int len = strlen(s);
    if ( len == 0 )
	return *this;
    uint olen = length();
    int nlen = olen + len;
    if ( index >= olen ) {			// insert after end of string
	// **SHOULD DETACH**
	if ( QByteArray::resize(nlen+index-olen+1) ) {
	    memset( data()+olen, ' ', index-olen );
	    memcpy( data()+index, s, len+1 );
	}
    } else if ( QByteArray::resize(nlen+1) ) {	// normal insert
	// **SHOULD DETACH**
	memmove( data()+index+len, data()+index, olen-index+1 );
	memcpy( data()+index, s, len );
    }
    return *this;
}

/*!
  Insert \e c into the string at (before) position \e index and returns
  a reference to the string.

  If \e index is beyond the end of the string, the string is extended with
  spaces (ASCII 32) to length \e index and \e c is then appended.

  Example:
  \code
    Q1String s = "Yes";
    s.insert( 3, '!');				// s == "Yes!"
  \endcode

  \sa remove(), replace()
*/

Q1String &Q1String::insert( uint index, char c )	// insert char
{
    char buf[2];
    buf[0] = c;
    buf[1] = '\0';
    return insert( index, buf );
}

/*!
  \fn Q1String &Q1String::prepend( const char *s )

  Prepend \s to the string. Equivalent to insert(0,s).

  \sa insert()
*/

/*!
  Removes \e len characters starting at position \e index from the
  string and returns a reference to the string.

  If \e index is too big, nothing happens.  If \e index is valid, but
  \e len is too large, the rest of the string is removed.

  \code
    Q1String s = "Montreal";
    s.remove( 1, 4 );
    // s == "Meal"
  \endcode

  \sa insert(), replace()
*/

Q1String &Q1String::remove( uint index, uint len )
{
    uint olen = length();
    if ( index + len >= olen ) {		// range problems
	if ( index < olen ) {			// index ok
	    // **SHOULD DETACH**
	    resize( index+1 );
	}
    } else if ( len != 0 ) {
	// **SHOULD DETACH**
	memmove( data()+index, data()+index+len, olen-index-len+1 );
	QByteArray::resize(olen-len+1);
    }
    return *this;
}

/*!
  Replaces \e len characters starting at position \e index from the
  string with \e s, and returns a reference to the string.

  If \e index is too big, nothing is deleted and \e s is inserted at the
  end of the string.  If \e index is valid, but \e len is too large, \e
  str replaces the rest of the string.

  \code
    Q1String s = "Say yes!";
    s.replace( 4, 3, "NO" );			// s == "Say NO!"
  \endcode

  \sa insert(), remove()
*/

Q1String &Q1String::replace( uint index, uint len, const char *s )
{
    remove( index, len );
    insert( index, s );
    return *this;
}


/*!
  Returns the string converted to a <code>long</code> value.

  If \e ok is non-null, \e *ok is set to TRUE if there are no
  conceivable errors, and FALSE if the string is not a number at all, or if
  it has trailing garbage.
*/

long Q1String::toLong( bool *ok ) const
{
    char *p = data();
    long val=0;
    const long max_mult = 214748364;
    bool is_ok = FALSE;
    int neg = 0;
    if ( !p )
	goto bye;
    while ( isspace(*p) )			// skip leading space
	p++;
    if ( *p == '-' ) {
	p++;
	neg = 1;
    } else if ( *p == '+' ) {
	p++;
    }
    if ( !isdigit(*p) )
	goto bye;
    while ( isdigit(*p) ) {
	if ( val > max_mult || (val == max_mult && (*p-'0') > 7+neg) )
	    goto bye;
	val = 10*val + (*p++ - '0');
    }
    if ( neg )
	val = -val;
    while ( isspace(*p) )			// skip trailing space
	p++;
    if ( *p == '\0' )
	is_ok = TRUE;
bye:
    if ( ok )
	*ok = is_ok;
    return is_ok ? val : 0;
}

/*!
  Returns the string converted to an <code>unsigned long</code>
  value.

  If \e ok is non-null, \e *ok is set to TRUE if there are no
  conceivable errors, and FALSE if the string is not a number at all,
  or if it has trailing garbage.
*/

ulong Q1String::toULong( bool *ok ) const
{
    char *p = data();
    ulong val=0;
    const ulong max_mult = 429496729;
    bool is_ok = FALSE;
    if ( !p )
	goto bye;
    while ( isspace(*p) )			// skip leading space
	p++;
    if ( *p == '+' )
	p++;
    if ( !isdigit(*p) )
	goto bye;
    while ( isdigit(*p) ) {
	if ( val > max_mult || (val == max_mult && (*p-'0') > 5) )
	    goto bye;
	val = 10*val + (*p++ - '0');
    }
    while ( isspace(*p) )			// skip trailing space
	p++;
    if ( *p == '\0' )
	is_ok = TRUE;
bye:
    if ( ok )
	*ok = is_ok;
    return is_ok ? val : 0;
}

/*!
  Returns the string converted to a <code>short</code> value.

  If \e ok is non-null, \e *ok is set to TRUE if there are no
  conceivable errors, and FALSE if the string is not a number at all, or if
  it has trailing garbage.
*/

short Q1String::toShort( bool *ok ) const
{
    long v = toLong( ok );
    if ( ok && *ok && (v < -32768 || v > 32767) )
	*ok = FALSE;
    return (short)v;
}

/*!
  Returns the string converted to an <code>unsigned short</code> value.

  If \e ok is non-null, \e *ok is set to TRUE if there are no
  conceivable errors, and FALSE if the string is not a number at all, or if
  it has trailing garbage.
*/

ushort Q1String::toUShort( bool *ok ) const
{
    ulong v = toULong( ok );
    if ( ok && *ok && (v > 65535) )
	*ok = FALSE;
    return (QChar)v;
}


/*!
  Returns the string converted to a <code>int</code> value.

  If \e ok is non-null, \e *ok is set to TRUE if there are no
  conceivable errors, and FALSE if the string is not a number at all,
  or if it has trailing garbage.
*/

int Q1String::toInt( bool *ok ) const
{
    return (int)toLong( ok );
}

/*!
  Returns the string converted to an <code>unsigned int</code> value.

  If \e ok is non-null, \e *ok is set to TRUE if there are no
  conceivable errors, and FALSE if the string is not a number at all,
  or if it has trailing garbage.
*/

uint Q1String::toUInt( bool *ok ) const
{
    return (uint)toULong( ok );
}

/*!
  Returns the string converted to a <code>double</code> value.

  If \e ok is non-null, \e *ok is set to TRUE if there are no conceivable
  errors, and FALSE if the string is not a number at all, or if it has
  trailing garbage.
*/

double Q1String::toDouble( bool *ok ) const
{
    char *end;
    double val = strtod( data() ? data() : "", &end );
    if ( ok )
	*ok = ( data() && *data() && ( end == 0 || *end == '\0' ) );
    return val;
}

/*!
  Returns the string converted to a <code>float</code> value.

  If \e ok is non-null, \e *ok is set to TRUE if there are no
  conceivable errors, and FALSE if the string is not a number at all,
  or if it has trailing garbage.
*/

float Q1String::toFloat( bool *ok ) const
{
    return (float)toDouble( ok );
}


/*!
  Makes a deep copy of \e str without dereferencing the current
  string, i.e. all strings that share data are modified.
  Returns a reference to the string.
*/

Q1String &Q1String::setStr( const char *str )
{
    if ( str )					// valid string
	store( str, strlen(str)+1 );
    else					// empty
	resize( 0 );
    return *this;
}

/*!
  Sets the string to the printed value of \e n and returns a
  reference to the string.

  \bug setNum(-2147483648) does not work on 32-bit systems.
*/

Q1String &Q1String::setNum( long n )
{
    // **SHOULD DETACH**
    char buf[20];
    register char *p = &buf[19];
    bool neg;
    if ( n < 0 ) {
	neg = TRUE;
	n = -n;
    } else {
	neg = FALSE;
    }
    *p = '\0';
    do {
	*--p = ((int)(n%10)) + '0';
	n /= 10;
    } while ( n );
    if ( neg )
	*--p = '-';
    store( p, strlen(p)+1 );
    return *this;
}

/*!
  Sets the string to the printed unsigned value of \e n and
  returns a reference to the string.
*/

Q1String &Q1String::setNum( ulong n )
{
    // **SHOULD DETACH**
    char buf[20];
    register char *p = &buf[19];
    *p = '\0';
    do {
	*--p = ((int)(n%10)) + '0';
	n /= 10;
    } while ( n );
    store( p, strlen(p)+1 );
    return *this;
}

/*!
  \fn Q1String &Q1String::setNum( int n )
  Sets the string to the printed value of \e n and returns a reference
  to the string.
*/

/*!
  \fn Q1String &Q1String::setNum( uint n )
  Sets the string to the printed unsigned value of \e n and returns a
  reference to the string.
*/

/*!
  \fn Q1String &Q1String::setNum( short n )
  Sets the string to the printed value of \e n and returns a reference
  to the string.
*/

/*!
  \fn Q1String &Q1String::setNum( ushort n )
  Sets the string to the printed unsigned value of \e n and returns a
  reference to the string.
*/

/*!
  Sets the string to the printed value of \e n.

  \arg \e f is the format specifier: 'f', 'F', 'e', 'E', 'g', 'G' (same
  as sprintf()).
  \arg \e prec is the precision.

  Returns a reference to the string.
*/

Q1String &Q1String::setNum( double n, char f, int prec )
{
#if defined(CHECK_RANGE)
    if ( !(f=='f' || f=='F' || f=='e' || f=='E' || f=='g' || f=='G') )
	warning( "Q1String::setNum: Invalid format char '%c'", f );
#endif
    char format[20];
    register char *fs = format;			// generate format string
    *fs++ = '%';				//   "%.<prec>l<f>"
    if ( prec > 99 )
	prec = 99;
    *fs++ = '.';
    if ( prec >= 10 ) {
	*fs++ = prec / 10 + '0';
	*fs++ = prec % 10 + '0';
    } else {
	*fs++ = prec + '0';
    }
    *fs++ = 'l';
    *fs++ = f;
    *fs = '\0';
    return sprintf( format, n );
}

/*!
  \fn Q1String &Q1String::setNum( float n, char f, int prec )
  Sets the string to the printed value of \e n.

  \arg \e f is the format specifier: 'f', 'F', 'e', 'E', 'g', 'G' (same
  as sprintf()).
  \arg \e prec is the precision.

  Returns a reference to the string.
*/


/*!
  Sets the character at position \e index to \e c and expands the
  string if necessary, filling with spaces.

  Returns FALSE if this \e index was out of range and the string could
  not be expanded, otherwise TRUE.
*/

bool Q1String::setExpand( uint index, char c )
{
    // **SHOULD DETACH**
    uint oldlen = length();
    if ( index >= oldlen ) {
	if ( !QByteArray::resize( index+2 ) )	// no memory
	    return FALSE;
	if ( index > oldlen )
	    memset( data() + oldlen, ' ', index - oldlen );
	*(data() + index+1) = '\0';		// terminate padded string
    }
    *(data() + index) = c;
    return TRUE;
}


/*!
  \fn Q1String::operator const char *() const
  Returns the string data.
*/

/*!
  \fn bool Q1String::operator!() const
  Returns TRUE if it is a null string, otherwise FALSE.
*/


/*!
  \fn Q1String& Q1String::append( const char *str )
  Appends \e str to the string and returns a reference to the string.
  Equivalent to operator+=().
 */

/*!
  Appends \e str to the string and returns a reference to the string.
*/

Q1String& Q1String::operator+=( const char *str )
{
    if ( !str )
	return *this;				// nothing to append
    // **SHOULD DETACH**
    uint len1 = length();
    uint len2 = strlen(str);
    if ( !QByteArray::resize( len1 + len2 + 1 ) )
	return *this;				// no memory
    memcpy( data() + len1, str, len2 + 1 );
    return *this;
}

/*!
  Appends \e c to the string and returns a reference to the string.
*/

Q1String &Q1String::operator+=( char c )
{
    // **SHOULD DETACH**
    uint len = length();
    if ( !QByteArray::resize( len + 2 ) )
	return *this;				// no memory
    *(data() + len) = c;
    *(data() + len+1) = '\0';
    return *this;
}


/*****************************************************************************
  Q1String stream functions
 *****************************************************************************/

/*!
  \relates Q1String
  Writes a string to the stream.

  Output format: [length (Q_UINT32) data...]
*/

QDataStream &operator<<( QDataStream &s, const Q1String &str )
{
    return s.writeBytes( str.data(), str.size() );
}

/*!
  \relates Q1String
  Reads a string from the stream.
*/

QDataStream &operator>>( QDataStream &s, Q1String &str )
{
    // **SHOULD DETACH** (str)
    Q_UINT32 len;
    s >> len;					// read size of string
    if ( len == 0 || s.eof() ) {		// end of file reached
	str.resize( 0 );
	return s;
    }
    if ( !str.QByteArray::resize( (uint)len )) {// resize string
#if defined(CHECK_NULL)
	warning( "QDataStream: Not enough memory to read Q1String" );
#endif
	len = 0;
    }
    if ( len > 0 )				// not null array
	s.readRawBytes( str.data(), (uint)len );
    return s;
}


/*****************************************************************************
  Documentation for related functions
 *****************************************************************************/

/*!
  \fn bool operator==( const Q1String &s1, const Q1String &s2 )
  \relates Q1String
  Returns TRUE if the two strings are equal, or FALSE if they are different.

  Equivalent to <code>strcmp(s1,s2) == 0</code>.
*/

/*!
  \fn bool operator==( const Q1String &s1, const char *s2 )
  \relates Q1String
  Returns TRUE if the two strings are equal, or FALSE if they are different.

  Equivalent to <code>strcmp(s1,s2) == 0</code>.
*/

/*!
  \fn bool operator==( const char *s1, const Q1String &s2 )
  \relates Q1String
  Returns TRUE if the two strings are equal, or FALSE if they are different.

  Equivalent to <code>strcmp(s1,s2) == 0</code>.
*/

/*!
  \fn bool operator!=( const Q1String &s1, const Q1String &s2 )
  \relates Q1String
  Returns TRUE if the two strings are different, or FALSE if they are equal.

  Equivalent to <code>strcmp(s1,s2) != 0</code>.
*/

/*!
  \fn bool operator!=( const Q1String &s1, const char *s2 )
  \relates Q1String
  Returns TRUE if the two strings are different, or FALSE if they are equal.

  Equivalent to <code>strcmp(s1,s2) != 0</code>.
*/

/*!
  \fn bool operator!=( const char *s1, const Q1String &s2 )
  \relates Q1String
  Returns TRUE if the two strings are different, or FALSE if they are equal.

  Equivalent to <code>strcmp(s1,s2) != 0</code>.
*/

/*!
  \fn bool operator<( const Q1String &s1, const char *s2 )
  \relates Q1String
  Returns TRUE if \e s1 is alphabetically less than \e s2, otherwise FALSE.

  Equivalent to <code>strcmp(s1,s2) \< 0</code>.
*/

/*!
  \fn bool operator<( const char *s1, const Q1String &s2 )
  \relates Q1String
  Returns TRUE if \e s1 is alphabetically less than \e s2, otherwise FALSE.

  Equivalent to <code>strcmp(s1,s2) \< 0</code>.
*/

/*!
  \fn bool operator<=( const Q1String &s1, const char *s2 )
  \relates Q1String
  Returns TRUE if \e s1 is alphabetically less than or equal to \e s2,
  otherwise FALSE.

  Equivalent to <code>strcmp(s1,s2) \<= 0</code>.
*/

/*!
  \fn bool operator<=( const char *s1, const Q1String &s2 )
  \relates Q1String
  Returns TRUE if \e s1 is alphabetically less than or equal to \e s2,
  otherwise FALSE.

  Equivalent to <code>strcmp(s1,s2) \<= 0</code>.
*/

/*!
  \fn bool operator>( const Q1String &s1, const char *s2 )
  \relates Q1String
  Returns TRUE if \e s1 is alphabetically greater than \e s2, otherwise FALSE.

  Equivalent to <code>strcmp(s1,s2) \> 0</code>.
*/

/*!
  \fn bool operator>( const char *s1, const Q1String &s2 )
  \relates Q1String
  Returns TRUE if \e s1 is alphabetically greater than \e s2, otherwise FALSE.

  Equivalent to <code>strcmp(s1,s2) \> 0</code>.
*/

/*!
  \fn bool operator>=( const Q1String &s1, const char *s2 )
  \relates Q1String
  Returns TRUE if \e s1 is alphabetically greater than or equal to \e s2,
  otherwise FALSE.

  Equivalent to <code>strcmp(s1,s2) \>= 0</code>.
*/

/*!
  \fn bool operator>=( const char *s1, const Q1String &s2 )
  \relates Q1String
  Returns TRUE if \e s1 is alphabetically greater than or equal to \e s2,
  otherwise FALSE.

  Equivalent to <code>strcmp(s1,s2) \>= 0</code>.
*/

/*!
  \fn Q1String operator+( const Q1String &s1, const Q1String &s2 )
  \relates Q1String
  Returns the concatenated string of s1 and s2.
*/

/*!
  \fn Q1String operator+( const Q1String &s1, const char *s2 )
  \relates Q1String
  Returns the concatenated string of s1 and s2.
*/

/*!
  \fn Q1String operator+( const char *s1, const Q1String &s2 )
  \relates Q1String
  Returns the concatenated string of s1 and s2.
*/

/*!
  \fn Q1String operator+( const Q1String &s, char c )
  \relates Q1String
  Returns the concatenated string of s and c.
*/

/*!
  \fn Q1String operator+( char c, const Q1String &s )
  \relates Q1String
  Returns the concatenated string of c and s.
*/
