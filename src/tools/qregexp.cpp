/****************************************************************************
** $Id: //depot/qt/main/src/tools/qregexp.cpp#60 $
**
** Implementation of QRegExp class
**
** Created : 950126
**
** Copyright (C) 1992-1998 Troll Tech AS.  All rights reserved.
**
** This file is part of Troll Tech's internal development tree for Qt.
**
** This header text will be replaced by an appropriate text by the
** mkdist script which generates external distributions.
**
** If you are using the Qt Professional Edition or the Qt Free Edition,
** please notify Troll Tech at <info@troll.no> if you see this text.
**
** To Troll Tech developers: This header was generated by the script
** fixcopyright-int. It has the same number of text lines as the free
** and professional editions to avoid line number inconsistency.
**
*****************************************************************************/

#include "qregexp.h"
#include <ctype.h>
#include <stdlib.h>

/*!
  \class QRegExp qregexp.h
  \ingroup tools
  \ingroup misc
  \brief The QRegExp class provides pattern matching using regular expressions and wildcards.

  QRegExp knows these regexp primitives:
  <ul plain>
  <li><dfn>c</dfn> matches the character 'c'
  <li><dfn>.</dfn> matches any character
  <li><dfn>^</dfn> matches start of input (except [^x] which matches NOT [x])
  <li><dfn>$</dfn>  matches end of input
  <li><dfn>[]</dfn> matches a set of characters, for example [a-z0-9_]
  <li><dfn>a*</dfn> matches a sequence of zero or more a's
  <li><dfn>a+</dfn> matches a sequence of one or more a's
  <li><dfn>a?</dfn> matches an optional a
  <li><dfn>\c</dfn> escape code for matching special characters like \, [, *, +, . etc.
  <li><dfn>\b</dfn> matches the BELL character (7)
  <li><dfn>\t</dfn> matches the TAB character (9)
  <li><dfn>\n</dfn> matches newline (10)
  <li><dfn>\r</dfn> matches return (13)
  <li><dfn>\s</dfn> matches white space (9,10,11,12,13,32)
  <li><dfn>\x12</dfn> matches the character 0x12 (18 decimal, 12 hexadecimal).
  <li><dfn>\022</dfn> matches the character 022 (18 decimal, 22 octal).
  </ul>

  In wildcard mode, it only knows four primitives:
  <ul plain>
  <li><dfn>c</dfn> matches the character 'c'
  <li><dfn>?</dfn> matches any character
  <li><dfn>*</dfn> matches any sequence of characters
  <li><dfn>[]</dfn> matches a defined set of characters,
    e.g. [a-zA-Z0-9\.] matches upper and lower case ASCII letters, digits,
    and dot, and [^z] matches everything except lower-case z.
  </ul>
  
  When writing regular expressions in C++ code, remember that the C++
  preprocessor processes \ characters.  So in order to match e.g. a "."
  character, you must write "\\." in C++ source, not "\.".
*/


//
// The regexp pattern is internally represented as an array of uints,
// each element containing an 16-bit character or a 32-bit code
// (listed below).  User-defined character classes (e.g. [a-zA-Z])
// are encoded as this:
// uint no:	1		2		3		...
// value:	CCL | n		from | to	from | to
//
// where n is the (16-bit) number of following range definitions, and
// from and to define the ranges inclusive. from <= to is always
// true. Single characters in the class are coded as from==to.
// Negated classes (e.g. [^a-z]) use CCN instead of CCL.

const uint END	= 0x00000000;
const uint PWS	= 0x10010000;		// predef whitespace charclass \s
const uint CCL	= 0x20010000;		// character class	[]
const uint CCN	= 0x20020000;		// neg character class	[^]
const uint CHR	= 0x40000000;		// character
const uint BOL	= 0x80010000;		// beginning of line	^
const uint EOL	= 0x80020000;		// end of line		$
const uint BOW	= 0x80030000;		// beginning of word	\<
const uint EOW	= 0x80040000;		// end of word		\>
const uint ANY	= 0x80050000;		// any character	.
const uint CLO	= 0x80070000;		// Kleene closure	*
const uint OPT	= 0x80080000;		// Optional closure	?

const uint MCC  = 0x20000000;		// character class bitmask
const uint MCD  = 0xffff0000;		// code mask
const uint MVL  = 0x0000ffff;		// value mask

//
// QRegExp::error codes (internal)
//

const int PatOk		= 0;			// pattern ok
const int PatNull	= 1;			// no pattern defined
const int PatSyntax	= 2;			// pattern syntax error
const int PatOverflow	= 4;			// pattern too long


/*****************************************************************************
  QRegExp member functions
 *****************************************************************************/

/*!
  Constructs an empty regular expression.
*/

QRegExp::QRegExp()
{
    rxdata = 0;
    cs = TRUE;
    wc = FALSE;
    error = PatOk;
}

/*!
  Constructs a regular expression.

  \arg \e pattern is the regular expression pattern string.
  \arg \e caseSensitive specifies whether or not to use case sensitive
  matching.
  \arg \e wildcard specifies whether the pattern string should be used for
  wildcard matching (also called globbing expression), normally used for
  matching file names.

  \sa setWildcard()
*/

QRegExp::QRegExp( const QString &pattern, bool caseSensitive, bool wildcard )
{
    rxstring = pattern;
    rxdata = 0;
    cs = caseSensitive;
    wc = wildcard;
    compile();
}

/*!
  Constructs a regular expression which is a copy of \e r.
  \sa operator=(const QRegExp&)
*/

QRegExp::QRegExp( const QRegExp &r )
{
    rxstring = r.pattern();
    rxdata = 0;
    cs = r.caseSensitive();
    wc = r.wildcard();
    compile();
}

/*!
  Destroys the regular expression and cleans up its internal data.
*/

QRegExp::~QRegExp()
{
    if ( rxdata )                      // Avoid purify complaints
	delete [] rxdata;
}

/*!
  Copies the regexp \e r and returns a reference to this regexp.
  The case sensitivity and wildcard options are copied, as well.
*/

QRegExp &QRegExp::operator=( const QRegExp &r )
{
    rxstring = r.rxstring;
    cs = r.cs;
    wc = r.wc;
    compile();
    return *this;
}

/*!
  Sets the pattern string to \e pattern and returns a reference to this regexp.
  The case sensitivity or wildcard options do not change.
*/

QRegExp &QRegExp::operator=( const QString &pattern )
{
    rxstring = pattern;
    compile();
    return *this;
}


/*!
  Returns TRUE if this regexp is equal to \e r.

  Two regexp objects are equal if they have equal pattern strings,
  case sensitivity options and wildcard options.
*/

bool QRegExp::operator==( const QRegExp &r ) const
{
    return rxstring == r.rxstring && cs == r.cs && wc == r.wc;
}

/*!
  \fn bool QRegExp::operator!=( const QRegExp &r ) const

  Returns TRUE if this regexp is \e not equal to \e r.

  \sa operator==()
*/

/*!
  \fn bool QRegExp::isEmpty() const
  Returns TRUE if the regexp is empty.
*/

/*!
  \fn bool QRegExp::isValid() const
  Returns TRUE if the regexp is valid, or FALSE if it is invalid.

  The pattern "[a-z" is an example of an invalid pattern, since it lacks a
  closing bracket.
*/


/*!
  \fn bool QRegExp::wildcard() const
  Returns TRUE if wildcard mode is on, otherwise FALSE. \sa setWildcard().
*/

/*!
  Sets the wildcard option for the regular expression.	The default
  is FALSE.

  Setting \e wildcard to TRUE makes it convenient to match filenames
  instead of plain text.

  For example, "qr*.cpp" matches the string "qregexp.cpp" in wildcard mode,
  but not "qicpp" (which will be matched in normal mode).

  \sa wildcard()
*/

void QRegExp::setWildcard( bool wildcard )
{
    if ( wildcard != wc ) {
	wc = wildcard;
	compile();
    }
}

/*!
  \fn bool QRegExp::caseSensitive() const

  Returns TRUE if case sensitivity is enabled, otherwise FALSE.	 The
  default is TRUE.

  \sa setCaseSensitive()
*/

/*!
  Enables or disables case sensitive matching.

  In case sensitive mode, "a.e" matches "axe" but not "Axe".

  See also: caseSensitive()
*/

void QRegExp::setCaseSensitive( bool enable )
{
    if ( cs != enable ) {
	cs = enable;
	compile();
    }
}


/*!
  \fn QString QRegExp::pattern() const
  Returns the pattern string of the regexp.
*/


/*!
  Attempts to match in \e str, starting from position \e index.
  Returns the position of the match, or -1 if there was no match.

  If \e len is not a null pointer, the length of the match is stored in
  \e *len.

  If \e indexIsStart is TRUE (the default), the position \e index in
  the string will match the start-of-input primitive (^) in the
  regexp, if present. Otherwise, position 0 in \e str will match.

  Example:
  \code
    QRegExp r("[0-9]*\.[0-9]+");		// matches floating point
    int len;
    r.match("pi = 3.1416", 0, &len);		// returns 5, len == 6
  \endcode
*/

int QRegExp::match( const QString &str, int index, int *len,
		    bool indexIsStart ) const
{
    if ( error )			// cannot match ##null strings?
	return -1;
    if ( str.length() < (uint)index )
	return -1;
    const QChar *start = str.unicode();
    const QChar *p = start + index;
    uint pl = str.length() - index;
    uint *d  = rxdata;
    const QChar *ep = 0;

    if ( *d == BOL ) {				// match from beginning of line
	ep = matchstr( d, p, pl, indexIsStart ? p : start );
    } else {
	if ( *d & CHR ) {
	    if ( cs ) {				// case sensitive
		while ( pl && *p != (QChar)*d ) {
		    p++;
		    pl--;
		}
	    } else {				// case insensitive
		while ( pl && (QChar)tolower(*p) != (QChar)*d ) { //### uc...
		    p++;
		    pl--;
		}
	    }
	}
	while ( pl ) {				// regular match
	    if ( (ep=matchstr(d,p,pl, indexIsStart ? start+index : start )) )
		break;
	    p++;
	    pl--;
	}
    }
    if ( ep ) {					// match
	if ( len )
	    *len = ep - p;
	return (int)(p - start);		// return index
    } else {					// no match
	if ( len )
	    *len = 0;
	return -1;
    }
}

static inline bool iswordchar( int x ) //###
{
    return isalnum(x) || x == '_';
}


/*!
  \internal
  Match character class 
*/

bool matchcharclass( uint *rxd, QChar c )
{
    uint *d = rxd;
    uint clcode = *d & MCD;
    bool neg;
    if ( clcode == CCL )
	neg = FALSE;
    else if ( clcode == CCN )
	neg = TRUE;
    else
	warning("QRegExp: coding error!");
    uint numFields = *d & MVL;
    uint cval = (((uint)(c.row)) << 8) | ((uint)c.cell);
    bool found = FALSE;
    for ( int i = 0; i < (int)numFields; i++ ) {
	d++;
	if ( *d == PWS ) {
	    if ( isspace( c ) ) {
		found = TRUE;
		break;
	    }
	}
	else {
	    uint from = ( *d & MCD ) >> 16;
	    uint to = *d & MVL;
	    if ( (cval >= from) && (cval <= to) ) {
		found = TRUE;
		break;
	    }
	}
    }
    return neg ? !found : found;
}


/*!
  \internal
  Recursively match string.
*/

const QChar *QRegExp::matchstr( uint *rxd, const QChar *str, uint strlength, 
				const QChar *bol ) const
{
    const QChar *p = str;
    uint pl = strlength;
    uint *d = rxd;

    //### in all cases here: handle pl == 0! (don't read past strlen)
    while ( *d ) {
	if ( *d & CHR ) {			// match char
	    if ( !pl )
		return 0;
	    if ( cs ) {				// case sensitive
		if ( *p != (QChar)*d )
		    return 0;
		p++;
		pl--;
	    } else {				// case insensitive
		if ( (QChar)tolower(*p) != (QChar)*d ) //### uc...
		    return 0;
		p++;
		pl--;
	    }
	    d++;
	}
	else if ( *d & MCC ) {			// match char class
	    if ( !pl )
		return 0;
	    if ( !matchcharclass( d, *p ) )
		return 0;
	    p++;
	    pl--;
	    d += (*d & MVL) + 1;
	}
	else switch ( *d++ ) {
	    case PWS:				// match whitespace
		if ( !pl || !isspace( *p ) )
		    return 0;
		p++;
		pl--;
		break;
	    case ANY:				// match anything
		if ( !pl )
		    return 0;
		p++;
		pl--;
		break;
	    case BOL:				// match beginning of line
		if ( p != bol )
		    return 0;
		break;
	    case EOL:				// match end of line
		if ( pl )
		    return 0;
		break;
	    case BOW:				// match beginning of word
		if ( !iswordchar(*p) || (p > bol && iswordchar(*(p-1)) ) )
		    return 0;
		break;
	    case EOW:				// match end of word
		if ( iswordchar(*p) || p == bol || !iswordchar(*(p-1)) )
		    return 0;
		break;
	    case CLO:				// Kleene closure
		{
		const QChar *first_p = p;
		if ( *d & CHR ) {		// match char
		    if ( cs ) {			// case sensitive
			while ( pl && *p == (QChar)*d ) {
			    p++;
			    pl--;
			}
		    }
		    else {			// case insensitive
			while ( pl && (QChar)tolower(*p) == (QChar)*d ) { //### uc...
			    p++;
			    pl--;
			}
		    }
		    d++;
		}
		else if ( *d & MCC ) {			// match char class
		    while( pl && matchcharclass( d, *p ) ) {
			p++;
			pl--;
		    }
		    d += (*d & MVL) + 1;
		}
		else if ( *d == PWS ) {
		    while ( pl && isspace( *p ) ) {
			p ++;
			pl--;
		    }
		    d++;
		}
		else if ( *d == ANY ) {
		    p += pl;
		    pl = 0;
		    d++;
		}
		else {
		    return 0;			// error
		}
		d++;				// skip CLO's END
		const QChar *end;
		while ( p >= first_p ) {	// go backwards
		    if ( (end = matchstr(d,p,pl,bol)) )
			return end;
		    --p;
		    ++pl;
		}
		}
		return 0;
	    case OPT:				// optional closure
		{
		const QChar *first_p = p;
		if ( *d & CHR ) {		// match char
		    if ( cs ) {			// case sensitive
			if ( pl && *p == (QChar)*d ) {
			    p++;
			    pl--;
			}
		    }
		    else {			// case insensitive
			if ( pl && (QChar)tolower(*p) == (QChar)*d ) { // ### uc...
			    p++;
			    pl--;
			}
		    }
		    d++;
		}
		else if ( *d & MCC ) {			// match char class
		    if ( pl && matchcharclass( d, *p ) ) {
			p++;
			pl--;
		    }
		    d += (*d & MVL) + 1;
		}
		else if ( *d == PWS ) {
		    if ( pl && isspace( *p ) ) {
			p ++;
			pl--;
		    }
		    d++;
		}
		else if ( *d == ANY ) {
		    if ( pl ) {
			p++;
			pl--;
		    }
		    d++;
		}
		else {
		    return 0;			// error
		}
		d++;				// skip OPT's END
		const QChar *end;
		while ( p >= first_p ) {	// go backwards
		    if ( (end = matchstr(d,p,pl,bol)) )
			return end;
		    --p;
		    ++pl;
		}
		}
		return 0;

	    default:				// error
		return 0;
	}
    }
    return p;
}


//
// Translate wildcard pattern to standard regexp pattern.
// Ex:	 *.cpp	==> ^.*\.cpp$
//

static QString wc2rx( const QString &pattern )
{
    //const QChar *p = pattern.unicode();
    int patlen = (int)pattern.length();
    QString wcpattern = "^";

    QChar c;
    //while ( (c=*p++) ) {
    for( int i = 0; i < patlen; i++ ) {
	c = pattern[i];
	switch ( (char)c ) {
	case '*':				// '*' ==> '.*'
	    wcpattern += '.';
	    break;
	case '?':				// '?' ==> '.'
	    c = '.';
	    break;
	case '.':				// quote special regexp chars
	case '+':
	case '\\':
	case '$':
	case '^':
	    wcpattern += '\\';
	    break;
	case '[':
	    if ( (char)pattern[i+1] == '^' ) { // don't quote '^' after '['
		wcpattern += '[';
		c = pattern[i+1];
		i++;
	    }
	    break;
	}
	wcpattern += c;

    }
    wcpattern += '$';
    return wcpattern;				// return new regexp pattern
}


//
// Internal: Get char value and increment pointer.
//

static uint char_val( const QChar **str, uint *strlength )   // get char value
{
    const QChar *p = *str;
    uint pl = *strlength;
    uint len = 1;
    uint v = 0;
    if ( (char)*p == '\\' ) {			// escaped code
	p++;
	pl--;
	if ( !pl ) {				// it is just a '\'
	    (*str)++;
	    (*strlength)--;
	    return '\\';
	}
	len++;					// length at least 2
	int i = 0;
	char c;
	char ch = tolower((char)*p);
	switch ( ch ) {
	    case 'b':  v = '\b';  break;	// bell
	    case 'f':  v = '\f';  break;	// form feed
	    case 'n':  v = '\n';  break;	// newline
	    case 'r':  v = '\r';  break;	// return
	    case 't':  v = '\t';  break;	// tab
	    case 's':  v = PWS; break;		// whitespace charclass
	    case '<':  v = BOW; break;		// word beginning matcher
	    case '>':  v = EOW; break;		// word ending matcher

	    case 'x': {				// hex code
		p++;
		pl--;
		for ( i = 0; (i < 4) && pl; i++ ) {	//up to 4 hex digits
		    c = tolower((char)*p);
		    bool a = ( c >= 'a' && c <= 'f' );
		    if ( (c >= '0' && c <= '9') || a ) {
			v <<= 4;
			v += a ? 10 + c - 'a' : c - '0';
			len++;
		    }
		    else {
			break;
		    }
		    p++;
		    pl--;
		}
	    }
	    break;

	    default: {
		if ( ch >= '0' && ch <= '7' ) {	//octal code
		    len--;
		    for ( i = 0; (i < 3) && pl; i++ ) {	// up to 3 oct digits
			c = tolower((char)*p);
			if ( c >= '0' && c <= '7' ) {
			    v <<= 3;
			    v += c - '0';
			    len++;
			}
			else {
			    break;
			}
			p++;
			pl--;
		    }
		}
		else {				// not an octal number
		    v = (((uint)(p->row)) << 8) | ((uint)p->cell);
		}
	    }
	}
    } else {
	v = (((uint)(p->row)) << 8) | ((uint)p->cell);
    }
    *str += len;
    *strlength -= len;
    return v;
}


#if defined(DEBUG)
static uint *dump( uint *p )
{
    while ( *p != END ) {
	if ( *p & CHR ) {
	    QChar uc = (QChar)*p;
	    char c = (char)uc;
	    uint u = (((uint)(uc.row)) << 8) | ((uint)uc.cell);
	    debug( "\tCHR\tU%04x (%c)", u, (c ? c : ' '));
	    p++;
	}
	else if ( *p & MCC ) {
	    uint clcode = *p & MCD;
	    uint numFields = *p & MVL;
	    if ( clcode == CCL )
		debug( "\tCCL\t%i", numFields );
	    else if ( clcode == CCN )
		debug( "\tCCN\t%i", numFields );
	    else
		debug("coding error!");
	    for ( int i = 0; i < (int)numFields; i++ ) {
		p++;
		if ( *p == PWS )
		    debug( "\t\tPWS" );
		else {
		    uint from = ( *p & MCD ) >> 16;
		    uint to = *p & MVL;
		    char fc = (char)QChar(from);
		    char tc = (char)QChar(to);
		    debug( "\t\tU%04x (%c) - U%04x (%c)", from,
			   (fc ? fc : ' '), to, (tc ? tc : ' ') );
		}
	    }
	    p++;
	}
	else switch ( *p++ ) {
	    case PWS:
		debug( "\tPWS" );
		break;
	    case BOL:
		debug( "\tBOL" );
		break;
	    case EOL:
		debug( "\tEOL" );
		break;
	    case BOW:
		debug( "\tBOW" );
		break;
	    case EOW:
		debug( "\tEOW" );
		break;
	    case ANY:
		debug( "\tANY" );
		break;
	    case CLO:
		debug( "\tCLO" );
		p = dump( p );
		break;
	    case OPT:
		debug( "\tOPT" );
		p = dump( p );
		break;
	}
    }
    debug( "\tEND" );
    return p+1;
}
#endif // DEBUG


static const int maxlen = 1024;			// max length of regexp array
static uint rxarray[ maxlen ];			// tmp regexp array

/*!
  \internal
  Compiles the regular expression and stores the result in rxdata.
  The 'error' flag is set to non-zero if an error is detected.
  NOTE! This function is not reentrant!
*/

void QRegExp::compile()
{
    if ( rxdata ) {				// delete old data
	delete [] rxdata;
	rxdata = 0;
    }
    if ( rxstring.isEmpty() ) {			// no regexp pattern set
	error = PatNull;
	return;
    }

    error = PatOk;				// assume pattern is ok

    QString pattern;
    if ( wc )
	pattern = wc2rx(rxstring);
    else
	pattern = rxstring;
    const QChar *start = pattern.unicode();	// pattern pointer
    const QChar *p = start;			// pattern pointer
    uint pl = pattern.length();
    uint *d = rxarray;				// data pointer
    uint *prev_d = 0;

#define GEN(x)	*d++ = (x)

    while ( pl ) {
	char ch = (char)*p;
	switch ( ch ) {

	    case '^':				// beginning of line
		prev_d = d;
		GEN( p == start ? BOL : (CHR | ch) );
		p++;
		pl--;
		break;

	    case '$':				// end of line
		prev_d = d;
		GEN( pl == 1 ? EOL : (CHR | ch) );
		p++;
		pl--;
		break;

	    case '.':				// any char
		prev_d = d;
		GEN( ANY );
		p++;
		pl--;
		break;

	    case '[':				// character class
		{
		prev_d = d;
		p++;
		pl--;
		if ( !pl ) {
		    error = PatSyntax;
		    return;
		}
		bool firstIsEscaped = ( (char)*p == '\\' );
		uint cch = char_val( &p, &pl );
		if ( cch == '^' && !firstIsEscaped ) {	// negate!
		    GEN( CCN );
		    if ( !pl ) {
			error = PatSyntax;
			return;
		    }
		    cch = char_val( &p, &pl );
		} else {
		    GEN( CCL );
		}
		uint numFields = 0;
		while ( pl ) {
		    if ( ( pl>2 ) && ((char)*p == (uint)'-') && 
			 ((char)*(p+1) != (uint)']') ) {
			// Found a range
			uint cch2 = char_val( &p, &pl ); // Read the '-'
			cch2 = char_val( &p, &pl ); // Read the range end
			if ( cch > cch2 ) { 		// swap start and stop
			    int tmp = cch;
			    cch = cch2;
			    cch2 = tmp;
			}
			GEN( (cch << 16) | cch2 );	// from < to
			numFields++;
		    }
		    else {
			// Found a single character
			if ( cch & MCD ) // It's a code; will not be mistaken
			    GEN( cch );	 // for a range, since from > to
			else
			    GEN( (cch << 16) | cch ); // from == to range
			numFields++;
		    }
		    if ( !pl ) {		// At least ']' should be left
			error = PatSyntax;
			return;
		    }
		    if ( d >= rxarray + maxlen ) {	// pattern too long
			error = PatOverflow;		
			return;
		    }
		    cch = char_val( &p, &pl );
		    if ( cch == (uint)']' )
			break;
		}
		*prev_d |= numFields;		// Store number of fields
		}
		break;

	    case '*':				// Kleene closure, or
	    case '+':				// positive closure, or
	    case '?':				// optional closure
		{
		if ( prev_d == 0 ) {		// no previous expression
		    error = PatSyntax;		// empty closure
		    return;
		}
		switch ( *prev_d ) {		// test if invalid closure
		    case BOL:
		    case BOW:
		    case EOW:
		    case CLO:
		    case OPT:
			error = PatSyntax;
			return;
		}
		int ddiff = d - prev_d;
		if ( *p == '+' ) {		// convert to Kleene closure
		    if ( d + ddiff >= rxarray + maxlen ) {
			error = PatOverflow;	// pattern too long
			return;
		    }
		    memcpy( d, prev_d, ddiff*sizeof(uint) );
		    d += ddiff;
		    prev_d += ddiff;
		}
		memmove( prev_d+1, prev_d, ddiff*sizeof(uint) );
		*prev_d = ch == '?' ? OPT : CLO;
		d++;
		GEN( END );
		p++;
		pl--;
		}
		break;

	    default:
		{
		prev_d = d;
		uint c = char_val( &p, &pl );
		if ( c & MCD ) {			// It's a code
		    GEN( c );
		}
		else {
		    if ( !cs && c < 256 )	//### uctolower?
			c = tolower( c );
		    GEN( CHR | c );
		}
		}
	}
	if ( d >= rxarray + maxlen ) {		// oops!
	    error = PatOverflow;		// pattern too long
	    return;
	}
    }
    GEN( END );
    int len = d - rxarray;
    rxdata = new uint[ len ];			// copy from rxarray to rxdata
    CHECK_PTR( rxdata );
    memcpy( rxdata, rxarray, len*sizeof(uint) );
#if defined(DEBUG)
    //dump( rxdata );	// uncomment this line for debugging
#endif
}
