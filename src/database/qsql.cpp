#include "qsql.h"

#ifndef QT_NO_SQL

#include "qsqlresult.h"
#include "qsqldriver.h"

QSqlResultShared::~QSqlResultShared()
{
    if ( sqlResult )
	delete sqlResult;
}

/*! \class QSql qsql.h
  
    \brief Class used for executing and manipulating SQL queries.

    \module database

    This class is used to execute SQL queries on a QSqlDatabase.  QSql
    encapsulates the functionality involved in creating, navigating
    and retrieving data from SQL queries.  This class works with QSqlResult
    to form a simple, but flexible, interface to SQL database engines.

    Once an SQL result is created, it is initially in an inactive state.
    A result becomes active when it is supplied with a SQL query (see operator<<) (see
    isActive()).  Alternatively, use the QSqlDatabase::query() or QSqlDatabase::exec()
    convenience methods to create active QSqlResult objects.

    An active result object must be 'scrolled' to valid records within the
    SQL query as generated by the SQL database.  Data cannot be accessed until
    the result is positioned on a valid record (see isValid()).  To 'scroll', or
    navigate, through the result set, use the following methods:

    <ul>
    <li>next()
    <li>previous()
    <li>first()
    <li>last()
    <li>seek()
    </ul>

    These methods allow the programmer to move forward, backward or randomly through the records
    returned by the query.  Once an active result object is positioned on a valid record, data can
    be retrieved using operator[].

    For example:

    /code
    QSql mySql = myDatabase->query("select name from customer;");
    while ( mySql->next() ) {
	QString name = mySql[0];
	DoSomething( name );
    }
    /endcode


    To obtain additional information about a QSql object, use info() (see
    QSqlResultInfo).

    \sa QSql QSqlResultInfo QSqlDriver QSqlResult
*/

/*! \fn QSql::QSql( QSqlResult * r )
    Creates a QSql object which uses QSqlResult to communicate with a database.  QSql is implicitly
    shared.
*/

/*! Destroys the object and frees any allocated resources.

*/

QSql::~QSql()
{
    qDebug("~QSql()");
    if (d->deref()) {
	delete d;
    }
}

/*! \fn QSql::QSql( const QSql& other )
    Copy constructor.  QSql is implicitly shared.
*/

/*! \fn QSql& QSql::operator=( const QSql& other )
    Assigns \a other.  QSql is implicitly shared.
*/

/*!  Returns TRUE if field \a field is NULL, otherwise returns FALSE.  The result
     must be active and valid before calling this method.  In addition, for some drivers,
     isNull() will not return accurate information until after an attempt is made to retrieve
     data (see operator[]).

     \sa isActive() isValid() operator[]

*/

bool QSql::isNull( int field ) const
{
    if ( d->sqlResult->isActive() && d->sqlResult->isValid() )
	return d->sqlResult->isNull( field );
    return FALSE;
}

/*! Applies the SQL \a query.  The \a query string must use SQL syntax appropriate for the SQL database
    being queried.

    The QSql object is reset to an invalid state, and must be positioned to
    a valid record before data values can be retrieved.

    If this operation fails, the QSql object is reset to an inactive state.

    \sa isActive(), isValid(), next(), previous(), first(), last()

*/

bool QSql::operator<< ( const QString& query )
{
    d->sqlResult->setActive( FALSE );
    d->sqlResult->setAt( QSqlResult::BeforeFirst );
    d->sqlResult->sql = query.stripWhiteSpace();
    if ( !driver()->isOpen() || driver()->isOpenError() )
	return FALSE;
    return d->sqlResult->reset( query );
}

/*! Returns the value of field \a i (zero based) in the result as reported by the database, or
    QVariant() if it cannot be determined.
    Note that the result must be active and positioned on a valid record.

    \sa previous(), next(), first(), last(), seek(), isActive(), isValid()

*/

QVariant QSql::operator[] ( int i )
{
    if ( isActive() && isValid() && ( i > QSqlResult::BeforeFirst ) ) {
	return d->sqlResult->data( i );
    }
    return QVariant();
}

/*! Retrieves current index of the result.  If the index is invalid, a
    QSqlResult::Location will be returned indicating the position.

    \sa isValid()

*/

int QSql::at() const
{
    return d->sqlResult->idx;
}


/*! Returns the current query used, or QString::null if there is none.

*/

QString QSql::query() const
{
    return d->sqlResult->sql;
}

/*! Returns the database driver associated with the result.

*/

const QSqlDriver* QSql::driver() const
{
    return d->sqlResult->sqldriver;
}

/*! Positions the result to a random index \a i.  If \a relative is TRUE,
    the index is moved relative to the current index.  If successful,
    TRUE is returned. If the record is not available, FALSE is returned.

    If \a relative==FALSE, the following rules apply:
    If \a i is negative, the result is positioned before the first record and FALSE is returned.
    Otherwise, an attempt is made to move to the record at index \a i.

    If \a relative==TRUE, the following rules apply:
    If the result is currently located before the first record or on the first
    record, and \a i is  negative, there is no change, and FALSE is returned.
    If the result is currently located after the last record, and \a i is
    positive, there is no change, and FALSE is returned.
    If the result is currently located somewhere in the middle, and the relative
    offset \a i moves the result below zero, the result is positioned before the
    first record and FALSE is returned.
    Otherwise, an attempt is made to move the result.  If the attempt fails, the
    result is positioned after the last record, and FALSE is returned.

*/
bool QSql::seek( int i, bool relative )
{
    if ( isActive() ) {
        int actualIdx;
	if ( !relative ) { // random seek
	    if ( i < 0 ) {
		d->sqlResult->setAt( QSqlResult::BeforeFirst );
		return FALSE;
	    }
	    actualIdx = i;
	}
	else {
	    switch ( at() ) { // relative seek
	    	case QSqlResult::BeforeFirst:
		    if ( i > 0 )
		    	actualIdx = i;
		    else
			return FALSE;
		    break;
		case QSqlResult::AfterLast:
		    if ( i < 0 )
		    	actualIdx = i;
		    else
			return FALSE;
		    break;
		default:
		    if ( ( at() + i ) < 0  ) {
		    	d->sqlResult->setAt( QSqlResult::BeforeFirst );
			return FALSE;
		    }
		    actualIdx = i;
		    break;
	    }
	}
	// let drivers optimize
	if ( actualIdx == ( at() + 1 ) ) {
	    if ( !d->sqlResult->fetchNext() ) {
	    	d->sqlResult->setAt( QSqlResult::AfterLast );
		return FALSE;
	    }
	}
	if ( actualIdx == ( at() - 1 ) ) {
	    if ( !d->sqlResult->fetchPrevious() ) {
	    	d->sqlResult->setAt( QSqlResult::BeforeFirst );
		return FALSE;
	    }
	}
	if ( !d->sqlResult->fetch( actualIdx ) ) {
	    d->sqlResult->setAt( QSqlResult::AfterLast );
	    return FALSE;
	}
	return TRUE;
    } else
	return FALSE;
}

/*! Retrieves the next record in the result, if available.  Note that the result must be in an active
    state before calling this method.  The following rules apply:

    If the result is currently located before the first record, an attempt is made to get the first record.
    If the result is currently located after the last record, there is no change and FALSE is returned.
    If the result is located somewhere in the middle, an attempt is made to get the next record.

    In any case, if the record could not be retrieved, the result is positioned after the last record
    and FALSE is returned. If the record is successfully retrieved, TRUE is returned.

    \sa at()

*/

bool QSql::next()
{
    if ( isActive() ) {
	switch ( at() ) {
	    case QSqlResult::BeforeFirst:
	    	return d->sqlResult->fetchFirst();
	    case QSqlResult::AfterLast:
		return FALSE;
	    default:
		if ( !d->sqlResult->fetchNext() ) {
		    d->sqlResult->setAt( QSqlResult::AfterLast );
		    return FALSE;
		}
        	return TRUE;
	}
    }
    return FALSE;
}

/*! Positions the result to the previous record in the result, if available.  Note that the result must
    be in an active state before calling this method.  The following rules apply:

    If the result is currently located before the first record, there is no change and FALSE is returned.
    If the result is currently located after the last record, an attempt is made to get the last record.
    If the result is somewhere in the middle, an attempt is made to get the previous record.

    In any case, is the record could not be retrieved, the result is positioned before the first record
    and FALSE is returned.  If the record is successfully retrieved, TRUE is returned.

    \sa at()

*/

bool QSql::previous()
{
    if ( isActive() ) {
	switch ( at() ) {
	    case QSqlResult::BeforeFirst:
		return FALSE;
	    case QSqlResult::AfterLast:
		return d->sqlResult->fetchLast();
	    default:
		if ( !d->sqlResult->fetchPrevious() ) {
		    d->sqlResult->setAt( QSqlResult::BeforeFirst );
		    return FALSE;
		}
        	return TRUE;
	}
    }
    return FALSE;
}

/*! Positions the result to the first record of an active result.  Returns TRUE on success, FALSE otherwise.
    Note that the result must be in an active state before calling this method.

*/

bool QSql::first()
{
    if ( isActive() )
	return d->sqlResult->fetchFirst();
    return FALSE;
}

/*! Positions the result to the last record of an active result.  Returns TRUE on success, FALSE otherwise.
    Note that the result must be in an active state before calling this method.

*/

bool QSql::last()
{
    if ( isActive() )
	return d->sqlResult->fetchLast();
    return FALSE;
}

/*! Returns a pointer to a QSqlResultInfo object, which can be queried for information about the result.

    \sa QSqlResultInfo

*/

const QSqlResultInfo* QSql::info()
{
    return d->sqlResult->info();
}

/*! Returns a QSqlError object which contains information about the last error (if any) that occurred.

    \sa QSqlError

*/

QSqlError QSql::lastError() const
{
    return d->sqlResult->error;
}

bool QSql::isValid() const
{
    return d->sqlResult->isValid();
}

bool QSql::isActive() const
{
    return d->sqlResult->isActive();
}

#endif // QT_NO_SQL
