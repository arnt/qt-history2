/****************************************************************************
** $Id: index.doc,v 1.8 1999/06/16 20:04:48 agulbra Exp $
**
** Index page
**
** Copyright (C) 1999-2000 by Troll Tech AS.  All rights reserved.
**
*****************************************************************************/

#if defined(DEBUG)
static char ident[] = "$Id: index.doc,v 1.8 1999/06/16 20:04:48 agulbra Exp $";
#endif

/*! \page xembed.html

<title>Qt XEmbed</title>
</head>

<body bgcolor=#ffffff>
<h1 align=center>Qt XEmbed - run applications in a subwidget</h1>

<hr>

Qt XEmbed is an \l experimental Qt extension that supports graphical
embedding of external Qt applications running X11.

<h2>Information</h2>

The XEmbed extension contains a signal widget, \l QXEmbed. It serves
as a container that can manage one single embedded X-window. These
so-called client windows can be arbitrary QWidgets.

Using xembed has a couple of significant advantages compared to a
low-level call of XReparentWindow

  <ul>
  <li> The embedded window is integrated into the outer application's
  focus chain. With a plain XReparentWindow, it's unpredictable which
  application will get the focus and process key events.
  <li> The outer application always receives keyevents
  first. Therefore menu accelerators and other shortcuts continue to
  work.
  <li> The XDND drag and drop protocol is routed respectively. Plain
  XReparentWindow would break drag and drop for the embedded window.
  </ul>

QXEmbed, however, also manages non-Qt windows. But as long as these
windows do not support the Qt embedding protocol, the specific
advantages are lost. This will result in completely broken and
unpredictable focus handling, broken accelerators and disfunctional
XDND drag and drop.

<h2> Background </h2>

Qt XEmbed was developed as part of some component model research done
within the KDE project in early 1999. By that time, embedding of
XWindows was basically done with XReparentWindow plus some crude
XSetInputFocus hacks. As negative side effect, higher-level features
like keyboard accelerators or drag and drop were broken in
applications using this technique, sometimes even ordinary input focus
didn't work at all. This was were we started experimenting with
xembed. By today, KDE dropped embedding of external processes almost
complety. Instead, it loades components as shared libraries
dynamically via dlopen(), a strongly recommended technique for this
kind of task.

But since history has shown that X11 programmers want to use
XReparentWindow from time to time, we decided not to hide this code
but rather distribute it as experimental extensions.

Note that the extension itself only contains half of the xembed
technology. The other half had to be implemented deep inside Qt's X11
kernel. For that reason, you always have to use xembed together with
the respective Qt version.

<h2> Warning </h2>

The extension is experimental. Therefore we cannot guarantee to
continue supporting the currently underlying protocol. It may happen
that applications relying on xembed may have to be recompiled with (or
dynamically linked to) a new version of xembed when upgrading Qt.

<h2>How-to</h2>

See the \l QXEmbed class documentation and the include shell/container 
example for details on using xembed.

<h2>Known Bugs</h2>

This extension is experimental.  The following problems exist:

<ul>
 <li> Micro focus hint not routed.
 <li> What's This? help mode not routed.
</ul>
*/
