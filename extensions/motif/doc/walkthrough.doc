/* Walkthrough for the Motif Extension */

/*! \page motif-walkthrough.html
    \title Qt Motif Extension - A Migration Walkthrough

\tableofcontents

\section1 Introduction

This walkthrough covers a complete migration of a Motif based program
to the Qt toolkit using the \e {Qt Motif Extension}.

It is rarely practical for a large project with hundreds of thousands
or even millons of lines of code to be migrated all at once; such an
endeavor would require too many development resources and would incur
significant risks. Every line of code would have to be rewritten,
every user interface redesigned, and quality assurance tests and
procedures all rewritten. The \e {Qt Motif Extension} provides a
complete and working solution for incremental migration that can be
paced to suit each individual project and the available resources. The
user interface and related code can be migrated in steps while the
rest of the project need not be changed at all.

This document is intended for programmers who will be migrating an
existing Motif based project to the Qt toolkit. We assume that they
have experience with C/C++ and Xt/Motif. Some experience with the Qt
toolkit is also necessary. For developers completely new to Qt we
recommend following the learning plan outlined in \link
how-to-learn-qt.html How to Learn Qt\endlink; or to go on a Qt
training course. (See \link http://www.trolltech.com\endlink for
details of training courses.)

\section2 Goals for this Document

The goal of this document is to provide the reader with enough
knowledge to migrate Motif applications to the Qt toolkit. We will do
this by example: We will convert a real-world Motif based program
step-by-step. This walkthrough will discuss both techniques and their
rationales throughout the process.

We will use the \e todo demo program included with the Motif 2.x
distribution as our migration project. This walkthrough contains
references to the source code, which is included in the \c
extensions/motif/examples/walkthrough subdirectory.

\section1 Prerequisites

Before we can start using the \e {Qt Motif Extension}, we must satisfy
three requirements.

\list 1
\i Ensure you are using X11R6.x and Motif 2.x libraries
\i Ensure your project is compilable by a C++ compiler
\i Build and install the \e {Qt Motif Extension}
\i Build and link your project with the Qt toolkit and the \e
{Qt Motif Extension}
\endlist

\section2 X11R6.x and Motif 2.x libraries

The mechanisms used by the \e {Qt Motif Extension} require development
headers and libraries from the X11R6 release and the Motif 2.0
release. Newer versions of these can also be used.

\section2 C++ Compiler

Since Qt is a C++ toolkit, all new code will be written in C++. In
order for existing code to coexist with new code, a C++ compiler must
be able to compile the existing code.

It is possible to keep existing code and new code separate, and only
convert or rewrite existing code as needed. This is a normal part
of the migration process, and does not need to be done before the
migration process begins. This is the most common scenario, and we
will demonstrate it by migrating existing C code to C++ as needed in
this walkthrough.

\section2 Build and Install the Qt Motif Extension

The \e {Qt Motif Extension} is not built and installed along with the
Qt toolkit. The extension resides in the \c extensions/motif
subdirectory. Run \e make in this directory to build the extension
and the examples. Once the extension has been built, run \e {make
install}

\code
    $ cd extensions/motif
    $ make
    $ make install
\endcode

The \e {Qt Motif Extension} is now installed and ready to use.

\section2 Build and link your project with the Qt toolkit and the Qt
Motif Extension

For simplicity, we use \e qmake to create the \c Makefile. The \c
-project option causes \e qmake to automatically generate a project
file. After \e {qmake -project} has generated our project file, we
run \e qmake again to generate a \c Makefile. Now, we can just run \e
make to build our project.

\code
    $ qmake -project
    $ qmake
    $ make
\endcode

Everything builds correctly, but fails to link because we don't link
with the Motif library. We tell \e qmake to do this by adding the \c
-lXm to the \c LIBS variable in our project file. Since we are
planning to use the \e {Qt Motif Extension} in this project as well,
we should also add \c -lqmotif to the list of libraries.

\code
    LIBS += -lXm -lqmotif
\endcode

Now we regenerate our \c Makefile by running \c qmake again, and
rebuild using \c make. This time, our project succesfully links, and
the application runs as expected.

We are now ready to start using the \e {Qt Motif Extension}.

\section1 Getting Started

\section2 Starting with QMotif and QApplication

To be able to use Qt, we need to create a QApplication object. The
QApplication class controls all the event delivery and display
management for all other Qt objects and widgets. We need to use the
QMotif class from the \e {Qt Motif Extension} to allow QApplication
and the \c XtAppContext to coexist.

The QApplication object must be created in the \c main() function,
We will need to modify \c {todo.c} to compile with a C++ compiler, so we
rename \c {todo.c} to \c {todo.cpp}.

Next, we add the appropriate includes for the QMotif and QApplication
classes.

\quotefile walkthrough/todo-gettingstarted.cpp

\skipto REV_INFO
\printuntil pwd.h

Next, we create the QMotif and QApplication objects. We create QMotif
with a foreign \c XtAppContext, and we create QApplication with a
foreign \c Display.

\skipto XtVaAppInitialize
\printuntil XtManageChild

The next change is not yet necessary, but it is included to show that
the \e {Qt Motif Extension} provides a complete intregration.
Normally, a Motif based program would use the \c XtAppMainLoop()
function to run the application's event loop. This is still possible,
but since we are migrating to the Qt toolkit, we would like to use the
QApplication::exec() function for running the event loop.

\skipuntil Eventloop integration
\printuntil }

Since we renamed \c {todo.c} to \c {todo.cpp}, we must change the
project file and rerun \e qmake to regenerate our \c Makefile. When we
build our project, there are compile and link errors.

\section2 Migrating to C++

We need to convert the code in this file to proper C++ code.
Fortunately, the changes are not too large. Most files included from
existing C projects are not C++ compatible, so we make them compatible
by wrapping them in an \c {extern "C"} block.

\quotefile walkthrough/todo-gettingstarted.cpp

\skipuntil Wrap non-standard includes
\printuntil } // extern "C"

Global C functions that are forward declared must also be wrapped into
an \c {extern "C"} block.

\skipuntil Wrap extern/callback functions and global variables with extern "C"
\printuntil } // extern "C"

The \c manageCB() function needs to be converted to proper C++.

\skipuntil Use proper C++ function declarations
\printuntil }

And we need to fix two invalid casts. One is in the \c Save() function.

\skipuntil Temporarily fix invalid casts
\printuntil SaveDB

The other invalid cast is in the \c Open() function.

\skipuntil Temporarily fix invalid casts
\printuntil ReadDB

After these changes, the project compiles and links, and the
application runs and operates correctly.

\section1 Migrating the User Interface

We are ready to start migrating the user interface for our project.
As mentioned in the introduction, we do this in steps, ensuring that
our application is still usable at every step of the migration process. 

The user interface can be viewed as a heirarchy; each top-level window
and dialog depends upon a parent (which is another top-level window or
dialog). When using the Motif \c XmMainWindow widgets, these should
be viewed as two separate entities: the \e {Main Window} widget with
the popup-menu heirarchy and the \e View widget contained in the \e
{Main Window} widget. The \e View widget depends on the \e {Main
Window} widget.

We begin migrating the pieces that have no dependencies, and work our
way up the dependency tree until all pieces have been migrated.

The heirarchy for this project looks something like this:

\img motif-todo.png Motif Todo Hierarchy

We will begin by migrating and replacing all of the dialogs, then the
\e {Main Window} widget with popup-menu heirarchy, and finally the \e
View widget.

However, we are not ready to begin just yet. The migration process
can be long, but it does not have to be difficult. The \e Open, \e
{Save As}, \e {Page Delete} and \e {IO Error} dialogs use a Motif
predefined dialog type. Qt provides similar functionality with
QFileDialog and QMessageBox, which we can begin using immediately.

The \e Print and \e Help dialogs are special, however. The \e Print
dialog cannot be replaced until after we have replaced the \e View
widget. Qt provides a complete printing mechanism with QPrinter, but
we cannot start using it until we have replaced the \e View widget.
Instead of replacing the \e Help dialog with a custom QDialog, we will
use the \link helpsystem.html Qt Help System\endlink classes to
provide a more advanced online help.  However, we cannot start using
classes like QToolTip and QWhatsThis until we replace the \e {Main
Window} and \e View widgets.

NOTE: The help text included with the original project is very small
and only contains information about the XmNoteBook widget.  The use of
tooltips and whats-this text will suffice for this example.  If your
migration project already has a large online help system, we recommend
looking at the \link helpviewer-example.html Simple HTML Help
Browser\endlink example for information on how to build an rich text
help system with hypertext navigation and full printing capabilities.

\section2 Using Qt Standard Dialogs

We start by using two of the \link dialogs.html Qt Standard
Dialogs\endlink: QFileDialog and QMessageBox. Both of these classes
provide static convenience functions that we can use.

\list
\i QFileDialog::getOpenFileName() -- replacement for the \e Open dialog
\i QFileDialog::getSaveFileName() -- replacement for the \e {Save As} dialog
\i QMessageBox::information() -- replacement for \e {Page Delete} dialog
\i QMessageBox::warning() -- replacement for \e {IO Error} dialog.
\endlist

Each of these functions takes a \c {QWidget *parent} argument. If we
pass zero as the \e parent argument, then we will have dialogs that
are centered on the screen, instead of being centered over our main
window. We can have QMotifWidget create our \c XmMainWindow, and we
can then use this class as the parent for both Motif dialogs and Qt
dialogs.

We need to include the appropriate headers for QMotifWidget and
QFileDialog.

\quotefile walkthrough/todo.cpp

\skipto Qt includes
\printuntil qmotifwidget.h

Next, we make a few modifications to how the application is
initialized. We could initialize Xt/Motif and create the \c
XtAppContext ourselves, but QMotif can do this for us.
We also let QApplication open the connection to the X server. Next,
we create a QMotifWidget, passing \c xmMainWindowWidgetClass as the \e
widgetclass argument. We can now use the QMotifWidget::motifWidget()
function to access the Motif widget. The shell widget is created
automatically by QMotifWidget. We use \c XtParent() to access it.
The top-level window is now a QMotifWidget, which means we can use it
as the parent for the Qt Standard Dialogs.

\skipto QMotif integrator
\printuntil XtManageChild

\section3 Replacing the \e {Open} and \e {Save As} dialogs

First, we completely remove all use of the existing Motif file
selection dialog. We remove the \c Xm/FileSB.h include, the global \c
file_dialog variable, and the code to create the dialog. We also
remove the \c PresentFDialog() callback function. None of this code
is needed to use QFileDialog.

Since we removed the \c PresentFDialog() callback function, we need to
make \e Open and \e {Save As} popup-menu callbacks call the \c Open()
and \c Save() functions.

First we must change the declaration of these two functions.

\quotefile walkthrough/todo.cpp

\skipto Wrap extern/callback functions and global variables with extern "C"
\skipto void Open
\printto void Print

We also change the arguments to the callbacks. We pass the top-level
QMotifWidget as the \c client_data to these functions, since we will
be using this as the parent for the QFileDialog.

\skipto XmdCreateMenu(FILE_MENU
\printuntil (XtCallbackProc) SaveIt

Next, we modify the \c Save() function to use
QFileDialog::getSaveFileName().

\skipuntil Save using QFileDialog
\printuntil SaveDB

... and the \c Open() function to use QFileDialog::getOpenFileName().

\skipuntil Open using QFileDialog
\printuntil ReadDB

After we build the project, the application runs and operates as
expected. The difference is that the \e Open and \e {Save As} dialogs
now use QFileDialog.

\section3 Replacing the \e {Page Delete} and \e {IO Error} dialogs

The \e {Page Delete} dialog is created and used in \c {actions.c}. We
need to migrate this file to C++. We rename it to \c {actions.cpp},
modify the project file and regenerate the \c Makefile.

The changes required to make \c {actions.cpp} compile are minimal. We
need to wrap more C header files and global variables in an \c {extern
"C"} block.

\quotefile walkthrough/actions.cpp

\skipuntil Wrap non-standard includes and global variables with extern "C"
\printuntil extern int maxpages

We need to forward declare the \c NewPage(), \c DeletePage(), \c
EditPage() and \c SaveIt() functions so that the compiler generates
the correct symbols for these functions.

\printuntil } // extern "C"

We need to fix a single invalid pointer cast.

\skipto // XtFree((XtPointer) pages[currentPage]);
\printline
\printline

And we need to change the variable name \e new in the \c Trim()
function.

\skipuntil Change variable name 'new'
\printuntil return(newstr);
\printline

We can now change the \c DeletePage() function to use
QMessageBox::information().

First, we need to make sure we include the proper header for
QMessageBox and QMotifWidget.

\quotefile walkthrough/actions.cpp

\skipto Qt includes
\printline
\printline
\printline

The code for \c DeletePage() looks like this:

\skipuntil DeletePage using QMessageBox
\printuntil return

At this point in the code, the page should be deleted. The code to do
this is in the \c DoDeletePage() function. We move the contents of \c
DoDeletePage() to this point and remove the \c DoDeletePage() function
completely.

Next, we change \c {todo.cpp} to pass the top-level QMotifWidget as the
\c client_data tot he \c DeletePage() function.

\quotefile walkthrough/todo.cpp

\skipto XtManageChild(selected_menu[SELECTED_DELETE]);
\printuntil (XtCallbackProc) DeletePage, (XtPointer) &toplevel

The \e {IO Error} dialog is created and used in \c {io.c}. We need to
migrate this file to C++. We rename it to \c {io.cpp}, modify the
project file and regenerate the \c Makefile.

The changes required to make \c {io.cpp} compile are minimal. We need
to wrap more C header files and global variables in an \c {extern "C"}
block.

\quotefile walkthrough/io.cpp

\skipuntil Wrap non-standard includes and global variables with extern "C"
\printuntil Page AllocPage()

We need to forward declare the \c ReadDB() and \c SaveDB() functions
so that the compiler generates the correct symbols for these
functions.

\printuntil } // extern "C"

The \c ParseNewLines() function needs to be converted to proper C++.

\skipuntil Convert ParseNewLines to proper C++
\printuntil look for "\n"

The \c PrintWithNewLines() function also needs to be converted to proper
C++.

\skipuntil Convert PrintWithNewLines to proper C++
\printuntil look for '\n'

We can now change the \c ReadDB() and \c SaveDB() functions to use
QMessageBox::warning().

First, we need to make sure we include the proper header for QMessageBox.

\quotefile walkthrough/io.cpp

\skipto Qt includes
\printline
\printline

The code for \c ReadDB() looks like this:

\skipto input = fopen(filename, "r")
\printuntil Destroy current pages on reread

The code for \c SaveDB() looks like this:

\skipto (access(filename, F_OK) == 0
\printuntil Append a ~ to make the old filename

After we build the project, the application runs and operates as
expected. The difference is that the \e {Page Delete} and \e {IO
Error} dialogs now use QMessageBox.

\section2 Using Custom QDialogs

After we have replaced the standard dialogs, we move onto the custom
dialogs.  This project has a single custom dialog: the \e {Page Edit}
dialog.

Instead of writing the code ourselves, we use the \link
designer-manual.html Qt Designer\endlink to design our dialog.  The
steps involved in designing our custom dialog is beyond the scope of
this document and will not be discussed here.  The \link
designer-manual.html Qt Designer Manual\endlink is a complete
reference on the use of \e {Qt Designer}.

\section3 Replacing the \e {Page Edit} Dialog

The custom QDialog description for the \e {Page Edit} dialog is saved
as \c pageeditdialog.ui.  We add this file to the project file and
regenerate the \c Makefile.  The \e uic utility generates the code for
our custom QDialog, which is then compiled and linked into our
application.

We need to pass the top-level QMotifWidget as the \c client_data
argument to the \c EditPage function, which we will use as the parent
for our new \c PageEditDialog.  We do this the same way as we have
done for the \e Open and \e {Save As} dialogs.

\quotefile walkthrough/todo.cpp

\skipto XtManageChild(selected_menu[SELECTED_PROPERTIES]);
\printuntil (XtCallbackProc) EditPage, (XtPointer) &toplevel );

The \c EditPage() function is implemented in \c actions.cpp.  We start
by adding the includes needed for the \c PageEditDialog and QLineEdit.

\quotefile walkthrough/actions.cpp

\skipto // PageEditDialog includes
\printline
\printline
\printline

In the \c EditPage() function, We create the \c PageEditDialog, set
the initial values of the three QLineEdit widgets with values from the
current page and execute the dialog.

\skipuntil // EditPage using custom QDialog
\printuntil return
\printuntil return

At this point in the code, the page properties should be modified. The
code to do this is in the \c DoEditPage() function. We move the
contents of \c DoEditPage() to this point and remove the \c
DoEditPage() function completely.

The \c Page struct defined in \c page.h stores strings in \c {char *}
arrays.  Since the PageEditDialog and the data it contains will be
destroyed when we return from this function, we need to convert the
unicode QString data into a QCString in the locale encoding and
duplicate it with \c qstrdup().

\skipto // pages[currentPage] -> label = XmTextFieldGetString(labelEditW);
\printuntil pages[currentPage]->label = qstrdup( qstr.local8Bit().data() );

The same process must be done for the minorTab text:

\skipto // temp = XmTextGetString(minorTabW);
\printuntil temp = qstrdup( qstr.local8Bit().data() );

... and for the majorTab text:

\skipto // temp = XmTextGetString(majorTabW);
\printuntil temp = qstrdup( qstr.local8Bit().data() );

\section2 Using Existing Dialogs with QMotifDialog

As mentioned above, the \e Print dialog cannot be replaced until we
have converted the \e View widget.  The \e Print dialog will be
removed once we have finished our migration, since we will use
QPrinter.  Based on this information, we decide that it is not worth
replacing the \e Print dialog with a custom QDialog replacement.
Instead, we will keep the Motif based dialog and use QMotifDialog to
integrate the dialog with the application.

\section3 Modality Requirements

Modality with QDialog is different from Motif.  The QDialog::exec()
function does not return until the dialog is finished.  In Motif,
modality is simply a property of the shell, and the application
programmer must write QDialog::exec() style functionality if he or she
desires that behavior.

Since we will be using QMotifDialog (which is a QDialog subclass), we
will need to have an \e accept and a \e reject callback for each
dialog we integrate with QMotifDialog.  The predefined Motif dialogs
have these already: the \c XmNokCallback and \c XmNcancelCallback
callbacks.  However, the \e Print dialog only has an \e accept callback
(the \c XmdNprintCallback), but it does not have a \e reject callback.
We need to add this.

This is easily done.  We add an \c XtCallbackList for the \c
XmNcancelCallback callback in \c Xmd/PrintP.h:

\quotefile walkthrough/Xmd/PrintP.h
\skipto print_callback
\printline
\printline

We add the \c XmNcancelCallback callback to the list of resources for
the \c XmdPrint widget class in \c Xmd/Print.c:

\quotefile walkthrough/Xmd/Print.c
\skipto XmdNprintCallback
\printuntil XmRPointer, (XtPointer) NULL }
\printuntil XmRPointer, (XtPointer) NULL }

We need to activate this callback whenever we unmanage the widget and
do not activate the \e print callback, which is in the \c do_help_cb()
function:

\skipto do_help_cb(Widget button, Widget pw, XtPointer ignore)
\printuntil XtUnmanageChild
\printline

... and in the unmanage_cb() function:

\skipto unmanage_cb(Widget button, Widget pw, XtPointer ignore)
\printuntil XtUnmanageChild
\printline

\section3 Integrating the \e Print Dialog

Now that the \e Print dialog has the appropriate \e accept and \e
reject callbacks, we can use QMotifDialog.  First we need to include
the QMotifDialog header in \ctodo.cpp.

\quotefile walkthrough/todo.cpp

\skipto qmotifdialog.h
\printline

We add a \c ShowPrintDialog() function which will create and execute the
print dialog.

\skipto void ShowPrintDialog(Widget, XtPointer, XmPushButtonCallbackStruct *);
\printline

We change the \e Print menu item callback to call the new \c
ShowPrintDialog() function.  We pass the top-level QMotifWidget, which
we will use as the parent for the dialog.

\skipto XmdCreatePrintDialog(shell, "print_manager", NULL, 0);
\printuntil (XtCallbackProc) ShowPrintDialog, (XtPointer) &toplevel);

The dialog is created in the \c ShowPrintDialog() function, so we will
have to add the help callback there instead.

\skipto XtAddCallback(help_menu[HELP_OVERVIEW], XmNactivateCallback,
\printuntil //               (XtCallbackProc) help_cb, (XtPointer) 1);

The \c ShowPrintDialog() function creates the \e Print dialog and
executes it.  We use the \c XmdNprintCallback callback to accept the
dialog and the \c XmNcancelCallback callback to reject the dialog.  We
can do this easily by using the QMotifDialog::acceptCallback() and
QMotifDialog::rejectCallback() functions, respectively.  We also
ensure that the \e print and \e help callbacks continue to call the \c
Print() and \c help_cb() functions as they did before.

\skipto ShowPrintDialog(Widget, XtPointer client_data,
\printuntil dialog.exec();
\printline


















###<font color=red>THE STUFF BELOW IS UNFINISHED AND VERY TERSE</font>

\section1 Continuing Development

\section2 Exploiting Qt Features

Since we have a bright and shiny new interface, let's give it a face-lift.

\section2 Writing Platform-Independent Code

We deploy our application(s) on UNIX... this year.

*/
