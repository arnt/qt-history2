/* Walkthrough for the Motif Extension */

/*! \page motif-walkthrough.html
    \title Qt Motif Extension - A Migration Walkthrough

\tableofcontents

\section1 Introduction

This walkthrough covers a complete migration of a Motif based program
to the Qt toolkit using the \e {Qt Motif Extension}.

It is rarely practical for a large project with hundreds of thousands
or even millons of lines of code to be migrated all at once; such an
endeavor would require too many development resources and would incur
significant risks. Every line of code would have to be rewritten,
every user interface redesigned, and quality assurance tests and
procedures all rewritten. The \e {Qt Motif Extension} provides a
complete and working solution for incremental migration that can be
paced to suit each individual project and the available resources. The
user interface and related code can be migrated in steps while the
rest of the project need not be changed at all.

This walkthrough is intended for programmers who will be migrating an
existing Motif based project to the Qt toolkit. We assume that they
have experience with C/C++ and Xt/Motif. Some experience with the Qt
toolkit is also necessary. For developers completely new to Qt we
recommend following the learning plan outlined in \link
how-to-learn-qt.html How to Learn Qt\endlink; or to go on a Qt
training course. (See \link http://www.trolltech.com\endlink for
details of training courses.)

\section2 Goals for this Walkthrough

The goal of this walkthrough is to provide the reader with enough
knowledge to migrate Motif applications to the Qt toolkit. We will do
this by example: We will convert a real-world Motif based program
step-by-step. This walkthrough will discuss both techniques and their
rationales throughout the process.

We will use the \e todo demo program included with the Motif 2.x
distribution as our migration project. This walkthrough contains
references to the source code, which is included in the \c
extensions/motif/examples/walkthrough subdirectory.

\section1 Prerequisites

Before we can start using the \e {Qt Motif Extension}, we must satisfy
three requirements.

\list 1
\i Ensure you are using X11R6.x and Motif 2.x libraries
\i Ensure your project is compilable by a C++ compiler
\i Build and install the \e {Qt Motif Extension}
\i Build and link your project with the Qt toolkit and the \e
{Qt Motif Extension}
\endlist

\section2 X11R6.x and Motif 2.x Libraries

The mechanisms used by the \e {Qt Motif Extension} require development
headers and libraries from the X11R6 release and the Motif 2.0
release. Newer versions of these can also be used.

\section2 C++ Compiler

Since Qt is a C++ toolkit, all new code will be written in C++. In
order for existing code to coexist with new code, a C++ compiler must
be able to compile the existing code.

It is possible to keep existing code and new code separate, and only
convert or rewrite existing code as needed. This is a normal part
of the migration process, and does not need to be done before the
migration process begins. This is the most common scenario, and we
will demonstrate it by migrating existing C code to C++ as needed in
this walkthrough.

\section2 Build and Install the Qt Motif Extension

The \e {Qt Motif Extension} is not built and installed along with the
Qt toolkit. The extension resides in the \c extensions/motif
subdirectory. Run \e make in this directory to build the extension
and the examples. Once the extension has been built, run \e {make
install}

\code
    $ cd extensions/motif
    $ make
    $ make install
\endcode

The \e {Qt Motif Extension} is now installed and ready to use.

\section2 Build and Link Your Project with the Qt Toolkit and the Qt
Motif Extension

For simplicity, we use \e qmake to create the \c Makefile. The \c
-project option causes \e qmake to automatically generate a project
file. After \e {qmake -project} has generated our project file, we
run \e qmake again to generate a \c Makefile. Now, we can just run \e
make to build our project.

\code
    $ qmake -project
    $ qmake
    $ make
\endcode

Everything builds correctly, but fails to link because we don't link
with the Motif library. We tell \e qmake to do this by adding the \c
-lXm to the \c LIBS variable in our project file. Since we are
planning to use the \e {Qt Motif Extension} in this project as well,
we should also add \c -lqmotif to the list of libraries.

\code
    LIBS += -lXm -lqmotif
\endcode

Now we regenerate our \c Makefile by running \c qmake again, and
rebuild using \c make. This time, our project succesfully links, and
the application runs as expected.

We are now ready to start using the \e {Qt Motif Extension}.

\section1 Getting Started

\section2 Starting with QMotif and QApplication

To be able to use Qt, we need to create a QApplication object. The
QApplication class controls all the event delivery and display
management for all other Qt objects and widgets. We need to use the
QMotif class from the \e {Qt Motif Extension} to allow QApplication
and the \c XtAppContext to coexist.

The QApplication object must be created in the \c main() function,
We will need to modify \c {todo.c} to compile with a C++ compiler, so we
rename \c {todo.c} to \c {todo.cpp}.

Next, we add the appropriate includes for the QMotif and QApplication
classes.

\quotefile walkthrough/todo-gettingstarted.cpp

\skipto REV_INFO
\printuntil pwd.h

Next, we create the QMotif and QApplication objects. We create QMotif
with a foreign \c XtAppContext, and we create QApplication with a
foreign \c Display.

\skipto XtVaAppInitialize
\printuntil XtManageChild

The next change is not yet necessary, but it is included to show that
the \e {Qt Motif Extension} provides a complete intregration.
Normally, a Motif based program would use the \c XtAppMainLoop()
function to run the application's event loop. This is still possible,
but since we are migrating to the Qt toolkit, we would like to use the
QApplication::exec() function for running the event loop.

\skipuntil Eventloop integration
\printuntil }

Since we renamed \c {todo.c} to \c {todo.cpp}, we must change the
project file and rerun \e qmake to regenerate our \c Makefile. When we
build our project, there are compile and link errors.

\section2 Migrating to C++

We need to convert the code in this file to proper C++ code.
Fortunately, the changes are not too large. Most files included from
existing C projects are not C++ compatible, so we make them compatible
by wrapping them in an \c {extern "C"} block.

\quotefile walkthrough/todo-gettingstarted.cpp

\skipuntil Wrap non-standard includes
\printuntil } // extern "C"

Global C functions that are forward declared must also be wrapped into
an \c {extern "C"} block.

\skipuntil Wrap extern/callback functions and global variables with extern "C"
\printuntil } // extern "C"

The \c manageCB() function needs to be converted to proper C++.

\skipuntil Use proper C++ function declarations
\printuntil }

And we need to fix two invalid casts. One is in the \c Save() function.

\skipuntil Temporarily fix invalid casts
\printuntil SaveDB

The other invalid cast is in the \c Open() function.

\skipuntil Temporarily fix invalid casts
\printuntil ReadDB

After these changes, the project compiles and links, and the
application runs and operates correctly.

\section1 Preparing to Migrate the User Interface

We are ready to start migrating the user interface for our project.
As mentioned in the introduction, we do this in steps, ensuring that
our application is still usable at every step of the migration process. 

The user interface can be viewed as a heirarchy; each top-level window
and dialog depends upon a parent (which is another top-level window or
dialog). When using Motif \c XmMainWindow widgets, these should be
viewed as two separate entities: the \e {Main Window} widget with the
popup-menu heirarchy and the \e View widget contained in the \e {Main
Window} widget. The \e View widget depends on the \e {Main Window}
widget.

We begin migrating the pieces that have no dependencies, and work our
way up the dependency tree until all pieces have been migrated.

The heirarchy for this project looks something like this:

\img motif-todo.png Motif Todo Hierarchy

We will begin by migrating and replacing all of the dialogs, then the
\e {Main Window} widget with popup-menu heirarchy, and finally the \e
View widget.

However, we are not ready to begin just yet. The migration process can
be long, but it does not have to be difficult. The \e Open, \e {Save
As}, \e {Page Delete} and \e {IO Error} dialogs use Motif \c
XmFileSelectionBox and \c XmMessageBox dialogs. Qt provides similar
functionality with QFileDialog and QMessageBox, which we can begin
using immediately.

The \e Print dialog is special, however. The \e Print dialog cannot be
replaced until after we have replaced the \e View widget. Qt provides
a complete printing mechanism with QPrinter, but we cannot start using
it until we have replaced the \e View widget.

\section2 Removing the \e Help Dialog

The \e Help dialog is also special.  Instead of replacing the \e Help
dialog with a custom QDialog, we will use the \link helpsystem.html Qt
Help System\endlink classes to provide a more advanced online help.
However, we cannot start using classes like QToolTip and QWhatsThis
until we replace the \e {Main Window} and \e View widgets.

The help text included with the original project is very small and
only contains information about the \c XmNoteBook widget.  The use of
tooltips and whats-this text will suffice for this example.  If your
migration project has a large online help system, we recommend looking
at the \link helpviewer-example.html Simple HTML Help Browser\endlink
example for information on how to build an rich text help system with
hypertext navigation and full printing capabilities.

Removing the existing \e Help dialog is relatively simple.  We remove
the \c Xmd/Help.h, \c Xmd/HelpP.h and \c Xmd/Help.c files from our
project file and regenerate our \c Makefile.

The code to create the \e Help menu and \e Help dialog is in \c
todo.cpp.  We remove the \c Xmd/Help.h include, the \c *help_manager
resource string, the \c help_cb() function forward declaration and the
\c help_widget global variable.

\quotefile walkthrough/todo-dialogs.cpp

\skipto Demo include files
\printuntil Xmd/Help.h

\code
    ...
\endcode

\skipto void SetPage(int);
\printuntil void help_cb(Widget, XtPointer, XmAnyCallbackStruct *);

\code
    ...
\endcode

\skipto Widget shell, notebook, textw, labelw;
\printuntil  Widget help_widget;

We also need to remove the code that creates the \e Help dialog.  We
will also remove the code to create the \e Help menu, since this menu
is now empty.

\skipto XmdCreateMenu(HELP_MENU, menubar, &help_menu, &size);
\printuntil XtManageChild(help_menu[HELP_OVERVIEW]);

\code
    ...
\endcode

\skipto help_widget = XmdCreateHelpDialog(shell, "help_manager", NULL, 0);
\printuntil (XtCallbackProc) help_cb, (XtPointer) 1);

Next, we remove the \c help_cb() function implementation.

\skipuntil Callback to show the Help widget
\printuntil XmdGotoHelpItem(w, (int) item, help_widget);
\printline

The \e Help dialog is now removed from our project.  We cannot add
QToolTip and QWhatsThis help at the moment, since we are still using
\c XmMainWindow for the \e {Main Window} widget.  Once we have
migrated the \e {Main Window} and the popup-menu heirarchy, we can
begin using QToolTip and QWhatsThis for online help.

\section1 Using Qt Standard Dialogs

We start by using two of the \link dialogs.html Qt Standard
Dialogs\endlink: QFileDialog and QMessageBox. Both of these classes
provide static convenience functions that we can use.

\list
\i QFileDialog::getOpenFileName() -- replacement for the \e Open dialog
\i QFileDialog::getSaveFileName() -- replacement for the \e {Save As} dialog
\i QMessageBox::information() -- replacement for \e {Page Delete} dialog
\i QMessageBox::warning() -- replacement for \e {IO Error} dialog.
\endlist

Each of these functions takes a \c {QWidget *parent} argument. If we
pass zero as the \e parent argument, then we will have dialogs that
are centered on the screen, instead of being centered over our main
window. We can have QMotifWidget create our \c XmMainWindow, and we
can then use this class as the parent for both Motif dialogs and Qt
dialogs.

We need to include the appropriate headers for QMotifWidget and
QFileDialog in \c todo.cpp.

\quotefile walkthrough/todo-dialogs.cpp

\skipto Qt includes
\printuntil qmotifwidget.h

Next, we make a few modifications to how the application is
initialized. We could initialize Xt/Motif and create the \c
XtAppContext ourselves, but QMotif can do this for us.
We also let QApplication open the connection to the X server. Next,
we create a QMotifWidget, passing \c xmMainWindowWidgetClass as the \e
widgetclass argument. We can now use the QMotifWidget::motifWidget()
function to access the Motif widget. The shell widget is created
automatically by QMotifWidget. We use \c XtParent() to access it.
The top-level window is now a QMotifWidget, which means we can use it
as the parent for the Qt Standard Dialogs.

\skipto QMotif integrator
\printuntil XtManageChild

\section2 Replacing the \e {Open} and \e {Save As} Dialogs

First, we completely remove all use of the existing Motif file
selection dialog. We remove the \c Xm/FileSB.h include, the global \c
file_dialog variable, and the code to create the dialog. We also
remove the \c PresentFDialog() callback function. None of this code
is needed to use QFileDialog.

\quotefile walkthrough/todo-dialogs.cpp

\skipto Motif include files
\printuntil Xm/FileSB.h
\printline

\code
    ...
\endcode

\skipto void manageCB(Widget, Widget, XtPointer);
\printuntil void PresentFDialog(Widget, XtPointer, XmPushButtonCallbackStruct*);

\code
    ...
\endcode

\skipto Widget shell, notebook, textw, labelw;
\printuntil Widget file_dialog;

\code
    ...
\endcode

\skipuntil Callback to show the XmFileSelectionBox dialog
\printuntil XtManageChild(file_dialog);
\printline

Since we removed the \c PresentFDialog() callback function, we need to
make \e Open and \e {Save As} popup-menu callbacks call the \c Open()
and \c Save() functions.

First we must change the declaration of these two functions.

\quotefile walkthrough/todo-dialogs.cpp

\skipto Wrap extern/callback functions and global variables with extern "C"
\skipto void Open
\printto void Print

We also change the arguments to the callbacks. We pass the top-level
QMotifWidget as the \c client_data to these functions, since we will
be using this as the parent for the QFileDialog.

\skipto XmdCreateMenu(FILE_MENU
\printuntil (XtCallbackProc) SaveIt

Next, we modify the \c Save() function to use
QFileDialog::getSaveFileName().

\skipuntil Save using QFileDialog
\printuntil SaveDB

... and the \c Open() function to use QFileDialog::getOpenFileName().

\skipuntil Open using QFileDialog
\printuntil ReadDB

After we build the project, the application runs and operates as
expected. The difference is that the \e Open and \e {Save As} dialogs
now use QFileDialog.

\section2 Replacing the \e {Page Delete} and \e {IO Error} Dialogs

The \e {Page Delete} dialog is created and used in \c {actions.c}. We
need to migrate this file to C++. We rename it to \c {actions.cpp},
modify the project file and regenerate the \c Makefile.

The changes required to make \c {actions.cpp} compile are minimal. We
need to wrap more C header files and global variables in an \c {extern
"C"} block.

\quotefile walkthrough/actions.cpp

\skipuntil Wrap non-standard includes and global variables with extern "C"
\printuntil extern int maxpages

We need to forward declare the \c NewPage(), \c DeletePage(), \c
EditPage() and \c SaveIt() functions so that the compiler generates
the correct symbols for these functions.

\printuntil } // extern "C"

We need to fix a single invalid pointer cast.

\skipto // XtFree((XtPointer) pages[currentPage]);
\printline
\printline

And we need to change the variable name \e new in the \c Trim()
function.

\skipuntil Change variable name 'new'
\printuntil return(newstr);
\printline

We can now change the \c DeletePage() function to use
QMessageBox::information().

First, we need to make sure we include the proper header for
QMessageBox.

\quotefile walkthrough/actions.cpp

\skipto Qt includes
\printline
\printline
\printline

The code for \c DeletePage() looks like this:

\skipuntil DeletePage using QMessageBox
\printuntil return

At this point in the code, the page should be deleted. The code to do
this is in the \c DoDeletePage() function. We move the contents of \c
DoDeletePage() to this point and remove the \c DoDeletePage() function
completely.

Next, we change \c {todo.cpp} to pass the top-level QMotifWidget as the
\c client_data tot he \c DeletePage() function.

\quotefile walkthrough/todo-dialogs.cpp

\skipto XtManageChild(selected_menu[SELECTED_DELETE]);
\printuntil (XtCallbackProc) DeletePage, (XtPointer) &toplevel

The \e {IO Error} dialog is created and used in \c {io.c}. We need to
migrate this file to C++. We rename it to \c {io.cpp}, modify the
project file and regenerate the \c Makefile.

The changes required to make \c {io.cpp} compile are minimal. We need
to wrap more C header files and global variables in an \c {extern "C"}
block.

\quotefile walkthrough/io.cpp

\skipuntil Wrap non-standard includes and global variables with extern "C"
\printuntil Page AllocPage()

We need to forward declare the \c ReadDB() and \c SaveDB() functions
so that the compiler generates the correct symbols for these
functions.

\printuntil } // extern "C"

The \c ParseNewLines() function needs to be converted to proper C++.

\skipuntil Convert ParseNewLines to proper C++
\printuntil look for "\n"

The \c PrintWithNewLines() function also needs to be converted to proper
C++.

\skipuntil Convert PrintWithNewLines to proper C++
\printuntil look for '\n'

We can now change the \c ReadDB() and \c SaveDB() functions to use
QMessageBox::warning().

First, we need to make sure we include the proper header for QMessageBox.

\quotefile walkthrough/io.cpp

\skipto Qt includes
\printline
\printline

The code for \c ReadDB() looks like this:

\skipto input = fopen(filename, "r")
\printuntil Destroy current pages on reread

The code for \c SaveDB() looks like this:

\skipto (access(filename, F_OK) == 0
\printuntil Append a ~ to make the old filename

After we build the project, the application runs and operates as
expected. The difference is that the \e {Page Delete} and \e {IO
Error} dialogs now use QMessageBox.

\section1 Using Custom QDialogs

After we have replaced the standard dialogs, we move onto the custom
dialogs.  This project has a single custom dialog: the \e {Page Edit}
dialog.

Instead of writing the code ourselves, we use the \link
designer-manual.html Qt Designer\endlink to design our dialog.  The
steps involved in designing our custom dialog are beyond the scope of
this walkthrough and will not be discussed here.  The \link
designer-manual.html Qt Designer Manual\endlink is a complete
reference on the use of \e {Qt Designer}.

\section2 Replacing the \e {Page Edit} Dialog

The custom QDialog description for the \e {Page Edit} dialog is saved
as \c pageeditdialog.ui.  We add this file to the project file and
regenerate the \c Makefile.  The \e uic utility generates the code for
our custom QDialog, which is then compiled and linked into our
application.

We need to pass the top-level QMotifWidget as the \c client_data
argument to the \c EditPage function, which we will use as the parent
for our new \c PageEditDialog.  We do this the same way as we have
done for the \e Open and \e {Save As} dialogs in \c todo.cpp.

\quotefile walkthrough/todo-dialogs.cpp

\skipto XtManageChild(selected_menu[SELECTED_PROPERTIES]);
\printuntil (XtCallbackProc) EditPage, (XtPointer) &toplevel );

The \c EditPage() function is implemented in \c actions.cpp.  We start
by adding the includes needed for the \c PageEditDialog and QLineEdit.

\quotefile walkthrough/actions.cpp

\skipto // PageEditDialog includes
\printline
\printline
\printline

In the \c EditPage() function, We create the \c PageEditDialog, set
the initial values of the three QLineEdit widgets with values from the
current page and execute the dialog.

\skipuntil // EditPage using custom QDialog
\printuntil return
\printuntil return

At this point in the code, the page properties should be modified. The
code to do this is in the \c DoEditPage() function. We move the
contents of \c DoEditPage() to this point and remove the \c
DoEditPage() function completely.

The \c Page struct defined in \c page.h stores strings in \c {char *}
arrays.  Since the PageEditDialog and the data it contains will be
destroyed when we return from this function, we need to convert the
unicode QString data into a QCString in the locale encoding and
duplicate it with \c qstrdup().

\skipto // pages[currentPage] -> label = XmTextFieldGetString(labelEditW);
\printuntil pages[currentPage]->label = qstrdup( qstr.local8Bit().data() );

The same process must be done for the minorTab text:

\skipto // temp = XmTextGetString(minorTabW);
\printuntil temp = qstrdup( qstr.local8Bit().data() );

... and for the majorTab text:

\skipto // temp = XmTextGetString(majorTabW);
\printuntil temp = qstrdup( qstr.local8Bit().data() );

\section1 Using Existing Dialogs with QMotifDialog

As mentioned above, the \e Print dialog cannot be replaced until we
have converted the \e View widget.  The \e Print dialog will be
removed once we have finished our migration, since we will use
QPrinter.  Based on this information, we decide that it is not worth
replacing the \e Print dialog with a custom QDialog replacement.
Instead, we will keep the Motif based dialog and use QMotifDialog to
integrate the dialog with the application.

\section2 Modality Requirements

Modality with QDialog is different from Motif.  The QDialog::exec()
function does not return until the dialog is finished.  In Motif,
modality is simply a property of the shell, and the application
programmer must write QDialog::exec() style functionality if he or she
desires that behavior.

Since we will be using QMotifDialog (which is a QDialog subclass), we
will need to have an \e accept and a \e reject callback for each
dialog we integrate with QMotifDialog.  The predefined Motif dialogs
have these already: the \c XmNokCallback and \c XmNcancelCallback
callbacks.  However, the \e Print dialog only has an \e accept callback
(the \c XmdNprintCallback), but it does not have a \e reject callback.
We need to add this.

This is easily done.  We add an \c XtCallbackList for the \c
XmNcancelCallback callback in \c Xmd/PrintP.h:

\quotefile walkthrough/Xmd/PrintP.h
\skipto print_callback
\printline
\printline

We add the \c XmNcancelCallback callback to the list of resources for
the \c XmdPrint widget class in \c Xmd/Print.c:

\quotefile walkthrough/Xmd/Print.c
\skipto XmdNprintCallback
\printuntil XmRPointer, (XtPointer) NULL }
\printuntil XmRPointer, (XtPointer) NULL }

We need to activate this callback whenever we unmanage the widget and
do not activate the \e print callback, which is in the \c do_help_cb()
function:

\skipto do_help_cb(Widget button, Widget pw, XtPointer ignore)
\printuntil XtUnmanageChild
\printline

... and in the unmanage_cb() function:

\skipto unmanage_cb(Widget button, Widget pw, XtPointer ignore)
\printuntil XtUnmanageChild
\printline

\section2 Integrating the \e Print Dialog

Now that the \e Print dialog has the appropriate \e accept and \e
reject callbacks, we can use QMotifDialog.  First we need to include
the QMotifDialog header in \c todo.cpp.

\quotefile walkthrough/todo-dialogs.cpp

\skipto qmotifdialog.h
\printline

We add a \c ShowPrintDialog() function which will create and execute the
print dialog.

\skipto void ShowPrintDialog(Widget, XtPointer, XmPushButtonCallbackStruct *);
\printline

We change the \e Print menu item callback to call the new \c
ShowPrintDialog() function.  We pass the top-level QMotifWidget, which
we will use as the parent for the dialog.

\skipto XmdCreatePrintDialog(shell, "print_manager", NULL, 0);
\printuntil (XtCallbackProc) ShowPrintDialog, (XtPointer) &toplevel);

The \c ShowPrintDialog() function creates the \e Print dialog and
executes it.  We use the \c XmdNprintCallback callback to accept the
dialog and the \c XmNcancelCallback callback to reject the dialog.  We
can do this easily by using the QMotifDialog::acceptCallback() and
QMotifDialog::rejectCallback() functions, respectively.  We also
ensure that the \e print callback continues to call the \c
Print() function as before.

\skipto ShowPrintDialog(Widget, XtPointer client_data,
\printuntil dialog.exec();
\printline

\section1 Using Qt Main Window Classes

After we have replaced all dialogs, we are ready to begin replacing
the \e {Main Window}.  \link motif-walkthrough.html#4 As mentioned
above\endlink, we will replace the existing \c XmMainWindow and
popup-menu heirarchy with \link application.html Qt Main Window
Classes\endlink.

We will use \link designer-manual.html Qt Designer\endlink to design
our new main window.  The steps involved in designing the main window are
beyond the scope of this walkthrough and will not be discussed here.
The \link designer-manual.html Qt Designer Manual\endlink is a
complete reference on the use of \e {Qt Designer}.

\section2 Implementing the \e {Main Window}

The description for the \e {Main Window} is saved as \c mainwindow.ui.
We add this file to the probject file and regenerate the \c Makefile.
The \e uic utility generates the code for our \e {Main Window}, which
is then compiled and link into our application.

\e {Qt Designer} also created the \c mainwindow.ui.h file.  We need to
add the implementation for our \e {Main Window} to this skeleton
implementation.

We begin by adding the necessary includes for QApplication,
QMessageBox and QMotifWidget.

\quotefile walkthrough/mainwindow.ui.h

\skipto Qt includes
\printuntil qmotifwidget.h

We need includes for the Motif callback structs and the \c XmdPrint
widget.

\skipto Motif includes
\printuntil Xmd/Print.h

We are now ready to add implementations for the slots in our \e {Main
Window}.  We have one slot per menu item.  Each slot will call the
existing callback functions found in \c todo.cpp and \c actions.cpp.

\list
\i File menu
    \list
    \i New - \c MainWindow::fileNew() - calls the \c New() callback
    \i Open - \c MainWindow::fileOpen() - calls the \c Open() callback
    \i Save - \c MainWindow::fileSave() - calls the \c SaveIt() callback
    \i Save As - \c MainWindow::fileSaveAs() - calls the \c Save() callback
    \i Print - \c MainWindow::filePrint() - calls the \c ShowPrintDialog() callback
    \i Exit - \c MainWindow::fileExit() - calls QApplication::quit()
    \endlist
\i Selected menu
    \list
    \i Properties - \c MainWindow::selProperties() - calls the \c EditPage() callback
    \i New - \c MainWindow::selNewPage() - calls the \c NewPage() callback
    \i Delete to Trash - \c MainWindow::selDeletePage() - calls the \c DeletePage() callback
    \endlist
\endlist

We need to add forward declarations for these callbacks before we can
use them.

\skipuntil Existing functions/variables found in todo.cpp and action.cpp
\printuntil // extern "C"

Each of the existing callback functions takes 3 arguments.  We pass
NULL to all of the arguments in this example (with a few exceptions,
see below).  The existing code does not rely on any of the arguments.
Each slot implementation is a single line calling the related callback
function. The code is not very interesting and it not shown here due
to space considerations.

There are 4 exceptions to the above.  The \c Open(), \c Save(), \c
EditPage() and \c DeletePage() callbacks accept a pointer to the
toplevel QWidget as argument 2 (the \c client_data argument).  For
these 4 functions, we pass \c this as argument 2, which is a toplevel
\c MainWindow derived from QMainWindow.

\section2 Replacing the \e {Main Window}

The next step is to use the new \e {Main Window} in our application.
The changes needed in \c todo.cpp are large due to the large amount of
code being removed.

First, we add the include for our new \e {Main Window}.

\quotefile walkthrough/todo.cpp

\skipto Qt based Main Window
\printuntil mainwindow.h

We can cleanup the Motif includes, since many of them are no longer
needed.

\skipto Motif include files
\printuntil Xm/Text.h

\skipto Demo include files
\printuntil Xmd/Print.h

The \c QuitAppl() and \c manageCB() callbacks are not needed anymore,
so we remove them.

\skipto static void QuitAppl(Widget, char *, XmPushButtonCallbackStruct *);
\printline

\code
    ...
\endcode

\skipto void manageCB(Widget, Widget, XtPointer);
\printline

\code
    ...
\endcode

\skipuntil Unneeded QuitAppl callback
\printuntil // }

\code
    ...
\endcode

\skipuntil Unneeded manageCB callback
\printuntil // }

We do not need the toplevel shell either.

\quotefile walkthrough/todo.cpp

\skipto Widget shell;
\printuntil Widget file_dialog;

Next, we remove all references to the shell variable in the \c New(),
\c Save() and \c Open() callbacks:

\skipuntil New( Widget, char *, XmPushButtonCallbackStruct * )
\skipto options.todoFile = str;
\printuntil //               XA_STRING, NULL, NULL);

In \c main(), we make the large changes.  First, we use our new \c
MainWindow instead of QMotifWidget with \c XmMainWindow.

\quotefile walkthrough/todo.cpp

\skipto QMotif integrator
\printuntil context	= integrator.applicationContext();

We will now use QMotifWidget to create the \c XmNotebook widget.

\skipto n = 0;
\printuntil (XtCallbackProc) PageChange, NULL);

We remove all of the code used to create the Motif menus.  The
remaining code in \c main() is self-explanatory.

\printuntil return app.exec();
\printline








<font color=red>THE STUFF BELOW IS UNFINISHED AND VERY TERSE</font>

\section1 Preparing to Replace the \e {View} widget

\section1 Continuing Development

\section2 Exploiting Qt Features

Since we have a bright and shiny new interface, let's give it a face-lift.

\section2 Writing Platform-Independent Code

We deploy our application(s) on UNIX... this year.

*/
