/* Walkthrough for the Motif Extension */

/*! \page motif-walkthrough.html
    \title Qt Motif Extension - A Migration Walkthrough

\tableofcontents

\section1 Introduction

This walkthrough covers a complete migration of a Motif based program
to the Qt toolkit using the \e {Qt Motif Extension}.

It is rarely practical for a large project with hundreds of thousands
or even millons of lines of code to be migrated all at once; such an
endeavor would require too many development resources and would incur
significant risks. Every line of code would have to be rewritten,
every user interface redesigned, and quality assurance tests and
procedures all rewritten. The \e {Qt Motif Extension} provides a
complete and working solution for incremental migration that can be
paced to suit each individual project and the available resources. The
user interface and related code can be migrated in steps while the
rest of the project need not be changed at all.

This document is intended for programmers who will be migrating an
existing Motif based project to the Qt toolkit. We assume that they
have experience with C/C++ and Xt/Motif. Some experience with the Qt
toolkit is also necessary. For developers completely new to Qt we
recommend following the learning plan outlined in \link
how-to-learn-qt.html How to Learn Qt\endlink; or to go on a Qt
training course. (See \link http://www.trolltech.com\endlink for
details of training courses.)

\section2 Goals for this Document

The goal of this document is to provide the reader with enough
knowledge to migrate Motif applications to the Qt toolkit. We will do
this by example: We will convert a real-world Motif based program
step-by-step. This walkthrough will discuss both techniques and their
rationales throughout the process.

We will use the \e todo demo program included with the Motif 2.x
distribution as our migration project. This walkthrough contains
references to the source code, which is included in the \c
extensions/motif/examples/walkthrough subdirectory.

\section1 Prerequisites

Before we can start using the \e {Qt Motif Extension}, we must satisfy
three requirements.

\list 1
\i Ensure you are using X11R6.x and Motif 2.x libraries
\i Ensure your project is compilable by a C++ compiler
\i Build and install the \e {Qt Motif Extension}
\i Build and link your project with the Qt toolkit and the \e
{Qt Motif Extension}
\endlist

\section2 X11R6.x and Motif 2.x libraries

The mechanisms used by the \e {Qt Motif Extension} require libraries
from the X11R6 release and the Motif 2.0 release. Newer versions of
these can also be used.

###<font color=red>What about header files?</font>

\section2 C++ Compiler

Since Qt is a C++ toolkit, all new code will be written in C++. In
order for existing code to coexist with new code, a C++ compiler must
be able to compile the existing code.

It is possible to keep existing code and new code separate, and only
convert or rewrite existing code as needed. This is a normal part
of the migration process, and does not need to be done before the
migration process begins. This is the most common scenario, and we
will demonstrate it by migrating existing C code to C++ as needed in
this walkthrough.


\section2 Build and Install the Qt Motif Extension

The \e {Qt Motif Extension} is not built and installed along with the
Qt toolkit. The extension resides in the \c extensions/motif
subdirectory. Run \e make in this directory to build the extension
and the examples. Once the extension has been built, run \e {make
install}

\code
    $ cd extensions/motif
    $ make
    $ make install
\endcode

The \e {Qt Motif Extension} is now installed and ready to use.


\section2 Build and link your project with the Qt toolkit and the Qt
Motif Extension

For simplicity, we use \e qmake to create the \c Makefile. The \c
-project option causes \e qmake to automatically generate a project
file. After \e {qmake -project} has generated our project file, we
run \e qmake again to generate a \c Makefile. Now, we can just run \e
make to build our project.

\code
    $ qmake -project
    $ qmake
    $ make
\endcode

Everything builds correctly, but fails to link because we don't link
with the Motif library. We tell \e qmake to do this by adding the \c
-lXm to the \c LIBS variable in our project file. Since we are
planning to use the \e {Qt Motif Extension} in this project as well,
we should also add \c -lqmotif to the list of libraries.

\code
    LIBS += -lXm -lqmotif
\endcode

Now we regenerate our \c Makefile by running \c qmake again, and
rebuild using \c make. This time, our project succesfully links, and
the application runs as expected.

We are now ready to start using the \e {Qt Motif Extension}.


\section1 Getting Started

\section2 Starting with QMotif and QApplication

To be able to use Qt, we need to create a QApplication object. The
QApplication class controls all the event delivery and display
management for all other Qt objects and widgets. We need to use the
QMotif class from the \e {Qt Motif Extension} to allow QApplication
and the \c XtAppContext to coexist.

The QApplication object must be created in the \c main() function,
We will need to modify \c {todo.c} to compile with a C++ compiler, so we
rename \c {todo.c} to \c {todo.cpp}.

Next, we add the appropriate includes for the QMotif and QApplication
classes.

\quotefile walkthrough/todo-gettingstarted.cpp

\skipto REV_INFO
\printuntil pwd.h

Next, we create the QMotif and QApplication objects. We create QMotif
with a foreign \c XtAppContext, and we create QApplication with a
foreign \c Display.

\skipto strcmp(argv[1], "-help")
\printuntil XtManageChild

The next change is not yet necessary, but it is included to show that
the \e {Qt Motif Extension} provides a complete intregration.
Normally, a Motif based program would use the \c XtAppMainLoop()
function to run the application's event loop. This is still possible,
but since we are migrating to the Qt toolkit, we would like to use the
QApplication::exec() function for running the event loop.

\skipuntil Eventloop integration
\printuntil }

Since we renamed \c {todo.c} to \c {todo.cpp}, we must change the
project file and rerun \e qmake to regenerate our \c Makefile. When we
build our project, there are compile and link errors.

\section2 Migrating to C++

We need to convert the code in this file to proper C++ code.
Fortunately, the changes are not too large. Most files included from
existing C projects are not C++ compatible, so we make them compatible
by wrapping them in an \c {extern "C"} block.

\quotefile walkthrough/todo-gettingstarted.cpp

\skipuntil Wrap non-standard includes
\printuntil } // extern "C"

Global C functions that are forward declared must also be wrapped into
an \c {extern "C"} block.

\skipuntil Wrap extern/callback functions and global variables with extern "C"
\printuntil } // extern "C"

The \c manageCB() function needs to be converted to proper C++.

\skipuntil Use proper C++ function declarations
\printuntil }

And we need to fix two invalid casts. One is in the \c Save() function.

\skipuntil Temporarily fix invalid casts
\printuntil SaveDB

The other invalid cast is in the \c Open() function.

\skipuntil Temporarily fix invalid casts
\printuntil ReadDB

After these changes, the project compiles and links, and the
application runs and operates correctly.


\section1 Migrating the User Interface

We are ready to start migrating the user interface for our project.
As mentioned in the introduction, we do this in steps, ensuring that
our application is still usable at every step of the migration process. 

The user interface can be viewed as a heirarchy; each top-level window
and dialog depends upon a parent (which is another top-level window or
dialog). When using the Motif \c XmMainWindow widgets, these should
be viewed as two separate entities: the \e {Main Window} widget with
the popup-menu heirarchy and the \e View widget contained in the \e
{Main Window} widget. The \e View widget depends on the \e {Main
Window} widget.

We begin migrating the pieces that have no dependencies, and work our
way up the dependency tree until all pieces have been migrated.

The heirarchy for this project looks something like this:

\img motif-todo.png Motif Todo Hierarchy

We will begin by migrating and replacing all of the dialogs, then the
\e {Main Window} widget with popup-menu heirarchy, and finally the \e
View widget.

However, we are not ready to begin just yet. The migration process
can be long, but it does not have to be difficult. The \e Open, \e
{Save As}, \e {Page Delete} and \e {IO Error} dialogs use a Motif
predefined dialog type. Qt provides similar functionality with
QFileDialog and QMessageBox, which we can begin using immediately.

The \e Print dialog is special, however. The \e Print dialog cannot
be replaced until after we have replaced the \e View widget. Qt
provides a complete printing mechanism with QPrinter, but we cannot
start using it until we have replaced the \e View widget.

\section2 Using Qt Standard Dialogs

We start by using two of the \link dialogs.html Qt Standard
Dialogs\endlink: QFileDialog and QMessageBox. Both of these classes
provide static convenience functions that we can use.

\list
\i QFileDialog::getOpenFileName() -- replacement for the \e Open dialog
\i QFileDialog::getSaveFileName() -- replacement for the \e {Save As} dialog
\i QMessageBox::information() -- replacement for \e {Page Delete} dialog
\i QMessageBox::warning() -- replacement for \e {IO Error} dialog.
\endlist

Each of these functions takes a \c {QWidget *parent} argument. If we
pass zero as the \e parent argument, then we will have dialogs that
are centered on the screen, instead of being centered over our main
window. We can have QMotifWidget create our \c XmMainWindow, and we
can then use this class as the parent for both Motif dialogs and Qt
dialogs.

We need to include the appropriate headers for QMotifWidget and
QFileDialog.

\quotefile walkthrough/todo.cpp

\skipto Qt includes
\printuntil qmotifwidget.h

Next, we make a few modifications to how the application is
initialized. We could initialize Xt/Motif and create the \c
XtAppContext ourselves, but QMotif can do this for us.
We also let QApplication open the connection to the X server. Next,
we create a QMotifWidget, passing \c xmMainWindowWidgetClass as the \e
widgetclass argument. We can now use the QMotifWidget::motifWidget()
function to access the Motif widget. The shell widget is created
automatically by QMotifWidget. We use \c XtParent() to access it.
The top-level window is now a QMotifWidget, which means we can use it
as the parent for the Qt Standard Dialogs.

\skipto strcmp(argv[1], "-help")
\printuntil XtManageChild


\section3 Using QFileDialog

First, we completely remove all use of the existing Motif file
selection dialog. We remove the \c Xm/FileSB.h include, the global \c
file_dialog variable, and the code to create the dialog. We also
remove the \c PresentFDialog() callback function. None of this code
is needed to use QFileDialog.

Since we removed the \c PresentFDialog() callback function, we need to
make \e Open and \e {Save As} popup-menu callbacks call the \c Open()
and \c Save() functions.

First we must change the declaration of these two functions.

\quotefile walkthrough/todo.cpp

\skipto Wrap extern/callback functions and global variables with extern "C"
\skipto void Open
\printto void Print

We also change the arguments to the callbacks. We pass the top-level
QMotifWidget as the \c client_data to these functions, since we will
be using this as the parent for the QFileDialog.

\skipto XmdCreateMenu(FILE_MENU, menubar, &file_menu, &size)
\printuntil (XtCallbackProc) SaveIt

Next, we modify the \c Save() function to use
QFileDialog::getSaveFileName().

\skipuntil Save using QFileDialog
\printuntil SaveDB

... and the \c Open() function to use QFileDialog::getOpenFileName().

\skipuntil Open using QFileDialog
\printuntil ReadDB

After we build the project, the application runs and operates as
expected. The difference is that the \e Open and \e {Save As} dialogs
now use QFileDialog.


\section3 Using QMessageBox

The \e {Page Delete} dialog is created and used in \c {actions.c}. We
need to migrate this file to C++. We rename it to \c {actions.cpp},
modify the project file and regenerate the \c Makefile.

The changes required to make \c {actions.cpp} compile are minimal. We
need to wrap more C header files and global variables in an \c {extern
"C"} block.

\quotefile walkthrough/actions.cpp

\skipuntil Wrap non-standard includes and global variables with extern "C"
\printuntil extern int maxpages

We need to forward declare the \c NewPage(), \c DeletePage(), \c
EditPage() and \c SaveIt() functions so that the compiler generates
the correct symbols for these functions.

\printuntil } // extern "C"

We need to fix a single invalid pointer cast.

\skipto // XtFree((XtPointer) pages[currentPage]);
\printline
\printline

And we need to change the variable name \e new in the \c Trim() function.

\skipuntil Change variable name 'new'
\printuntil return(newstr);
\printline

We can now change the \c DeletePage() function to use
QMessageBox::information().

First, we need to make sure we include the proper header for QMessageBox.

\quotefile walkthrough/actions.cpp

\skipto Qt includes
\printline
\printline

The code for \c DeletePage() looks like this:

\skipuntil DeletePage using QMessageBox
\printuntil return

At this point in the code, the page should be deleted. The code to do
this is in the \c DoDeletePage() function. We move the contents of \c
DoDeletePage() to this point and remove the \c DoDeletePage() function
completely.

\printuntil SetPage(currentPage)
\printline

Next, we change \c {todo.cpp} to pass the top-level QMotifWidget as the
\c client_data tot he \c DeletePage() function.

\quotefile walkthrough/todo.cpp

\skipto XmdCreateMenu(SELECTED_MENU, menubar, &selected_menu, &size)
\printuntil (XtCallbackProc) DeletePage, (XtPointer) &toplevel

The \e {IO Error} dialog is created and used in \c {io.c}. We need to
migrate this file to C++. We rename it to \c {io.cpp}, modify the
project file and regenerate the \c Makefile.

The changes required to make \c {io.cpp} compile are minimal. We need
to wrap more C header files and global variables in an \c {extern "C"}
block.

\quotefile walkthrough/io.cpp

\skipuntil Wrap non-standard includes and global variables with extern "C"
\printuntil Page AllocPage()

We need to forward declare the \c ReadDB() and \c SaveDB() functions
so that the compiler generates the correct symbols for these
functions.

\printuntil } // extern "C"

The \c ParseNewLines() function needs to be converted to proper C++.

\skipuntil Convert ParseNewLines to proper C++
\printuntil look for "\n"

The \c PrintWithNewLines() function also needs to be converted to proper
C++.

\skipuntil Convert PrintWithNewLines to proper C++
\printuntil look for '\n'

We can now change the \c ReadDB() and \c SaveDB() functions to use
QMessageBox::warning().

First, we need to make sure we include the proper header for QMessageBox.

\quotefile walkthrough/io.cpp

\skipto Qt includes
\printline
\printline

The code for \c ReadDB() looks like this:

\skipto input = fopen(filename, "r")
\printuntil Destroy current pages on reread

The code for \c SaveDB() looks like this:

\skipto (access(filename, F_OK) == 0
\printuntil Append a ~ to make the old filename

After we build the project, the application runs and operates as
expected. The difference is that the \e {Page Delete} and \e {IO
Error} dialogs now use QMessageBox.


###<font color=red>THE STUFF BELOW IS UNFINISHED AND VERY TERSE</font>

\section2 Migrate Existing Motif Dialogs to QMotifDialog


\section2 Replace Existing Dialogs with QDialog subclasses

After replacing all dialogs with appropriate QDialog subclasses, we
keep modality working by using QMotifWidget as a parent for all
dialogs.


\section2 Replacing the Main Window, Part 1

We continue using QMotifWidget, but this time we use it as a wrapper
for the \e View widget in a QMainWindow.


\section2 Replacing the Main Window, Part 2

We now replace the \e View widget of the QMainWindow with a real Qt
widget.


\section1 Continuing Development

\section2 Exploiting Qt Features

Since we have a bright and shiny new interface, let's give it a face-lift.


\section2 Writing Platform-Independent Code

We deploy our application(s) on UNIX... this year.


*/
