/*! \page activeqt.html

    \title The ActiveQt framework
    \keyword ActiveQt

    Qt's ActiveX support allows Qt/Windows developers to:
    \list 1
    \i Access and use ActiveX controls provided by any ActiveX server
    in their Qt applications.
    \i Make their Qt applications available as ActiveX servers, with
    any number of Qt widgets as ActiveX controls.
    \endlist

    The framework consists of two modules. 

    \section1 QAxContainer

    The \link qaxcontainer.html QAxContainer module  \endlink is a 
    library implementing a QWidget subclass, \l QAxWidget, that acts 
    as a container for ActiveX controls. If the library is built 
    against a shared Qt library it integrates as a widget plugin into 
    \link designer-manual.book Qt Designer\endlink. This module
    provides the QAxBase, QAxObject and QAxWidget classes.

    \section2 Additional Information

    \list
    \i \link activeqt-examples.html Examples\endlink. 
    \i \link qaxcontainer-faq.html QAxContainer FAQ\endlink.
    \endlist

    \section1 QAxServer

    The \link qaxserver.html QAxServer module \endlink is a 
    static library that implements ActiveX server functionality for
    in-process and executable ActiveX servers. This module provides
    the QAxAggregated, QAxBindable and QAxFactory classes.

    \section2 Additional Information

    \list
    \i \link activeqt-examples.html Examples\endlink. 
    \i \link qaxserver-faq.html QAxServer FAQ\endlink.
    \endlist
*/

/*! \page qaxserver.html

    \title The QAxServer Module

    The QAxServer module provides a static library implementing the
    functions required to turn a standard Qt binary into an ActiveX
    control server. 
    
    This module is part of the \link activeqt.html ActiveQt
    framework\endlink. (To incorporate ActiveX controls in a Qt
    application see the \link qaxcontainer.html QAxContainer
    module\endlink.) 

    The module consists of three classes
    \list
    \i QAxFactory defines a factory for the creation of ActiveX components.
    \i QAxBindable provides an interface between the Qt widget and the 
       ActiveX control.
    \i QAxAggregated can be subclassed to implement additional COM interfaces.
    \endlist

    Some \link activeqt-examples.html example implementations \endlink 
    of ActiveX controls are provided.

    \section1 Building the library

    In the \c activeqt directory (usually \c QTDIR/extensions/activeqt)
    enter the \c control subdirectory and run \c qmake to generate the
    makefile, and use the make tool (\c nmake for VC++, \c make for Borland)
    to build the library. The library \c qaxserver.lib will be linked into 
    \c QTDIR/lib.
    
    \section1 Using the library

    To turn a standard Qt application into an ActiveX server using the
    QAxServer library you must add \c activeqt as a CONFIG setting
    in your \c .pro file.

    An out-of-process executable server is generated from a \c .pro
    file like this:
    \code
    TEMPLATE = app
    CONFIG  += qt activeqt

    RC_FILE  = qaxserver.rc
    ...
    \endcode
    
    To build an in-process server, use a \c .pro file like this:
    \code
    TEMPLATE = lib
    CONFIG  += qt activeqt dll
    
    DEF_FILE = qaxserver.def
    RC_FILE  = qaxserver.rc
    ...
    \endcode

    The files \c qaxserver.rc and \c qaxserver.def are part of the
    framework and can be used from their usual location (specify a
    path in the \c .pro file), or copied into the project directory.
    You should \e not modify these files.

    The \c activeqt configuration will cause the \c qmake tool to add the 
    required build steps to the build system:
    \list
    \i link the binary against \c qaxserver.lib
    \i generate an interface definition and link the type library into
       the binary
    \i register the server
    \endlist

    See the \link qaxserver-faq.html QAxServer FAQ \endlink for a list of
    common problems when building the ActiveX server.

    \section2 Out-of-process vs. In-process

    Whether your ActiveX server should run as a stand-alone executable
    or as a shared library in the client process depends mainly on the
    type of controls you want to provide in the server. 
    
    An executable server has the advantage of being able to run as a
    stand-alone application, but adds considerable overhead to the
    communication between the ActiveX client and the control. If the
    control has a programming error only the server process running
    the control will crash, and the client application will probably
    continue to run.

    An in-process server is usually smaller and has faster startup
    time. The communication between client and server is done directly
    through virtual function calls and does not introduce the overhead
    required for remote procedure calls. But if the server crashes the
    client application is likely to crash as well.

    Both server types can use Qt either as a shared library, or
    statically linked into the server binary.

    \section1 Implementing Controls

    To implement an ActiveX control with Qt, create a subclass of QWidget
    or any existing QWidget subclass:

    \code
    #include <qwidget.h>

    class MyActiveX : public QWidget
    {
        Q_OBJECT
    \endcode

    The \c Q_OBJECT macro is required to provide the meta object information
    about the widget to the ActiveQt framework.
    Use the \c Q_PROPERTY macro to declare properties for the ActiveX control:

    \code
        Q_PROPERTY( int value READ value WRITE setValue )
    \endcode

    Declare a standard QWidget constructor taking a parent widget and a name, 
    and functions, signals and slots like any normal QWidget.
    \footnote
    If a standard constructor is not present the compiler will issue
    an error "no overloaded function takes 2 parameters" when using
    the default factory through the QAXFACTORY_DEFAULT macro. If you
    cannot provide a standard constructor you must implement a \l
    QAxFactory custom factory and call the constructor you have in
    your implementation of QAxFactory::create.
    \endfootnote

    \code
    public:
        MyActiveX( QWidget *parent = 0, const char *name = 0 )
        ...
        
        int value() const;

    public slots:
        void setValue( int );
        ...
       
    signals:
        void valueChange( int );
        ...

    };
    \endcode

    The ActiveQt framework will expose properties and public slots as ActiveX 
    properties and methods, and signals as ActiveX events.

    The Qt data types that are supported for properties and
    signal/slot parameters are:
    \list
    \i bool
    \i double
    \i int
    \i unsigned int
    \i QColor
    \i QDate
    \i QDateTime
    \i QTime
    \i QFont
    \i QString
    \i QCString
    \endlist
    Properties and signals/slots that have parameters using any other
    data types are ignored by the QActiveX framework.

    To make the properties bindable for the ActiveX client, use multiple
    inheritance from the QAxBindable class:

    \raw
    <pre>
    #include &lt;qwidget.h&gt;
    <b>#include &lt;qaxbindable.h&gt;</b>

    class MyActiveX : public QWidget<b>, public QAxBindable</b>
    {
        Q_OBJECT
    </pre>
    \endraw
  
    When implementing the property write functions, use the
    QAxBindable class's requestPropertyChange() and propertyChanged()
    functions to allow ActiveX clients to bind to the control
    properties. 
    \footnote 
    This is not required, but gives the client more control over 
    the ActiveX control.
    \endfootnote

    \section1 Serving Controls

    To make an ActiveX control available to the COM system it must
    be registered in the system registry using five unique
    identifiers. These identifiers are provided by tools like \c
    guidgen or \c uuidgen. The registration information allows COM to
    localize the binary providing a requested ActiveX control,
    marshall remote procedure calls to the control and read type
    information about the methods and properties exposed by the
    control.

    To create the ActiveX control when the client asks for it the
    server must export an implementation of a QAxFactory. Use the
    default factory when the server provides only a single ActiveX
    control, and implement a subclass of QAxFactory to provide
    multiple ActiveX controls. The default factory is available
    through a macro that takes the identifiers COM requires to locate
    the ActiveX control on the target system:

    \code
    QAXFACTORY_DEFAULT ( MyActiveX,
		"{ad90301a-849e-4e8b-9a91-0a6dc5f6461f}",
		"{87a5b65e-7fa9-4dc6-a176-47295988dcbd}",
		"{a6130ae9-8327-47ec-815b-d0b45a0d6e5e}",
		"{26c4e136-4e23-4347-af37-faf933b027e9}",
		"{a8f21901-7ff7-4f6a-b939-789620c03d83}" )
    \endcode

    The \link QAxFactory QAxFactory class documentation \endlink explains 
    how to use this macro, and how to implement and use custom factories.

    For out-of-process executable servers, implement a main()
    function, instantiate a QApplication object, and enter the event
    loop just like any normal Qt application. By default the
    application will start as a standard Qt application, but if you
    pass \c -activex on the command line it will start as an ActiveX
    server. Use QAxFactory::isServer() to create and run a standard
    application interface, or to prevent a stand-alone execution:

    \raw
    <pre>
    #include &lt;qapplication.h&gt;
    <b>#include &lt;qaxfactory.h&gt;</b>

    int main( int argc, char **argv )
    {
        QApplication app( argc, argv );
        <b>if ( !QAxFactory::isServer() ) {
            // create and show main window...
        }</b>
        return app.exec();
    }
    </pre>
    \endraw

    In-process servers must also implement \c main(); but it is never
    called so a dummy implementation is sufficient.

    \code
    int main( int , char ** )
    {
        return 0;
    }
    \endcode

    To build the ActiveX server executable run \link qmake-manual.book
    qmake\endlink to generate the makefile, and use your compiler's
    make tool as for any other Qt application. The make process will
    also register the controls in the system registry by calling the
    resulting executable with the \c -regserver command line option.
    See the \link qaxserver-faq.html Typical build errors
    \endlink list for information on problems that can occur when
    building the ActiveQt server executable.

    If the ActiveX server is an executable, the following command line
    options are supported:
    \table
    \header \i Option \i Result
    \row \i \c -regserver \i Registers the server in the system registry
    \row \i \c -unregserver \i Unregisters the server from the system registry
    \row \i \c -activex \i Starts the application as an ActiveX server
    \row \i \c{-dumpidl <file>} \i Writes the server's IDL to the
    specified file
    \endtable

    In-process servers can be registered using the \c regsvr32 tool available
    on all Windows systems.

    \section1 Using the Controls

    To use the ActiveX controls, e.g. to embed them in a web page, use
    the \c <object> HTML tag. 

    \code
    <object ID="MyActiveX1" CLASSID="CLSID:ad90301a-849e-4e8b-9a91-0a6dc5f6461f">
       ...
    <\object>
    \endcode

    To initialize the control's properties, use
    \code
    <object ID=...>
        <param name="name" value="value">
    <\object>
    \endcode

    If the web browser supports scripting use JavaScript, VBScript and
    forms to script the control. The \link activeqt-examples.html
    examples \endlink include demonstration HTML pages for the
    example controls.

    \section1 Enhanced features

    \section2 More Interfaces

    The ActiveX control provide by ActiveQt servers supports a minimal
    set of COM interfaces to implement the OLE specifications. When the ActiveX 
    class inherits from the QAxBindable class it can also implement additional 
    COM interfaces.

    Create a new subclass of QAxAggregated and use multiple inheritance
    to subclass additional COM interface classes. 

    \code
    class AxImpl : public QAxAggregated, public ISomeCOMInterface
    {
    public:
        AxImpl() {}

        long queryInterface( const QUuid &iid, void **iface )
        {
	    *iface = 0;	    
	    if ( iid == IID_ISomeCOMInterface )
	        *iface = (ISomeCOMInterface*)this;
	    else
	        return E_NOINTERFACE;

            AddRef();
	    return S_OK;
        }
        
        // IUnknown
	QAXAGG_IUNKNOWN

        // ISomeCOMInterface
        ...
    }
    \endcode

    Reimplement the \c queryInterface() function to support the additional 
    COM interfaces.

    \code
    long AxImpl::queryInterface( const QUuid &iid, void **iface )
    {
        *iface = 0;
	if ( iid == IID_ISomeCOMInterface )
	    *iface = (ISomeCOMInterface*)this;
	else
	    return E_NOINTERFACE;

	AddRef();
	return S_OK;
    }
    \endcode

    Since \c ISomeCOMInterface is a subclass of \c IUnknown you will have
    to implement the \c QueryInterface, \c AddRef and \c Release functions. 
    Use the \c QAXAGG_IUNKNOWN macro in your class definition to do that. If 
    you implement the IUnknown functions manually, delegate the calls to the
    interface pointer returned by the controllingUnknown() function, e.g.
    \code
    HRESULT AxImpl::QueryInterface( REFIID iid, void **iface )
    {
        return controllingUnknown()->QueryInterface( iid, iface );
    }
    \endcode
    Do not support the \c IUnknown interface itself in your \c queryInterface() 
    implementation.

    Implement the methods of the COM interfaces. If you need to make
    calls to the QWidget implementing the ActiveX control, use
    QAxAggregated::widget().

    In your QAxBindable subclass, implement \c createAggregate() to return
    a new object of the QAxAggregated subclass.
    
    \raw
    <pre>
    class MyActiveX : public QWidget,                       
                      <b>public QAxBindable</b>
    {
    	Q_OBJECT
    public:
        MyActiveX( QWidget *parent, const char *name = 0 );

        <b>QAxAggregated *createAggregate()
        {
            return new AxImpl();
        }
        </b>
    };
    </pre>
    \endraw

    \section2 Fewer methods and properties

    By default all ActiveX controls expose not only their own methods
    and properties to ActiveX clients, but also those of all super
    classes, including QWidget.

    This can be controlled by reimplementing QAxFactory's
    exposeToSuperClass() function. Reimplement the function to return
    the last (furthest up the inheritance hierarchy) super class that
    should be exposed:

    \code
    QString MyFactory::exposeToSuperClass( const QString &key ) const
    {
        if ( key == "SmallActiveX" )
            return key;
        return QAxFactory::exposeToSuperClass( key );
    }
    \endcode

    The SmallActiveX control will only expose its own functions and
    properties to clients, while all other ActiveX controls provided
    by this factory will expose their own functions and properties and
    also those of all their super classes including QWidget. The
    SmallActiveX class can of course propagate some of the QWidget
    functions and properties into its own interface.
*/

/*! \page qaxcontainer.html

    \title The QAxContainer Module

    The ActiveQt framework provides a library implementing a QWidget
    subclass, QAxWidget, that acts as a container for ActiveX
    controls. 
    
    This module is part of the \link activeqt.html ActiveQt
    framework\endlink. (To make an application into an ActiveX server
    see the \link qaxserver.html QAxServer module\endlink.)

    The module consists of three classes
    \list 1
    \i QAxBase is an abstract class that provides an API to initialize 
       and access a COM/ActiveX object.
    \i QAxObject provides a QObject that wraps a COM object.
    \i \l QAxWidget is a \l QWidget that wraps an ActiveX control.
    \endlist

    Some \link activeqt-examples.html example applications \endlink
    that use standard ActiveX controls to provide high level user
    interface functionality are provided.

    \section1 Building the library

    In the \c activeqt directory (usually \c QTDIR/extensions/activeqt)
    enter the \c container subdirectory and run \c qmake to generate the
    makefile, and use the make tool (\c nmake for VC++, \c make for Borland)
    to build the library. The library \c qaxcontainer.lib will be linked 
    into \c QTDIR/lib. If you build a shared library (i.e. when Qt is a 
    shared library) the \c qaxcontainer.dll will be copied into 
    \c QTDIR/bin and into the \link designer-manual.book Qt
    Designer\endlink plugin directory.
    
    \section1 Using the library

    To use the classes the application must link against
    the \c qaxcontainer.lib file. Add

    \code
    LIBS += $(QTDIR)/lib/qaxcontainer.lib
    \endcode

    to your application's \c .pro file.

    
    See the QAxWidget API reference for documentation about how to 
    use this class to embed ActiveX controls in Qt applications.

    The \link qaxcontainer-faq.html QAxContainer FAQ \endlink provides
    additional information about building and distributing Qt 
    applications hosting ActiveX controls.
*/
