/*!
    \page activeqt-dotnet.html
    \ingroup qaxserver-examples
    \title Walkthrough: Using Qt objects in Microsoft .NET

    \tableofcontents

    \section1 Introduction

    In the following walkthrough we will show how Qt objects can be
    used in a .NET environment using the ActiveQt framework as the
    interoperability bridge between the .NET world and Qt.

    \section1 Qt vs. .NET

    Qt is a C++ library and is compiled into traditional, native
    binaries that make full use of the performance provided by the
    runtime environment, and even though Qt provide powerful mechansims
    to simplify memory management it does not provide any garbage
    collection.

    One key concept of .NET is the idea of "managed code" - source
    code is compiled into an intermediate bytecode, and that bytecode
    is run through a virtual machine - the common language runtime, CLR.
    This virtual machine provides among other things garbage collection
    for allocated objects.

    While it is possible to compile Qt application code into bytecode
    for the CLR, and to call managed code from that application,
    it is impossible to go the other way round - managed code can not
    call unmanaged code.
    \footnote The .NET framework provides Platform Invocation Services -
    P/Invoke - that enable managed code to call C-style functions in
    DLLs directly, but there is no such functionality for C++ classes.
    \endfootnote

    \section1 Wrapping Classes

    To use unmanaged C++ classes in managed code you have to write a
    managed wrapper class for each of your classes.

    \section2 Writing a managed wrapper

    \code
    // unmanaged Qt/C++ class
    class Worker : public QObject
    {
    public:
        Worker();

        QString statusString() const;
        void setStatusString(const QString &str);
    };

    // managed .NET class
    public __gc class netWorker
    {
    public: 
        netWorker();
        ~netWorker();

        String *statusString();
        void setStatusString(String *string);
    private:
        Worker *worker;
    };
    \endcode

    In addition to writing a wrapper class you also have to convert
    Qt's and your own datatypes into .NET datatypes, e.g. \c QString 
    objects need to be converted into a objects of type \c {String*}.

    \code
    String *StringFromQString(const QString &qstring)
    {
        String string = new String;
        ###
        return string;
    }

    QString QStringFromString(String *string)
    {
        QString qstring;
        ###
        return qstring;
    }
    \endcode

    Such converter function can then be used in the managed wrapper
    class to call the functions in the unmanaged C++ class.

    \code
    netWorker::netWorker()
    {
        worker = new Worker();
    }

    netWorker::~netWorker()
    {
        delete worker;
    }

    String *netWorker::statusString()
    {
        return QStringToString(worker->statusString());
    }

    void netWorker::setStatusString(String *string)
    {
        worker->setStatusString(StringToQString(string));
    }
    \endcode

    That wrapper can now be used in managed code, e.g. using C++, C#, 
    Visual Basic or any other programming language available for .NET.

    \code
    Public Sub
        Dim netWorker
        netWorker = New netWorker
        netWorker.setStatusString("Idle");
    End Sub
    \endcode

    This is clearly a big effort already for a simple class, and
    concepts like signals and slots cannot even be mapped through such
    a wrapper. In addition this effort is necessary to be able to support
    your code on a single additional platform - Microsoft .NET - and is
    useless for any other environment, where the wrapper class will not
    even compile as it uses Microsoft specific C++ extensions.

    \section2 COM Interop with ActiveQt

    A core technology of Microsoft is COM, and fortunately .NET provides 
    a generic wrapper for COM objects, the \e {Runtime Callable Wrapper} 
    (RCW). This wrapper is a managed proxy class for the COM object and 
    provides data marshaling, and is generated by the CLR when a .NET 
    Framework client activates a COM object. This provides a way to 
    reuse COM objects in a .NET Framework project.

    Making a QObject class into a COM object is easily done with ActiveQt
    and demonstrated in the \link qaxserver-examples examples \endlink.

    The walkthrough will use the Qt classes implemented in the
    \link qaxserver-examples.html QAxServer examples \endlink, so
    the first thing to do is to make sure that those examples have
    been built correctly.

    \section1 Walkthrough

    In the following we will create a simple user interface in Visual 
    Studio.NET, with some functionality implemented using C#.
    The interface will use the QPushButton class as well
    as the \link qaxserver-example-multiple.html QAxWidget2 \endlink 
    class.

    \section2 Starting a Project

    Start Visual Studio.NET, and start a new project ###
*/
