/*!
  \page arthur.html

  \ingroup examples

  \title Arthur, The Paint Engine

  \section1 Introduction

  The purpose of this demo is to present a visual overview of the
  features available from Qt 4's painting API. Some of these features
  are new in Qt 4, and some were present in Qt 3.x.

  \section2 The DemoWidget class

  We have implemented the convenience class DemoWidget for displaying
  the different parts of this demo. Each part is implemented as a
  subclass of DemoWidget.

  Most of the widgets in the demo have some animation. DemoWidget
  provides two functions to control this: DemoWidget::startAnimation()
  and DemoWidget::stopAnimation(). When the widget is running it will
  trigger a repaint on given intervals.

  Since most of the parts have motion, we provided a semi-random
  cosinus/sinus based function for continous modulation. The x and y
  coordinate of this function are available in DemoWidget::xfunc() and
  DemoWidget::yfunc().

  The demo also has a set of options that can be chosen by the user.
  These objects are available in the Attributes class. The function
  DemoWidget::fillBackground() takes care of background based on what
  the user has selected. LineAntialising and Alpha-blended primitives
  is handled in each separate paint event.

  DemoWidget also provides some protected member variables that are
  used in the demos.
  \list

  \i \c timeoutRate -- The number of milliseconds between each timeout.

  \i \c animationStep -- This value is incremented by one for each
  timeout, so it counts the number of steps onto the animation we are.

  \endlist


  \section1 Alpha-blended primitives

  The purpose of this part of the demo is to demonstrate how
  alpha-blending works in Qt 4.0. This example also makes heavy use of
  transformations in QPainter. We are drawing two shapes, the first is
  a rotating square with a drop shadow, and the second is a "snake" of
  primitives that move around the screen. The implementation of the
  example is located in the file \l alphashade.cpp

  In addition to to showing alpha-blending this part also draws
  with antialiased lines on the platforms where this is supported
  (Windows and Mac). This is done in AlphaShade::paintEvent() using
  the lines:

  \quotefile arthur/alphashade.cpp

  \skipto ->antialias)

  \printto p->setRenderHint

  \section2 A rotating rectangle with drop shadow

  We start by setting a world transform for the painter that does what
  we need. The easiest way to get rotating behavour is to move the
  origin of the painter to the center of the screen. Then rotate it
  by our given angle (we use animation step, which means one more degree
  per repaint) and then translate the origin back 1/4 to get the origin
  rotating at an ellipse of roughly 1/4 of the widget size.

  \skipto // Get painter into position

  \printto int offset

  We then specify the color of the drop shadow. We want it to be a
  semi-transparent black, so we set the color and specify an alpha
  value of 31 (this is roughly 1/8 opacity).

  \skipto // Tr
  \printto for (int x=0

  Then we want to draw the drop shadow. To get the effect of blurry
  edges we draw a number of rectangles instead of just one. Each of
  the rectangles is offset by a small number of pixels. Since the
  shadow should appear below the rectangle we transform the painter
  accordingly.

  \printto // The solid

  Then we draw the rectangle on top and restore.

  \printto p->restore()

  \section2 A snake of primitives

  The snake of primitives is drawn by using the motion function
  described in DemoWidget above. We use the animationStep and each
  primitive's index to modulate the function. This displaces each drawn
  primitive in such away that it appears as a snake. We also use each
  primitive's index to decide its color. We have defined a colormap for
  this.

  \quotefile arthur/alphashade.cpp
  \skipto for (int i=0; i<count

  \printuntil } // for

  \section2 Comparison to Qt 3.x

  Alpha-blending is a new feature in Qt 4, so to achieve these
  particular effects with Qt 3.x we would have to manipulate pixels
  directly in a QImage and draw that instead. This would have been
  fairly complex given the world matrix and the complexity of some of
  the polygons. In addition it would be rather slow, since we could
  not take advantage of alpha-blending in hardware where present. The
  transformation code on the other hand, is identical to how it would
  be done in Qt 3.x


  \section1 Rotating gradient

  Qt 4.0 has support for filling using linear gradients. This means
  that you can specify a linear gradient brush and use it to fill any
  primitive type drawn by QPainter. The linear gradients in Qt are
  implemented using two arbitrary points with a color attached to
  each. The area between the points is filled with colors gradually
  shifting from the color of the first point to the color of the next
  point. The areas on each side of the gradient area is painted with
  the color on that respective side.

  In this example we want to have two points that move in a circular
  motion around each other.

  \quotefile arthur/rotatinggradient.cpp

  \skipto // Define
  \printuntil fade = 511

  We define a value that moves up and down beween 0 and 255. This value
  is used later in the function for several purposes.

  \printuntil QPoint p2

  We create two points on opposite sides of the origin and multiply them
  with a matrix. The matrix is rotated one degree clockwise (in
  RotatingGradient::timerEvent()) so the points will then move in a
  circle around the upper left corner of the widget. We then add the
  widget center to the points so that they rotate around the center of
  the widget.

  \skipto // Define

  \printuntil p.setBrush

  We then create a brush from p1 to p2. We use the fade value to let
  the colors vary. Then we set the brush on the painter.

  \printuntil p.drawRect

  Now that the widget's fill mode is set to a rotating gradient, we
  can fill the contents using QPainter::drawRect(). Note that once a
  gradient brush is set, any QPainter::draw*() call can be used for
  filling.

  \section2 Comparison to Qt 3.x

  Like alpha-blended primitives, Qt 3.x did not support gradient
  filling using brushes, so this would have to be done manually by the
  programmer.

  \section1 Clip regions

  The purpuse of this part is to demonstrate the use of complex clip
  regions. This is achieved using QRegion and some of its operators.
  It is possible to add to a region by combining it with another
  region. This is done using QRegion::unite() or QRegion::operator|=.
  It is also possible to invert regions by using QRegion::eor() or
  QRegion::operator=^().

  In this example we have a number of rectangles. We want to move
  them around in the widget and unite them in one region. The
  DemoWidget class supports animation through a timerEvent, so we
  reimplement the timerEvent function and move the rectangles
  there. Another thing we wanted to achieve is to let the user draw
  rectangle using the mouse. We then invert the region in the area
  of the rectangle dragged out by the mouse. This produces a nice and
  complex clip region.

  We then take a look at the paintEvent to see how the region is
  created.

  \quotefile arthur/clipping.cpp

  \skipto // Start with an

  \printuntil QRegion region

  We start out with an empty region.

  \printto // If the mouse

  Then we iterate through all the rectangles in our list of
  rectangles. The rectangles are united with the region using
  QRegion::operator|=. Also, just to make the region a bit more
  interresting, we create an elliptical region of some of them. The \c
  i%4==0 will make every fourth rectangle an ellipse instead of a
  rectangle.

  \printto // Create

  We then add the rectangle defined by the mouse if dragged. We've
  reimplemnted QWidget::mousePressEvent() and
  QWidget::mouseReleaseEvent() to get the mouse positions. \c
  pressPoint specifies where the drag started and currentPoint
  specifies the mouse cursor's current position. We create a rectangle
  based on this and use it to invert the region using
  QRegion::operator^=().

  \printuntil pt.setClip

  Now we want to create the clip region that covers the entire widget,
  except the pieces covered by the region we have built up. We do this
  by creating a clip region that's the same size as the widget, and
  invert it with the built up region.

  \printuntil pt.drawRect

  Then we set the painter's brush to the widget's background color and
  fill it.

  \section2 Comparison to Qt 3.x

  The class QRegion that we used in this example has not changed
  behavior since Qt 3.x, so using complex regions in this way
  would be similar if done in Qt 3.x.

  \section1 Paths

  In this part we want to show how to use paths for filling and
  outlining. Paths are a new way of drawing introduced in Qt 4.0; see
  the class documentation for QPainterPath for more information.

  In this example we want to create a path based on a simple shape (a
  rectangle in this case) and a more complex shape (some bezier
  curves).

  \quotefile arthur/paths.cpp

  \skipuntil // Define some

  \printto // Create the

  The first thing we do is to create some semi-random points. These
  will be used to modulate the bezier curves.

  \printto // Add the bez

  Then we create the path

  \printuntil path.closeSubpath

  We now want to add the bezier curves to the path. We want these to
  compose a closed shape, so we start by opening a subpath. (Opening a
  subpath is not strictly necessary in this case since QPainterPath
  always starts out with a subpath that can be added to). After that
  we add the points and close the subpath. This will connect the last
  point added to the first point in the subpath, producing a closed
  shape.

  \printuntil path.addRect

  We then add a rectangle at the center of the widget.

  \printuntil p.drawPath

  Finally, we draw the path, using the current pen and brush.

  \section2 Comparison to Qt 3.x

  Painter paths are a new feature in Qt 4.0, but it was to some degree
  possible to achieve the same results using QRegion operations (as we
  did in the clipping example above), in combination with QPolygon
  and clipped filling. QPainterPath has several advantages over that
  approach. One is that a QPainterPath is scalable, meaning that when
  you draw on a painter with a world matrix, you don't lose precision
  when zooming in. And in most cases, QPainterPath is significantly
  faster since performing operations on QRegions is computationally
  expensive if the region is complex. And finally, the QPainterPath
  API is much easier to use.

  \section1 Stretched Pixmap

  The purpose of this part is to demonstrate how pixmaps can be
  stretched by QPainter.

  What we want to do in this example is to take a pixmap and
  stretch it a bit in different directions. The approach chosen for
  this is to split the pixmap into four equally large parts and split
  the widget into four unequal parts. We let each of the pixmap parts
  cover one of the widget's parts. The size of the widget's parts is
  selected by using either the mouse position currently pressed by the
  user or just a semi-random one.

  \quotefile arthur/warpix.cpp

  \skipto p.drawPixmap(

  The above lines are the relevant parts of the paint event that
  stretch and draw the pixmaps.

  \section2 Comparison to Qt 3.x

  The functionality shown in this example has not changed since Qt
  3.x. What has changed is how the function might perform on certain
  platforms. In Qt 4.0 we make use of native transformations if the
  underlying platform supports it. This means that the time spent on
  these type of operations may be significantly reduced.

*/
