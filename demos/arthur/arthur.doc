/*!
  \page arthur.html

  \ingroup examples

  \title Arthur, The Paint Engine

  \section1 Introduction

  The purpose of this example is to sum up the features available by
  the Qt painting API. Some of these features are new in Qt 4, and some
  were present in Qt 3.x.

  \section2 The DemoWidget class

  We have implemented a the conveninece class DemoWidget for
  displaying the different sides of this demo. Each of the different
  topics in this demo are implemented as a subclass of DemoWidget.

  Most of the widgets in the demo have some animation. DemoWidget
  provides two functions DemoWidget::startAnimation() and
  DemoWidget::stopAnimation(). When the widget is running it will
  trigger a repaint on given intervals.

  Since most of the demos have motion, we provided a semirandom
  cosinus/sinus based function for continous modulation. The x and y
  coordinate of this function are available in DemoWidget::xfunc() and
  DemoWidget::yfunc().

  The demo has a set of options that can be chosen by the user. These objects
  are available in the Attributes class. The function DemoWidget::fillBackground()
  takes care of background based on what the user has selected. LineAntialising
  and Alpha blended primitives is handled in each separate paint event.

  DemoWidget also provides some protected membervariables that we
  make use of in the demos.
  \list

  \i \c timeoutRate; The number of milliseconds between each timeout.

  \i \c animationStep; This value is incremented by one for each
  timeout, so it counts the number of steps onto the animation we are.

  \endlist


  \section1 Alphablended primitives

  The purpose of this demo is tho demonstrate how alpha blending works
  with Qt 4.0. This example also makes heavy use of transformations in
  QPainter. We are drawing two shapes in this example. The first is a
  rotating square with a drop shadow. The second is a "snake" of
  primitives that move around the screen. The implementation of the
  example is located in the file \l alphashade.cpp

  In addition to to showing alphablending this examples also draws
  with antialiased lines on the platforms where this is supported
  (Windows and Mac). This is done in AlphaShade::paintEvent() using
  the lines:

  \quotefile arthur/alphashade.cpp

  \skipto if (attributes->antialias)

  \printto p.setRenderHint

  \section2 A rotating rectangle with drop shadow.

  We start by setting a world transform for the painter that does what
  we need. The easiest way to get rotating behavour is to move the
  origin of the painter to the center of the screen. Then rotate it
  our given angle (we use animation step, which means one more degree
  pr repaint) and then translate the origin back 1/4 to get the origin
  rotating at an ellipse of rouhgly 1/4 the widget size.

  \skipto // Get painter into position

  \printto int offset

  We then specify the color of the drop shadow. We want it to be a
  semitransparent black, so we set the color and specify an alpha
  value of 31 (this is roughly 1/8 opacity).

  \skipto // Tr
  \printto for (int x=0

  Then we want to draw the drop shadow. To get the effect blurry edges
  we draw a number of rectangles instead of just one. Each of the
  rectangles is offseted by a small number of pixels. Since the shadow
  should appear below the rectangle we transform the painter thus.

  \printto // The solid

  Then we draw the rectangle on top and restore.

  \printto p.restore()

  \section2 A snake of primitives

  The snake of primitives drawn by using the motion function described
  in DemoWidget above. We use the animationStep and the each
  primitives index to modulate the function. This displaces each drawn
  primitive in such away that it appears as a snake. We also use the
  primitives index to decide its color. We have defined a colormap for
  this.

  \quotefile arthur/alphashade.cpp
  \skipto for (int i=0; i<count

  \printuntil } // for

  \section2 Comparison to Qt 3.x

  Alphablending is a new feature in Qt 4, so to acheive these
  particular effects with Qt 3.x we would have to manipulate pixels
  directly in a QImage in draw that instead. This would have been
  fairly complex given the world matrix and the complexity of some of
  the polygons. In addition it would be rather slow, since we could
  not take advantage of alphablending in hardware were present. The
  transformation code on the other hand, is identical to how it would
  be done in Qt 3.x


  \section1 Rotating gradient

  Qt 4.0 has support for filling using linear gradients. This means
  that you can specify a linear gradient brush and use it to fill any
  primitive type drawn by QPainter. The linear gradients in Qt are
  implemented using two arbitrary points with a color attached to
  each. The area between the points is filled with colors gradually
  shifting from the color of the first point to the color of the next
  point. The areas on each side of the gradient area is covered with
  the color on that respective side.

  In this example we want to have two points that move in circular
  motion around each other.

  \quotefile arthur/rotatinggradient.cpp

  \skipto // Define
  \printuntil fade = 511

  We define a value that moves up and down beween 0 and 255. This value
  is used later in the function for several purposes.

  \printuntil QPoint p2

  We create two points on oposide sides of origo and multiply them
  with a matrix. The matrix is rotated one degree clockwise (in
  RotatingGradient::timerEvent()) so the points will then move in a
  circle around the upper left corner of the widget. We then add the
  widget center to the points so that they rotate around the center of
  the widget.

  \skipto // Define

  \printuntil p.setBrush

  We then create a brush from p1 to p2. We use the fade value to let
  the colors vary. Then we set the brush on the painter.

  \printuntil p.drawRect

  Now that the fill mode of the widget is set to a rotating gradient,
  we can fill the contents using QPainter::drawRect(). Note that once
  a gradient brush is set, any QPainter::drawxxx call can be used to
  fill.

  \section2 Comparison to Qt 3.x

  Like Alpha blended primitives, Qt 3.x did not support gradient
  filling using brushes, so this would have to be done manually by the
  programmer.

  \section1 Clip regions

  The purpuse of this example is to demonstrate use of complex clip
  regions. This is acheived using QRegion and some of its
  operators. It is possible to add to a region by joining it with
  another region. This is done using QRegion::unite() or
  QRegion::operator|=. It is also possible to invert regions by using
  QRegion::eor() QRegion::operator=^().

  In this example we have a number of rectangles. We want to move
  these around in the widget and unite them in one region. The
  DemoWidget class supports animation through a timerEvent, so we
  reimplement the timerEvent function and move the rects
  there. Another thing we wanted to acheive is that the user can draw
  up a rectangle using the mouse. We then invert the region in the area
  of the mouse rect. This produces a nice and complex clip region.

  We then take a look at the paintEvent to see how the region is
  created.

  \quotefile arthur/clipping.cpp

  \skipto // Start with an

  \printuntil QRegion region

  We start out with an empty region.

  \printto // If the mouse

  Then we iterate through all the rectangles in our list of rects. The
  rectangles are united with the region using the
  QRegion::operator|=. Also, just to make the region a bit more
  interresting, we create an elliptical region of some of them. The \c
  i%4==0 will make every fourth rectangle an ellipse instead of a
  region.

  \printto // Create

  We then add the rectangle defined by the mouse if dragged. We've
  reimplemnted QWidget::mousePressEvent() and
  QWidget::mouseReleaseEvent() to get the mouse positions. \c
  pressPoint describes where the drag started and currentPoint
  describes where the cursor currently is. We create a rectangle based
  on this and use it to invert the region using QRegion::operator^=().

  \printuntil pt.setClip

  We now want to create the clip region that covers the entire widget,
  except the pieces covered by the region we have built up. We do this
  by creating a widget of same size as the widget, and inverting it
  with the built up region.

  \printuntil pt.drawRect

  The we set the painters brush to the widgets background color and
  fill it.

  \section2 Comparison to Qt 3.x

  The class QRegion that we used in this example has not changed
  behaviour since Qt 3.x so using complex regions in this way
  would be similar if done in Qt 3.x.

  \section1 Paths

  In this example we want to show how to use paths for filling and
  outlining. Paths is a new way of drawing introduced in Qt 4.0, see
  the class documentation for QPainterPath for more info.

  In this example we want to create a path based on a simple shape (a
  rectangle in this case) and a more complex shape (some bezier
  curves).

  \quotefile arthur/paths.cpp

  \skipuntil // Define some

  \printto // Create the

  The first thing we do is to create some semirandom points. These
  will be used to modulate the bezier curves.

  \printto // Add the bez

  Then we create the path

  \printuntil path.closeSubpath

  We now want to add the bezier curves to the path. We want these to
  compose a closed shape, so we start by opening a subpath. (Opening a
  subpath is not strictly necessary in this case since QPainterPath
  always starts out with a subpath that can be added to). After that
  we add the points and close the subpath. This will connect that last
  point added to the first point in the subpath, causing a closed
  shape.

  \printuntil path.addRect

  We then add a rect at the center of the widget.

  \printuntil p.drawPath

  Finally, we draw the path, using the current pen and brush.

  \section2 Comparison to Qt 3.x

  Painter paths are a new feature in Qt 4.0, but it was to some degree
  possible to acheive the same results using QRegion operations as we
  did in the clipping example above in combination with QPaintArray
  and clipped filling. QPainterPath has several advantages over this
  approach. One is that a QPainterPath is scalable, meaning that when
  you draw on a painter with a world matrix, you don't loose precision
  when zooming in. QPainterPath will also in most cases be
  significantly faster since performing operations on QRegions is
  heavy if the region is complex. And finally, the QPainterPath API is
  much easier to use.

  \section1 Stretched Pixmap

  The purpose of this example is to demonstrate how pixmaps can be
  stretched using the function QPainter functionallity.

  What we want to do in this pixmap is to take a pixmap and make
  stretch it a bit in different directions. The approach choosen for
  this is to split the pixmap into four equally large parts and split
  the widget into four unequal parts. We let each of the pixmap parts
  cover one of the pixmaps. The size of the widget parts is selected
  by using either the mouse position currently pressed by the user or
  just a semirandom one.

  \quotefile arthur/warpix.cpp

  \skipto p.drawPixmap(

  The above lines are the relevant parts of the paint event that
  stretch and draw the pixmaps.

  \section2 Comparison to Qt 3.x

  The functionality shown in this example has not changed since Qt
  3.x. What has changed is how the function might perform on certain
  platforms. In Qt we make use native transformations if the
  underlying platform supports it. This means that the time spend on
  these type of operations may be significantly reduced.

*/
