<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<!-- d:\depot\qt\main/doc/src/qt4-arthur.qdoc -->
<head>
    <title>Qt 4: The Arthur Paint Subsystem</title>
    <style>h3.fn,span.fn { margin-left: 1cm; text-indent: -1cm; }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
body { background: #ffffff; color: black; }</style>
</head>
<body>
<h1 align="center">Qt 4: The Arthur Paint Subsystem</h1>
<p>This document describes Qt 4's approach to painting, and contrasts it with the Qt 3 approach.</p>
<ul><li><a href="#sec.1">Architecture</a></li>
<ul><li><a href="#sec.1.1">A Look Back at Qt 3</a></li>
<li><a href="#sec.1.2">How Painting is Done in Qt 4</a></li>
<li><a href="#sec.1.3">Enabling Use of GDI+ on Windows</a></li>
</ul>
<li><a href="#sec.2">New Features in the Qt 4 Paint Subsystem</a></li>
<ul><li><a href="#sec.2.1">Linear Gradient Brushes</a></li>
<li><a href="#sec.2.2">Alpha-Blended Drawing</a></li>
<li><a href="#sec.2.3">QPainter&nbsp;and QGLWidget</a></li>
<li><a href="#sec.2.4">Anti-Aliased Edges</a></li>
<li><a href="#sec.2.5">Extensive Use of Native Graphics Operations</a></li>
<li><a href="#sec.2.6">Painter Paths</a></li>
<li><a href="#sec.2.7">Widget Double-Buffering</a></li>
<li><a href="#sec.2.8">Pen and Brush Transformation</a></li>
</ul>
<li><a href="#sec.3">More to Come</a></li>
</ul>
<a name="sec.1"></a>
<h2>Architecture</h2>
<p>The Qt 4 Paint Subsystem is primarly based on the classes <b>QPainter</b>, <b>QPaintDevice</b>&nbsp;and <b>QPaintEngine</b>. <b>QPainter</b>&nbsp;is the class used to perform drawing operations, for example, <tt>drawLine()</tt>&nbsp;and <b>drawRect</b>(). <b>QPaintDevice</b>&nbsp;is an object that can be painted on using a <b>QPainter</b>. Both <b>QWidget</b>&nbsp;and <b>QPixmap</b>&nbsp;are QPaintDevices. <b>QPaintEngine</b>&nbsp;is the painter's means of drawing to a specific device type.</p>
<a name="sec.1.1"></a>
<h3>A Look Back at Qt 3</h3>
<p>In Qt 3, QPainter&nbsp;could be used to draw on widgets and pixmaps. (It could also be used to draw to printers on Windows and Mac OS X). When other paint devices needed to be supported, such as QPrinter&nbsp;on X11, this was done by deriving from QPaintDevice&nbsp;and reimplementing the virtual function QPaintDevice::cmd(). A reimplemented paint device was treated as an external device.</p>
<p>QPainter&nbsp;was capable of recognizing external devices and could serialize each paint operation to the reimplemented cmd()&nbsp;function. This allowed reimplementation of arbitrary devices, but the approach has some disadvantages which we have addressed in Qt 4. One of these is that an external device could not reuse any functionality implemented in QPainter&nbsp;since QPainter&nbsp;is tied to widget/pixmap painting on the current platform. Supporting multiple device backends, such as OpenGL, was therefore inconvenient and not very efficient.</p>
<p>This has led us to devise a more convenient and intuitive API for Qt 4.</p>
<a name="sec.1.2"></a>
<h3>How Painting is Done in Qt 4</h3>
<p>In Qt 4 we have introduced the abstract class <b>QPaintEngine</b>. Implementations of this class provide the concrete functionallity needed to draw to a specific device type. The class QPaintEngine&nbsp;is only used internally by QPainter&nbsp;and QPaintDevice&nbsp;and is hidden from application programmers, unless they reimplement their own device type in their own QPaintEngine&nbsp;subclass. Qt currently provides paint engines for the following platforms and API's:</p>
<ul>
<li>GDI and GDI+ on Windows</li>
<li>OpenGL&nbsp;on all platforms</li>
<li>PostScript&nbsp;on Linux, Unix, and Mac OS X</li>
<li>QuickDraw&nbsp;and CoreGraphics&nbsp;on Mac OS X</li>
<li>X11&nbsp;and the X Render Extension on Linux and Unix systems</li>
<li>QVFb, VNC and LinuxFb&nbsp;on Qt/Embedded</li>
</ul>
<p>To implement support for a new backend, you must derive from QPaintEngine&nbsp;and reimplement its virtual functions. You also need to derive from QPaintDevice&nbsp;and reimplement the virtual function <b>QPaintDevice::paintEngine</b>()&nbsp;to tell QPainter&nbsp;which paint engine should be used to draw on this particular device.</p>
<p>The main benefit of this approach is that all painting follows the same painting pipeline which means that adding support for new features and providing default implementations for unsupported ones has become much simpler.</p>
<a name="sec.1.3"></a>
<h3>Enabling Use of GDI+ on Windows</h3>
<p>GDI+ is installed by default on Windows XP, and is available as a downloadable redistributable binary for 98/ME/NT/2000. In order for Qt to take advantage of the features in GDI+ the gdiplus.dll library must be in the PATH.</p>
<a name="sec.2"></a>
<h2>New Features in the Qt 4 Paint Subsystem</h2>
<a name="sec.2.1"></a>
<h3>Linear Gradient Brushes</h3>
<p>With Qt 4 it is possible to fill shapes using a linear gradient brush. A gradient in this case is used to describe the transition from one color at one point to another color at another point. We use the term linear gradient since the transition area follows a line.</p>
<p>Setting a linear gradient brush is done using the <b>QBrush</b>&nbsp;constructor that takes two points and two colors, as sketched below:</p>
<pre>&nbsp;   QBrush diagonalGradient(QPoint(0, 0), Qt::red, QPoint(width(), height()), Qt::blue);
    painter.setBrush(diagonalGradient);
    painter.drawRect(0, 0, width(), height());</pre>
<p>The code shown above produces a pattern as show in the following pixmap:</p>
<center><img src=":/res/diagonalGradient.png" /></center><a name="sec.2.2"></a>
<h3>Alpha-Blended Drawing</h3>
<p>With Qt 4 we support alpha-blended outlining and filling. The alpha channel of a color is specified through <b>QColor</b>.</p>
<pre>&nbsp;   // Specfiy semi-transparent red
    painter.setBrush(QColor(255, 0, 0, 127));
    painter.drawRect(0, 0, width()/2, height());

    // Specify semi-transparend blue
    painter.setBrush(QColor(0, 0, 255, 127));
    painter.drawRect(0, 0, width(), height()/2);</pre>
<p>The code shown above produces the following output.</p>
<center><img src=":/res/alphafill.png" /></center><p>Alpha-blended drawing is supported on Windows, Mac OS X, and on X11&nbsp;systems that have the X Render extension installed.</p>
<a name="sec.2.3"></a>
<h3>QPainter&nbsp;and QGLWidget</h3>
<p>It is now possible to open a QPainter&nbsp;on a QGLWidget&nbsp;as if it were a normal QWidget. One huge benefit from this is that we utilize the high performance of OpenGL&nbsp;for most drawing operations, such as transformations and pixmap drawing.</p>
<a name="sec.2.4"></a>
<h3>Anti-Aliased Edges</h3>
<p>On platforms where this is supported by the drawing API's, we provide the option of turning on anti-aliased edges when drawing primitives.</p>
<pre>&nbsp;   // One line without anti-aliasing
    painter.drawLine(0, 0, width()/2, height());

    // One line with anti-aliasing
    painter.setRenderHints(QPainter::LineAntialiasing);
    painter.drawLine(width()/2, 0, width()/2, height());</pre>
<p>This produces the following output.</p>
<center><img src=":/res/antialiased.png" /></center><p>Supported backends are currently Mac OS X, Windows if GDI+ is installed, X11&nbsp;and OpenGL.</p>
<a name="sec.2.5"></a>
<h3>Extensive Use of Native Graphics Operations</h3>
<p>In the Qt 4 Paint Subsystem we make more use of native graphics operations. The benefit we gain from this is that these operations can potentially be performed in hardware which gives significant speed improvements.</p>
<p>Among these are native transformations (Windows 2000/XP, Mac OS X, and, OpenGL) making painting with a world matrix much faster. Some pixmap operations have also been moved closer to hardware.</p>
<a name="sec.2.6"></a>
<h3>Painter Paths</h3>
<p>A painter path is an object composed of a number of graphical building blocks, such as rectangles, ellipses, lines and curves. A painter path can be used for filling, outlining, and for clipping. The main advantage of painter paths over normal drawing operations is that it is possible to build up non-linear shapes which can be drawn later one go.</p>
<p>Building blocks can be joined in closed subpaths, such as a rectangle or an ellipse, or they can exist independently as unclosed subpaths, although an unclosed path will not be filled.</p>
<p>Below is a code example on how a path can be used. The painter in this case has a pen width of 3 and a light blue brush. We first add a rectangle, which becomes a closed subpath. We then add two bezier curves, and finally draw the entire path.</p>
<pre>&nbsp;   QPainterPath path;
    path.addRect(20, 20, 60, 60);
    path.addBezier(0, 0,  99, 0,  50, 50,  99, 99);
    path.addBezier(99, 99,  0, 99,  50, 50,  0, 0);
    painter.drawPath(path);</pre>
<p>The code above produces the following output:</p>
<center><img src=":/res/pathexample.png" /></center><a name="sec.2.7"></a>
<h3>Widget Double-Buffering</h3>
<p>In Qt 4, all widgets are double-buffered by default.</p>
<p>In previous versions of Qt double-buffereing was acheived by painting to an off-screen pixmap then copying the pixmap to the screen. e.g.</p>
<pre>&nbsp;   QPixmap buffer(size());
    QPainter painter(&amp;buffer);

    // Paint code here

    painter.end();
    bitBlt(this, 0, 0, &amp;buffer);</pre>
<p>Since the double-buffering is handled by QWidget&nbsp;internally this now becomes:</p>
<pre>&nbsp;   QPainter painter(this);

    // Paint code here

    painter.end();</pre>
<p>Double-buffering is turned on by default, but can be turned off by setting the widget attribute Qt::WA_PaintOnScreen.</p>
<pre>&nbsp;   unbufferedWidget-&gt;setAttribute(Qt::WA_PaintOnScreen);</pre>
<a name="sec.2.8"></a>
<h3>Pen and Brush Transformation</h3>
<p>In Qt 3, pens and brushes weren't affected by the painter's transformation matrix. For example, if you drew a rectangle with a pen width of 1 using a scaled painter, the resulting line width would still be 1. This made it difficult to implement features such as zooming and high-resolution printing.</p>
<p>In Qt 4, pens and brushes honor the painter's transformation matrix.</p>
<p>Note that this feature is still in development and not yet supported on all platforms.</p>
<a name="sec.3"></a>
<h2>More to Come</h2>
<p>The Qt 4 Paint Subsystem is mostly completed, but there is still work being done.</p>
<p>Part of the work in progress is the finalization of the rendering pipeline for all platforms, so that all features are supported and look the same on all platforms. Among the currently unfinished features are these:</p>
<ul>
<li>Gradients cannot have alpha color on X11.</li>
<li>Support for querying for supported features (such as if antialiasing is available)</li>
</ul>
<p><a href="qt4-intro.html">[Back to the Technology Preview page]</a></p>
<p>See also <b>QBrush</b>.</p>
</body>
</html>
