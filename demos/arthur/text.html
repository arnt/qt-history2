<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<!-- d:\depot\qt\main/doc/tech-preview/painting.doc -->
<head>
    <title>The Qt 4.0 Paint Subsystem</title>
    
</head>
<body>
<h1 align="center">The Qt 4.0 Paint Subsystem</h1>
<p>This document describes Qt 4's approach to painting, and contrasts it with the Qt 3 approach.</p>
<ul><li>Architecture</li>
<ul><li>A look back at Qt 3.x</li>
<li>How painting is done in Qt 4</li>
<li>Enabling use of GDI+ on Windows</li>
</ul>
<li>New features in the Qt 4 paint subsystem</li>
<ul><li>Linear gradient brushes</li>
<li>Alpha-blended drawing</li>
<li>QPainter and QGLWidget</li>
<li>Anti-aliased edges</li>
<li>Extensive use of native graphics operations</li>
<li>QPainterPath</li>
<li>Widget double-buffering</li>
</ul>
<li>More to come</li>
</ul>
<a name="sec.1"></a>
<h2>Architecture</h2>
<p>The Qt 4 Paint Subsystem is primarly based on the classes QPainter, QPaintDevice&nbsp;and QPaintEngine. QPainter&nbsp;is the class used to perform drawing operations, for example, <tt>drawLine()</tt>&nbsp;and <b>drawRect</b>(). QPaintDevice&nbsp;is an object that can be painted on using a QPainter. Both QWidget&nbsp;and QPixmap&nbsp;are QPaintDevices. QPaintEngine&nbsp;is the painter's means of drawing to a specific device type.</p>
<a name="sec.1.1"></a>
<h3>A look back at Qt 3.x</h3>
<p>In Qt 3.x QPainter could be used to draw on widgets and pixmaps. (It could also be used to draw to printers on Windows and Mac OS X). When other paint devices needed to be supported, such as QPrinter on X11, this was done by deriving from QPaintDevice and reimplementing the virtual function QPaintDevice::cmd(). A reimplemented paint device was treated as an external device.</p>
<p>QPainter was capable of recognizing external devices and could serialize each paint operation to the reimplemented cmd() function. This allowed reimplementation of arbitrary devices, but the approach has some disadvantages which we have addressed in Qt 4. One of these is that an external device could not reuse any functionality implemented in QPainter since QPainter is tied to widget/pixmap painting on the current platform. Supporting multiple device backends, such as OpenGL, was therefore inconvenient and not very efficient.</p>
<p>This has led us to devise a more convenient and intuitive API for Qt 4.</p>
<a name="sec.1.2"></a>
<h3>How painting is done in Qt 4</h3>
<p>In Qt 4 we have introduced the abstract class QPaintEngine. Implementations of this class provide the concrete functionallity needed to draw to a specific device type. The class QPaintEngine is only used internally by QPainter and QPaintDevice and is hidden from application programmers, unless they reimplement their own device type in their own QPaintEngine subclass. Qt currently provides paint engines for the following platforms and API's:</p>
<ul>
<li>GDI and GDI+ on Windows.</li>
<li>OpenGL on all platforms.</li>
<li>PostScript on Linux, Unix, and Mac OS X</li>
<li>QuickDraw and CoreGraphics on Mac OS X.</li>
<li>X11 and the X Render Extension on Linux and Unix systems</li>
</ul>
<p>To implement support for a new backend, you must derive from QPaintEngine and reimplement its virtual functions. You also need to derive from QPaintDevice and reimplement the virtual function <b>QPaintDevice::paintEngine</b>()&nbsp;to tell QPainter which paint engine should be used to draw on this particular device.</p>
<p>The main benefit of this approach is that all painting follows the same painting pipeline which means that adding support for new features and providing default implementations for unsupported ones has become much simpler.</p>
<a name="sec.1.3"></a>
<h3>Enabling use of GDI+ on Windows</h3>
<p>GDI+ is installed by default on Windows XP, and is available as a downloadable redistributable binary for 98/ME/NT/2000. In order for Qt to take advantage of the features in GDI+ the gdiplus.dll library must be in the PATH.</p>
<a name="sec.2"></a>
<h2>New features in the Qt 4 paint subsystem</h2>
<a name="sec.2.1"></a>
<h3>Linear gradient brushes</h3>
<p>With Qt 4 it is possible to fill shapes using a linear gradient brush. A gradient in this case is used to describe the transition from one color at one point to another color at another point. We use the term linear gradient since the transition area follows a line.</p>
<p>Setting a linear gradient brush is done using the QBrush&nbsp;constructor that takes two points and two colors, as sketched below:</p>
<pre>&nbsp;   QBrush diagonalGradient(QPoint(0, 0), Qt::red, QPoint(width(), height()), Qt::blue);
    painter.setBrush(diagonalGradient);
    painter.drawRect(0, 0, width(), height());</pre>
<p>The code shown above produces a pattern as show in the following pixmap:</p>
<center><img src="diagonalGradient.png"></center><a name="sec.2.2"></a>
<h3>Alpha-blended drawing</h3>
<p>With Qt 4 we support alpha-blended outlining and filling. The alpha channel of a color is specified through QColor.</p>
<pre>&nbsp;   // Specfiy semi-transparent red
    painter.setBrush(QColor(255, 0, 0, 127));
    painter.drawRect(0, 0, width()/2, height());

    // Specify semi-transparend blue
    painter.setBrush(QColor(0, 0, 255, 127));
    painter.drawRect(0, 0, width(), height()/2);</pre>
<p>The code shown above produces the following output.</p>
<center><img src="alphafill.png"></center><p>Alpha-blended drawing is supported on Windows, Mac OS X, and on X11 systems that have the X Render extension installed.</p>
<a name="sec.2.3"></a>
<h3>QPainter and QGLWidget</h3>
<p>It is now possible to open a QPainter on a QGLWidget as if it were a normal QWidget. One huge benefit from this is that we utilize the high performance of OpenGL for most drawing operations, such as transformations and pixmap drawing.</p>
<a name="sec.2.4"></a>
<h3>Anti-aliased edges</h3>
<p>On platforms where this is supported by the drawing API's, we provide the option of turning on anti-aliased edges when drawing primitives.</p>
<pre>&nbsp;   // One line without anti-aliasing
    painter.drawLine(0, 0, width()/2, height());

    // One line with anti-aliasing
    painter.setRenderHints(QPainter::LineAntialiasing);
    painter.drawLine(width()/2, 0, width()/2, height());</pre>
<p>This produces the following output.</p>
<center><img src="antialiased.png"></center><p>Supported platforms are currently Mac OS X, Windows if GDI+ is installed, and OpenGL.</p>
<a name="sec.2.5"></a>
<h3>Extensive use of native graphics operations</h3>
<p>In the Qt 4 Paint Subsystem we make more use of native graphics operations. The benefit we gain from this is that these operations can potentially be performed in hardware which gives significant speed improvements.</p>
<p>Among these are native transformations (Windows 2000/XP, Mac OS X, and, OpenGL) making painting with a world matrix much faster. Some pixmap operations have also been moved closer to hardware.</p>
<a name="sec.2.6"></a>
<h3>QPainterPath</h3>
<p>A painter path is an object composed of a number of graphical building blocks, such as rectangles, ellipses, lines and curves. A painter path can be used for filling, outlining, and for clipping. The main advantage of painter paths over normal drawing operations is that it is possible to build up non-linear shapes which can be drawn later one go.</p>
<p>Building blocks can be joined in closed sub-paths, such as a rectangle or an ellipse, or they can exist independently as unclosed sub-paths, although an unclosed path will not be filled.</p>
<p>Below is a code example on how a path can be used. The painter in this case has a pen width of 3 and a light blue brush. We first add a rectangle, which becomes a closed sub-path. We then add two bezier curves, and finally draw the entire path.</p>
<pre>&nbsp;   QPainterPath path;
    path.addRect(20, 20, 60, 60);
    path.addBezier(0, 0,  99, 0,  50, 50,  99, 99);
    path.addBezier(99, 99,  0, 99,  50, 50,  0, 0);
    painter.drawPath(path);</pre>
<p>The code above produces the following output:</p>
<center><img src="pathexample.png"></center><a name="sec.2.7"></a>
<h3>Widget double-buffering</h3>
<p>In Qt 4, all widgets are double-buffered by default.</p>
<p>In previous versions of Qt double-buffereing was acheived by painting to an off-screen pixmap then copying the pixmap to the screen. e.g.</p>
<pre>&nbsp;   QPixmap buffer(size());
    QPainter painter(&amp;buffer);

    // Paint code here

    painter.end();
    bitBlt(this, 0, 0, &amp;buffer);</pre>
<p>Since the double-buffering is handled by QWidget internally this now becomes:</p>
<pre>&nbsp;   QPainter painter(this);

    // Paint code here

    painter.end();</pre>
<p>Double-buffering is turned on by default, but can be turned off by setting the widget attribute Qt::WA_PaintOnScreen.</p>
<pre>&nbsp;   unbufferedWidget-&gt;setAttribute(Qt::WA_PaintOnScreen);</pre>
<a name="sec.3"></a>
<h2>More to come</h2>
<p>The Qt 4 Paint Subsystem is mostly completed, but there is still work being done.</p>
<p>Part of the work in progress is the finalization of the rendering pipeline for all platforms, so that all features are supported and look the same on all platforms. Among the currently unfinished features are these:</p>
<ul>
<li>Gradients cannot have alpha color on X11.</li>
<li>Anti-aliasing of lines on X11.</li>
<li>Clipping regions on OpenGL.</li>
<li>Transformation of pen widths.</li>
<li>Transformation of fill patterns.</li>
<li>Support for querying for supported features (such as if antialiasing is available)</li>
<li>Not all primitive types are supported with gradient filling or alpha filling at the moment. These will be made more consistent in the time to come.</li>
<li>Use painter paths for clipping.</li>
</ul>
<p><address><hr><div align="center">
