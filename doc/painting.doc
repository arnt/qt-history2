/*!
  \page painting.html

  \title The Qt 4.0 Painting Framework

  The purpose of this document is to describe the Qt 4 Painting
  Framework. We

  \section1 Architecture

  The Qt 4.0 Painting Framework is primarly based on the classes \l
  QPainter, \l QPaintDevice and \l QPaintEngine. \l QPainter is the
  class used by programmers to perform drawing operations, such as \c
  drawLine() and \l drawRect(). \l QPaintDevice is an object that can
  be painted on using \l QPainter, including \l QWidget and \l
  QPixmap. \l QPaintEngine is the painter's means of drawing to a
  specific device type.

  \section2 A look back on Qt 3.x

  In Qt 3.x QPainter could be used to draw on widgets and pixmaps. (It
  could also be used to draw to printers on Windows and Mac OS
  X). When other paint devices needed to be supported, such as
  QPrinter on X11, this was done by deriving from QPaintDevice and
  reimplementing the virtual function QPaintDevice::cmd(). A
  reimplemented paint device was treated as an external device.

  QPainter was capable of recognizing external devices and could
  serialize each paint operation to the reimplemented cmd()
  function. This allowed reimplementation of arbitrary devices, but
  the approach has some disadvantages which we have addressed in Qt
  4. One of these is that an external device could not reuse any
  functionality implemented in QPainter since QPainter is tied to
  widget/pixmap painting on a the current platform. Supporting
  multiple device backends, such as OpenGL, was therefore inconvenient
  and not efficient enough.

  We therefore wanted to provide a more convenient and intuitive
  API. Both to our users and to ourselves.

  \section2 How it is done in Qt 4

  In Qt 4 we have introduced the abstract class \l QPaintEngine.
  Implementations of this class provide the concrete functionallity
  needed to draw to a specific device type. The class QPaintEngine
  is used only internally by QPainter and QPaintDevice and will be
  hidden to programmers, unless they reimplement their own device
  type. Qt currently provides paint engines for the following
  platforms and api's:

  \list
  \i \l GDI and GDI+ on windows.
  \i \l X11 on Linux and Unix systems
  \i \l QuickDraw and CoreGraphics on Mac OS X.
  \i \l OpenGL on all platforms.
  \i \l PostScript on Linux, Unix and Mac OS X
  \endlist

  To implement support for a new backend, the programmer is required
  to derive from QPaintEngine and reimplement its virtual functions.
  One also needs to derive from QPaintDevice and reimplement the
  virtual function \l QPaintDevice::paintEngine() to tell QPainter which
  paint engine should be used to draw on this particular device.

  The main benefit of this approach is that all painting follows the
  same painting pipeline which means that adding support for new features
  and providing default implementations for unsupported ones have
  become much simpler.




  \section1 New Features in the Qt 4 Painting Framework


  \section2 Linear Gradient Brushes

  With Qt 4 it is possible to fill shapes using a linear gradient
  brush. A gradient in this case is used to describe the transtition
  from one color at one point to another color in another point. We
  use the term linear gradient since the transition area follows a
  line.

  Setting a linear gradient brush is done using the \l QBrush constructor
  that takes two points and two colors, as sketched below:

  \code
  QBrush diagonalGradient(QPoint(0, 0), Qt::red, QPoint(width(), height()), Qt::blue);
  painter.setBrush(diagonalGradient);
  painter.drawRect(0, 0, width(), height());
  \endcode

  The code shown above produces a pattern as show in the following pixmap:

  \img diagonalGradient.png

  \sa QBrush


  \section2 Alphablended drawing

  With Qt 4 we support alphablended outlining and filling. The alpha
  channel of a color is specified through \l QColor.

  \code
  // Specfiy semitransparent red
  painter.setBrush(QColor(255, 0, 0, 127));
  painter.drawRect(0, 0, width()/2, height());

  // Specify semitransparend blue
  painter.setBrush(QColor(0, 0, 255, 127));
  painter.drawRect(0, 0, width(), height()/2);
  \endcode

  The code shown above produces the following output.

  \img alphafill.png

  Alphablended drawing is supported on Windows, Mac OS X and X11
  systems with X Render extension installed.


  \section2 QPainter and QGLWidget

  It has become possible to open a QPainter on a QGLWidget as if it
  where a normal QWidget. One huge benefit from this is that we
  utilize the high performance of OpenGL for most drawing operations,
  such as transformations and pixmap drawing.


  \section2 Antialiased edges

  One platforms where this is supported by the drawing API's, we
  provide the option of turning on antialiased edges when drawing
  primitives.

  \code
  // One line without antialiasing
  painter.drawLine(0, 0, width()/2, height());

  // One line with antialiasing
  painter.setRenderHints(QPainter::LineAntialiasing);
  painter.drawLine(width()/2, 0, width()/2, height());
  \endcode

  This produces the following output.

  \img antialiased.png

  Supported platforms are currently Mac OS X,  Windows if GDI+ is
  installed and OpenGL.


  \section2 Extensive use of native graphics operations

  In the Qt 4 Painting Framework we make more use of native graphics
  operations. The benefit we gain from this is that these operations
  can potentially be performed in hardware which gives significant
  speed improvements.

  Among these are native transformations (Windows 2000/XP and Mac OS
  X, OpenGL) making painting with a world matrix much faster. Some
  pixmap operations have also been moved closer to hardware.


  \section2 QPainterPath

  A painter path is a object composed of a number of graphical
  building blocks, such as rects, ellipses, lines and curves. A can be
  used for filling, outlining and for clipping. The main advantage of
  painter paths over normal drawing operations is that it is possible
  to build up nonlinear shapes which can be drawn later one go.

  Building blocks can be joined in closed subpaths, such as a
  rectangle or an ellipse, or they can exist independently as unclosed
  subpaths, though an unclosed path will not be filled.

  Below is listed a code example on how a path can be used. The
  painter in this case has a pen width of 3 and a light blue brush. We
  first add a rectangle, which becomes a closed subpath.  We then add
  two bezier curves along.

  \code
  QPainterPath path;
  path.addRect(20, 20, 60, 60);
  path.addBezier(0, 0,  99, 0,  50, 50,  99, 99);
  path.addBezier(99, 99,  0, 99,  50, 50,  0, 0);
  painter.drawPath(path);
  \endcode

  The code above produces the following output:

  \img pathexample.png


  \section2 Widget double buffering

  In Qt 4, all widgets are double buffered by default.

  In previous versions of Qt double buffereing was acheived by
  painting to an offscreen pixmap then copying the pixmap to the
  screen. e.g.

  \code
  QPixmap buffer(size());
  QPainter painter(&buffer);

  // Paint code here

  painter.end();
  bitBlt(this, 0, 0, &buffer);
  \endcode

  Since the double buffering is handled by QWidget internally this now becomes:

  \code
  QPainter painter(this);

  // Paint code here

  painter.end();
  \endcode

  Double buffering is turned on by default, but can be turned off by
  setting the widget attribute Qt::WA_PaintOnScreen.

  \code
  unbufferedWidget->setAttribute(Qt::WA_PaintOnScreen);
  \endcode

  \section1 More to come

  The Qt 4 Painting Framework is mostly completed, but there is still
  work waiting to be done.

  Part of the work in progress is the finalization of the rendering
  pipeline for all platforms, so that all features are supported and
  looks the same on all platforms. Among the currently unfinished
  features we mention:

  \list
  \i Gradients cannot have alpha color on X11
  \i Antialiasing of lines on X11, (though this might not be present at all).
  \i Clipping regions on OpenGL.
  \i Transformation of pen widths.
  \i Transformation of fill patterns.
  \endlist



*/
