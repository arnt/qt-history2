/****************************************************************************
**
**
** Qt plugin support
**
** Copyright (C) 1992-2000 Trolltech AS.  All rights reserved.
**
** This file is part of the Qt GUI Toolkit.
**
** This file may be distributed under the terms of the Q Public License
** as defined by Trolltech AS of Norway and appearing in the file
** LICENSE.QPL included in the packaging of this file.
**
** This file may be distributed and/or modified under the terms of the
** GNU General Public License version 2 as published by the Free Software
** Foundation and appearing in the file LICENSE.GPL included in the
** packaging of this file.
**
** Licensees holding valid Qt Enterprise Edition or Qt Professional Edition
** licenses may use this file in accordance with the Qt Commercial License
** Agreement provided with the Software.
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
**   information about Qt Commercial License Agreements.
** See http://www.trolltech.com/qpl/ for QPL licensing information.
** See http://www.trolltech.com/gpl/ for GPL licensing information.
**
** Contact info@trolltech.com if any conditions of this licensing are
** not clear to you.
**
**********************************************************************/

/*! \page component.html

\title The Qt Component Model

Qt's Object Model provides very powerful extensions to the C++ Object
Model and makes it natural to write components that are highly 
encapsulated and easily reused. 

The Qt Component Model implements the Universal Component Model (UCOM) and 
extends the aspects of encapsulation and reusability. As the combination of 
C++ and the Qt Object Model helps to break an application source code into 
reusable and specialized classes, the Component Model helps to break a monolithic
binary into components that can be dynamically loaded and used by different 
applications. While a single application with fixed functionality needs 
recompiling and linking for every extension, using components makes it trivial
to replace or extend only parts of the application, or to add new functionality
at runtime.

Most exisiting component models, e.g. COM, use a similar architecture.
This document assumes that you have a basic knowledge of component
development. Recommended reading:
<ul>
<li><a href="http://www.amazon.com/exec/obidos/ASIN/1572313498/trolltech/t/107-3518660-0427733">
Inside COM</a>
</ul>

<table cellpadding=2 cellspacing=1 border=0 width=100% bgcolor=#E5E5E5>
<tr>
<th bgcolor=#A2C511 width=100%>
Component Concepts
</th>
</tr>
<tr>
<td>
<h3>Interface</h3>
An interfaces is a group of well-defined functions that provide access to a component. 
A client can query a component for an interface, and can use the interface to call functions 
implemented in the component. In the Qt Component Model, 
<ul>
<li>all interfaces inherit QUnknownInterface
<li>all interfaces are pure abstract classes
</ul>
Interfaces can't change. Changing an interface would break any application and 
component relying on the binary compatibility of the interface.

<h3>Universally Unique Identifiers</h3>
A Universally Unique Identifier is a 128 bit value that is unique over both time and space. 
UUIDs are used by various component models to assign a 128 bit value to an interface or a 
component, so that interfaces and components can be compared efficently.
Most platforms provide an API that generates UUIDs (or GUIDs) with an algorithm that 
guarantees that the resulting ID is unique, using the network card address of the computer
and a 60bit timestamp that represents the count of 100-nanosecond intervals since 15 October
1582.

<h3>Components</h3>
A component is executable code that provides a specified set of publicly
available services. A component can implement any number of interfaces.
The client using the component does not have to know anything about the
implementation details. If the client can get an interface from a
component then it has to be safe for the client to use the interface
without any preconditions. Components can have an ID like interfaces and
can use this ID to be registered in a system global database (e.g. the
Windows Registry). This makes it fairly efficient for applications to
load a specific component.

<h3>Component Server</h3>
Components are distributed by the means of component servers. In most cases 
this is a shared library, e.g. a DLL or .so. A component server can provide 
any number of components.

<h3>Plug-Ins and Add-Ins</h3>
Plugins are components that implement an application specific interface.
The application can make use of any available implementation of its
interfaces to extend or modify existing functionality. The application
can provide the plugin with interfaces implemented in the application
itself so that the plugin is able to access and modify application data.
</td>
</tr>
</table>


<h2>Defining an Interface</h2>
In the Qt Component Model, interfaces are declared as pure abstract classes.
Since it does not make sense to have interfaces that have protected or private
member functions, the \e struct keyword is used so that all functions are made
public:

\code
struct IntegerInterface : public QUnknownInterface
{
    int add( int a, int b ) = 0;
    int sub( int a, int b ) = 0;
    int mul( int a, int b ) = 0;
    int mod( int a, int b ) = 0;
};
\endcode

Most platforms provide a tool to generate a UUID that is associated with
this interface. The Qt distribution includes \e quuidgen which is a GUI tool 
that makes it easy to copy the generated ID directly into the source code:

\code
// {2FFC826E-AA74-4528-8FC9-2FDE08F77CD4} 
#ifndef IID_IntegerInterface
#define IID_IntegerInterface QUuid( 0x2ffc826e, 0xaa74, 0x4528, 0x8f, 0xc9, 0x2f, 0xde, 0x08, 0xf7, 0x7c, 0xd4)
#endif
\endcode

It is common to use the name of the interface together with the prefix \e IID_
as the descriptor for an interface ID.

<h2>Implementing an Interface</h2>
A component implementing an interface simply inherits from the interface and
implements all the functions the interface declares. Since all
interfaces inherit from QUnknownInterface, whose functions are all
pure virtual, every QUnknownInterface function must be implemented.

\code
class NumberComponent : public IntegerInterface
{
public:
    NumberComponent();

    // from QUnknownInterface
    QUnknownInterface *queryInterface( const QUuid &iid );
    ulong addRef();
    ulong release();

    // from IntegerInterface
    int add( int a, int b );
    int sub( int a, int b );
    int mul( int a, int b );
    int mod( int a, int b );

private:
    ulong ref;
};
\endcode

The implementation of IntegerInterface is trivial.

<h3>Implementing QUnknownInterface</h3>

The implementation of the QUnknownInterface defines the set of interfaces
the component provides and controls the lifetime of the component using
reference counting.

The implementation of \e queryInterface has to follow several rules to make the 
use of the component reliable:

<ul>
<li>A query for \e QUnknownInterface must always return the same pointer value
<li>The set of interfaces accessible must be static - it mustn't change in
runtime
<li>It must be symmetric, reflexive and transitive
</ul>
See the \link qunknowninterface.html QUnknownInterface API reference \endlink for a
more detailed explanation of those rules.

An implementation of \e queryInterface usually looks like this:

\code
QUnknownInterface *NumberComponent::queryInterface( const QUuid &iid )
{
    QUnknownInterface *iface = 0;
    if ( uuid == IID_QUnknownInterface )
	iface = this;
    else if ( uuid == IID_IntegerInterface )
	iface = this;

    if ( iface )
        iface->addRef();
    return iface;
}
\endcode

Since a single component can be used by multiple clients at a time the
client itself cannot simply delete the interface pointer when it is no
longer used - it would invalidate all references a different client has
to the same interface. Only the interface itself knows when it is safe to 
delete itself, but the client has to tell the interface when it is no longer 
used. This is done using a reference count. Whenever a pointer to an interface 
is copied, the reference count is increased using \e addRef:

\code
ulong NumberComponent::addRef()
{
    return ref++;
}
\endcode

\e addRef should also be called by any function that returns an
interface, e.g. in \e queryInterface. Whenever a pointer to an interface
is no longer used, the counter is decreased using \e release. As soon as
the count reaches zero the interface knows that there are no more
references and it can delete itself:

\code
ulong NumberComponent::release()
{
    if ( !--ref ) {
        delete this;
	return 0;
    }
    return ref;
}
\endcode

If the reference count runs out of sync it is usually the reason for hard to
find bugs - crashes when the interface get's released to often, or memory
leaks when there are to many addRef calls.

<h3>Implementing multiple interfaces</h3>
Since interfaces consist entirely of pure virtual functions,
multiple inheritance makes it easy to implement multiple interfaces
within a single class, without having to implement QUnknownInterface
many times in a single component. But it makes some casting necessary,
since all interfaces inherit from QUnknownInterface. If the
NumberComponent implemented a second interface

\code
struct DoubleInterface : public QUnknownInterface
{
    double add( double a, double b ) = 0;
    double sub( double a, double b ) = 0;
    double mul( double a, double b ) = 0;
    double mod( double a, double b ) = 0;
};
\endcode

the relevant part of the queryInterface implementation would become:

\code
    ...
    if ( uuid == IID_QUnknownInterface )
        iface = (QUnknownInterface*)(IntegerInterface*)this;
    else if ( uuid == IID_IntegerInterface )
        iface = (IntegerInterface*)this;
    else if ( uuid == IID_DoubleInterface )
        iface = (DoubleInterface*)this;
    ...
\endcode

Which inheritance path is used for the casting is not important, but it has to be 
consistent throughout the component.

<h2>Writing a Component Server</h2>

In order to be able to distribute a component in binary
form it must be wrapped in a component server. The most common kind of
server is a shared library that gets dynamically loaded by the
application. In order for the application to be able to access the
component there must be a function exported by this shared library.
This function will return a pointer to a QUnknownInterface
implementation that can be used as an entry point to query for the
interfaces needed. Qt provides a macro 

\code Q_EXPORT_INTERFACE \endcode 

that declares an exported function 

\code QUnknownInterface *ucom_instantiate() \endcode

for all platforms. The address to this function can be resolved using 
the standard procedures for dynamically loaded libraries, or using the QLibrary class. 
An implementation of this function might look like this:

\code
Q_EXPORT_INTERFACE
{
    NumberComponent *comp = new NumberComponent;
    return comp->queryInterface( IID_QUnknownInterface );
}
\endcode

This default implementation is provided by another macro:

\code Q_CREATE_INSTANCE( NumberComponent ) \endcode

The <tt>ucom_instantiate</tt> function must be declared and implemented exactly once for 
each component server.

<h3>Multiple Components in one Component Server</h3>

The function exported by the component server returns a pointer to an implementation of 
QUnknownInterface. The client can then use \e queryInterface on that interface to query 
for the component's interfaces. All interfaces returned will always be implemented by the 
same component - it is not possible to query one component for an interface and get the 
interface implementation of another component. This makes it impossible for a client to 
access any other component than the one returned by the exported function.

The solution is to make use of another component that has the sole purpose of creating other 
components. This component has to be the one returned by the exported function, and it has 
to implement the interface

\code
struct QComponentFactoryInterface : public QUnknownInterface
{
    QUnknownInterface *createInstance( const QUuid &cid, const QUuid &iid ) = 0;
};
\endcode

The \e cid parameter is a unique identifier for the component and tells the component factory which 
component to create. Each component supported by this component factory must have such an ID defined,
for example like this:

\code
class NumberComponent ...
{
public:
    ...
    static QUuid CID;
    ...

};

QUuid NumberComponent::CID = QUuid( 0xDD19964B, 0xA2C8, 0x42AE, 0xAA, 0xF9, 0x8A, 0xDC, 0x50, 0x9B, 0xCA, 0x03 );
\endcode

The \e iid parameter is then passed to the queryInterface function of the created component:

\code
QUnknownInterface *ComponentFactory::createInstance( const QUuid &cid, const QUuid &iid )
{
    if ( cid == NumberComponent::CID ) {
	NumberComponent *comp = new NumberComponent;
	return comp->queryInterface( iid );
    } else if ( cid == SecondComponent::CID ) {
	SecondComponent *comp = new SecondComponent;
	return comp->queryInterface( iid );
    }

    return 0;
}
\endcode

Note that it is not possible to use the Q_CREATE_INTERFACE macro, since this would not propagate the
\e iid parameter.

<h2>Using Components</h2>
The client application can now use this component by loading the shared
library, resolving and calling the <tt>ucm_instantiate</tt> function,
and using the interfaces returned by the queryInterface implementation.

<h3>Loading the Component Server</h2>
If the application knows which component server provides the component it
wants to use it can load the component server using the QLibrary class like this:

\code
int sum;

QLibrary lib( "filename" );
IntegerInterface *iface = (IntegerInterface*)lib->queryInterface( IID_IntegerInterface );
if ( iface ) {
    sum = iface->add( 5, 8 );
    iface->release;
}
\endcode

The loading and unloading of the shared library and resolving of the \e ucm_instantiate 
function is done by the the QLibray object and explained in the \link qlibrary.html
API reference \endlink.

<h3>Using a specific Component</h3>
But loading a specific library file is not very generic - it makes the usage of the
component depend on the correct installation of the shared library.

Most applications know only which component it wants to use. In order to find the component 
server that provides this specific component the application has to look up the filename of 
the component server in some kind of central database, and the component will have to register 
itself in this central database. 
The identification of components is again done using the UUID assigned to the component, and 
using this UUID a component - or the installation process for the component - can add an entry 
to the central database. The application can then look up the UUID it requires in the database 
and use the filename to create a QLibrary object. 

Registering the components in a server is done by implementing the QComponentServerInterface 
using the \link qsettings.html QSettings \endlink class like this:

\code
bool ComponentFactory::registerComponents( const QString &filepath ) const
{
    QSettings settings;
    settings.insertSearchPath( QSettings::Windows, "/Classes" );
    bool ok;

    QString cid = NumberComponent::CID.toString();
    ok = settings.writeEntry( "/CLSID/" + cid + "/Default", "NumberComponent" );
    ok = settings.writeEntry( "/CLSID/" + cid + "/InprocServer32/Default", filepath ) && ok;

    cid = SecondComponent::CID.toString();
    ok = ...

    return ok;
}

bool ComponentFactory::unregisterComponents() const
{
    QSettings settings;
    settings.insertSearchPath( QSettings::Windows, "/Classes" );
    bool ok;

    QString cid = NumberComponent::CID.toString();
    ok = settings.removeEntry( "/CLSID/" + cid + "/InprocServer32/Default" );
    ok = settings.removeEntry( "/CLSID/" + cid + "/Default" ) && ok;

    cid = SecondComponent::CID.toString();
    ok = ...

    return ok;
}
\endcode

On Windows, this will use the system registry and register the component
along with all other COM components. On UNIX, this will create a
settings file .CLSID that lists all installed components. To register
all components in a server, it is sufficient to load the library, 
query for the QComponentServerInterface and call the registerComponent
function during the installation process of the component.

Any client application that wants to use this specific component can then use the static
functions of the QComponentFactory class to get an interface to the requested component:

\code
int sum;

IntegerInterface *iface = QComponentFactory::createInstance( QUuid("{DD19964B-A2C8-42AE-AAF9-8ADC509BCA03}"), IID_IntegerInterface );
if ( iface ) {
    sum = iface->add( 5, 3 );
    iface->release();
}
\endcode

<h3>Using Components as Plugins</h3>
Both approaches described above make it necessary for the application to know 
details of the component it wants to use. But many applications only know that 
they want to use any component that implements a certain interface, e.g. to provide 
plugin support. The application would then have to load multiple component servers, 
query for the required interface and add the returned component to an internal list 
which it can look-up to use the component when necessary.

A component implements the interface providing a certain set of
"features", and it must inform the client application about the list
of features it provides. To achieve this the component must implement the
QFeatureListInterface

\code
struct QFeatureListInterface : public QUnknownInterface
{
    QStringList	featureList() const = 0;
};
\endcode

For example, a plugin for an image processing application might implement the
ImageColorInterface providing the feature "Sepia", or multiple features
like "Contrast" and "Brightness". The ImageColorInterface might be

\code
struct ImageColorInterface : public QFeatureListInterface
{
    QImage	changeColor( const QString &feature, const QImage &image ) = 0;
};
\endcode

All functions of this interface must be passed the name of the requested
feature, and are implemented like this:

\code
QImage ImageColorComponent::changeColor( const QString &feature, const QImage &image )
{
    QImage newImage;
    if ( feature == "Sepia" ) {
	...
    } else if ( feature == "Contrast" ) {
	...
    } else if ( feature == "Brightness" ) {
	...
    } else {
	newImage = image;
    }

    return newImage;
}
\endcode

Sometimes this is not necessary or wanted, so there is another interface that can be used to 
inform the application about what the component does:

\code
struct QComponentInterface : public QUnknownInterface
{
    QString	name() const = 0;
    QString	description() const = 0;
    QString	version() const = 0;
    QString	author() const = 0;
};
\endcode

Any component that implements the ImageColorInterface and either the
QFeatureListInterface or the QComponentInterface can now be used as
a plugin for an image processing (or any other) application. The
QInterfaceManager template class provides a generic solution for this.

\code
QImage image( "picture.png" );
QInterfaceManager<ImageColorInterface> colorPlugins( IID_ImageColorInterface, "./plugins" );

ImageColorInterface *iface = colorPlugins.queryInterface( "Sepia" );
if ( iface ) {
    image = iface->changeColor( "Sepia", image );
    iface->release();
}
\endcode

<h3>Using a Component Trader</h3>
While the plugin concept allows you to dynamically extend and modify an
application it has one major drawback: the application has to load a large
number of libraries to determine which ones provide suitable
components. This might not be a problem for a small number of highly
specialized plugins, but when plugins are shared
between different applications the number of libraries being loaded and
unloaded unnecessarily makes application startup very inefficient.

A Component Trader tells an application which components implement a
certain set of interfaces, and the application can then select and use
one of those components. If multiple components are suitable the user
should be able to prioritize a single component. This makes it 
necessary for components to register their set of implemented interfaces
in the central database, so that the component trader can look up the
components matching the request and pick the preferred one for the
application to use.

Registering (and unregistering) the component once again uses the
implementation of the QComponentServerInterface:

\code
bool NumberComponent::registerComponents( const QString &filepath ) const
{
    QSettings settings;
    bool ok;

    settings.insertSearchPath( QSettings::Windows, "/Classes" );
    ok = settings.writeEntry( "/CLSID/{DD19964B-A2C8-42AE-AAF9-8ADC509BCA03}/Default", "NumberComponent" );
    ok = settings.writeEntry( "/CLSID/{DD19964B-A2C8-42AE-AAF9-8ADC509BCA03}/InprocServer32/Default", filepath ) && ok;
    ok = settings.writeEntry( "/Interface/" + IID_IntegerInterface.toString() + "/Default", "IntegerInterface" ) && ok;
    ok = settings.writeEntry( "/Interface/" + IID_IntegerInterface.toString() + "/Components", "{DD19964B-A2C8-42AE-AAF9-8ADC509BCA03}" ) && ok;

    return ok;
}
\endcode
*/
