/****************************************************************************
**
** Documentation for qmake commands
**
** Copyright (C) 1992-2001 Trolltech AS.  All rights reserved.
**
** This file is part of the Qt GUI Toolkit.
**
** This file may be distributed under the terms of the Q Public License
** as defined by Trolltech AS of Norway and appearing in the file
** LICENSE.QPL included in the packaging of this file.
**
** This file may be distributed and/or modified under the terms of the
** GNU General Public License version 2 as published by the Free Software
** Foundation and appearing in the file LICENSE.GPL included in the
** packaging of this file.
**
** Licensees holding valid Qt Enterprise Edition or Qt Professional Edition
** licenses may use this file in accordance with the Qt Commercial License
** Agreement provided with the Software.
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
**   information about Qt Commercial License Agreements.
** See http://www.trolltech.com/qpl/ for QPL licensing information.
** See http://www.trolltech.com/gpl/ for GPL licensing information.
**
** Contact info@trolltech.com if any conditions of this licensing are
** not clear to you.
**
**********************************************************************/

/*! \page qmake-commandreference.html

\title <em>qmake</em> Command Reference

<ul>
<li><a href="#Commands">Command Line Options</a></li>
<li><a href="#SystemVariables">System Variables</a></li>
<li><a href="#Functions">Functions</a></li>
<li><a href="#Environment">Environment Variables and Configuration</a></li> 
</ul>


<h1><a href="Commands">Command Line Options</a></h1>

<h3>Syntax</h3>

\code
qmake [options] project-files
\endcode

<h3>Options</h3>

The following options can be specified on the command line to <em>qmake</em>:

<ul>
<li>\c -nocache       <p>
	<em>qmake</em> will ignore the .qmake.cache file.
<li>\c -nodepend      <p>
	<em>qmake</em> will not genereate any dependancy information.
<li>\c -o file <p>
	<em>qmake</em> output will be directed to \a file.
<li>\c -unix  <p>
	<em>qmake</em> will run in unix mode.  In this mode ###
<li>\c -win32    <p>    
	<em>qmake</em> will run in win32 mode.  In this mode ###
<li>\c -cache file <p>
	<em>qmake</em> will use \a file as the cache file, ignoring any other .qmake.cache file found
<li>\c -path dir <p>
	<em>qmake</em> will use \a dir as a path to platform-conpiler information and QMAKEPATH will be ignored.
<li>\c -d <p>
	<em>qmake</em> will output useful debugging information.
</ul>

The \c project-files can be a list of one or more project files,
separated by spaces.  If \a project-files is a directory name, all
project files in that directory (and all subdirectories) will be
processed.

<h1><a href="SystemVariables">System Variables</a></h1>

<h2>Project Variable Reference</h2>

<p><h3>***Notes***</h3>
For all project files that specify a directory and are interpreted by qmake
(DESTDIR, OBJECTS_DIR, MOC_DIR, etc) the directory will be created when qmake
is called, ie before the 'make' command is specified. This is to assure
portablity.

<h4><a name="ALL_DEPS"></a>ALL_DEPS</h4>
Specifies additional dependencies for the makefile target "all:".<p>


<h4><a name="CLEAN_FILES"></a>CLEAN_FILES</h4>
Specifies additional files to be removed for "make clean".<p>
Example:<pre>
  CLEAN_FILES = core *~
</pre>


<h4><a name="CONFIG"></a>CONFIG</h4>
The <code>CONFIG</code> variable is recognized by qmake
templates and specifies what compiler options to use and which extra
libraries to link in.

<p>
You may assign anything to this variable, however some will be recognized
internally by qmake and have special meaning, they are as follows.

<p>
These options control the compilation flags:
<p>
<table border="0">
  <tr>
    <td>&nbsp;</td>
    <td>release</td>
    <td>&nbsp;</td>
    <td>Compile with optimization enabled, ignored if
    "debug" is specified.</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>debug</td>
    <td>&nbsp;</td>
    <td>Compile with debug options enabled.</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>warn_on</td>
    <td>&nbsp;</td>
    <td>The compiler should emit more warnings than normally, ignored if
     "warn_off" is specified.</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>warn_off</td>
    <td>&nbsp;</td>
    <td>The compiler should emit no warnings or as few as possible.</td>
  </tr>
</table>

<p>
These options define the application/library type:
<p>
<table border="0">
  <tr>
    <td>&nbsp;</td>
    <td>qt</td>
    <td>&nbsp;</td>
    <td>The target is a Qt application/library and requires Qt header
     files/library.</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>opengl</td>
    <td>&nbsp;</td>
    <td>The target requires the OpenGL (or Mesa) headers/libraries.</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>thread</td>
    <td>&nbsp;</td>
    <td>The target is a multi-threaded application or library.</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>x11</td>
    <td>&nbsp;</td>
    <td>The target is a X11 application or library.</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>windows</td>
    <td>&nbsp;</td>
    <td>The target is a Win32 window application (app only).</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>console</td>
    <td>&nbsp;</td>
    <td>The target is a Win32 console application (app only).</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>dll</td>
    <td>&nbsp;</td>
    <td>The target is a shared object/DLL.</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>staticlib</td>
    <td>&nbsp;</td>
    <td>The target is a static library (lib only).</td>
  </tr>
</table>

<h4><a name="OBJECTS_DIR"></a>OBJECTS_DIR</h4>
This specifies where all intermediate .o/.obj files should be placed, this
allows concurrent builds to live together in the same source tree.

<h4><a name="MOC_DIR"></a>MOC_DIR</h4>
This specifies the directory where all intermediate moc files (see <a
href="http://doc.trolltech.com/metaobjects.html">meta object compiler</a>).

<h4><a name="DEF_FILE"></a>DEF_FILE</h4>
Win32/app only: Specifies a .def file.

<h4><a name="DESTDIR"></a>DESTDIR</h4>
Specifies where to put the target file.
Example:<pre>
  DESTDIR = ../../lib
</pre>


<h4><a name="DISTFILES"></a>DISTFILES</h4>
Adds other files to the distribution archive ("dist target").
The source files and project file are always included in the
distribution archive.
Example:<pre>
  DISTFILES = CHANGES README
</pre>

<h4><a name="REQUIRES"></a>REQUIRES</h4>
This is a special variable processed by qmake, if the contents of this
variable do not appear in CONFIG by the time this variable is assigned to
then a minimal makefile will be generated that states what dependancies
(the values assigned to REQUIRES) were missing.

<h4><a name="HEADERS"></a>HEADERS</h4>
Defines the header files of the project.

<h4><a name="INTERFACES"></a>INTERFACES</h4>
Defines the .ui files (see the <a href="eh">Designer</a>) to be processed
through uic before compiling.

<h4><a name="LEXSOURCES"></a>LEXSOURCES</h4>
Define the files to be processed by lex before compiling.

<h4><a name="YACCSOURCES"></a>YACCSOURCES</h4>
Define the files to be processed by yacc before compiling.

<h4><a name="INCPATH"></a>INCPATH</h4>
This variable is generated from <code>INCLUDEPATH</code>. The ';' or ':'
separators have been replaced by ' ' (single space). This makes it
easier to split. qtapp.t and other templates expand
<code>INCPATH</code> to set -I options for the C++ compiler.


<h4><a name="INCLUDEPATH"></a>INCLUDEPATH</h4>
This variable specifies the #include directories. It can be set in the
project file, or by the <a href="#AddIncludePath">AddIncludePath()</a>
function.<p>
Example:<pre>
  INCLUDEPATH = c:\msdev\include d:\stl\include
</pre>
Use ';' or space as the directory separator.


<h4><a name="LIBS"></a>LIBS</h4>
Defines additional libraries to be linked in when creating an application
or a shared library.  You probably want to use a platform qualifier since
libraries are specified differently on Unix and Win32.<p>
Example:<pre>
  unix:LIBS  = -lXext -lm
  win32:LIBS = ole32.lib
</pre>


<h4><a name="MOC_DIR"></a>MOC_DIR</h4>
Specifies where to put the temporary moc output files.  By default they
are stored in the directory where the moc input files are.
<p>
Example:<pre>
  MOC_DIR = tmp
</pre>
You must create this directory before running make.
<p>
See also: <a href="#OBJECTS_DIR">OBJECTS_DIR</a>.


<h4><a name="OBJECTS"></a>OBJECTS</h4>
This varialble is generated from <code>SOURCES</code> by the StdInit() function.
The extension of each source file has been replaced by .o (Unix) or .obj
(Win32).<p>
Example:<pre>
  SOURCES = a.x b.y
</pre>
Then <code>OBJECTS</code> become "a.o b.o" on Unix and "a.obj b.obj" on
Win32.


<h4><a name="OBJECTS_DIR"></a>OBJECTS_DIR</h4>
Specifies where to put object files.  By default they are stored in
the directory where the source files are.<p>
Example:<pre>
  OBJECTS_DIR = tmp
</pre>
You must create this directory before running make.
<p>
See also: <a href="#MOC_DIR">MOC_DIR</a>.


<h4><a name="OBJMOC"></a>OBJMOC</h4>
This variable is generated if files can be found that contain <code>Q_OBJECT</code>.
<code>OBJMOC</code> contains the name of all intermediate moc object files.<p>
Example:<pre>
  HEADERS = demo.h
  SOURCES = demo.cpp main.cpp
</pre>
If <tt>demo.h</tt> and <tt>main.cpp</tt> define classes that use signals
and slots (i.e. the <code>Q_OBJECT</code> "keyword" is found in these two
files), <code>OBJMOC</code> becomes:<pre>
  OBJMOC  = moc_demo.obj
</pre>
See also: <a href="#SRCMOC">SRCMOC</a>.


<h4><a name="PROJECT"></a>PROJECT</h4>
This is the name of the project.  It defaults to the name of the project
file, excluding the .pro extension.


<h4><a name="RC_FILE"></a>RC_FILE</h4>
Win32/app.t only: Specifies a .rc file.  Cannot be used with the RES_FILE
variable.


<h4><a name="RES_FILE"></a>RES_FILE</h4>
Win32/app.t only: Specifies a .res file.  You can either specify a
.rc file or one or more .res files.


<h4><a name="SOURCES"></a>SOURCES</h4>
Defines the source files of the project.


<h4><a name="SRCMOC"></a>SRCMOC</h4>
This variable is generated by the <code>CONFIG</code> contains "qt". 
<code>SRCMOC</code> contains the name of all intermediate moc files.<p>
Example:<pre>
  HEADERS = demo.h
  SOURCES = demo.cpp main.cpp
</pre>
If <tt>demo.h</tt> and <tt>main.cpp</tt> define classes that use signals
and slots (i.e. the <code>Q_OBJECT</code> "keyword" is found in these two
files), <code>SRCMOC</code> becomes:<pre>
  SRCMOC  = moc_demo.cpp main.moc
</pre>
See also: <a href="#OBJMOC">OBJMOC</a>.


<h4><a name="TARGET"></a>TARGET</h4>
Sets the makefile target, i.e. what program to build.


<h4><a name="TEMPLATE"></a>TEMPLATE</h4>
Sets the default template. This can be overridden by the qmake -t
<a href="qmake.html#usage">option</a>.


<h4><a name="QMAKE_CC"></a>QMAKE_CC</h4>
Contains the name of the compiler.


<h4><a name="QMAKE_CFLAGS"></a>QMAKE_CFLAGS</h4>
Contains the default compiler flags.


<h4><a name="QMAKE_FILEVARS"></a>QMAKE_FILEVARS</h4>
Tells qmake which variables contain file names.  This is because qmake
on Windows replace the directory separator / with \.


<h1><a href="Functions">Functions</a></h1>

<p>
<table border="1">
    <tr>
        <td>&nbsp;</td>
        <td>Function name</td>
        <td>&nbsp;</td>
        <td>Arguments</td>
        <td>&nbsp;</td>
        <td>Description</td>
    </tr>

    <tr>
        <td>&nbsp;</td>
        <td>include</td>
        <td>&nbsp;</td>
        <td>string</td>
        <td>&nbsp;</td>
        <td>This function will succeed if the file could be found and
        parsed correctly, it will fail otherwise.</td>
    </tr>
    <tr>
        <td>&nbsp;</td>
        <td>contains</td>
        <td>&nbsp;</td>
        <td>variable, value</td>
        <td>&nbsp;</td>
		<td>This function will succeed if variable (the name of a qmake
		variable) contains the given value</td>
    </tr>
    <tr>
        <td>&nbsp;</td>
        <td>count</td>
        <td>&nbsp;</td>
        <td>variable, count</td>
        <td>&nbsp;</td>
		<td>This function will succeed if variable (the name of a qmake
		variable) contains count values</td>
    </tr>
    <tr>
        <td>&nbsp;</td>
        <td>isEmpty</td>
        <td>&nbsp;</td>
        <td>variable</td>
        <td>&nbsp;</td>
		<td>This function will succeed if variable (the name of a qmake
		variable) is empty (same as count(variable, 0))<cite></td>
    </tr>
    <tr>
        <td>&nbsp;</td>
        <td>system</td>
        <td>&nbsp;</td>
        <td>string</td>
        <td>&nbsp;</td>
        <td>This function will execute string in a secondary shell and will
        succeed if the command exits with a exit status of 1.</td>
    </tr>
    <tr>
        <td>&nbsp;</td>
        <td>message</td>
        <td>&nbsp;</td>
        <td>string</td>
        <td>&nbsp;</td>
        <td>This function will always return succeed, but will display the
        given string to the user.</td>
    </tr>
    <tr>
        <td>&nbsp;</td>
        <td>error</td>
        <td>&nbsp;</td>
        <td>string</td>
        <td>&nbsp;</td>
        <td>This function will never return, but will display the given
        string to the user, and then exit qmake, this should only be used
        for very fatal configurations.</td>
    </tr>
</table>

<p>
Example usages:

<pre>
  !include(file.pri):message(I couldn't include file.pri):file_pri=FAILED
  release:debug:error(You can't have release and debug at the same time!)
  system(ls /bin):HAS_BIN=FALSE
  !contains(HAS_BIN, TRUE):message(why you don't have a /bin directory!):
</pre>

<h1><a href="Environmemt">Environment Variables and Configuration</a></h1>

<h3>QMAKEPATH</h3>

The QMAKEPATH path will automatically be added to the INCLUDEPATHS system variable.


<h3>Cache File</h3>

The cache file (mentioned above in the options) is a special file qmake
will read to find settings not specified in the mkspec, the .pro file, or
the command line. If neither -mkspec nor -nocache are specified qmake will
try to find a file called .qmake.cache in parent directories, if it fails
to find this file it will silently ignore this step of processing. 

<p>

Additional Information


 *CONFIG*

  Qmake allows you to use the CONFIG variable to see what is in scope,
  however it has special interpretation of the following values in it:

  qt        The target is a Qt application/library and requires Qt header files/library.
  opengl    The target requires the OpenGL (or Mesa) headers/libraries.
  thread    The target is a multi-threaded application or library.
  x11       The target is a X11 application or library.
  windows   The target is a Win32 window application (app.t only).
  console   The target is a Win32 console application (app.t only).
  dll       The target is a shared object/DLL.
  staticlib The target is a static library (lib.t only).
  plugin    The target is a plugin (QInterface).

  release   Compile with optimization enabled, ignored if "debug" is specified.
  debug     Compile with debug options enabled.
  warn_on   The compiler should emit more warnings than normally, ignored if "warn_off" is specified.
  warn_off  The compiler should emit no warnings or as few as possible.

 *INSTALLS*

  Qmake allows you to define an install target for the output makefile
  (currently supported only by unix makefile backends). You enable this
  like the following:

    animals.path = /usr/local/animals
    animals.files = *.pig *.cow
    INSTALLS += animals

  This will copy all files that match *.pig and *.cow into /usr/local/animals.
  Each backend can support builtin INSTALLS (like animals). Currently target is
  the only supported one, this will allow you to do:

   target.path = /usr/local/myapp/bin
   INSTALLS += target

  This allows Qmake to define what files get copied in (usually just $$TARGET,
  but in the case of libs this will include symlinks created to the shared
  object). If you specify a target.files or a target.extra (described below)
  the builtin behaviour will not happen and will be overridden by your targets.
  You can specify as many INSTALLS as you like to install your whole project.

  If .files doesn't allow you enough control you can also use .extra to put
  literal commands into the makefile like this:

     msgfiles.path = /usr/local/myapp/msgs
     msgfiles.files = ../msgfiles/*.msg
     unix:msgfiles.extra = $(QTDIR)/bin/msg2qm $$msgfiles.path/*.msg $$msgfiles.path/msgfile.qm
     INSTALLS += msgfiles

  This will copy all .msg files from ../msgfiles/ into /usr/local/myapp/msgs
  after that it will run msg2qm on those files. 

 *TEMPLATE*

  Although qmake doesn't actually support custom templates, it does allow
  you to tell it what kind of project this is from a hardcoded list,
  currently this list is app, subdirs, and lib. The following variables
  will be used with their respective TEMPLATE:

  *APP and LIB template*

  These "templates" will generate a application and a library respectivly:

  HEADERS      Header files.
  SOURCES      Source files.
  TARGET       Name of executable (adds .exe if on Windows).
  DESTDIR      Where to put the target.
  DEFINES      Tell compiler to define C preprocessor macros (-D option).
  INCLUDEPATH  Sets the include file search path for the compiler (-I option). 
  INTERFACES   Sets the .ui files to be compiled into the project.
  OBJECTS_DIR  Sets the directory all object files will be dumped to.
  MOC_DIR      Sets the directory all move files output will be placed in.
  LEXSOURCES   Sets the files to be processed by lex before compiling
  YACCSOURCES  Sets the files to be process by yacc before compiling
  DEPENDPATH   Sets the dependency search path for tmake.

  DEF_FILE     Win32 only: Link with a .def file.
  RC_FILE      Win32 only: Use a .rc file (compile to temporary .res). 
  RES_FILE     Win32 only: Link with a .res file. 
  VERSION      Lib template only: Will specify the version number of the library
  INSTALLS     This defines values to use as install targets, see *INSTALLS* section.

  *Subdirs template*

  This template is usefull for wrapping a bunch of other makefiles into one:

  SUBDIRS      A list of directories to be made

 *MAKEFILE_GENERATOR*

  This tells qmake what kind of makefile it is to generate currently these
  map directly to the list of output makefiles above.

Operators:

you can do this:

FOO=one_file.cpp two_file.cpp three_file.cpp
OBJ_FOO~= s/.cpp/.o/g #now OBJFOO contains one_file.o two_file.o three_file.o

> 
> *=     ???



Similarly this will prevent a file being added multiple times

FOO=one_file two_file
FOO+=one_file #foo is one_file one_file two_file
FOO*=two_file #foo is still one_file one_file two_file

note that two_file wasn't added for a second time, as one_file was in +=.

*/