/****************************************************************************
** $Id: qmap.doc,v 1.1 1999/06/08 17:22:49 weis Exp $
**
** QMap and QMapIterator class documentation
**
** Copyright (C) 1992-1999 Troll Tech AS.  All rights reserved.
**
** This file is part of the Qt GUI Toolkit.
**
** This file may be distributed under the terms of the Q Public License
** as defined by Troll Tech AS of Norway and appearing in the file
** LICENSE.QPL included in the packaging of this file.
**
** Licensees with valid Qt Professional Edition licenses may distribute and
** use this file in accordance with the Qt Professional Edition License
** provided at sale or upon request.
**
** See http://www.troll.no/pricing.html or email sales@troll.no for
** information about the Professional Edition licensing, or see
** http://www.troll.no/qpl/ for QPL licensing information.
**
*****************************************************************************/


/*****************************************************************************
  QMap documentation
 *****************************************************************************/

/*!
  \class QMap qmap.h
  \brief The QMap class is a value based template class that provides a dictionary

  \ingroup qtl
  \ingroup tools

  Define a template instance QMap\<Key,Data\> to create a dictionary with keys of type X
  and values of type Y. Please notice that QMap does not store pointers to the
  members of the map. It holds a copy of every member. That is the reason why this
  kind of classes are called "value based" while QList and QDict are "reference based".

  Some classes can not be used within a QMap. For example everything derived from
  QObject and as a reason of this that extends to all classes which implement widgets.
  You can only put stuff in a QMap which can be easily copied. That means that the 
  class X and Y must implement a copy constructor.

  Example:
  \code
    #include <qmap.h>
    #include <qstring.h>
    #include <stdio.h>

    class Employee
    {
    public:
        Employee( const QString& name, int salary ) { n=name; s=salary; }
        Employee( const Employee& _e ) { n = _e.name; s = _e.s; }

        QString     name()   const		 { return n; }
        int	    salary() const		 { return s; }
	void	    setSalary( int _s ) const	 { s = _s; }
    private:
        QString     n;
        int         s;
    };

    void main()
    {
	typedef QMap<QString,Employee> EmployeeMap;
	EmployeeMap map;		// map of Employee

	map.insert( "Gates", Employee("Bill", 50000) );
	map.insert( "Ballmer", ( Employee("Steve",80000) );
	map.insert( "Sommer," ( Employee("Ron",  60000) );

	Employee joe( "Joe", 50000 );
	map.insert( "Doe", joe );
	joe.setSalary( 4000 );
	
	EmployeeMap::Iterator it;
	for( it = map.begin(); it != map.end(); ++it )
	    printf( "%s, %s earns %d\n", it.key(), it.data().name(), it.data().salary() );
    }
  \endcode

  Program output:
  \code
	Ballmer, Steve earns 80000
	Doe, Joe earns 50000
	Gates, Bill earns 50000
	Sommer, Ron earns 60000
  \endcode

  As you can see, the latest changes to Joes salary did not affect the value
  in the list because the map created a copy of Joes entry. In addition you
  should notice that the items are alphabetically sorted when iterating
  over the map.

  There are two ways to find values in the list. The first one is to use
  the find() function. It returns an iterator pointing to the desired
  item or the end() iterator it no such element exists.

  The scond approach uses the operator[]. But be warned: If you dont know
  that the element you are searching for is really in the list, then you
  should not use operator[]. The following example illustrated that.

  \code
	QMap<QString,QString> map;
	map.insert( "Weis", "Torben" );
	str << map["Weis"] << map["Ettrich"] << endl;

	const QMap<QString,QString>& map2 = map;
	str << map["Weis"] << map["Reggie"] << endl;
	
  \endcode

  The code fragment will print out "Weis", "" and the second part will
  print "Weis", "". In addition the first fragment inserted an empty entry
  with they "Ettrich". The second one did not insert an empty entry with
  key "Reggie" because the const operator[] was used which can not do insertion.
  So if you are not shure wether a certain element is in the map you should
  use find() and iterators.

  If you just want to know wether a certain key is contained in the map,
  the the contains() function is what you are looking for. In addition count()
  tells you how many keys there are currently in the map.

  Another method for traversing a map is to use the functions begin() and end().
  With a simple for loop as shown in the example you can iterate over the complete map.
  It is save to have multiple iterators at the same time. If some member of the map is
  removed then only iterators pointing to the removed member become invalid. Inserting in
  the map does not invalidate any iterator.

  Since QMap is value based there is no need to care about deleting elements in the
  list. The list holds its own copies and will free them if the corresponding member or
  the list itself is deleted. You can force the list to free all of its item with clear().

  QMap is implict shared. That means you can just make copies of the map
  in time O(1). If multiple QMap instances share the same data and one
  is doing a modification of the maps data then this modifying instance makes a copy
  and modifies its private copy. So it does not affect the other instances.
  From a developers point of view you can think that a QMap and a copy of this
  map have nothing to do with each other. Developers may only notice that copying is
  very fast. People known to a CPUs MMU architecture will know this pattern as "copy on write".

  There are two ways of inerting new elements in a list. One uses the insert() method
  while the other one uses operator[] like this:

  \code
  	QMap<QString,QString> map;
	map["Weis"] = "Torben";
  \endcode;

  Items can be removed from the map in two ways. The first is to pass an iterator to
  the remove(). The other possibility is to pass a key value to remove() which will
  delete the entry with the requested key. In addition you can clear the entire
  map using the clear() method.

  \sa QMapIterator
*/


/*!
  \fn QMap::QMap()
  Constructs an empty map.
*/

/*!
  \fn QMap::QMap( const QMap<key,type> &map )
  Constructs a copy of \e map.

  This operation costs O(1) time since QMap is implicit shared.
  The first instance applying modifications to a shared list will create
  a copy which takes in turn O(n) time. However returning a QMap from
  a function is very fast.
*/

/*!
  \fn QMap::~QMap()
  Destroys the map. References to the values in the map and all iterators
  of this map become invalidated. Since QMap is highly tuned for performance
  you wont see warnings if you use invalid iterators,
  because it is impossible for
  an iterator to check wether it is valid or not.
*/

/*!
  \fn QMap<key,type> &QMap::operator=(const QMap<key,type> &m)
  Assigns \e m to this map and returns a reference to this map.

  All iterators of the current map become invalidated by this operation.
  The cost of such an assignment is O(1) since QMap is implict shared.
*/

/*!
  \fn const type &QMap::operator[]( const key& k ) const
  Returns the value associated with the key \e k. If no such
  key is present then a reference to an empty item is returned.
*/

/*!
  \fn type &QMap::operator[]( const key& k )
  Returns the value associated with the key \e k. If no such
  key is present then en empty item is inserted with this key
  and a reference to the item is returned.

  You can use this operator in two directions: For reading and for writing:

  \code
  	QMap<QString,QString> map;
	map[ "Weis" ] = "Torben";
	stream << map[ "Weis" ];
  \endcode
*/

/*!
  \fn uint QMap::count() const
  Returns the number of items in the ap.
  \sa isEmpty()
*/

/*!
  \fn bool QMap::isEmpty() const
  Returns TRUE if the list is empty, i.e. count() == 0. Returns FALSE
   otherwise.
  \sa count()
*/

/*!
  \fn Iterator QMap::insert( const key& k, const type& item )
  Inserts the \e item with key \e k.

  Returns an iterator pointing at the inserted item.
*/

/*!
  \fn void QMap::remove( Iterator it )
  Removes the item at position \e it in the map.

  \sa clear()
*/

/*!
  \fn void QMap::remove( const key& k )
  Removes the item with the key \e k.

  \sa clear()
*/

/*!
  \fn void QMap::clear()
  Removes all items from the map.

  \sa remove()
*/

/*!
  \fn Iterator QMap::find( const key& k )
  Finds the key \e k in the map.

  Returns end() if no key did match.
*/

/*!
  \fn ConstIterator QMap::find( const key& k ) const
  Finds the key \e k in the map.

  Returns end() if no key did match.
*/

/*!
  \fn bool QMap::contains( const key& k ) const
  Returns TRUE if the key \k is contained in the map.
*/

/*!
  \fn Iterator QMap::begin()
  Returns an iterator pointing to the first element in the map. This
  iterator equals end() if the map is empty;
  \sa end()
*/

/*!
  \fn ConstIterator QMap::begin() const
  Returns an iterator pointing to the first element in the map. This
  iterator equals end() if the map is empty;
  \sa end()
*/

/*!
  \fn Iterator QMap::end()
  Returns an iterator pointing behind the last element in the map. This
  iterator equals begin() if the map is empty.

  \sa begin()
*/

/*!
  \fn ConstIterator QMap::end() const
  Returns an iterator pointing behind the last element in the map. This
  iterator equals begin() if the map is empty.

  \sa begin()
*/

/*****************************************************************************
  QMapIterator documentation
 *****************************************************************************/

/*!
  \class QMapIterator qmap.h
  \brief The QMapIterator class provides an iterator for QMap.

  \ingroup qtl
  \ingroup tools

  You can not create an iterator by yourself. Instead you have to
  ask a map to give you one. An iterator has only the size of a pointer.
  On 32 bit machines that means 4 bytes otherwise 8 bytes. That makes them
  very fast. In fact they resemble the semantics of pointers as good as possible
  and they are almost as fast as usual pointers.

  \code
    #include <qmap.h>
    #include <qstring.h>
    #include <stdio.h>

    class Employee
    {
    public:
        Employee( const QString& name, int salary ) { n=name; s=salary; }
        Employee( const Employee& _e ) { n = _e.name; s = _e.s; }

        QString     name()   const		 { return n; }
        int	    salary() const		 { return s; }
	void	    setSalary( int _s ) const	 { s = _s; }
    private:
        QString     n;
        int         s;
    };

    void main()
    {
	typedef QMap<QString,Employee> EmployeeMap;
	EmployeeMap map;		// map of Employee

	map.insert( "Gates", Employee("Bill", 50000) );
	map.insert( "Ballmer", ( Employee("Steve",80000) );
	map.insert( "Sommer," ( Employee("Ron",  60000) );

	Employee joe( "Joe", 50000 );
	map.insert( "Doe", joe );
	joe.setSalary( 4000 );
	
	EmployeeMap::Iterator it;
	for( it = map.begin(); it != map.end(); ++it )
	    printf( "%s, %s earns %d\n", it.key(), it.data().name(), it.data().salary() );
    }
  \endcode

  Program output:
  \code
	Ballmer, Steve earns 80000
	Doe, Joe earns 50000
	Gates, Bill earns 50000
	Sommer, Ron earns 60000
  \endcode
 
  The only way to traverse a map is to use iterators.
  QMap is highly optimized for performance and memory usage.
  On the other hand that means that you have to be a bit more careful
  by what you are doing. QMap does not know about all its iterators
  and the iterators dont even know to which map they belong. That makes
  things fast and slim but a bit dangerous because it is up to you to make
  shure that iterators you are using are still valid. QDictIterator will be able
  to give warnings while QMapIterator may end up in an undefined state.

  For every Iterator there is a ConstIterator. When accessing a QMap
  in a const environment or if the reference or pointer to the map is itself
  const, then you have to use the ConstIterator. Its semantics are the same,
  but it returns only const references to the item it points to.

  \sa QMap
*/

/*!
  \fn QMapIterator::QMapIterator( const QMapIterator<type> &list )
  Constructs a copy of the iterator.
*/

/*!
  \fn QMapIterator::~QMapIterator()
  Destroys the iterator.
*/

/*!
  \fn QMapIterator<type>& QMapIterator::operator++()
  Prefix ++ makes the succeeding item current and returns
  an iterator pointing to the new current item.
  The iterator can not check wether it reached the end of the map. Incrementing
  the iterator as returned by end() causes undefined results.
*/

/*!
  \fn QMapIterator<type< QMapIterator::operator++(int)
  Postfix ++ makes the succeeding item current and returns
  an iterator pointing to the new current item.
  The iterator can not check wether it reached the end of the map. Incrementing
  the iterator as returned by end() causes undefined results.
*/

/*!
  \fn QMapIterator<type>& QMapIterator::operator--()
  Prefix -- makes the previous item current and returns
  an iterator pointing to the new current item.
  The iterator can not check wether it reached the end of the map. Incrementing
  the iterator as returned by end() causes undefined results.
*/

/*!
  \fn QMapIterator<type< QMapIterator::operator++(int)
  Postfix -- makes the succeeding item current and returns
  an iterator pointing to the new current item.
  The iterator can not check wether it reached the end of the map. Incrementing
  the iterator as returned by end() causes undefined results.
*/

/*!
  \fn type &QMapIterator::operator*()
  Asterix operator. Returns a reference to the current item. The same as data().
*/

/*!
  \fn bool QMapIterator::operator==( const QMapIterator<type>& it )
  Compares both iterators and returns TRUE if they point to the same item.
*/

/*!
  \fn bool QMapIterator::operator!=( const QMapIterator<type>& it )
  Compares both iterators and returns TRUE if they point to different items.
*/

/*!
  \fn type &QMapIterator::data()
  Returns a reference to the current item.
*/

/*!
  \fn key &QMapIterator::key()
  Returns a reference to the current key.
*/
