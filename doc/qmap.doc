/****************************************************************************
** $Id: qmap.doc,v 1.4 1999/08/10 16:35:34 paul Exp $
**
** QMap and QMapIterator class documentation
**
** Copyright (C) 1992-2000 Trolltech AS.  All rights reserved.
**
** This file is part of the Qt GUI Toolkit.
**
** This file may be distributed under the terms of the Q Public License
** as defined by Trolltech AS of Norway and appearing in the file
** LICENSE.QPL included in the packaging of this file.
**
** This file may be distributed and/or modified under the terms of the
** GNU General Public License version 2 as published by the Free Software
** Foundation and appearing in the file LICENSE.GPL included in the
** packaging of this file.
**
** Licensees holding valid Qt Enterprise Edition or Qt Professional Edition
** licenses may use this file in accordance with the Qt Commercial License
** Agreement provided with the Software.
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
**   information about Qt Commercial License Agreements.
** See http://www.trolltech.com/qpl/ for QPL licensing information.
** See http://www.trolltech.com/gpl/ for GPL licensing information.
**
** Contact info@trolltech.com if any conditions of this licensing are
** not clear to you.
**
**********************************************************************/


/*****************************************************************************
  QMap documentation
 *****************************************************************************/

/*!
  \class QMap qmap.h
  \brief The QMap class is a value-based template class that provides a dictionary.

  \ingroup qtl
  \ingroup tools
  \ingroup shared

  QMap is a Qt implementation of an STL-like map container.  It
  can be used in your application if the standard map<> is not
  available.  QMap is part of the <a href="qtl.html"> Qt Template
  Library</a>.

  QMap<Key,Data> defines a template instance to create a dictionary
  with keys of type Key and values of type Data. QMap does not store
  pointers to the members of the map. Instead, it holds a copy of
  every member. For that reason this kind of classes is called
  "value-based", whereas QPtrList and QDict are "reference-based".

  QMap contains and manages a collection of objects of type Data with
  associated key values of type Key and provides iterators that allow
  the contained objects to be addressed.  QMap owns the contained
  elements.  For more relaxed ownership semantics, see QPtrCollection and
  friends which are pointer-based containers.

  Some classes cannot be used within a QMap - for example everything
  derived from QObject and thus all classes that implement widgets.
  Only values can be used in a QMap. To qualify as a value, the class
  must provide

  <ul>
  <li>A copy constructor
  <li>An assignment operator
  <li>A default constructor, i.e., a constructor that does not take any arguments.
  </ul>

  Note that C++ defaults to field-by-field assignment operators and
  copy constructors if no explicit version is supplied. In many cases,
  this is sufficient.

  QMap uses an STL-like syntax to manipulate and address the
  objects it contains.  For historical reasons, QMap contains
  additional functions which essentially perform the same task.  It is
  recommended that the STL-like functions be used in application code
  to ease the transition to a future version of Qt.  See <a
  href="qtl.html">this document</a> for more information.

  The class used for the key requires that the \c operator< is implemented
  to define ordering of the keys.

  Example:
  \code
    #include <qmap.h>
    #include <qstring.h>
    #include <stdio.h>

    class Employee
    {
    public:
	Employee(): s(0) {}
	Employee( const QString& name, int salary )
	    : n(name), s(salary)
	{}

	QString     name()   const	 	{ return n; }
	int	    salary() const	 	{ return s; }
	void	    setSalary( int salary )	{ s = salary; }
    private:
	QString     n;
	int         s;
    };


    int main()
    {
	typedef QMap<QString,Employee> EmployeeMap;
	EmployeeMap map;		// map of Employee

	map["Gates"] = Employee("Bill", 50000);
	map["Ballmer"] = Employee("Steve",80000);
	map[ "Sommer"] = Employee("Ron",  60000);

	Employee joe( "Joe", 50000 );
	map["Doe"] = joe ;
	joe.setSalary( 4000 );

	EmployeeMap::Iterator it;
	for( it = map.begin(); it != map.end(); ++it )
	    printf( "%s, %s earns %d\n", it.key().latin1(), it.data().name().latin1(), it.data().salary() );

	return 0;
    }
  \endcode

  Program output:
  \code
	Ballmer, Steve earns 80000
	Doe, Joe earns 50000
	Gates, Bill earns 50000
	Sommer, Ron earns 60000
  \endcode

  As you can see, the latest changes to Joe's salary did not affect
  the value in the list because the map created a copy of Joe's
  entry. In addition, notice that the items are sorted alphabetically
  when iterating over the map.

  There are several ways to find items in a map.  The begin() and
  end() functions return iterators to the beginning and end of the
  map. The advantage of getting an iterator is that you can now move
  forward or backward from this position by incrementing/decrementing
  the iterator.  The iterator returned by end() points to the element
  which is one past the last element in the container. The
  past-the-end iterator is still associated with the map it belongs
  to, however it is \e not dereferenceable; operator*() will not
  return a well-defined value. If the map is empty(), the iterator
  returned by begin() will equal the iterator returned by end().
  Since end() returns a past-the-end iterator, the size() of the list
  is equal to end() - begin().

  Another way to find an element in the map is by using the find()
  function.  It returns an iterator pointing to the desired
  item or to the end() iterator if no such element exists.

  Another approach uses the operator[]. But be warned: If the map does
  not contain an entry for the element you are looking for, operator[]
  inserts a default value.  If you do not know that the element you
  are searching for is really in the list, you should not use
  operator[]. The following example illustrates this:

  \code
	QMap<QString,QString> map;
	map["Weis"] = "Torben";
	str << map["Weis"] << map["Ettrich"] << endl;

  \endcode

  The code fragment will print out "Torben", "".  Since the value
  associated with the "Ettrich" key did not exist, the map inserted a
  default value (in this case, an empty string).  If you are not
  sure whether a certain element is in the map, you should use find()
  and iterators instead.

  If you just want to know whether a certain key is contained in the map,
  the count() function is what you are looking for. In addition,
  size() tells you how many keys there are currently in the map.

  It is safe to have multiple iterators at the same time. If some
  member of the map is removed, only iterators pointing to the removed
  member become invalid; inserting in the map does not invalidate any
  iterators.

  Since QMap is value-based, there is no need to be concerned about deleting
  elements in the map. The map holds its own copies and will free
  them if the corresponding member or the map itself is deleted. You
  can force the map to free all its item with clear().

  QMap is implicitly shared. This means you can just make copies of
  the map in time O(1). If multiple QMap instances share the same data
  and one is modifying the map's data, this modifying instance
  makes a copy and modifies its private copy; it thus does not affect
  other instances.  From a developer's point of view you can think
  that a QMap and a copy of this map have nothing to do with each
  other. If a QMap is being used in a multi-threaded program, you must
  protect all access to the map.  See QMutex.

  There are several ways of inserting new elements into the map. One
  uses the insert() method; the other one uses operator[] like this:

  \code
  	QMap<QString,QString> map;
	map["Weis"] = "Torben";
	map.insert( qMakePair( "Berton","Dave" ) );
  \endcode;

  Items can also be removed from the map in several ways. The first is
  to pass an iterator to erase(). The other is to pass a key
  value to erase(), which will delete the entry with the requested
  key. In addition you can clear the entire map using the clear()
  method.

  \sa QMapIterator
*/


/*! \enum  QMap::key_type 
	The map's key type. */
/*! \enum  QMap::mapped_type 
	The map's data type. */
/*! \enum  QMap::value_type 
	Corresponds to QPair<key_type,mapped_type>.*/
/*! \enum  QMap::pointer 
	Pointer to value_type.*/
/*! \enum  QMap::const_pointer 
	Const pointer to value_type.*/
/*! \enum  QMap::reference 
	Reference to value_type.*/
/*! \enum  QMap::const_reference 
	Const reference to value_type.*/
/*! \enum  QMap::size_type 
	An unsigned integral type, used to represent various sizes. */
/*! \enum  QMap::iterator 
	The map's iterator type.*/
/*! \enum  QMap::const_iterator 
	The map's const iterator type.*/

/*!
  \fn QMap::QMap()
  Constructs an empty map.
*/

/*!
  \fn QMap::QMap( const QMap<Key,T>& m )
  Constructs a copy of \a m.

  This operation costs O(1) time because QMap is shared implicitly.  The
  first instance of applying modifications to a shared list will create a
  copy that takes in turn O(n) time. However, returning a QMap from a
  function is very fast.
*/

/*! \fn QMap::QMap( const std::map<Key,T>& m )
  Constructs a copy of \a m.
*/

/*! \fn QMap<Key,T>& QMap::operator= ( const std::map<Key,T>& m )

  \overload

  Assigns \a m to this map and returns a reference to this map.

  All iterators of the current map become invalidated by this
  operation.
*/

/*!
  \fn QMap::~QMap()

  Destroys the map. References to the values in the map and all
  iterators of this map become invalidated. Since QMap is highly tuned
  for performance you won't see warnings if you use invalid iterators,
  because it is impossible for an iterator to check whether it is
  valid or not.
*/

/*!
  \fn QMap<Key, T>& QMap::operator= (const QMap<Key, T>& m)
  Assigns \a m to this map and returns a reference to this map.

  All iterators of the current map become invalidated by this
  operation.  The cost of such an assignment is O(1), because QMap is
  shared implicitly.
*/

/*!
  \fn T& QMap::operator[] ( const Key& k )
  Returns the value associated with the key \a k. If no such
  key is present, an empty item is inserted with this key
  and a reference to the item is returned.

  You can use this operator both for reading and writing:

  \code
  	QMap<QString,QString> map;
	map[ "Weis" ] = "Torben";
	stream << map[ "Weis" ];
  \endcode
*/

/*!
  \fn void QMap::clear()
  Removes all items from the map.

  \sa erase()
*/

/*!
  \fn Iterator QMap::find( const Key& k )
  Finds the key \a k in the map.

  Returns end() if no key matched.

  \sa QMapIterator
*/

/*!
  \fn ConstIterator QMap::find( const Key& k ) const

  \overload

  Finds the key \a k in the map.

  Returns end() if no key matched.

  \sa QMapConstIterator
*/

/*!
  \fn Iterator QMap::begin()
  Returns an iterator pointing to the first element in the map. This
  iterator equals end() if the map is empty.

  \sa end() QMapIterator
*/

/*!
  \fn ConstIterator QMap::begin() const

  \overload

  Returns an iterator pointing to the first element in the map. This
  iterator equals end() if the map is empty.

  \sa end() QMapConstIterator
*/

/*!
  \fn Iterator QMap::end()
  Returns an iterator pointing behind the last element in the map. This
  iterator equals begin() if the map is empty.

  \sa begin() QMapIterator
*/

/*!
  \fn ConstIterator QMap::end() const

  \overload

  Returns an iterator pointing behind the last element in the map. This
  iterator equals begin() if the map is empty.

  \sa begin() QMapConstIterator
*/

/*!
  \fn void QMap::detach()
  If the map does not share its data with another QMap instance, nothing happens; otherwise the function creates a new copy of this
  data and detaches from the shared one. This function is called
  whenever the map is modified.  The implicit sharing mechanism is
  implemented this way.
*/


/*!
  \fn QDataStream& operator>>( QDataStream& s, QMap<Key,T>& m )
  \relates QMap
  Reads the map \m from the stream \s. The types \e Key and \e T must implement
  the streaming operator as well.
*/

/*!
  \fn QDataStream& operator<<( QDataStream& s, const QMap<Key,T>& m )
  \relates QMap
  Writes the map \a m to the stream \a s. The types \e Key and \e T must implement
  the streaming operator as well.
*/

/*! \fn size_type QMap::size() const
  Returns the number of elements in the map.
*/

/*! \fn bool QMap::empty() const
  Returns TRUE if and only if the map's size is zero.
*/

/*! \fn QPair<iterator,bool> QMap::insert( const value_type& x )

  Inserts \a x into the map.  \a x is a QPair<> whose \c first
  element is a key to be inserted and whose \c second element is the
  associated value to be inserted.  Returns a pair<> whose \c first
  element is an iterator pointing at the inserted item and whose \c
  second element is a bool indicating TRUE if \a x was inserted and
  FALSE if it was not inserted because it was already present.
*/

/*! \fn void QMap::erase( iterator it )
  Removes the item at position \a it in the map.

  \sa clear() QMapIterator
*/

/*! \fn void QMap::erase( const key_type& k )

  \overload

  Removes the item with the key \a k.

  \sa clear()
*/

/*! \fn size_type QMap::count( const key_type& k )
  Returns the number of elements whose key are \a k.  The return value is either 0 or 1.
*/

/*! \fn Iterator QMap::replace( const Key& k, const T& v )
  Replaces the value with key \a k from the map if possible, and
  inserts the new value \a v with key \a k in the map.

  \sa insert() remove() QMapIterator
*/

// *****************************************************
// Note : The following documentation is for historical reasons. 
// These functions should be avoided in new code.
// *****************************************************

/*! \fn const T& QMap::operator[] ( const Key& k ) const

  \overload

  \warning This function differs from the non-const version of the
  same function.  It will \e not insert an empty value if the key \a k
  does not exist.  This may lead to logic errors in your program.  You
  should check if the element exists before calling this function.

  Returns the value associated with the key \a k. If no such
  key is present, a reference to an empty item is returned.
*/

/*! \obsolete
  \fn uint QMap::count() const

  Use size() instead.

  \sa isEmpty()
*/

/*! \obsolete
  \fn bool QMap::isEmpty() const
  
  Use empty() instead.

  \sa size()
*/

/*! \obsolete
  \fn Iterator QMap::insert( const Key& key, const T& value, bool overwrite )

  Use \link QMap::insert( value_type ) insert() \endlink instead.

  \sa iterator
*/

/*! \obsolete
  \fn void QMap::remove( iterator it )

  Use erase() instead.

  \sa clear() iterator
*/

/*! \obsolete
  \fn void QMap::remove( const Key& k )

  Use erase() instead.

  \sa clear()
*/

/*! \obsolete
  \fn bool QMap::contains( const Key& k ) const
  
  Use count() instead.

*/


/*****************************************************************************
  QMapIterator documentation
 *****************************************************************************/

/*!
  \class QMapIterator qmap.h
  \brief The QMapIterator class provides an iterator for QMap.

  \ingroup qtl
  \ingroup tools

  You cannot create an iterator by yourself. Instead, you have to ask
  a map to give you one. An iterator is as big as a pointer;
  on 32-bit machines that means 4 bytes, on 64-bit ones 8 bytes. That makes
  copying them very fast. They resemble the semantics of pointers as
  much as possible, and they are almost as fast as usual pointers.

  Example:
  \code
    #include <qmap.h>
    #include <qstring.h>
    #include <stdio.h>

    class Employee
    {
    public:
	Employee(): s(0) {}
	Employee( const QString& name, int salary )
	    : n(name), s(salary)
	{}

	QString     name()   const	 	{ return n; }
	int	    salary() const	 	{ return s; }
	void	    setSalary( int salary )	{ s = salary; }
    private:
	QString     n;
	int         s;
    };


    int main()
    {
	typedef QMap<QString,Employee> EmployeeMap;
	EmployeeMap map;		// map of Employee

	map.insert( "Gates", Employee("Bill", 50000) );
	map.insert( "Ballmer", Employee("Steve",80000) );
	map.insert( "Sommer,", Employee("Ron",  60000) );

	Employee joe( "Joe", 50000 );
	map.insert( "Doe", joe );
	joe.setSalary( 4000 );
	
	EmployeeMap::Iterator it;
	for( it = map.begin(); it != map.end(); ++it )
	    printf( "%s, %s earns %d\n", it.key().latin1(), it.data().name().latin1(), it.data().salary() );

	return 0;
    }
  \endcode

  Program output:
  \code
	Ballmer, Steve earns 80000
	Doe, Joe earns 50000
	Gates, Bill earns 50000
	Sommer, Ron earns 60000
  \endcode

  The only way to traverse a map is to use iterators.  QMap is highly
  optimized for performance and memory usage.  On the other hand this
  means that you have to be a bit more careful with what you are
  doing. QMap does not know about all its iterators, and the iterators
  don't even know to which map they belong. That makes things fast but
  a bit dangerous because it is up to you to make sure that the
  iterators you are using are still valid. QDictIterator will be able
  to give warnings, whereas QMapIterator may end up in an undefined
  state.

  For every Iterator there is also a ConstIterator. You have to use the ConstIterator to access a QMap
  in a const environment or if the reference or pointer to the map is
  itself const. Its semantics are the same, but it returns only const references to the item it
  points to.

  \sa QMap
*/

/*! \enum  QMapIterator::iterator_category 
	The type of iterator category, \c std::bidirectional_iterator_tag. */
/*! \enum  QMapIterator::value_type
	The type of value. */
/*! \enum  QMapIterator::pointer
	Pointer to value_type. */
/*! \enum  QMapIterator::reference
	Reference to value_type. */

/*!
  \fn QMapIterator::QMapIterator()
  Creates an uninitialized iterator.
*/

/*!
  \fn QMapIterator::QMapIterator (QMapNode<K, T> * p) 
  Constructs an iterator starting at node \a p.
*/

/*!
  \fn QMapIterator::QMapIterator( const QMapIterator<K,T>& it )
  Constructs a copy of the iterator.
*/

/*!
  \fn QMapIterator<K,T>& QMapIterator::operator++()

  Prefix ++ makes the succeeding item current and returns an iterator
  pointing to the new current item.  The iterator can not check
  whether it reached the end of the map. Incrementing the iterator as
  returned by end() causes undefined results.
*/

/*!
  \fn QMapIterator<K,T> QMapIterator::operator++(int)

  \overload

  Postfix ++ makes the succeeding item current and returns an iterator
  pointing to the new current item.  The iterator can not check
  whether it reached the end of the map. Incrementing the iterator as
  returned by end() causes undefined results.
*/

/*!
  \fn QMapIterator<K,T>& QMapIterator::operator--()

  Prefix -- makes the previous item current and returns an iterator
  pointing to the new current item.  The iterator can not check
  whether it reached the beginning of the map. Decrementing the
  iterator as returned by begin() causes undefined results.
*/

/*!
  \fn QMapIterator<K,T> QMapIterator::operator--(int)

  \overload

  Postfix -- makes the previous item current and returns an iterator
  pointing to the new current item.  The iterator can not check
  whether it reached the beginning of the map. Decrementing the
  iterator as returned by begin() causes undefined results.
*/

/*!
  \fn T& QMapIterator::operator*()

  Asterix operator. Returns a reference to the current item. The same
  as data().
*/

/*!
  \fn const T& QMapIterator::operator*() const

  \overload

  Asterix operator. Returns a const reference to the current item. The
  same as data().
*/

/*!
  \fn bool QMapIterator::operator==( const QMapIterator<K,T>& it ) const

  Compares the iterator to the \a it iterator and returns TRUE if they point to the same
  item.
*/

/*!
  \fn bool QMapIterator::operator!=( const QMapIterator<K,T>& it ) const

  Compares the iterator to the \a it iterator and returns TRUE if they point to the same
  item.
*/

/*!
  \fn T& QMapIterator::data()

  Returns a reference to the current item.
*/

/*!
  \fn const T& QMapIterator::data() const

  \overload

  Returns a const reference to the data of the current item.
*/

/*!
  \fn const K& QMapIterator::key() const

  Returns a const reference to the data of the current key.
*/

/*****************************************************************************
  QMapConstIterator documentation
 *****************************************************************************/

/*!
  \class QMapConstIterator qmap.h
  \brief The QMapConstIterator class provides an iterator for QMap.

  \ingroup qtl
  \ingroup tools

  In contrast to QMapIterator, this class is used to iterate over a
  const map. It does not allow to modify the values of the map because
  this would break the const semantics.

  For more informations on QMap iterators, see QMapIterator.

  \sa QMap QMapIterator
*/

/*! \enum  QMapConstIterator::iterator_category 
	The type of iterator category, \c std::bidirectional_iterator_tag. */
/*! \enum  QMapConstIterator::value_type
	The type of const value. */
/*! \enum  QMapConstIterator::pointer
	Const pointer to value_type. */
/*! \enum  QMapConstIterator::reference
	Const reference to value_type. */


/*!
  \fn QMapConstIterator::QMapConstIterator()
  Constructs an uninitialized iterator.
*/

/*!
  \fn QMapConstIterator::QMapConstIterator (QMapNode<K, T> * p) 
  Constructs an iterator starting at node \a p.
*/

/*!
  \fn QMapConstIterator::QMapConstIterator( const QMapConstIterator<K,T>& it )
  Constructs a copy of the iterator.
*/

/*!
  \fn QMapConstIterator::QMapConstIterator( const QMapIterator<K,T>& it )
  Constructs a copy of the iterator.
*/

/*!
  \fn QMapConstIterator<K,T>& QMapConstIterator::operator++()

  Prefix ++ makes the succeeding item current and returns an iterator
  pointing to the new current item.  The iterator can not check
  whether it reached the end of the map. Incrementing the iterator as
  returned by end() causes undefined results.
*/

/*!
  \fn QMapConstIterator<K,T> QMapConstIterator::operator++(int)

  \overload

  Postfix ++ makes the succeeding item current and returns an iterator
  pointing to the new current item.  The iterator can not check
  whether it reached the end of the map. Incrementing the iterator as
  returned by end() causes undefined results.
*/

/*!
  \fn QMapConstIterator<K,T>& QMapConstIterator::operator--()

  Prefix -- makes the previous item current and returns an iterator
  pointing to the new current item.  The iterator can not check
  whether it reached the beginning of the map. Decrementing the
  iterator as returned by begin() causes undefined results.
*/

/*!
  \fn QMapConstIterator<K,T> QMapConstIterator::operator--(int)

  \overload

  Postfix -- makes the previous item current and returns an iterator
  pointing to the new current item.  The iterator can not check
  whether it reached the beginning of the map. Decrementing the
  iterator as returned by begin() causes undefined results.
*/

/*!
  \fn const T& QMapConstIterator::operator*() const

  Asterix operator. Returns a const reference to the current item. The
  same as data().
*/

/*!
  \fn bool QMapConstIterator::operator==( const QMapConstIterator<K,T>& it ) const

  Compares the iterator to the \a it iterator and returns TRUE if they point to the same
  item.
*/

/*!
  \fn bool QMapConstIterator::operator!=( const QMapConstIterator<K,T>& it ) const

  Compares the iterator to the \a it iterator and returns TRUE if they point to the same
  item.
*/

/*!
  \fn const T& QMapConstIterator::data() const
  Returns a const reference to the data of the current item.
*/

/*!
  \fn const K& QMapConstIterator::key() const
  Returns a const reference to the current key.
*/
