#include "qcom.h"

#ifndef QT_NO_COMPONENT

// We still have no name for the COM-like stuff here! See ###

/*!
  \class QUnknownInterface qcom.h
  \brief The QUnknownInterface class is the base class for all interfaces of the Qt Component Model.
  \ingroup componentmodel

  All ### interfaces are derived from the QUnknownInterface. This interface provides
  control of the object's lifetime and the ability to navigate a component implementing
  multiple interfaces.
  The object's lifetime is controlled using a reference count that is increased and
  decreased using the functions addRef and release, respectively.
  The queryInterface functions determines whether the component supports a specific interface.
  For every interface a Unique Universal Identifier (UUID) is provided to identify requests
  for the interface. In Qt, this identifier is wrapped in the \link QUuid QUuid \endlink class
  that provides convenience operators for comparison and copying.
*/

/*!
  \fn QRESULT  QUnknownInterface::queryInterface( const QUuid &request, QUnknownInterface** iface )

  Returns a pointer to an interface specified with \a request, or NULL if this interface
  can't provide the requested interface. An implementation of this function must call
  addRef() on the pointer it returns.

  Example:
  \code
  QRESULT MyComponent::queryInterface( const QUuid &request, QUnknownInterface** iface )
  {
      if ( request == IID_QUnknownInterface )
          *iface = this;
      else if ( request == IID_... )
          *iface = (...*)this;
      ...

      if ( iface )
          *iface->addRef();
     return #####;
  }
  \endcode

  There are five requirements for implementations of queryInterface:
  <ul>
  <li>Always the same QUnknownInterface
  For any component, a query for the QUnknownInterface must always return the same pointer value to
  allow a client to determine whether two interfaces point to the same component.
  <li>Static set of interfaces
  The number of interfaces for which queryInterface returns a valid pointer must not change.
  <li>Reflexive
  If a client holding a pointer to one interface queries for that interface, the call must succeed.
  <li>Symmetric
  If a client holding a pointer to one interface queries for another, a query through the obtained
  interface for the first interface must succeed.
  <li>Transitive
  If a client holding a pointer to one interface queries successfully for a second, and queries that
  successfully for a third interface, a query for that third interface on the first interface must succeed.
  </ul>

  \sa addRef(), release()
*/

/*!
  \fn ulong QUnknownInterface::addRef()

  Increases the reference counter for this interface by one and returns
  the old reference count.

  Example:
  \code
  int MyComponent::addRef()
  {
      return ref++;
  }
  \endcode

  This function must be called when this interface is returned as a result of a
  queryInterface() call. It should be called for every new copy of a pointer to
  this interface.

  \sa queryInterface(), release()
*/

/*!
  \fn ulong QUnknownInterface::release()

  Decreases the reference count for this interface by one and returns
  the new reference count. If the reference count falls to 0, the object is freed from memory.

  Example:
  \code
  int MyComponent::release()
  {
      if ( !--ref ) {
          delete this;
	  return 0;
      }
      return ref;
  }
  \endcode

  This function should be called whenever a copy of a pointer to this interface is no longer needed.

  \sa addRef()
*/



/*!
  \class QComponentInterface qcom.h
  \brief The QComponentInterface class provides a means of obtaining basic information about components.
  \ingroup componentmodel

    The functions provided by QComponentInterface are name(),
    description(), author() and version(), all of which return a string
    containing the relevant information.
*/

/*!
  \fn QString QComponentInterface::name() const

  Returns a string with the name of the module.
*/

/*!
  \fn QString QComponentInterface::description() const

  Returns a string with a description of the module.
*/

/*!
  \fn QString QComponentInterface::author() const

  Returns a string with information about the author of the module.
*/

/*!
  \fn QString QComponentInterface::version() const

  Returns a string with information about the version of the module.
*/


/*!
  \class QComponentFactoryInterface qcom.h
  \brief The QComponentFactoryInterface class is an interface for component creation.
  \ingroup componentmodel
*/

/*!
  \fn QComponentFactoryInterface::createInstance( const QUuid &cid, const QUuid &iid, QUnknownInterface **iface, QUnknownInterface *outer )

  Creates the component specified by \a cid and sets \a iface to the pointer to the interface \a iid implemented by this component. 
  The component can use the \a outer interface for containment and aggregation.
*/


/*!
  \class QLibraryInterface qcom.h
  \brief The QLibraryInterface class is an interface to control loading and unloading of components.
  \ingroup componentmodel
*/

/*!
  \fn bool QLibraryInterface::init()

  When this function returns FALSE, the component implementing this interface will not be loaded.
*/

/*!
  \fn void QLibraryInterface::cleanup()

  Called by QLibrary before unloading the component implementing this interface.
*/

/*!
  \fn bool QLibraryInterface::canUnload() const

  When this function returns FALSE, the component implementing this interface will not be unloaded.
  This function may be called regularily to unload unused libraries.
*/



/*!
  \class QFeatureListInterface qcom.h
  \brief The QFeatureListInterface class is an interface to retrieve information about features provided by a component.
  \ingroup componentmodel
*/

/*!
  \fn QStringList QFeatureListInterface::featureList() const

  Returns a list of features implemented in this component.
*/


/*!
  \class QComponentServerInterface qcom.h
  \brief The QComponentServerInterface class provides a means of registering and unregistering components.
  \ingroup componentmodel

  This class provides two functions, registerComponents() and
  unregisterComponents().

  \sa QComponentFactory
*/

/*!
  \fn bool QComponentServerInterface::registerComponents( const QString &filepath ) const

  Registers the components in this server in the system registry and
  returns TRUE when successful, otherwise returns FALSE. The \a filepath is
  the absolute path to the shared library file.

  Example:
  \code
  QSettings register;
  bool ok;

  register.insertSearchPath( QSettings::Windows, "/Classes" );
  ok = register.writeEntry( "/CLSID/{DD19964B-A2C8-42AE-AAF9-8ADC509BCA03}/Default", "Test Component" );
  ok = register.writeEntry( "/CLSID/{DD19964B-A2C8-42AE-AAF9-8ADC509BCA03}/InprocServer32/Default", filepath ) && ok;

  return ok;
  \endcode

  See \l QSettings.
*/

/*!
  \fn bool QComponentServerInterface::unregisterComponents() const

  Removes the component in this server from the system registry and returns
  TRUE if successful, otherwise returns FALSE.

  \code
  QSettings settings;
  bool ok;

  settings.insertSearchPath( QSettings::Windows, "/Classes" );
  ok = settings.removeEntry( "/CLSID/{DD19964B-A2C8-42AE-AAF9-8ADC509BCA03}/InprocServer32/Default" );
  ok = settings.removeEntry( "/CLSID/{DD19964B-A2C8-42AE-AAF9-8ADC509BCA03}/Default" ) && ok;

  return ok;
  \endcode

  See \l QSettings.
*/

#endif // QT_NO_COMPONENT
