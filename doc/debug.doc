/****************************************************************************
** $Id: debug.doc,v 2.8 1999/04/13 05:29:14 warwick Exp $
**
** Qt Debugging Techniques
**
** Copyright (C) 1992-1999 Troll Tech AS.  All rights reserved.
**
** This file is part of the Qt GUI Toolkit.
**
** This file may be distributed under the terms of the Q Public License
** as defined by Troll Tech AS of Norway and appearing in the file
** LICENSE.QPL included in the packaging of this file.
**
** Licensees with valid Qt Professional Edition licenses may distribute and
** use this file in accordance with the Qt Professional Edition License
** provided at sale or upon request.
**
** See http://www.troll.no/pricing.html or email sales@troll.no for
** information about the Professional Edition licensing, or see
** http://www.troll.no/qpl/ for QPL licensing information.
**
*****************************************************************************/

/*!
\page debug.html

<title>Qt Debugging Techniques</title>
</head><body bgcolor="#ffffff">
\postheader

<h1 align=center>Debugging Techniques</h1><br clear="all">

Here we present some useful methods for debugging your Qt-based software.

<h2>Command Line Options</h2>

When you run a Qt program you can specify several command line options
that can help with debugging.
<p>
<ul>
<li>-nograb The application should never grab \link QWidget::grabMouse the
mouse\endlink or \link QWidget::grabKeyboard() the keyboard \endlink.
This option is set by default when the program is running in the \c
gdb debugger under Linux.
<li>-dograb Ignore any implicit or explicit -nograb.  -dograb wins
over -nograb even when -nograb is last on the command line.
<li>-sync Runs the application in X synchronous mode.  Synchronous
mode forces the X server perform each X client request immediately and
not use a buffer optimization. It makes the program easier to debug and
often much slower.  The -sync option is only valid for the X11
version of Qt.
</ul>
<p>
(Note that these options are only available in the development
version of the Qt library, not in the production version.  Currently,
<a href="troll.html">Troll Tech</a> only supports a development version
of the Qt library.)
<p>

<hr>
<h2>Warning and Debugging Messages</h2>

Qt includes three global functions for writing out warning and debug
text.
<ul>
<li>\link ::debug() debug()\endlink for writing debug output for testing etc.
<li>\link ::warning() warning()\endlink for writing warning output when program
errors occur.
<li>\link ::fatal() fatal()\endlink for writing fatal error messages and exit.
</ul>

The Qt implementation of these functions prints the text to the \c stderr
output under Unix/X11 and to the debugger under Windows.  You can
take over these functions by installing a message handler;
\link ::qInstallMsgHandler() qInstallMsgHandler()\endlink.


<hr>
<h2>Debugging Macros</h2>

The header file qglobal.h contains many debugging macros and #defines.

Two important macros are:
<ul>
<li>\link ::ASSERT ASSERT(b)\endlink where b is a boolean expression, writes
the warning: "ASSERT: 'b' in file file.cpp (234)" if b is FALSE.
<li>\link ::CHECK_PTR() CHECK_PTR(p)\endlink where p is a pointer.
Writes the warning "In file file.cpp, line 234: Out of memory" if p is null.
</ul>

These macros are useful for detecting program errors, e.g. like this:
\code
  char *alloc( int size )
  {
      ASSERT( size > 0 );
      char *p = new char[size];
      CHECK_PTR( p );
      return p;
  }
\endcode

Note that the CHECK_PTR macro is a null expression if \c CHECK_NULL
(see below) is not defined.  Any code in it will simply not be
executed.  Here is an example of how you should NOT do it:
\code
  char *alloc( int size )
  {
      char *p;
      CHECK_PTR( p = new char[size] );	// never do this!
      return p;
  }
\endcode

Very tricky: \e p is set to a sane value only if you're debugging.
When you're ready to ship, that code is not executed (correctly, since
it's only a debugging aid) and \e alloc returns a wild pointer.

The Qt development library contains hundreds of warning messages that
are printed when some error is detected.

The warning messages inside Qt are conditional, based on the state of
various debugging flags:
<ul>
<li> \c CHECK_STATE: Check for consistent/expected object state
<li> \c CHECK_RANGE: Check for variables range errors
<li> \c CHECK_NULL: Check for dangerous null pointer
<li> \c NO_CHECK: Turn off all CHECK_... flags
<li> \c DEBUG: Enable debugging code
<li> \c NO_DEBUG: Turn off DEBUG flag
</ul>

Example:
\code
  void f( char *p, int i )
  {
  #if defined(CHECK_NULL)
      if ( p == 0 )
	  warning( "f: Null pointer not allowed" );
  #endif

  #if defined(CHECK_RANGE)
      if ( i < 0 )
	  warning( "f: The index cannot be negative" );
  #endif
  }
\endcode

<h2>Common bugs</h2>

There is one bug that is so common that it deserves mention here: If
you include the Q_OBJECT macro in a class declaration and run the moc,
but forget to link the moc-generated object code into your executable,
you will get very confusing error message.

Any link error complaining about a lack of <code>vtbl</code>,
<code>_vtbl</code>, <code>__vtbl</code> or similar is likely to be
this problem.

*/
