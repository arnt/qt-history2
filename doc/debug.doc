/****************************************************************************
** $Id: debug.doc,v 1.7 1995/12/27 18:17:10 hanord Exp $
**
** Qt Debugging Techniques
**
** Copyright (C) 1995 by Troll Tech AS.  All rights reserved.
**
*****************************************************************************/

/*!
\page debug.html

<title>Qt Debugging Techniques</title>
</head><body>
<a name=debuggingtechniques></a>
<h1>Qt Debugging Techniques</h1>
<hr>

<h2>Command Line Options</h2>

When you run a Qt program you can specify several command line options
for debugging purposes.
<p>
Notice that these options are only available in the development version of
the Qt library, not in the production version.
Currently, <a href=troll.html>Troll Tech</a> only supports a development
version of the Qt library.
<p>
Debugging options:
<ul>
<li>-nograb The application should never grab \link QWidget::grabMouse the
mouse\endlink or \link QWidget::grabKeyboard() the keyboard \endlink.
This option is automatically enabled when running the program in the
\c gdb debugger under Linux.
<li>-dograb Always grab the moust and the keyboard, even if running as
a \c gdb process under Linux.
<li>-sync Runs the application in X synchronous mode.
Synchronous mode forces the X server perform each X client request immediately
and not use a buffer optimizaton. It makes the program easier to debug.
The -sync option is only valid for the X-Windows version of Qt.
</ul>
<p>
<p>


<hr>
<h2>Warning and Debugging Messages</h2>

Qt has three functions for writing out warning and debug text.
<ul>
<li>\link ::debug() debug()\endlink for writing debug output for testing etc.
<li>\link ::warning() warning()\endlink for writing warning output when program
errors occur.
<li>\link ::fatal() fatal()\endlink for writing fatal error messages and exit.
</ul>

The Qt implementation of these functions prints the text to the \c stderr
output under UNIX/X-Windows and to the debugger under Windows.  You can
take over these functions by installing a message handler;
\link ::qInstallMsgHandler() qInstallMsgHandler()\endlink.


<hr>
<h2>Debugging Macros</h2>

The header file qglobal.h contains many debugging macros and #defines.

To important macros are:
<ul>
<li>\link ::ASSERT ASSERT(b)\endlink where b is a boolean expression, writes
the warning: "ASSERT: 'b' in file file.cpp (234)" if b is FALSE.
<li>\link ::CHECK_PTR() CHECK_PTR(p)\endlink where p is a pointer.
Writes the warning "In file file.cpp, line 234: Out of memory" if p is null.
</ul>

These macros are useful for detecting program errors.

Example:
\code
  char *alloc( int size )
  {
      ASSERT( size > 0 );
      char *p = new char[size];
      CHECK_PTR( p );
      return p;
  }
\endcode

Note that the CHECK_PTR macro will be substituted with nothing if
\c CHECK_NULL (see below) is not defined.

Example of misuse:
\code
  char *alloc( int size )
  {
      char *p;
      CHECK_PTR( p = new char[size] );	// never do this!
      return p;
  }
\endcode

The Qt development library contains hundreds of warning messages that
are printed when an internal error is detected.

The warning messages are conditional, based on one or more
debugging flags:
<ul>
<li> \c CHECK_STATE: Check for consistent/expected object state
<li> \c CHECK_RANGE: Check for variables range errors
<li> \c CHECK_NULL: Check for dangerous null pointer
<li> \c NO_CHECK: Turn off all CHECK_... flags
<li> \c DEBUG: Enable debugging code
<li> \c NO_DEBUG: Turn off DEBUG flag
</ul>

Example:
\code
  void f( char *p, int i )
  {
  #if defined(CHECK_NULL)
      if ( p == 0 )
	  warning( "f: Null pointer not allowed" );
  #endif

  #if defined(CHECK_RANGE)
      if ( i < 0 )
	  warning( "f: The index cannot be negative" );
  #endif
  }
\endcode
*/
