/****************************************************************************
** $Id: qinterfacemanager.doc,v 2.32 1999/10/25 14:49:09 vohi Exp $
**
** QInterfaceManager class documentation
**
** Copyright (C) 1992-2000 Trolltech AS.  All rights reserved.
**
** This file is part of the Qt GUI Toolkit.
**
** This file may be distributed under the terms of the Q Public License
** as defined by Trolltech AS of Norway and appearing in the file
** LICENSE.QPL included in the packaging of this file.
**
** This file may be distributed and/or modified under the terms of the
** GNU General Public License version 2 as published by the Free Software
** Foundation and appearing in the file LICENSE.GPL included in the
** packaging of this file.
**
** Licensees holding valid Qt Enterprise Edition or Qt Professional Edition
** licenses may use this file in accordance with the Qt Commercial License
** Agreement provided with the Software.
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
**   information about Qt Commercial License Agreements.
** See http://www.trolltech.com/qpl/ for QPL licensing information.
** See http://www.trolltech.com/gpl/ for GPL licensing information.
**
** Contact info@trolltech.com if any conditions of this licensing are
** not clear to you.
**
**********************************************************************/



/*****************************************************************************
  QInterfaceManager documentation
 *****************************************************************************/

/*!
  \class QInterfaceManager qinterfacemanager.h
  \brief The QInterfaceManager class provides basic functions to access a certain kind of functionality in libraries.
  \ingroup componentmodel

  A common usage of components is to provide a certain kind of functionality in the form of plugins. The application
  provides a set of built-in features, and different types of plugins can be loaded to add 3rd party commands to this
  set.
  The code to do this will be similar for all supported types of plugins: searching a specific directory for all shared
  libraries, loading them and trying to get information about the features the plugin wants to add to the application.
  The QInterfaceManager class provides a template based solution for this task making use of the COM-like interface 
  architecture provided by the Qt library.
  Specializing a QInterfaceManager is done by specifying the interface declaration and the QUuid that is used to query
  for this kind of interface:

  \code
  QInterfaceManager<MyPluginInterface> manager = new QInterfaceManager<MyPluginInterface>( IID_MyPluginInterface );
  \endcode

  Any interface that is to be used in a manager has to have a function \e featureList declared like this:

  \code
  virtual QStringList featureList() const = 0;
  \endcode

  The strings returned by this function can then be used to easily access the interface that provides the requested
  feature:

  \code
  MyPluginInterface *iface = manager->queryInterface( "feature" );
  if ( iface )
      iface->execute( "feature" );
  \endcode

  A standard example for this kind of component usage is support for 3rd party commands, e.g. in image processing
  software. An interface could be declared like this:

  \code
  struct ImageFilterInterface : public QUnknownInterface
  {
      virtual QStringList featureList() const = 0;
      virtual bool execute( const QString &filter, QImage *img ) = 0;
  };
  \endcode

  A component could then implement this interface like this:

  \code
  class ColorFilter : public ImageFilterInterface
  {
  public:
      ColorFilter();

      // implement pure virtual functions from ImageFilterInterface
      QStringList featureList() const;
      bool execute( const QString &filter, QImage *img );

      // implement pure virtual functions from QUnknownInterface
  };

  ColorFilter::ColorFilter()
  {
      //...
  }

  QStringList ColorFilter::featureList() const
  {
      QStringList list;
      list << "Convert to Grayscale";
      list << "Sepia";
      //...

      return list;
  }

  bool ColorFilter::execute( const QString &filter, QImage *img )
  {
      if ( !img )
          return FALSE;
      
      if ( filter == "Convert to Grayscale" ) {
          //...
      } else if ( filter == "Sepia" ) {
          //...
      }
  }
  \endcode

  In the application, a QInterfaceManager could be used to create the user interface based 
  on the list of features relevant plugins provide:

  \code
  QInterfaceManager<ImageFilterInterface> *manager = new QInterfaceManager<ImageFilterInterface>( IID_ImageFilterInterface );
  manager->addLibraryPath(...);

  QStringList features = actionPluginManager->featureList();
  for ( QStringList::Iterator it = features.begin(); it != features.end(); ++it ) {
      ImageFilterInterface *iface = manager->queryInterface( *it );

      // use QAction to provide toolbuttons and menuitems for each feature...
  }
  \endcode
*/

/*!
  \fn QInterfaceManager::QInterfaceManager( const QUuid& id, const QString& path = QString::null, const QString& filter = "*.dll; *.so", QLibrary::Policy pol = QLibrary::Delayed, bool cs = TRUE )

  Creates an QInterfaceManager that will load all library files in \a path that match \a filter, setting the default policy to \a pol. 
  If the \a cs flag is set to FALSE the manager will handle feature strings case insensitive.
  
  \warning
  Setting the cs flag to FALSE requires that components also convert to lower case when comparing with passed strings, so this has
  to be handled with care and documented very well.

  The \a pol parameter is propagated to the QLibrary object created for each library.
*/

/*!
  \fn void QInterfaceManager::addLibraryPath( const QString& path, const QString& filter = "*.dll; *.so" )

  Calls addLibrary for all files in \a path that match \a filter. 
  The current library policy will be used for all new QLibrary objects.

  \sa addLibrary, setDefaultPolicy
*/

/*!
  \fn QLibrary* QInterfaceManager::addLibrary( const QString& file )

  Tries to load the library \a file, adds the library to the managed list and
  returns the created QLibrary object if successful, otherwise returns 0. If
  there is already a QLibrary object for \a file, this object will be returned.
  The library will stay in memory if the default policy is Immediately, otherwise 
  it gets unloaded again.

  \sa removeLibrary, addLibraryPath
*/

/*!
  \fn bool QInterfaceManager::removeLibrary( const QString& file )

  Removes the library \a file from the managed list and returns TRUE if the library could
  be unloaded, otherwise returns FALSE.

  \warning
  The QLibrary object for this file will be destroyed.

  \sa addLibrary
*/

/*!
  \fn void QInterfaceManager::setDefaultPolicy( QLibrary::Policy pol )

  Sets the default policy for this library manager to \a pol. The default policy is
  propagated to all newly created QLibrary objects.

  \sa defaultPolicy
*/

/*!
  \fn QLibrary::Policy QInterfaceManager::defaultPolicy() const

  Returns the current default policy.

  \sa setDefaultPolicy
*/

/*!
  \fn Type* QInterfaceManager::queryInterface(const QString& feature) const

  Returns a pointer to the interface providing \a feature.

  \sa featureList, library
*/

/*!
  \fn QLibrary* QInterfaceManager::library( const QString& feature ) const

  Returns a pointer to the QLibrary providing \a feature.

  \sa featureList, libraryList
*/

/*!
  \fn QStringList QInterfaceManager::featureList() const

  Returns a list of all features provided by the interfaces managed by this 
  interface manager.

  \sa library, queryInterface
*/
