/*!
\page model-view-programming.html

\title Model/View Programming

\tableofcontents

\section1 Introduction

Qt 4 introduces a new set of item view classes that use a model/view
architecture to manage the relationship between data and the way it
is presented to the user. The separation of functionality introduced by
this architecture gives developers greater flexibility and access to
more features than was previously possible.
In this document, we give a brief introduction to the model/view paradigm,
outline the concepts involved, and describe the architecture of the item
view system. Each of the components in the architecture is explained,
and examples are given that show how to use the classes provided.

\section1 The model/view architecture

Model-View-Controller (MVC) is a design pattern originating from
Smalltalk that is often used when building user interfaces.
In \l{model-view-programming.html#Gamma}{Design Patterns}, Gamma et al.
write:

\quote
MVC consists of three kinds of objects. The Model is the application
object, the View is its screen presentation, and the Controller defines
the way the user interface reacts to user input. Before MVC, user
interface designs tended to lump these objects together. MVC decouples
them to increase flexibility and reuse.
\endquote

If the view and the controller objects are combined, the result is
the model/view architecture. This still separates the data in the
model from its presentation to the user, but provides a simpler
framework based on the same principles. This separation makes it
possible to display data from the same model in several different
views, and to implement new types of views, without changing the
underlying model.
To allow flexible handling of user input, we introduce the concept of
the \e delegate. The advantage of using a delegate is that it allows
input methods to be defined in addition to those provided by the view,
but does not introduce additional complexity in the common case.

Generally, the model/view classes can be separated into the three groups
described above: models, views, and delegates. Each of these components
are defined by \e abstract classes that provide common interfaces and,
in some cases, default implementations of features.
Abstract classes are meant to be subclassed in order to provide the full
set of functionality expected by other components; this also allows
specialized components to be written.
For example, all item models are based on the \l QAbstractItemModel
class. This class can be used to provide models for views that represent
data in the form of tables, lists, and trees. However, the
\l QAbstractListModel and \l QAbstractTableModel classes are better
starting points for new list and table models because they provide
appropriate default implementations of common functions. Each of these
classes can be subclassed to provide models that support specialized
kinds of lists and tables.

Complete implementations are provided for different kinds of
view widgets based on the \l QAbstractItemView class. \l QListView
provides a complete implementation of a simple list widget,
\l QTableView displays items from a model in a tabular form, and
\l QTreeView shows model items in a hierarchical list. Although
these classes are ready-to-use implementations, they can also be
subclassed to provide customized views.

The abstract base class for delegates is the \l QAbstractItemDelegate
class. A default delegate implementation is provided by the
\l QItemDelegate class which is used as the default delegate by
standard view implementations.

A number of \e convenience classes are derived from the standard view
classes for the benefit of applications that rely on Qt's item-based
item view and table classes. They are not intended to be subclassed,
but simply exist to provide a familiar interface to the equivalent classes
in Qt 3.
Examples of such classes include \c QListWidget, \c QTreeWidget, and
\c QTableWidget; these offer compatibility with the \c QListBox,
\c QListView, and \c QTable classes from Qt 3.
\expire 2004-08-01
These classes are not provided with the current release of Qt.

\section1 The model/view components

The following sections describe the way in which the model/view pattern
is used in Qt. Each section provides an example of use, and is followed
by a section showing how you can create new components.

\list
\i \l{model-view-model.html}{Model Classes}
\i \l{model-view-view.html}{View Classes}
\i \l{model-view-selection.html}{Handling Selections}
\i \l{model-view-delegate.html}{Delegate Classes}
\endlist


\section1 References

\target Gamma
\l{http://www.amazon.com/exec/obidos/ASIN/0201633612/103-8144203-3273444}
{Design Patterns - Elements of Reusable Object-Oriented Software},
by Gamma, Helm, Johnson, and Vlissides, ISBN 0-201-63361-2, provides
more information on the MVC paradigm, explaining MVC and its
sub-patterns in detail.

See also the \l{model-view.html}{list of model/view classes}.

*/

/*!
\page model-view-model.html

\title Model Classes

\tableofcontents

\section1 Basic concepts

In the model/view architecture, the model's purpose is to manage data,
and to provide a standard representation of that data to the other
components in the framework. In Qt, the standard interface to item models
is defined by the \l QAbstractItemModel class. This class exposes a
table-like interface to other components, regardless of how the data
is actually stored in the model, or presented to the user. It also
notifies any attached views of changes to the model through the signals
and slots mechanism.

This section describes some basic concepts that
are central to the way models are accessed by other components. More
advanced concepts are discussed later.

\section2 Model indices

To ensure that representation of the data in the model
is kept separate from the way it is accessed, the concept of a
\e{model index} is introduced. Each item of data is represented by a
model index that is provided by the model when required.
As a result, only the model needs to know how items are stored, and the
type of data managed by the model can be defined fairly generally.

Model indices provide \e temporary references to items, and can be used
to retrieve or modify their data. Since models may reorganize their
internal structures from time to time, model indices may become invalid,
and should not be stored. If a long-term reference to a model item is
required, a \e{persistent model index} must be created. This provides a
reference to the item that the model keeps up-to-date.
Temporary model indices are provided by the \l QModelIndex class, and
persistent model indices are provided by the \l QPersistentModelIndex
class.

To obtain a model index for an item in a model, four properties must
be specified: a row number, a column number, the index of a parent item,
and an item type. The following subsections describe and explain these
properties in detail.

\section2 Rows and columns

In its most basic form, an item model can be accessed as a simple table
in which items are located by their row and column numbers. 
We can retrieve information about any given item by specifying its row
and column numbers to the model, and we will receive an index that
represents the item:

\code
QModelIndex index = model->index(row, column, ...);
\endcode

We can ask the model for the item's data by passing it the model index
corresponding to the item:

\code
QVariant value = model->data(index, ...);
\endcode

The following diagram shows a representation of a basic model in which
each item is located by a pair of row and column numbers. 

\img modelindex-no-parent.png

The highlighted item is represented by a model index that was obtained by
specifying the relevant row and column numbers to the model. 

\section2 Parents of items

A simple tabular model is ideal for representing items in a table, or
for representing lists of items (i.e., where there is only one
column). However, structures such as tree views require a more
flexible interface to the items in the model. As a result, each item
can also be the parent of another table of items, in much the same way
that a top-level item in a tree view can contain another list of
items.

When requesting an index for a model item, we must provide some
information about the item's parent. Outside the model, the only way to
refer to an item is through a model index, so a parent model index must
also be given:

\code
QModelIndex index = model->index(row, column, parent, ...);
\endcode

The following diagram shows the row numbers, column numbers, and parent
indices for two items in the model: a top-level item, and one of its
children.

\img modelindex-parent.png

The model index of the highlighted top-level item is represented by the
'X' symbol, and this is given as the parent of the highlighted child
item.
Top-level items in a model do not have a parent model index
to refer to, so we ensure that the model knows that we are referring to
a top-level item by specifying a default (and invalid) model index.
This is a convention used by the model/view classes.
We can obtain the model indices for both items shown in the diagram:

\code
QModelIndex topLevelIndex = model->index(2, 1, QModelIndex(), ...); // 'X'
QModelIndex childIndex = model->index(3, 4, topLevelIndex, ...);
\endcode

Note that we used QModelIndex() to construct an invalid model index.

\section2 Item types and roles

There are three types of model indices: some indices refer to items
used as horizontal headers, some refer to items used as vertical
headers, and the rest refer to items shown in a view. By specifying
the type we want, we only retrieve the right type of information.
Usually, we want to refer to the data that will be displayed in
a view, so we specify the \l{QModelIndex::Type}{View} type when
obtaining the index. If we specify the
\l{QModelIndex::Type}{HorizontalHeader} or
\l{QModelIndex::Type}{VerticalHeader} types, the model can return an
index corresponding to a horizontal or vertical header.

\img modelindex-types.png

When we obtain a model index, we tell the model which type of item
we are interested in. The above diagram shows how different types of
model indices correspond to items in the model. The model indices
corresponding to the highlighted item and headers in the above diagram
can be obtained by specifying the appropriate index types:

\code
QModelIndex itemIndex = model->index(1, 2, parent);
QModelIndex horizHeaderIndex = model->index(1, 2, parent, QModelIndex::HorizontalHeader);
QModelIndex vertHeaderIndex = model->index(1, 2, parent, QModelIndex::VerticalHeader);
\endcode

The first line above is equivalent to
\code
QModelIndex itemIndex = model->index(1, 2, parent, QModelIndex::View);
\endcode
since \l{QModelIndex::Type}{View} is the default fourth argument.

Note that, for most models, the horizontal header will be the
same for all items in a column, and the vertical header will be the same
for all items in a row. The model/view architecture is flexible
enough to allow individual headers for each combination of row, column,
and parent supplied. However, many views will not automatically take
advantage of this capability.

Items in a model can perform various \e roles for other components,
allowing different kinds of data to be supplied for different situations.
For example, the \l{QAbstractItemModel::Role}{DisplayRole} role is used
to access a string that can be displayed as text in a view.
Typically, items contain data for a number of different roles. The role
indicates to the model which type of data is being referred to.
We will examine roles in more detail when we
\l{model-view-subclassing-model.html}{create an example model}.

\section2 Summary of concepts

Model indices contain information about the location of items within a
model; they are constructed by models at the request of other components,
such as views and delegates.
Each model index refers to an item at a given row and column, and
is of a particular type that indicates what the item's data is used
for. If a valid parent index is specified when an index is constructed,
the index refers to a child of the corresponding parent item; otherwise
the index refers to a top-level item in the model.

Where the item \l{QModelIndex::Type}{type} distinguishes between items
in a view and the headers, the \l{QAbstractItemModel::Role}{role}
distinguishes between the different kinds of data associated with an
item.


\section1 Using an existing model

One of the models provided by Qt is the \l QDirModel, a model that
maintains information about the contents of a directory. This provides a
ready-to-use model to experiment with, and can be easily set up using
existing data. Using this model, we can show how to set up a model for
use with ready-made views, and explore how to manipulate data using
model indices.

\section2 Using views with a model

The \l QListView and \l QTreeView classes are the most suitable views
to use with QDirModel. The example presented below displays the
contents of a directory in a tree view next to the same information in
a list view. The views share the user's selection so that the selected
items are highlighted in both views.

\img shareddirmodel.png

We will first set up a QDirModel so that it is ready for use, and then
we'll create some views to display the contents of a directory. This
shows the simplest pattern of use of a model. The construction and use
of the model is performed from within a single main() function:

\quotefile shareddirmodel/main.cpp
\skipto int main
\printuntil QDirModel

The model is set up to use data from a default directory, and is given
an arbitrary widget as its parent object. The parent can be any subclass
of QObject. We create two views so that we can examine the items held in
the model:

\printto QItemSelectionModel

The views are constructed in the same way as other widgets. Setting up
a view to display the items in the model is simply a matter of calling its
\l{QAbstractItemView::setModel()}{setModel()} function with the directory
model as the argument.

The rest of the function just displays the views within a splitter
widget, and runs the application's event loop:

\skipto splitter
\printuntil }

In the above example, we neglected to mention how to handle selections
of items. This subject is covered in more detail in the
\l{model-view-selection.html}{handling selections} section.

\section2 Using model indices

To demonstrate how data can be retrieved from a model, using model
indices, we will set up a QDirModel without a view and print out the
names of files and directories to a terminal. We will use the
qDebug() function for this purpose.
Although this does not show a normal way of using a model, it demonstrates
the conventions used by models when dealing with model indices.

We construct a directory model in the same way as before:

\quotefile simplemodel-use/main.cpp
\skipto QDirModel *model
\printuntil int numRows

In this case, we ensure that all files and directories are reported by
the model by setting the file filter, and we count the number of rows
in the model using the \l{QDirModel::rowCount()}{rowCount()} function.

For simplicity, we are only interested in the items in the first column
of the model. We examine each row in turn, obtaining a model index for
the first item in each row, and reading the data stored for that item
in the model.

\skipto for (
\printuntil QModelIndex index

To obtain a model index, we specify the row number, column number (zero
for the first column), the appropriate parent model index for top-level
model items (the default invalid model index), and the type of
information required. We want the \c View type of index
because we need the information that would be displayed in a view,
rather than the information used in a header, (although we could have
omitted the argument since \c View is the default fourth argument).

The text stored in each item is retrieved using the model's
\l{QDirModel::data()}{data()} function. We specify the model index and
the \l{QAbstractItemModel::Role}{DisplayRole} to obtain data for the
item in the form of a string.

\skipto QString text
\printuntil qDebug
\skipto }
\printuntil }

The above example demonstrates the basic principles used to retrieve
data from a model:

\list
\i The dimensions of a model can be found using
   \l{QAbstractItemModel::rowCount()}{rowCount()} and
   \l{QAbstractItemModel::columnCount()}{columnCount()}.
   These functions generally require a parent model index to be
   specified.
\i Model indices are used to access items in the model. The row, column,
   parent model index, and item type are needed to specify the item.
\i To access top-level items in a model, specify an invalid model index
   as the parent index with QModelIndex().
\i Items contain data for different roles. To obtain the data for a
   particular role, both the model index and the role must be supplied
   to the model.
\endlist


\section1 Further reading

New models can be created by implementing the standard interface provided
by QAbstractItemModel. We will demonstrate this by
\l{model-view-subclassing-model.html}{creating a new model}
to provide a convenient ready-to-use model for holding strings.

\l{model-view-programming.html}{[Up]}
\l{model-view-subclassing-model.html}{[Creating New Models]}

*/

/*!
\page model-view-view.html

\title View Classes

\tableofcontents

\section1 Concepts

In the model/view architecture, the view presents data from the model to
the user. The way in which the data is presented can be completely
different from the model's own representation of the data. This
separation of content and presentation is achieved by the use of a
\l{QAbstractItemModel}{standard interface} for the model classes,
an interface provided by the \l QAbstractItemView class, and
the use of model indices that represent model items in a general way.
Views typically manage the overall layout of the model's representation.
They may render individual items themselves, or use
\l{model-view-delegate.html}{delegates} to handle both input and output
capabilities.

As well as presenting data, views handle navigation between items,
and some aspects of item selection. The views also implement basic
user interface features, such as context menus and drag and drop.
A view may provide default editing facilities for items, or it may
work with a \l{model-view-delegate.html}{delegate} to provide a custom
editor.

A view can be constructed without a model, but a model must be
provided before it can display useful information. Views keep track of
the items that the user has selected through the use of
\l{model-view-selection.html}{selections} which can be maintained
separately for each view, or shared between multiple views.

Some views, such as \l QTableView and \l QTreeView, display headers
as well as items. These are also implemented by a view class,
\l QHeaderView. Headers usually access the same model as the view
that displays them. They retrieve a different
\l{QModelIndex::Type}{type} of data to that shown in the rest of
the view, and usually display it in the form of a label. New headers
can be subclassed from the \l QHeaderView class to provide more
specialized labelling for views.

\section1 Using an existing view

Qt provides three ready-to-use view classes that present data from
models in ways that are familiar to most users.
\l QListView displays items from a model in the form of a simple list;
these may be text labels or icons. \l QTreeView displays items from a
model as a hierarchy of lists, allowing deeply nested structures to be
represented in a compact way. \l QTableView presents items from a model
in the form of a table, much like the layout of a spreadsheet
application.

\img standard-views.png

The default behavior of the standard views shown above should be
sufficient for use in most applications. They provide basic editing
facilities, and can be customized to suit the needs of more specialized
user interfaces.

\section2 Using a model 

We will take the \l{model-view-subclassing-model.html}{string list model}
that we created as an example model, set it up with some data, and
construct a view to display the contents of the model. This can all
be performed within a single function:

\quotefile stringlistmodel/main.cpp
\skipto int main
\printuntil QAbstractItemModel

Note that the \c StringListModel is declared as a \l QAbstractItemModel.
This allows us to use the abstract interface to the model, and will
ensure that the code will still work even if we replace the string list
model with a different model in the future.

The list view provided by \l QListView is sufficient for presenting
the items in the string list model. We construct the view, and set up
the model using the following lines of code:

\skipto QListView
\printuntil QListView
\skipto view->setModel
\printuntil view->setModel

The view is shown in the normal way:

\skipto view->show
\printuntil }

The view renders the contents of a model, accessing data via the model's
interfaces. When the user tries to edit an item, the view uses a default
delegate to provide an editor widget.

\img stringlistmodel.png

The above image shows how a \l QListView represents the data in the
string list model. Each item in the list can be edited with the default
delegate.

\section2 Using multiple views onto the same model

Providing multiple views onto the same model is simply a matter of
setting the same model for each view. In the following code, we create
two table views, each using the same simple table model which we have
created for this example:

\quotefile sharedtablemodel/main.cpp
\skipto QTableView *first
\printuntil QTableView *second
\skipto firstTableView->
\printuntil secondTableView->

The use of signals and slots in the model/view architecture means that
changes to the model can be propagated to all the attached views,
ensuring that we can always access the same data regardless of the
view being used.

\img sharedmodel-tableviews.png

The above image shows two different views onto the same model, each
containing a number of selected items. Although the data from the model
is shown consistently across view, each view maintains its own internal
selection model. This can be useful in certain situations but, for
many applications, a shared selection model is desirable.

\section1 Handling selections of items

The mechanism for handling selections of items within views is provided
by the \l QItemSelectionModel class. Each of the standard views construct
their own selection models by default, and will interact with them in the
normal way. The selection model being used by a view can be obtained
through the \l{QAbstractItemView::selectionModel()}{selectionModel()}
function, and a replacement selection model can be specified with
\l{QAbstractItemView::setSelectionModel()}{setSelectionModel()}.
The ability to control the selection model used by a view is useful
when we want to provide multiple consistent views onto the same model
data.

Generally, unless you are subclassing a model or view, you will not
need to manipulate the contents of selections directly. However, the
interface to the selection model can be accessed, if required, and
this is explored in the section on
\l{model-view-selection.html}{handling selections}.

\section2 Sharing selections between views

Although it is convenient that the view classes provide their own
selection models by default, when we use more than one view onto the
same model it is often desirable that both the model's data and the
user's selection are shown consistently in all views.
Since the view classes allow their internal selection models to be
replaced, we can achieve a unified selection between views with the
following line:

\quotefile sharedtablemodel/main.cpp
\skipto secondTableView->setSelectionModel
\printuntil secondTableView->setSelectionModel

The second view is given the selection model for the first view.
Both views now operate on the same selection model, keeping both
the data and the selected items synchronized.

\img sharedselection-tableviews.png

In the example shown above, two views of the same type were used to
display the same model's data. However, if two different types of view
were used, the selected items may be represented very differently in
each view; for example, a contiguous selection in a table view may be
represented as a fragmented set of highlighted items in a tree view.

\l{model-view-subclassing-model.html}{[Creating New Models]}
\l{model-view-programming.html}{[Up]}
\l{model-view-selection.html}{[Handling Selections]}

*/

/*!
\page model-view-delegate.html

\title Delegate Classes

\tableofcontents

\section1 Concepts

Unlike the Model-View-Controller pattern, the model/view design does not
include a completely separate component for managing interaction with
the user. Generally, the view is responsible for the presentation of
model data to the user, and for processing user input. To allow some
flexibility in the way this input is obtained, the interaction is
performed by delegates. These components provide input capabilities
and are also responsible for rendering individual items in some views.
The standard interface for controlling delegates is defined in the
\l QAbstractItemDelegate class.

Delegates are expected to be able to render their contents themselves
by implementing the \l{QAbstractItemDelegate::paint()}{paint()}
and \l{QAbstractItemDelegate::sizeHint()}{sizeHint()} functions.
However, simple widget-based delegates can subclass \l QItemDelegate
instead of \l QAbstractItemDelegate, and take advantage of the default
implementations of those functions.
Editors for delegates can be implemented in two ways, either by using
widgets to manage the editing process, or by handling events directly.
The first approach is covered later in this section.


\section1 Using an existing delegate

The standard views provided with Qt use instances of \l QItemDelegate
to provide editing facilities. This default implementation of the
delegate interface renders items in the usual style for each of the
standard views: \l QListView, \l QTableView, and \l QTreeView.
The delegate being used for a view is returned by the
\l{QAbstractItemView::itemDelegate()}{itemDelegate()} function.
The \l{QAbstractItemView::setItemDelegate()}{setItemDelegate()} function
allows you to install a custom delegate for a standard view, and it is
necessary to use this function when setting the delegate for a custom
view.


\section1 A simple delegate

The delegate implemented here uses a \l QSpinBox to provide editing
facilities, and is mainly intended for use with models that display
integers. Although we set up a custom integer-based table model for
this purpose, the way that data in the model is accessed would also
allow a string-based model to be used with only minor inconvenience
when editing. We also construct a table view so that we can manipulate
the model's data.

\img spinbox-delegate.png

We subclass the delegate from \l QItemDelegate because we do not want
to write custom display functions. However, we must still provide
functions to manage the editor widget:

\quotefile spinbox-delegate/delegate.h
\skipto class SpinBoxDelegate
\printuntil };

Note that no editor widgets are set up when the delegate is
constructed. We will construct an editor widget when it is needed.

\section2 The editor type

The \c editorType() function returns a value describing the
\l{QAbstractItemDelegate::EditorType}{type of editor} that the delegate
provides. This delegate only supports widget-based editing, so the
implementation of this function is very simple:

\quotefile spinbox-delegate/delegate.cpp
\skipto QItemDelegate::EditorType
\printuntil }

The default implementation of this function informs the view that it
provides an event-based editor. Therefore, you must reimplement this
function if you want to provide a widget-based editor.

\section2 Providing an editor

In this example, when the table view needs to provide an editor, it
asks the delegate to provide an editor widget that is appropriate
for the item being modified. The
\l{QAbstractItemDelegate::editor()}{editor()} function is supplied
with everything that the delegate needs to be able to set up a
suitable widget.

\skipto QWidget *SpinBoxDelegate::editor
\printuntil return 0;
\printuntil }

We provide basic editing features with a spin box, checking only that
we are allowed to provide an editor, and ignoring the differences
between the actions defined by
\l{QAbstractItemDelegate::BeginEditAction}{BeginEditAction}. The view
will ensure that we set up the editor's data and geometry correctly by
calling functions that we define later for this purpose. Clearly we
can create different editors depending on say, the model index, for
example if we have a column of integers and a column of strings we
could return a \c QSpinBox or a \c QLineEdit depending on which column
the item to be edited is in.

The delegate must provide a function to copy model data into the
editor. In this example, we read the data stored in the
\l{QAbstractItemModel::Role}{display role}, and set the value in the
spin box accordingly.

\skipto void SpinBoxDelegate::setEditorData
\printuntil }

In this example, we know that the editor widget is a spin box, but we
could have provided different editors for different types of data in
the model, in which case we'd need to determine the type used and cast
accordingly.

\section2 Submitting data to the model

When the user has finished editing the value in the spin box, the view
informs the delegate through the
\l{QAbstractItemDelegate::releaseEditor()}{releaseEditor()} function
whether the edited value was
\l{QAbstractItemDelegate::EndEditAction}{accepted or cancelled}.

\quotefile spinbox-delegate/delegate.cpp
\skipto void SpinBoxDelegate::releaseEditor
\printuntil }

If the value was accepted then we use
\l{QAbstractItemDelegate::setModelData()}{setModelData()}
(implemented below) to write the value to the model. If the editing
operation was cancelled, the value is ignored.
The way we handle the editor widget is the same for both cases: we
destroy it. A new editor widget will be created by the delegate the
next time the view requires one.

Data supplied by the editor is written to the model by the following
function. In this example, an integer value is read from the spin box,
and written to the model using the index specified:

\skipto void SpinBoxDelegate::setModelData
\printuntil int value
\skipto model->setData
\printuntil }

All the operations on data are performed through the interface
provided by \l QAbstractItemModel. This makes the delegate mostly
independent from the type of data it manipulates, but some
assumptions must be made in order to use certain types of
editor widgets. In this example, we have assumed that the model
will always contain integer values, but we can still use this
delegate with different kinds of models because \l{QVariant} will
provide sensible default values for unexpected data.

\section2 Updating the editor's geometry

It is the responsibility of the delegate to manage the editor's
geometry. The geometry must be set when the editor is created, and
when the item's size or position in the view is changed. Fortunately,
the view provides all the necessary geometry information inside a
\l{QStyleOptionViewItem}{view option} object.

\skipto void SpinBoxDelegate::updateEditorGeometry
\printuntil }

In this case, we just use the geometry information provided by the
view option in the item rectangle. A delegate that renders items with
several elements would not use the item rectangle directly. It would
position the editor in relation to the other elements in the item.

\section2 Comments

The way the delegate provides editor widgets in this example is
quite simple: they are constructed on demand, and deleted when no
longer needed. A more sophisticated approach might be used to
provide user-friendly editing features, such as a record of
previously submitted values.

\l{model-view-selection.html}{[Handling Selections]}
\l{model-view-programming.html}{[Up]}

*/

/*!
\page model-view-selection.html

\title Handling Selections

\tableofcontents

\section1 Concepts

The selection model used in the new item view classes offers many
improvements over the selection model used in Qt 3. It provides a
more general description of selections based on the facilities of
the model/view architecture. Although the standard classes for
manipulating selections are sufficient for the item views provided,
the selection model allows you to create specialized selection models
to suit the requirements for your own item models and views.

Information about the items selected in a view is stored in an instance
of the \l QItemSelectionModel class. This maintains model indices for
items in a single model, and is independent of any views. Since there
can be many views onto a model, it is possible to share selections
between views, allowing applications to show multiple views in a
consistent way.

Selections are made up of \e{selection ranges}. These efficiently
maintain information about large selections of items by recording
only the starting and ending model indices for each range of selected
items. Non-contiguous selections of items are constructed by using
more than one selection range to describe the selection.

Selections are applied to a collection of model indices held by
a selection model. The most recent selection of items applied is
known as the \e{current selection}. The effects of this selection can
be modified even after its application through the use of certain
types of selection commands. These are discussed later in this
section.

When manipulating selections, it is often helpful to think of
\l QItemSelectionModel as a record of the selection state of all the
items in an item model. Once a selection model is set up, collections
of items can be selected, deselected, or their selection states can
be toggled without the need to know which items are already selected.
The indices of all selected items can be retrieved at any time, and
other components can be informed of changes to the selection model
via the signals and slots mechanism.


\section1 Using a selection model

The standard view classes provide default selection models that can
be used in most applications. A selection model belonging to one view
can be obtained using the view's
\l{QAbstractItemView::selectionModel()}{selectionModel()} function,
and shared between many views with
\l{QAbstractItemView::setSelectionModel()}{setSelectionModel()},
so the construction of new selection models is generally not required.
\omit
If a new selection model is required then it is only necessary to
construct 
\endomit

A selection is created by specifying a model, and a pair of model
indices to a \l QItemSelection. This uses the indices to refer to items
in the given model, and interprets them as the top-left and bottom-right
items in a block of selected items.
To apply the selection to items in a model requires the selection to be
submitted to a selection model; this may be achieved in a number of ways,
each having a different effect on the selections already present in the
selection model.


\section2 Selecting items

To demonstrate some of the principal features of selections, we construct
an instance of a custom table model with 32 items in total, and open a
table view onto its data:

\quotefile itemselection/main.cpp
\skipto TableModel
\printuntil QItemSelectionModel

The table view's default selection model is retrieved for later use.
We will not modify any items in the model, but instead select a few
items that the view will display at the top-left of the table. To do
this, we need to retrieve the model indices corresponding to the
top-left and bottom-right items in the region to be selected:

\skipto QModelIndex topLeft
\printuntil bottomRight = model->index

To select these items in the model, and see the corresponding change
in the table view, we need to construct a selection object then apply
it to the selection model. We must also specify the model that the
indices belong to because the model indices do not contain this
information:

\skipto QItemSelection
\printuntil selectionModel->select

The selection is applied to the selection model using a command
defined by a combination of
\l{QItemSelectionModel::SelectionFlag}{selection flags}.
In this case, the flags used cause the items recorded in the
selection object to be included in the selection model, regardless
of their previous state. The resulting selection is shown by the view.

\img selected-items1.png

The selection of items can be modified using various operations that
are defined by the selection flags. The selection that results from
these operations may have a complex structure, but will be represented
efficiently by the selection model. The use of different selection
flags to manipulate the selected items is described in the section on
\l{model-view-selection-commands.html}{selection commands}.

\section2 Reading the selection state

The model indices stored in the selection model can be read using
the \l{QItemSelectionModel::selectedItems()}{selectedItems()}
function. This returns an unsorted list of model indices that we can
iterate over as long as we know which model they are for:

\quotefile reading-selections/window.cpp
\skipto QModelIndexList indices
\printuntil }

The above code uses Qt's convenient \l{containers.html}{foreach
keyword} to iterate over, and modify, the items corresponding to the
indices returned by the selection model.

The selection model emits signals to indicate changes in the
selection. These notify other components about changes to both the
selection as a whole and the currently focused item in the item
model. We can connect the
\l{QItemSelectionModel::selectionChanged()}{selectionChanged()}
signal to a slot, and examine the items in the model that are selected or
deselected when the selection changes. The slot is called with two
\l{QItemSelection}s: one contains a list of indices that correspond
to newly selected items; the other contains indices that correspond
to newly deselected items.

In the following code, we provide a slot that receives the
\l{QItemSelectionModel::selectionChanged()}{selectionChanged()}
signal, fills in the selected items with
a string, and clears the contents of the deselected items.

\quotefile updating-selections/window.cpp
\skipto void MainWindow::updateSelection
\printuntil model->setData
\printuntil }

We can keep track of the currently focused item by connecting the
\l{QItemSelectionModel::currentChanged()}{currentChanged()} signal
to a slot that is called with two model indices. These correspond to
the previously focused item, and the currently focused item.

In the following code, we provide a slot that receives the
\l{QItemSelectionModel::currentChanged()}{currentChanged()} signal,
and uses the information provided to update the status bar of a
\l QMainWindow:

\skipto void MainWindow::changeCurrent
\printuntil }

Monitoring selections made by the user is straightforward with these
signals, but we can also update the selection model directly.

\section2 Updating a selection

Selection commands are provided by a combination of selection flags,
defined by \l{QItemSelectionModel::SelectionFlag}.
Each selection flag tells the selection model how to update its
internal record of selected items when either of the
\l{QItemSelection::select()}{select()} functions are called.
The most commonly used flag is the
\l{QItemSelectionModel::SelectionFlag}{Select} flag
which instructs the selection model to record the specified items as
being selected. The
\l{QItemSelectionModel::SelectionFlag}{Toggle} flag causes the
selection model to invert the state of the specified items,
selecting any deselected items given, and deselecting any currently
selected items. The \l{QItemSelectionModel::SelectionFlag}{Deselect}
flag deselects all the specified items.

Individual items in the selection model are updated by creating a
selection of items, and applying them to the selection model. In the
following code, we apply a second selection of items to the table
model shown above, using the
\l{QItemSelectionModel::SelectionFlag}{Toggle} command to invert the
selection state of the items given.

\quotefile itemselection/main.cpp
\skipto QItemSelection toggle
\printuntil selectionModel->select

The results of this operation are displayed in the table view,
providing a convenient way of visualizing what we have achieved:

\img selected-items2.png

By default, the selection commands only operate on the individual
items specified by the model indices. However, the flag used to
describe the selection command can be combined with additional flags
to change entire rows and columns. For example if you call
\l{QItemSelectionModel::select()}{select()} with only one index, but
with a command that is a combination of
\l{QItemSelectionModel::SelectionFlag}{Select} and
\l{QItemSelectionModel::SelectionFlag}{Rows}, the
entire row containing the item referred to will be selected.
The following code demonstrates the use of the
\l{QItemSelectionModel::SelectionFlag}{Rows} and 
\l{QItemSelectionModel::SelectionFlag}{Columns} flags:

\skipto QItemSelection columnSelection
\printuntil QItemSelectionModel::Select | QItemSelectionModel::Rows

Although only four indices are supplied to the selection model, the
use of the 
\l{QItemSelectionModel::SelectionFlag}{Columns} and
\l{QItemSelectionModel::SelectionFlag}{Rows} selection flags means
that two columns and two rows are selected. The following image shows
the result of these two selections:

\img selected-items3.png

The commands performed on the example model have all involved
accumulating a selection of items in the model. It is also possible
to clear the selection, or to replace the current selection with
a new one.

To replace the current selection with a new selection, combine
the other selection flags with the
\l{QItemSelectionModel::SelectionFlag}{Current} flag. A command using
this flag instructs the selection model to replace its current collection
of model indices with those specified in a call to
\l{QItemSelectionModel::select()}{select()}.
To clear all selections before you start adding new ones,
combine the other selection flags with the
\l{QItemSelectionModel::SelectionFlag}{Clear} flag. This will
have the effect of resetting the selection model's collection of model
indices.

\l{model-view-view.html}{[View Classes]}
\l{model-view-programming.html}{[Up]}
\l{model-view-delegate.html}{[Delegate Classes]}

*/

/*!
    \page model-view-subclassing-model.html

    \title Creating New Models

    \tableofcontents

    \section1 Introduction

    The separation of functionality between the components in the model/view
    architecture enables new models to be written that can take advantage
    of existing views. This approach lets us manage data from a variety of
    sources, and present it using a standard graphical user interface.
    The interface provided by the \l QAbstractItemModel class supports
    models that arrange their data in hierarchical structures, allowing for
    the possibility that data will be inserted, removed, changed, or sorted
    in some way. It also provides support for drag and drop operations.

    In this section, we will create a simple read-only model to explore
    the basic principles of the model/view architecture. This model will
    later be adapted so that items can be modified with an editor.


    \section1 A read-only example model

    The model implemented here is a simple, non-hierarchical, read-only data
    model. It has a \l QStringList as its internal data source, and
    implements only what is needed to make a functioning model. To make the
    implementation easier, we subclass \l QAbstractListModel because it
    defines sensible default behavior for list models, and it exposes a
    simpler interface than the \l QAbstractItemModel class.

    When implementing a model it is important to remember that
    \l QAbstractItemModel does not store any data itself, it merely
    presents an interface that the views use to access the data.
    For a minimal read-only model it is only necessary to implement a few
    functions as there are default implementations for most of the
    interface. The class declaration is as follows:

    \quotefile stringlistmodel/model.h

    \skipto class
    \printto isEditable
    \skipto private
    \printuntil }

    Apart from the model's constructor, we only need to implement two
    functions: \l{QAbstractItemModel::rowCount()}{rowCount()} returns the
    number of rows in the model, and \l{QAbstractItemModel::data()}{data()}
    returns an item of data corresponding to a specified model index.

    Note that this is a non-hierarchical model, so we don't have to worry
    about the parent-child relationships. If our model was hierarchical, we
    would also have to implement the
    \l{QAbstractItemModel::index()}{index()} and
    \l{QAbstractItemModel::parent()}{parent()} functions.

    \section2 Dimensions of the model

    We want the number of rows in the model to be the same as the number of
    strings in the string list. We implement the
    \l{QAbstractItemModel::rowCount()}{rowCount()} function with this in
    mind:

    \quotefile stringlistmodel/model.cpp
    \skipto int StringListModel
    \printuntil }

    Since the model is non-hierarchical, we can safely ignore the model index
    corresponding to the parent item. By default, models derived from
    \l QAbstractListModel only contain one column, so we do not need to
    reimplement the \l{QAbstractItemModel::columnCount()}{columnCount()}
    function.

    \section2 Model data

    The \l{QAbstractItemModel::data()}{data()} function is responsible for
    returning the data that corresponds to the index argument. There are
    three types of indices: \l{QModelIndex::Type}{View},
    \l{QModelIndex::Type}{HorizontalHeader}, and
    \l{QModelIndex::Type}{VerticalHeader}. If our model
    is displayed in a view with headers, we want the headers to show the
    row and column numbers. For \l{QModelIndex::Type}{View} items,
    we want to return the strings in our string list:

    \skipto QVariant
    \printuntil }

    An item can have several roles, giving out different data depending on the
    role specified. The items in our model only have one role,
    \l{QAbstractItemModel::Role}{DisplayRole}, so we will return the data
    for items irrespective of the role specified.
    However, we could reuse the data we provide for the
    \l{QAbstractItemModel::Role}{DisplayRole} in
    other roles, such as the
    \l{QAbstractItemModel::Role}{ToolTipRole} that views can use to
    display information about items in a tooltip.

    \section1 An editable model

    The read-only model shows how simple choices could be presented to the
    user but, for many applications, an editable list model is much more
    useful. We can modify the read-only model to make the items editable
    by implementing two extra functions:
    \l{QAbstractItemModel::isEditable()}{isEditable()} and
    \l{QAbstractItemModel::setData()}{setData()}.
    These are added to the class declaration:

    \quotefile stringlistmodel/model.h
    \skipto bool isEditable
    \printuntil setData

    \section2 Making the model editable

    A delegate will check whether an item is editable before creating an
    editor. The model must let the delegate know that its items are
    editable:

    \quotefile stringlistmodel/model.cpp
    \skipto bool StringListModel::isEditable
    \printuntil }

    Note that we do not have to know how the delegate will perform the actual
    editing process. We only have to provide a way for the delegate to set the
    data in the model. This is achieved through the
    \l{QAbstractItemModel::setData()}{setData()} function:

    \quotefile stringlistmodel/model.cpp
    \skipto bool StringListModel::setData
    \printuntil }
    \printuntil }

    In this model, the item in the string list that corresponds to the model
    index specified is replaced by the data provided by the delegate.
    However, before we actally set the data in the model, we make sure that
    the index is valid, the item is of the correct type, and that the role is
    supported. We insist that the role must be the
    \l{QAbstractItemModel::Role}{EditRole} since this indicates to us that
    the item is being modified by an editing operation. The underlying data
    in this model is the same for all roles, so this detail just makes it
    easier to integrate the model with other standard components.

    When the data has been set, the model must let the views know that the
    data in the model has changed. This is done by emitting the
    \l{QAbstractItemModel::dataChanged()}{dataChanged()} signal. Since
    only one item has changed, the range of items specified in the signal
    is limited to just one item.

    \section2 Inserting and removing rows

    It is possible to change the number of rows and columns in a model. In the
    string list model it only makes sense to change the number of rows, so we
    will reimplement the functions for inserting and removing rows. These are
    declared in the class definition:

    \quotefile stringlistmodel/model.h
    \skipto bool insertRows
    \printuntil bool removeRows

    We implement a function to allow rows to be inserted into the model:

    \quotefile stringlistmodel/model.cpp
    \skipto bool StringListModel::insertRows
    \printuntil return true
    \printuntil }

    Since rows in this model correspond to strings in a list, this function
    inserts a number of empty strings into the list before the given position.
    The number of strings is equivalent to the number of rows specified.
    The parent index is normally used to determine which table of items in
    the model is being referred to. In this case, we only have a single
    top-level list of string, so we just insert empty strings into that list.
    We could check the parent index to see whether it corresponds to an item
    in the list, and return false to indicate failure.

    The model emits the \l{QAbstractItemModel::rowsInserted()}{rowsInserted()}
    signal to inform other components that the number of rows has changed,
    specifying the first and last rows that were inserted.
    Note that the signal is always emitted after the rows are inserted,
    allowing other components to immediately access the new rows.

    The function to remove rows from the model is also simple to write:

    \quotefile stringlistmodel/model.cpp
    \skipto bool StringListModel::removeRows
    \printuntil return true
    \printuntil }

    The rows to be removed from the model are specified by the position and
    the number of rows given. 
    We ignore the parent index to simplify our implementation, and just
    remove the corresponding items from the string list.
    The \l{QAbstractItemModel::rowsRemoved()}{rowsRemoved()} signal is
    always emitted before the rows are removed, specifying the first and
    last rows to be removed. This is to allow other components to access the
    data before it is removed.

    \section1 Next steps

    We can display the contents of this model using the \l QListView class
    to present the model's items in the form of a vertical list. For the
    string list model, this view also provides a default editor so that
    the items can be manipulated. We examine the possibilities made
    available by the standard view classes in the
    \l{model-view-view.html}{introduction to the view classes}.

    \l{model-view-model.html}{[Model Classes]}
    \l{model-view-programming.html}{[Up]}
    \l{model-view-view.html}{[View Classes]}
*/
