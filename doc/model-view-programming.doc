/*!
\page model-view-programming.html

\title Model/View Programming

\tableofcontents

\section1 Introduction

Qt 4 introduces a new set of item view classes that use a Model/View
architecture to manage the relationship between raw data and the way it
is presented to the user. The separation of functionality this
architecture introduces gives developers greater flexibility and
access to more features than was previously possible. 
In this document, we give a brief introduction to the Model/View paradigm,
outline the concepts involved, and describe the architecture of the item
view. Each of the components in the architecture is explained, and
examples are given that show how to use the classes provided.

\section1 The Model/View architecture

Model-View-Controller (MVC) is a design pattern originating from
Smalltalk that is often used when building user interfaces.
In \l{model-view-programming.html#Gamma}{Design Patterns}, Gamma et al.
write:

\quote
MVC consists of three kinds of objects. The Model is the application
object, the View is its screen presentation, and the Controller defines
the way the user interface reacts to user input. Before MVC, user
interface designs tended to lump these objects together. MVC decouples
them to increase flexibility and reuse.
\endquote

If the view and the controller objects are combined, the result is
the Model/View architecture. This still separates the data in the
model from its presentation to the user, but provides a simpler
framework based on the same principles. This separation makes it
possible to display data from the same model in several different
views, and to implement new types of views, without changing the
underlying model.
To allow flexible handling of user input, we introduce the concept of
the \e delegate. The advantage of using a delegate is that it allows
input methods to be defined in addition to those provided by the view,
but does not introduce additional complexity by default.

Generally, the Model/View classes can be separated into the three groups
described above: models, views, and delegates. Each of these components
are defined by \e abstract classes that provide common interfaces and,
in some cases, default implementations of features.
Abstract classes are meant to be subclassed in order to provide the full
set of functionality expected by other components; this also allows
specialized components to be written.
For example, all item models are based on the \l QAbstractItemModel
class. This class can be used to provide models to views that represent
data in the form of tables and lists. However, the \l QAbstractListModel
and \l QAbstractTableModel classes are better starting points for new list
and table models because they provide default implementations of common
functions. Each of these classes could be subclassed to provide models
that support specialized kinds of lists and tables.

Complete implementations are provided for different kinds of
view widgets based on the \l QAbstractItemView class. \l QListView
provides a complete implementation of a simple list widget,
\l QTableView displays items from a model in a tabular form, and
\l QTreeView shows model items as a hierarchical list. Although
these classes are ready-to-use implementations, they can also be
subclassed to provide customized views.

A number of \e convenience classes are derived from the generic view
classes for the benefit of applications that rely on Qt's item-based
item view and table classes. They are not intended to be subclassed,
but simply exist to provide a familiar interface to the equivalent classes
in Qt 3.
Examples of these include the \l QTreeView and \l QTableView convenience
classes; these offer compatibility with the \c QListView and \c QTable
classes from Qt 3.


\section1 The Model/View components

The following sections describe the way in which the Model/View pattern
is used in Qt. Each section provides an example of use, and is followed
by a section showing how you can create new components.

\list
\i \l{model-view-model.html}{Model Classes}
\i \l{model-view-view.html}{View Classes}
\i \l{model-view-delegate.html}{Delegate Classes}
\endlist


\section1 References

\target Gamma
\l{http://www.amazon.com/exec/obidos/ASIN/0201633612/103-8144203-3273444}
{Design Patterns - Elements of Reusable Object-Oriented Software},
by Gamma, Helm, Johnson, and Vlissides, ISBN 0-201-63361-2, provides
more information on the MVC paradigm, explaining MVC and its
sub-patterns in detail.

See also \link model-view.html the Model/View classes\endlink

*/

/*!
\page model-view-architecture.html

\title Architecture Overview


For example, the following diagram shows the relationship between the Model/View
classes that can be used to display a directory structure in a tree view.
In this scheme, we could use the \c QTreeView to display the contents
of a \c QDirModel, or possibly populate a \c QTreeView with items from the model.

\img treeview-hierarchy.png

\section1 The Model


\section2 QAbstractItemModel

The QAbstractItemModel is an interface for accessing and storing data in the
model. It also provides functions for changing the dimensions of the model, and
give notice to the views about changes.

The interface operates with the concept of the data as a hierarchy of tables.
Each cell in a table is referred to as an 'item'. Each item can have a table of
children.

Each item can contain several data elements that have been assigned 'roles'.
The defined roles in QAbstractItemModel are: \c Display, \c Decoration, \c Edit,
\c ToolTip, \c StatusTip, and \c WhatsThis. Typically, the \c Display value is
used to render the main item text, the \c Decoration value is used to render the
item icon and the \c Edit value is used when editing the item.
If no data is returned for a specific role, it will not be shown. Subclasses of
QAbstractItemModel may also define additional roles.

Note that these concepts do not require the model to store the data in any
particular way, as long as it can be accessed using the QAbstractItemModel
interface.

\section2 QModelIndex

A QModelIndex is an index to an item in the model. In a two dimensional model
(a table), it is sufficient to know the row and column of the item, but in a
hierarchy it is neccessary to store additional information to know where the
item is. QModelIndex encapsulates this information along with the row and column
of the item. The model index is used by the model, the views, the delegate, and
the selections to refer to items in the model.

Since any change to the model may invalidate the QModelIndex, it should never be
stored.

\section2 QPersistentModelIndex

Sometimes it is neccessary to store indexes to items. In these cases, the
QPersistentModelIndex should be used. The persistent model index will be updated
by the model if it changes in a way that will affect the model index.

The trade-off for using persistent model indexes is that it adds to the overhead in the
model, both in terms of memory usage and processing.

Also note that the persistent indexes may still be invalidated by the model. The
difference is that the QPersistentModelIndex will be set to invalid, where a QModelIndex
will report that it is still valid because it has not been updated by the model.

\section1 The Views


\section2 QAbstractItemView

This is the super class for all itemviews. It implements navigation, selecting and dragging
and dropping of items.

\section2 QListView

This view shows the model as a one dimensional list of items. This means that it only shows
one column of one table. The items can be layed out top-to-bottom or left-to-right, with or
without wrapping the layout.

\section2 QTableView

This view renders the model as a two dimensional table of items. It shows one table in the model.

\section2 QTreeView

This view shows the model as a tree of rows. It shows the hieararchy in the first column in the model.

\section1 The Delegate

The item delegate is used by the view to handle rendering and editing of the items. The delegate typically uses the roles to get data for the different elements in an item (eg. text and pixmap).

\section2 QAbstractItemDelegate

The QAbstractItemDelegate provides a baseclass for implementing different delegates. It has default implementations for the editing functions, but subclasses must implement the painting and size hint functions.

\section2 QItemDelegate

The QItemDelegate is the default delegate used by the views. This delegate will render the Display role as text, and the Decoration role as a pixmap.

\section1 Selections

All selections in the item views are stored as ranges. A range is defined by a top left and a bottom right position. Anything contained within this range is then selected.

\section2 QItemSelectionModel

QListView, QTreeView and QTableView all have a QItemSelectionModel. The selection model is responsible for storing a views selection, and its current item. Whenever these change the selection model sends out selectionChanged and currentChanged signals.

The QItemSelectionModel is always connected to a model. This means that the top left and bottom right positions the each range consist of are QModelIndexes. Any view sharing the same model can then also share the same selection model as well.

### more on the selection model





\section1 Comparison with the Qt 3 Itemview Classes.

\section1 Architecture

The two main differences between the new itemview classes and the old views are the separation
between data and presentation, and the views now have a common baseclass.

\section2 The Model-View Architecture

The separation between data and presentation means that data is no longer duplicated.
This saves memory and saves startup-time because the views nolonger have to be initialized
with the data.
...

\section2 The New Class Hierarchy

The new common baseclass means that the views now share a lot of code that was previously
duplicated.
...

\section1 New Features

In addition to the Model-View architecture and the shared code, the new itemview classes have
several new features.
...

\section1 More

### How does the new architecture help the user ?

*/

/*!
\page model-view-model.html

\title Model Classes

\tableofcontents

\section1 Basic concepts

In the Model/View architecture, the model's purpose is to manage data,
and to provide a standard representation of that data to the other
components in the framework. In Qt, the standard interface to item models
is defined by the \l QAbstractItemModel class. This class presents the
model to other components in the form of a table, regardless of how the
data is actually stored. It also notifies any attached views of changes
to the model through the signals and slots mechanism.

This section describes some basic concepts that
are central to the way models are accessed by other components. More
advanced concepts are discussed later.

\section2 Model indices

To ensure that representation of the data in the model
is kept separate from the way it is accessed, the concept of a
\e{model index} is introduced. Each item of data is represented by a
model index that is provided by the model when required.
As a result, only the model needs to know how items are stored, and the
type of data managed by the model can be defined fairly generally.

Model indices provide \e temporary references to items, and can be used
to retrieve or modify their data. Since models may reorganize their
internal structures from time to time, model indices may become invalid,
and should not be stored. If a long-term reference to a model item is
required, a \e{persistent model index} must be created. This provides a
reference to the item that the model keeps up-to-date.

To obtain a model index for a given item in a model, four properties must
be specified: a row number, a column number, the index of a parent item,
and an item type. The following subsections describe and explain these
properties in detail.

\section2 Rows and columns

In its most basic form, an item model can be accessed as a simple table
in which items are located by their row and column numbers. 
We can retrieve information about any given item by specifying its row
and column numbers to the model, and we will receive an index that
represents the item. We can ask the model for the item's data by passing
it the model index corresponding to the item.

\img modelindex-no-parent.png

The diagram above shows a representation of a basic model in which each
item is located by a pair of row and column numbers. 
The highlighted item is represented by a model index that was obtained by
specifying the relevant row and column numbers to the model. 

\section2 Parents of items

A simple tabular model would be ideal for representing items in a table,
or as a list of items. However, structures such as tree views require a
more flexible interface to the items in the model. As a result, each item
can also be used as the parent of another table of items, in much the same
way that a top-level item in a tree view can contain another list of
items.

When requesting an index for a model item, we must provide some
information about the item's parent. Outside the model, the only way to
refer to an item is through a model index, so a parent model index must
be given. However, in the diagram shown above, the highlighted item did
not have a parent model index to refer to. This is also the case for
top-level items in any model. To ensure the model knows that we are
referring to a top-level item, we specify a default (and invalid)
model index; this is a convention used by the Model/View classes.

\img modelindex-parent.png

The diagram above shows the row numbers, column numbers, and parent
indices for two items in the model: a top-level model item (marked with
an 'I'), and one of its children. The parent of the highlighted child
item is represented by the 'X' symbol because it is referred to by its
model index ('X').

\section2 Item types and roles

Model indices are available in three different types: some indices refer
to items shown in a view, some refer to items used as horizontal headers,
and the rest refer to items used as vertical headers.
By specifying different types, we only retrieve the kind of information
that we need.
Usually, we want to refer to the data that will be displayed in a view,
so we specify the \l{QModelIndex::Type}{View} type when obtaining the
index.
If we specify the \l{QModelIndex::Type}{HorizontalHeader} or
\l{QModelIndex::Type}{VerticalHeader} types, the model can return an
index corresponding to a horizontal or vertical header.

\img modelindex-types.png

When we obtain a model index, we specify to the model the type of item
we are interested in. The above diagram shows how different types of
model indices correspond to items in the model.
Note that, for most models, the horizontal header will be the
same for all items in a column, and the vertical header will be the same
for all items in a row. The Model/View architecture is flexible
enough to allow individual headers for each combination of row, column,
and parent supplied. However, many views will not automatically take
advantage of this capability.

Items in a model can perform various \e roles for other components,
allowing different kinds of data to be supplied for different situations.
For example, the \l{QAbstractItemModel::Role}{DisplayRole} role is used
to access a string that can be displayed as text in a view.
Typically, items contain data for a number of different roles. The role
indicates to the model which kind of data is being referred to.
We will examine roles in more detail when we
\l{model-view-subclassing-model.html}{create an example model}.

\omit
For example, a model designed for a simple spreadsheet might
return an index that refers to the column header, regardless of the
vertical position (the row) of the item within the model.

Each item of data stored in the model can
be accessed by providing the model with the corresponding model index.

 * Describe the above structure better.
 * Talk about types and roles.
\endomit

\section2 Summary of concepts

Model indices contain information about the location of items within a
model; they are constructed by models at the request of other components.
Each model index refers to an item at a given row and column, and
is assigned a particular type indicating what the item's data is used
for. If a valid parent index is specified when an index is constructed,
the index refers to a child of the corresponding parent item; otherwise
the index refers to a top-level item in the model.

Where the item type distinguishes between items in a view and the
headers, the role distinguishes between the different types of data
associated with an item.


\section1 Using an existing model

One of the models provided by Qt is the QDirModel, a model that maintains
information about the contents of a directory. This provides a
ready-to-use model to experiment with, and can be easily set up with
existing data. Using this model, we can show how to set up a model for
use with ready-made views, and explore how to manipulate data using
model indices.

\section2 Using views with a model

The QListView and QTreeView classes are the most suitable view to use with
QDirModel. The example presented below displays the contents of a
directory in a tree view next to the same information in a list view.
The views share the user's selection so that the selected items are
highlighted in both views.

\img shareddirmodel.png

We will first set up a QDirModel so that it is ready for use then create
some views to display the contents of a directory. This shows the simplest
pattern of use of a model. The construction and use of the model is
performed from within a single \c main() function:

\quotefile shareddirmodel/main.cpp
\skipto int main
\printuntil QDirModel

The model is set up to use data from a default directory, and is given
an arbitrary widget as its parent object. The parent can be any subclass
of QObject. We create two views so that we can examine the items held in
the model:

\printto QItemSelectionModel

The views are constructed in the same way as other widgets. Setting up
a view to display the items in the model is simply a matter of calling its
\l{QAbstractItemView::setModel()}{setModel()} function with the directory
model as the argument.

The rest of the function just displays the views within a splitter
widget, and runs the application's event loop:

\skipto splitter
\printuntil }

In the above example, we neglected to mention how to handle selections of
items. This subject is covered in more detail in the section of this
document that deals with
\l{model-view-selection.html}{handling selections}.

\section2 Using model indices

To demonstrate how data can be retrieved from a model, using model
indices, we will set up a QDirModel without a view and print out the
names of files and directories to a terminal. We will use the
\c qDebug() function for this purpose.
Although this does not show a normal way of using a model, it demonstrates
the conventions used by models when dealing with QModelIndex instances.

We construct a directory model in the same way as before:

\quotefile simplemodel-use/main.cpp
\skipto QDirModel *model
\printuntil int numRows

In this case, we ensure that all files and directories are reported by
the model, and we count the number of rows in the model using the
\l{QDirModel::rowCount()}{rowCount()} function.

For simplicity, we are only interested in the items in the first column
of the model. We examine each row in turn, obtaining a model index for
the first item in each row, and reading the data stored for that item
in the model.

\skipto for (
\printuntil QModelIndex index

To obtain a model index, we specify the row number, column number (zero
for the first column), the appropriate parent model index for top-level
model items (the default invalid model index), and the type of
information required. The type of index we want is the \c View type
because we need the information that would be displayed in a view,
rather than the information used in a header.

The text stored in each item is retrieved using the model's
\l{QDirModel::data()}{data()} function. We specify the model index and
the \l{QAbstractItemModel::Role}{DisplayRole} to obtain data for the
item in the form of a string.

\skipto QString text
\printuntil qDebug
\skipto }
\printuntil }

The above example demonstrates the basic principles used to retrieve
data from a model:

\list
\i The dimensions of a model can be found using the
   \l{QAbstractItemModel::rowCount()}{rowCount()} and
   \l{QAbstractItemModel::columnCount()}{columnCount()} functions.
\i Model indices are used to access items in the model. The row, column,
   parent model index, and item type are needed to specify the item.
\i To access top-level items in a model, specify an invalid model index
   as the parent index.
\i Items contain data for different roles. To obtain the data for a
   particular role, both the model index and the role must be supplied
   to the model.
\endlist


\section1 Further reading

New models can be created by implementing the standard interface provided
by QAbstractItemModel. This is demonstrated in the
\l{model-view-subclassing-model.html}{following section}.

*/

/*!
\page model-view-view.html

\title Views

\tableofcontents

\section1 Concepts

In the Model/View architecture, the view presents data from the model to
the user. The way in which the data is presented can be completely
different from the model's own representation of the data. This
separation of content and presentation is achieved by the use of a
\l{QAbstractItemModel}{standard interface} for the model classes,
an interface provided by the \l QAbstractItemView class, and
the use of model indices that represent model items in a general way.

As well as presenting data, views handle navigation between items,
and some aspects of item selection. The views also implement basic
user interface features, such as context menus and drag and drop.
A view may provide default editing facilities for items, or it may
work with a \l{model-view-delegate.html}{delegate} to provide a custom
editor.

A view may be constructed without a model to use, but a model must be
provided before it can display useful information. Views keep track of
the items that the user has selected through the use of
\l{model-view-selection.html}{selections} which can be maintained for
a single view, or shared between many views.

Some views, such as \l QTableView and \l QTreeView, display headers
as well as items. These are also implemented by a view class,
\l QHeaderView. Headers usually share the same model with the view
that they are displayed in. They retrieve a different
\l{QModelIndex::Type}{type} of data to that shown in the rest of
the view, and usually display it in the form of a label. New headers
can be subclassed from the \l QHeaderView class to provide more
specialized labelling for views.

\omit
Views depend on models for the data that they present to the user, but
models themselves can be used as standalone components in an
application. One result of this is that we must specify the model to
the view, and not the view to 
\endomit

\section2 Using an existing view

Qt provides three ready-to-use view classes that present data from
models in ways that are familiar to most users.
\l QListView displays items from a model in the form of a simple list;
these may be text labels or icons. \l QTreeView displays items from a
model as a hierarchy of lists, allowing deeply nested structures to be
represented in a compact way. \l QTableView presents items from a model
in the form of a table, much like the layout of a spreadsheet
application.

\img standard-views.png

The default behavior of the standard views shown above should be
sufficient for use in most applications. They provide basic editing
facilities, and can be customized to suit the needs of more specialized
user interfaces.

\section3 Using a model 

We will take the \l{model-view-subclassing-model.html}{string list model}
that we created as an example model, set it up with some data, and
construct a view to display the contents of the model. This can all
be performed within a single function:

\quotefile stringlistmodel/main.cpp
\skipto int main
\printuntil QAbstractItemModel

The list view provided by \l QListView is sufficient for presenting
the items in the string list model. We construct the view, and set up
the model using the following lines of code:

\skipto QAbstractItemView
\printuntil QAbstractItemView
\skipto view->setModel
\printuntil view->setModel

The view is shown in the normal way:

\skipto view->show
\printuntil }

The view renders the contents of a model, accessing data via the model's
interfaces. When the user tries to edit an item, the view uses a default
delegate to provide an editor widget.

\img stringlistmodel.png

The above image shows how a \l QListView represents the data in the
string list model. Each item in the list can be edited with the default
delegate.

\section3 Using multiple views onto the same model

Providing multiple views onto the same model is simply a matter of
setting the same model for each view. In the following code, we create
two table views, each using the same simple table model:

\quotefile sharedtablemodel/main.cpp
\skipto QTableView *first
\printuntil QTableView *second
\skipto firstTableView->
\printuntil secondTableView->

The use of signals and slots in the Model/View architecture means that
changes to the model can be propagated to all the attached views,
ensuring that we can always access the same data regardless of the
view being used.

\img sharedmodel-tableviews.png

The above image shows two different views onto the same model, each
containing a number of selected items. Although the data from the model
is shown consistently across view, each view maintains its own internal
selection model. This can be useful in certain situations but, for
many applications, a shared selection model is desirable.

\section2 Handling selections of items

The mechanism for handling selections of items within views is provided
by the \l QItemSelectionModel class. Each of the standard views construct
their own selection models by default, and will interact with them in the
normal way. The selection model being used by a view can be obtained
through the \l{QAbstractItemView::selectionModel()}{selectionModel()}
function, and a replacement selection model can be specified with
\l{QAbstractItemView::setSelectionModel()}{setSelectionModel()}.
The ability to control the selection model used by a view is useful
when we want to provide multiple consistent views onto the same model
data.

Generally, unless you are subclassing a model or view, you will not
need to manipulate the contents of selections directly. However, the
interface to the selection model can be accessed, if required, and
this is explored in the section on
\l{model-view-selection.html}{handling selections}.

\section2 Sharing selections between views

Although it is convenient that the view classes provide their own
selection models by default, when we use more than one view onto the
same model it is often desirable that both the model's data and the
user's selection are shown consistently in all views.
Since the view classes allow their internal selection models to be
replaced, we can achieve a unified selection between views with the
following line:

\quotefile sharedtablemodel/main.cpp
\skipto secondTableView->setSelectionModel
\printuntil secondTableView->setSelectionModel

The second view is given the selection model for the first view.
Both views now operate on the same selection model, keeping both
the data and the selected items synchronized.

\img sharedselection-tableviews.png

In the example shown above, two views of the same type were used to
display the same model's data. However, if two different types of view
were used, the selected items may be represented very differently in
each view; for example, a contiguous selection in a table view may be
represented as a fragmented set of highlighted items in a tree view.


*/

/*!
\page model-view-delegate.html

\title Delegates

\section1 Concepts

The controller translates interactions with the view into actions to be
performed by the model. This is handled in Qt mostly by
QAbstractItemDelegate, but some user interaction (like item navigation
and selections) is handled by the view and supporting classes.


\section1 Rendering and editing items

\quotefile delegate01.cpp

The item delegate is responsible for drawing and editing items.

It is possible to customize item rendering, editing, internal layout, and size
hint by implementing a custom delegate. To implement a delegate with customized
rendering, we have to implement the following functions:

\skipto void paint
\printto };

\section2 Customized Rendering

\skipto GradientDelegate::paint
\printuntil }

This delegate only renders the Display role as text, with a gradient color
background. In more advanced delegates the items can be rendered using several
different roles, and these roles can have different layouts.

\section2 Size Hint

\skipto GradientDelegate::sizeHint
\printuntil }

Since the delegate is responsible for rendering the item, it also knows the size
of the item. In this delegate, the size hint is the size of the Display text.

\section1 Implementing a Non-Widget Editor
\quotefile delegate02.cpp

The default editor type for delegates is the non-widget editor. This means that
the input events are handled in the item delegate.
Note that the QAbstractItemDelegate inherits QObject, and can receive events just
like any other QObject.

\skipto GradientDelegate::event
\printuntil }

The editor will alternate the string between "On" and "Off", when the item is
clicked. To do this, it has to handle the mouse press event. All other events are
ignored.

\section1 Using a Widget Editor
\quotefile delegate03.cpp

It is also possible to edit the items using a QWidget based editor. This demands
a bit more work because the widget needs to be created, updated, and deleted.

\section2 The Editor Type

The delegate has to tell the view what type of editor it supports.

\skipto GradientDelegate::editorType
\printuntil }

The default implementation of this function returns Events. This delegate reports
that it's editor is a widget.

\section2 Creating And Deleting The Editor

\skipto GradientDelegate::editor
\printto GradientDelegate::releaseEditor

This delegate creates a QComboBox editor. Possible values in the editor are "On"
or "Off".
When the editing is done, the view will call releaseEditor on the editor.

\skipto GradientDelegate::releaseEditor
\printuntil }

This implementation simply deletes the widget. Since the delegate is responsible
for both creating and deleting editors, it is possible to keep a pool of editor
widgets and just return the widget to the pool when it is released.

\section2 Setting the Data in the Editor

When the editor is created or when the edited item is changed outside the editor,
it may be necessary to read the data from the model and set it in the editor.

\skipto GradientDelegate::setEditorData
\printuntil }

In this implementation, the value is read from the model and then the correct
current item is set in the QComboBox editor. Note that we read the Edit data from
the model. In some cases the Display value may be generated on the fly, based on
the Edit data (e.g. the Edit data can be a mathematical expression).

\section2 Setting the Data in the Model

When the editing is done, the delegate is responsible for setting the data in the
model.

\skipto GradientDelegate::setModelData
\printuntil }

This implementation simply gets the current text from the QComboBox and set the
data in the model.

\section2 Updating the Editor Geometry

It is the responsibility of the delegate to manage the editor geometry. The
geometry needs to be set when the editor is created, and when the item size or
position is changed. Item geometry can change for a number of reasons, among them
is that the view was scrolled.

\skipto GradientDelegate::updateEditorGeometry
\printuntil }

This implementation simply sets the editor geometry to be the item rectangle.
A delegate that renders items with several elements would not use the item
rectangle directly. It would position the editor in relation to the other
elements in the item.

*/

/*!
\page model-view-selection.html

\title Handling Selections

\section1 Concepts

The selection model used in the new item view classes offers many
improvements over the selection model used in Qt 3. It provides a
more general description of selections based on the facilities of
the Model/View architecture. Although the standard classes for
manipulating selections are sufficient for the item views provided,
the selection model allows you to create specialized selection models
to suit the requirements for your own models and views.

Information about the items selected in a view is stored in an instance
of the \l QItemSelectionModel class. This maintains model indices for
items in a single model, and is independent of any views. Since there
can be many views onto a model, it is possible to share selections
between views, allowing applications to show multiple views in a
consistent way.

Selections are made up of \e{selection ranges}. These efficiently
maintain information about large selections of items by recording
only the starting and ending model indices for each range of selected
items. Non-contiguous selections of items are constructed by using
more than one selection range to describe the selection.


\section1 Setting up a selection model

The standard view classes provide default selection models that can
be used in most applications. A selection model belonging to one view
can be shared between many views, so the construction of new selection
models is generally not required.



\section1 Creating a selection

A selection is created by specifying a model, and a pair of model
indices to a \l QItemSelection. This utility class treats the indices
as the top-left and bottom-right locations of items in the given model
and records them for later use. To apply the selection to items in a
model requires the selection to be submitted to a selection model;
this may be achieved in a number of ways, each having a different
effect on the selections already present in the selection model.

To demonstrate some of the principal features of selections, we create
a table model with 64 items in total, and open a table view onto its
data:

\quotefile itemselection/main.cpp
\skipto int main
\printuntil QItemSelectionModel

The table view's default selection model is retrieved for later use.
We will not modify any items in the model, but instead select a few
items that the view displays in the centre of the table. To do this,
we need to retrieve a model index corresponding to the top-left of
the region to be selected:

\skipto QModelIndex topLeft
\printuntil QModelIndex topLeft

We have chosen an item close to the centre of the table. An index
corresponding to the bottom-right item is retrieved in the same way:

\skipto QModelIndex bottomRight
\printuntil QModelIndex bottomRight

To select these items in the model, and see the corresponding change
in the table view, we need to construct a selection object, and apply
it to the selection model. We also have to specify the model that the
indices belong to since the model indices do not contain this
information:

\skipto QItemSelection
\printuntil selectionModel->select

The selection is applied to the selection model using a
\l{QItemSelectionModel::SelectionFlag}{selection flag} that selects the
items in the selection model regardless of their previous state. The
resulting selection is shown by the view in the following way:

\img selected-items1.png


\section2 Updating a selection

QItemSelectionModel provides these slots for setting and updating a
selection:

\quotefile gui/itemviews/qitemselectionmodel.h
\skipto virtual void select
\printto signals

The two \c select slots set or update the selection on a model
depending on the \c SelectionFlags. clear() completely clears any
selections in the selection model and sets the current item to an
invalid index.

The first select function takes a QModelIndex as a parameter, so it
only works on one item. The second select function takes a
QItemSelection as a parameter, and works on a list of selections.

\section2 SelectionFlags

The \c SelectionFlags tells the selection model how to update the
selections when you call either of the selection functions. The most
commonly used flag is the Select flag as it basically tells the
selection model that the specified items should be selected. Then you
have Toggle, which will select any unselected items and deselect any
currently selected ones. And finally Deselect which will deselect all
the specified items.

The selection model also takes some additional flags like Rows and
Columns which tells it to expand the specified items to either all
rows or all columns. For example if you call select with only one
index but with Select|Rows the whole row this index resides in will be
selected.

Whenever you do a selection call on the selection model it compresses
all previous selection operations and adds the new one on top of
these. If you want to modify the most recently added selected items
(ie. you want to continuously update your rubber band selection) you
can specify the Current flag. The Current flag tells the selection
model to not add a new selection on top of all the others, but to
replace the current one with the one you specified.

If you want to clear all selections before you start adding new ones
you can specify the Clear flag, so for example specifying Clear|Select
you will first clear all selections and then select the specified
items.

The selection model can be compared to a small binary calculator where
the SelectionFlags are the commands that can be performed and where
the end result is selected/deselected items. Using this analogy Clear
totally resets the calculator. Select, Toggle and Deselect are the
binary operations that can be performed. Current tells how the result
should be accumulated and Rows and Columns tells what the result
should apply to.

\section2 Updating the current item

QItemSelectionModel only provides one slot for updating the current
item:

\quotefile gui/itemviews/qitemselectionmodel.h
\skipto setCurrentItem
\printto virtual void select

This slot can also update selections depending on the SelectionFlags
specified.

\section1 QItemSelection

The QItemSelection class is basically a QList or selection ranges,
QItemSelectionRange, with some convenience functions added. Whenever
we operate on selections for more then one item in the selection
model use QItemSelections to store them.

The QItemSelectionModel expects, and returns, QItemSelections where
none of the ranges overlap.

\section1 QItemSelectionRange

A QItemSelectionRange consist of a top left and a bottom right
QModelIndex and the parent to these indexes. This means a
QItemSelectionRange can not span over levels, the top left and bottom
right index must share the same parent.

\section1 SelectionMode and SelectionBehavior

QItemSelectionModel is a small class with a clearly defined feature
set, like QRect or similar utility classes. The usage of a selection
model, how the user selects different items, and how the selection is
presented to the user are left to the implementation of the view.

Whenever a view updates a selection model it does so by specifying
what items are involved and what SelectionFlags to use. In
QAbstractItemView the function selectionCommand(...) returns the
SelectionFlags to be used based on user interactions, and this
function is always used when updating the selection model. This means
the by overriding the virtual selectionCommand(...) function one can
alter the selection behavior to get your own special selection mode.

In our item views we have three standard selection modes: Single,
Multi and Extended. Single selection mode will only let the user select
one item. Multi will let the user select multiple items but with basic
interactions and Extended will let the user select multiple items but
with advanced interactions like Toggle and split multiple selections.

In addition to the selection modes the item views also support three
selection behaviors which describes how selections affect items, rows
and columns. The default behavior is for selections to work only on
items: SelectItems, but if you specify either SelectRows or
SelectColumns the selections will work not on singular items but
always on rows or columns respectively.

Both the selection modes and the selection behaviors are completely
expressed by their implementation in the selectionCommand(...) 
function and the resulting SelectionFlags they return.

*/

/*!
    \page model-view-subclassing-model.html

    \title Creating New Models

    \tableofcontents

    \section1 Introduction

    The separation of functionality between the components in the Model/View
    architecture enables new models to be written that can take advantage
    of existing views. This approach lets us manage data from a variety of
    sources, and present it using a standard graphical user interface.
    The interface provided by the \l QAbstractItemModel class supports
    models that arrange their data in hierarchical structures, allowing for
    the possibility that data will be inserted, removed, changed, or sorted
    in some way. It also provides support for drag and drop operations.

    In this section, we will create a simple read-only model to explore
    the basic principles of the Model/View architecture. This model will
    later be adapted so that items can be modified with an editor.


    \section1 A read-only example model

    When implementing a model it is important to remember that the
    \l QAbstractItemModel class does not store any data itself, it merely
    presents an interface that the views use to access the data.
    For a minimal read-only model it is only necessary to implement a few
    functions as there are default implementations for most of the
    interface.

    \quotefile stringlistmodel/model.h

    The model implemented here is a simple, non-hierarchical, read-only data
    model. It has a \l QStringList as its internal data source, and implements
    only what is needed for a functional model. To make the implementation
    easier, we subclass \l QAbstractListModel because it provides default
    behavior for list models, and it exposes a simpler interface than the
    \l QAbstractItemModel class.

    \skipto class
    \printto isEditable
    \skipto private
    \printuntil }

    Apart from the constructor of the model, we need to implement only two
    functions: \c rowCount() returns the number of rows in the model, and
    \c data() returns data corresponding to model item indices.

    Note that this is a non-hierarchical model, so we don't have to worry
    about the parent-child relationships. If our model was hierarchical, we
    would also have to implement the \c index() and \c parent() functions.

    \section2 Dimensions of the model

    We want the number of rows in the model to be the same as the number of
    strings in the string list. We implement the \c rowCount() function with
    this in mind:

    \quotefile stringlistmodel/model.cpp
    \skipto int StringListModel
    \printuntil }

    Since the model is non-hierarchical, we can safely ignore the model index
    corresponding to the parent item. By default, models derived from
    \l QAbstractListModel only contain one column, so we do not need to
    reimplement the \c columnCount() function.

    \section2 Model data

    The \c data() function is responsible for returning the data that
    corresponds to the index argument. There are three types of indices:
    \c View, \c HorizontalHeader, and \c VerticalHeader. If our model is
    displayed in a view with headers, we want the headers to show the row and
    column numbers. For \c View items, we want to return the strings in our
    string list.

    \skipto QVariant
    \printuntil }

    An item can have several roles, giving out different data depending on the
    role specified. The items in our model only have one role, \c DisplayRole,
    so we will return the data for items irrespective of the role specified.
    However, we could reuse the data we provide for the \c DisplayRole in
    other roles, such as the \c ToolTipRole that views can use to display
    information about items in a tooltip.

    \section1 An editable model

    The read-only model showed how simple choices could be presented to the
    user but, for many applications, an editable list model is much more
    useful. We can modify the read-only model to make the items editable
    by implementing two extra functions: \c isEditable() and \c setData().
    These are declared in the header file:

    \quotefile stringlistmodel/model.h
    \skipto bool isEditable
    \printuntil setData

    \section2 Making the model editable

    A delegate will check whether an item is editable before creating an
    editor. The model has to let the delegate know that its items are
    editable:

    \quotefile stringlistmodel/model.cpp
    \skipto bool StringListModel::isEditable
    \printuntil }

    Note that we do not have to know how the delegate will perform the actual
    editing process. We only have to provide a way for the delegate to set the
    data in the model. This is achieved through the \c setData() function:

    \quotefile stringlistmodel/model.cpp
    \skipto bool StringListModel::setData
    \printuntil }

    In this model, the item in the string list that corresponds to the model
    index specified is replaced by the data provided by the delegate.
    However, before we actally set the data in the model, we make sure that
    the index is valid, the item is of the correct type, and that the role is
    supported. We insist that the role must be the \c EditRole since this
    indicates to us that the item is being modified by an editing operation.

    When the data has been set, the model has to let the views know that the
    data in the model has changed. This is done by emitting the
    \c dataChanged() signal. Since only one item has changed, the range of
    items specified in the signal is limited to just one item.

    \section2 Inserting and removing rows

    It is possible to change the number of rows and columns in a model. In the
    string list model it only makes sense to change the number of rows, so we
    will reimplement the functions for inserting and removing rows. These are
    declared in the class definition:

    \quotefile stringlistmodel/model.h
    \skipto bool insertRows
    \printuntil bool removeRows

    We implement a function to allow rows to be inserted into the model:

    \quotefile stringlistmodel/model.cpp
    \skipto bool StringListModel::insertRows
    \printuntil return true
    \printuntil }

    Since rows in this model correspond to strings in a list, this function
    inserts a number of empty strings into the list before the given position.
    The number of strings is equivalent to the number of rows specified.
    The parent index is normally used to determine which table of items in
    the model is being referred to. In this case, we only have a single
    top-level list of string, so we just insert empty strings into that list.
    We could check the parent index to see whether it corresponds to an item
    in the list, and return false to indicate failure.

    The model emits the \l{QAbstractItemModel::rowsInserted()}{rowsInserted()}
    signal to inform other components that the number of rows has changed,
    specifying the first and last rows that were inserted.
    Note that the signal is always emitted after the rows are inserted,
    allowing other components to immediately access the new rows.

    The function to remove rows from the model is also simple to write:

    \quotefile stringlistmodel/model.cpp
    \skipto bool StringListModel::removeRows
    \printuntil return true
    \printuntil }

    The rows to be removed from the model are specified by the position and
    the number of rows given. 
    We ignore the parent index to simplify our implementation, and just
    remove the corresponding items from the string list.
    The \l{QAbstractItemModel::rowsRemoved()}{rowsRemoved()} signal is
    always emitted before the rows are removed, specifying the first and
    last rows to be removed. This is to allow other components to access the
    data before it is removed.

    \section1 Next steps

    We can display the contents of this model using the \l QListView class
    to present the model's items in the form of a vertical list. For the
    string list model, this view also provides a default editor so that
    the items can be manipulated. We examine the possibilities made
    available by the standard view classes in the introduction to the
    view classes.

*/

/*!
    \page model-view-subclassing-view.html
*/

/*!
    \page model-view-subclassing-delegate.html
*/
