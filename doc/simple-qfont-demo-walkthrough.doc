/*
$Id$
*/

/*! \page simple-qfont-demo-walkthrough.html

\ingroup walkthroughs

\title Walkthrough: A simple QFont demonstration

The following \link simple-font-demo-example.html example \endlink
shows how to make use of the font setting and manipulation techniques  
provided by QFont.

In addition it shows some aspects of widget layout -- if you prefer leaving
this job to Qt Designer simply skip the relevant paragraphs. Moreover, if you
have asked yourself how to add strings to a QStringList and how to
step through its members, you will know after reading this walkthrough.

To get most out of the example you should at least be familiar with
\link signalsandslots.html signals and slots. \endlink

The example program consists of a main window split into two \l{QTextView}s.
The one to the left shows greetings in English, Russian, and Hebrew.
To the right we reveal some information about the fonts used to
draw these greetings. Three push buttons in the bottom of the main window
change the font used to display the greetings.

Note that the fonts and font characteristics in the example have been choosen
for demonstration purposes only -- in a real life application they
would rather count for bad design. 

<h3><a name="viewer.h">The API of the main window</a></h3>

The main window used in this example is an object of a custom class named
\e Viewer.

\walkthrough fonts/simple-qfont-demo/viewer.h
\skipto include
\printline qwidget
\printline qfont

As we derive it from QWidget we include the relevant header file.
Additionally we use a QFont object as a function argument, and
therefore include the QFont API.

\printline QTextView
\printline QPushButton

Furthermore we declare the use of the QTextView and the
QPushButton classes for class variables (we don't need to
include them at this stage yet because we only use pointers to these classes).

\printline Viewer
\printuntil Q_OBJECT

The \e Viewer class will have slots, so don't forget to add the
\e Q_OBJECT macro.

\printuntil Viewer()

As we won't use more than one object of this class 
there is no need for complex constructors, a simple one without
any arguments should be sufficient.

\printuntil setDefault

As previously mentioned we're going to have three push buttons. When the user
clicks on them, something should happen. Thus we define 
\link #setDefault() one slot that
sets the font in the greeting window back to the default, \endlink ...

\printline setSansSerif

... \link #setSansSerif() one that switches to a sans serif font, \endlink
and ...

\printline setItalics

... \link #setItalics() one that shows the greetings in italics.\endlink

\printuntil setFontSubstitutions

The greetings we write use different alphabets. For users who don't
have Unicode fonts installed we want to tell the application to try
to exchange missing characters in one font with appropriate characters
from other fonts. QFont does such font substitutions on its own but
with \link #setFontSubstitutions() this helper function \endlink
we define our preferred substitution pattern.

\printline layout

The task of putting the buttons and text views together we source out into 
a separate \link #layout() layout() \endlink function. 
Not only it makes the code cleaner -- you can simply 
skip this bit if you usually create your layouts with Qt Designer.

\printline showFontInfo

\link #showFontInfo() The last private function \endlink reveals 
font information in the text view to the right.

\printline textView
\printuntil italicsButton
\printline };

Last but not least we define the elements of our GUI as private
class variables.



<h3><a name="viewer.cpp">The main window implemented</a></h3>

Now let's implement the \e Viewer class.

\walkthrough fonts/simple-qfont-demo/viewer.cpp
\skipto include
\printuntil qlayout

First we include the relevant header files -- obviously the 
\link #viewer.h API of the Viewer class \endlink itself,
of the QPushButton and QTextView widgets, and of the QString
and QStringList helper classes. \e qlayout.h provides
classes for horizontal and vertical layout and will be used
in the \link #layout() layout() \endlink function.

<a name="Viewer()"></a>

\printline Viewer()
\printuntil {

As already mentioned the finger print of the \e Viewer constructor
is as simple as possible, without any arguments, derived from
the QWidget default constructor.

\printline setFontSubstitutions

First we define the font substitutions -- for clarity reasons we
do this in a \link #setFontSubstitutions() separate function.\endlink

\printline greeting_heb
\printline greeting_ru

The Hebrew and the Russian greeting we have readily available as UTF8 encoded
strings.
To use them in a QString we "import" them with QString::fromUtf8(). 

\printline greeting_en

Much less trouble we have with the English greeting... 

\printline textView

Now we create the first widget as a child of \e this main window, 
the QTextView with the identity string \e textview that shows the greetings. 

\printline setText
\printuntil greeting_heb

Now we merge the three greetings with line breaks in between and make
them the text to be shown by \e textView.

\printline fontInfo

The second text view to the right we call \e fontinfo and create
it as a child of \e this \e Viewer object.

\printline setDefault

Using the \link #setDefault() setDefault() \endlink function we
apply the initial font to the \e textView greetings and 
fill the \e{textView}er window with information about  
the used font.

\printline defaultButton
\printline pushbutton1

Now we create the first of the three push buttons -- the one
that leads back to the initial fonts -- with the label \e Default.

\printline times

The label should be printed in a member font of the Times family.
In the unlikely case that the user does not have installed a
matching font, QFont is responsible to find a replacement.
Note that case-sensitivity is no issue when specifying the font family.

As we don't explicitly request a font size or weight, QFont tries to
find a default 12 pt font with normal boldness. 

\printline connect
\printline setDefault

In order to make something happening when the user clicks the
\e defaultButton, we connect the QPushButton::clicked() signals
issued from it to the \e{Viewer}'s \link #setDefault() setDefault() \endlink
function.

\printline sansSerifButton
\printuntil Helvetica 

The newly created second button is labelled \e{Sans Serif}
in a 12 pt Helvetica font. Again: if this is not possible because
the requested font is not available on the system, QFont deals
with it and finds a replacement.

\printline connect
\printline setSansSerif

The clicked() signal of the \e sansSerifButton we connect
to the \link #setSansSerif() setSansSerif() \endlink slot.

\printline italicsButton
\printuntil QFont::Bold

\e italicsButton, the last push button, is labelled \e{Italics}.
This time we specify even more characteristics of the
label font: We wish it to be a 12 pt bold member of the Lucida family.
Furthermore it should be italic, indicated by the fourth QFont argument
being TRUE.

\printline connect
\printline setItalics

Again, the \e{italicsButton}'s clicked() signal is connected to
a slot of \e this \e Viewer object: \link #setItalics() setItalics().\endlink

\printline layout
\printline }

Finally we arrange all five child widgets of \e this main window
nicely using \link #layout() layout(). \endlink

<a name="setDefault()"></a>

\printline Viewer::setDefault
\printuntil font

For demonstration purposes on how the QFont substitution works
we use a phantasy font family, Bavaria, as the default font for
the greetings.

\printline 24

This font should have a size of 24 points, ...

\printline Bold

... it should be bold, ...

\printline TRUE

... and the text written with it should be underlined.

\printline textView

Now we ask the \e textView widget to use this \e font.

As a member of the Bavaria font family is unlikely to
be installed on your machine, run the program and observe
how QFont finds a substitute. Note that we define
custom substitutions for Bavaria in \link #setFontSubstitutions()
setFontSubstitutions(). \endlink

\printline showFontInfo
\printline }

Finally we use the custom function \link #showFontInfo()
showFontInfo() \endlink to display appropriate information
about the fonts used and required for drawing the greetings.


<a name="setSansSerif()"></a>

\printline Viewer::setSansSerif
\printuntil Newyork

The slot to change the greeting font to sans serif
works quite similar to \link #setDefault() setDefault(). \endlink
Here we save a line of code and define the (phantasy) font family (NewYork)
and size (18 points) at once.

\printline font.setStyleHint

We use a style hint to ask QFont for a sans serif font
(\e SansSerif is a member of the QFont::StyleHint enumeration). 

As a member of the NewYork family is quite unlikely to be installed
on your computer, QFont will try to follow the style hint and the font size
and use these information to find a replacement font.

\printline setFont

Finally we apply the requested font to the content of the
\e textView window ...

\printline showFontInfo
\printline }

... and display the appropriate font information. 


<a name="setItalics()"></a>

\printline Viewer::setItalics
\printuntil Tokyo
\printline 32
\printline Bold
\printline TRUE

The \link #setItalics() setItalics() \endlink slot changes the greetings'
font to a 32 pt bold and italic member of the (again phantasy)
Tokyo family. Note that \link #setFontSubstitutions()
setFontSubstitutions() \endlink defines a substitution family for Tokyo. 

\printline setFont

We ask \e textView to deploy \e font, and ...

\printline showFontInfo( font ); 
\printline }

... again display the appropriate font information.


<a name="showFontInfo()"></a>

\printline Viewer::showFontInfo
\printline {

Now, how do we do this?

\printline info

First we obtain information about the font that is actually used 
when \e font is required, and store it in \e info.

\printline messageText
\printuntil font.family

Then we start compiling the message we wish to show to the world:
first we print out the \e requested font family. As we want to
frame the family name with quotation marks, we have to escape the \e "
character so that it is not confused with the C++ quotation marks
used to terminate strings.

\printline font.pointSize

We obtain the \e requested font size in points and convert it to
a QString using QString::number(). With \e &lt;BR&gt; we add a rich-text
linebreak to the \e messageText string.

\printline used

After we have displayed information about the \e required font
we want to contrast it with the \e actually used one.
This is stored in the QFontInfo \e info variable. 

\printline info.family()

First we display the font family, ...

\printuntil info.pointSize()

... and then we add the actual font size, converted to a QString,  
to the message string. The unit abbreviation and a rich-text
paragraph (\e{&lt;P&gt;}) follow.

If custom substitutions are available for the requested \e font,
we're going to disclose them as well:

\printline substitutions

First we store the entire list of substitutes in a string list.

\printline substitutions.isEmpty

If it contains at least one substitute ...

\printuntil font.family

... we say so in the \e messageText, ...

\printline QStringList::Iterator

... and prepare ourselves to step through the list. For this
purpose we set the list iterator \e i to the first list member
of the \e substitutions string list.

\printline substitutions.end

As long as we haven't reached the last list member ...

\printline (* i) 

we add a bullet list entry (\e{&lt;LI&gt;})
of the current list member (i.e. the font family name
of the substitute), ...

\printuntil }

... and move the iterator one step further.
<a name="setFontSubstitutions()"></a>

\printline </UL>

Finally we add the end-of-bullet-list rich-text tag to the \e messageText.

\printuntil font.family
\printline }

If the substitution list was empty, we instead make a note about
it in the \e messageText.

\printuntil }

Now that we have the \e messageText ready we enter it into
the \e fontInfo QTextView.


\printline setFontSubstitutions()  
\printline {

With this function we finally reveal the secret of how to
define custom substitutions for a font family.

\printline QStringList

All we need is a string list.

\printline substitutes.append 
\printuntil <<

In a real life program you will probably stick to one of the above
methods to add strings to a string list. Here all possible ones are outlined
to give you an overview. 

After these append operations \e substitutes consists of four members:
\e{Times}, \e{Mincho}, \e{Arabic Newspaper}, and \e{Crox} in this
order. These are the font families that in the first place are searched 
for characters the base font does not provide.

\printline Bavaria

In \e Viewer objects, these four families provide a fallback
for the Bavaria font family requested by the \link #setDefault()
setDefault() \endlink slot.

\printline QFont::insertSubstitution
\printline }

For the Tokyo family used in \link #setItalics() setItalics() \endlink
we provide only one substitute family, Lucida. Because it is
only one and not many as for Bavaria, we use 
QFont::insertSubstitution() instead of QFont::insertSubstitutions().

If you usually create your GUIs using Qt Designer this walkthrough
has already come to an end. If this is one of your first encounters
with Qt you might however continue with the explanation
of the -- very simple -- \link #simple-qfont-demo.cpp main() program. \endlink


<a name="layout()"></a>

\skipto layout()   
\printline Viewer::layout
\printline {

This last member function of the \e Viewer class does not cover
any more QFont details. All it does is creating a nice automatic
layout for the three push buttons and the two text views.

The best solution for this task is to have the two \l{QTextView}s
lined up horizontally. The same applies to the \l{QPushButton}s.
Finally both of these layouts are placed together in a vertical
layout container. Qt takes care of the proportions so that everything
looks harmoniously.

\printline QHBoxLayout

Let's create a first container that aligns its members horizontally, ...

\printline textView

... and add the QTextView with the greetings, ...

\printline fontInfo

... as well as the text view with the font information. \e fontInfo appears
to the left of \e textView because it was added later.

\printline buttonContainer

Now we create the second container for the push buttons.

\printline defaultButton

\e defaultButton is placed on the left hand site of the container, ...

\printline sansSerifButton

... \e sansSerifButton in the middle, ...

\printline italicsButton

... and \e italicsButton on the right hand site.

Unfortunately we face a tiny problem: remember that -- a highly unusual
thing to do in a real life application -- the labels of the three
buttons are drawn in different fonts. Whilst the automatic layout
cares for that all three buttons have the same width, the uncommon
occurence of different character heights leads to different button heights.

To make the application window look nice we have to help it a little.

\printline maxButtonHeight
\printuntil = italicsButton->height()

By comparing the three button heights we find the largest one
and store it in \e maxButtonHeight.

\printline setFixedHeight
\printuntil italicsButton-

Now we set the height of each button to this maximum value and make sure
that the automatic layout does not change it.  

This was the hardest part of the entire layout process. There is one task
left:

\printline container

We create a container that arranges its members vertically.

\printline textViewContainer

This \e container contains the text views on top, ...

\printline buttonContainer

... and the button row below.

\printline resize
\printline }

Finally we set the size of the entire main window to a width of 700 points
and a height of 250 points.


<h3><a name="simple-qfont-demo.cpp">The main program</a></h3>

The main program is not much to say about.

\walkthrough fonts/simple-qfont-demo/simple-qfont-demo.cpp
\skipto include
\printline include
\printuntil textViewer

We create an object of the \link #viewer.cpp Viewer \endlink
class, ...

\printline MainWidget

... make it the main widget of the application object \e app, ...

\printline show

... display it to the user ...

\printline exec
\printline }

... and enter the application loop.


*/
