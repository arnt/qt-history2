/****************************************************************************
** $Id: //depot/qt/main/doc/sql.doc#1 $
**
** Documentation for sql programming
**
** Copyright (C) 1992-2000 Trolltech AS.  All rights reserved.
**
** This file is part of the Qt GUI Toolkit.
**
** This file may be distributed under the terms of the Q Public License
** as defined by Trolltech AS of Norway and appearing in the file
** LICENSE.QPL included in the packaging of this file.
**
** This file may be distributed and/or modified under the terms of the
** GNU General Public License version 2 as published by the Free Software
** Foundation and appearing in the file LICENSE.GPL included in the
** packaging of this file.
**
** Licensees holding valid Qt Enterprise Edition or Qt Professional Edition
** licenses may use this file in accordance with the Qt Commercial License
** Agreement provided with the Software.
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
**   information about Qt Commercial License Agreements.
** See http://www.trolltech.com/qpl/ for QPL licensing information.
** See http://www.trolltech.com/gpl/ for GPL licensing information.
**
** Contact info@trolltech.com if any conditions of this licensing are
** not clear to you.
**
**********************************************************************/

/*! \page sql.html

\title Qt SQL Module

The Qt SQL module provides classes to access SQL databases in a
uniform way across different platforms and across different SQL
database servers.  There are several sets of classes which handle
database connections, SQL queries and results, SQL database objects
such as tables, views, fields and indexes, and classes which help
display data from SQL databases in GUI classes such as QLineEdit,
QComboBox, etc.

Connections to SQL database servers at a low level are handled by the
QSqlDriver and QSqlResult abstract classes.  These classes provide an
interface for database-specific derived classes to implement the
actual connections to specific SQL servers.  All low-level interaction
with the SQL servers is handled by these drivers.

At a higher level, QSqlQuery and QSqlCursor provide funcitonality to
send SQL queries (INSERT, UPDATE, DELETE, etc.) to a database and to
return results (i.e., data) from those queries.  QSqlField, QSqlRecord
and QSqlIndex are helper classes which represent SQL fields, records
and indexes respectively.

QSqlTable and QSqlForm display data from SQL databases.  There are
also helper classes such as QSqlPropertyMap and QSqlEditorFactory
which help 'glue' together the GUI to the SQL database in your
applications.

<h2>Connecting to the database</h2>

Connections to SQL databases are encapsulated by the QSqlDatabase
class.  QSqlDatabase can establish a connection to a single database
using a QSqlDriver appropriate for that database.  There are also
QSqlDatabase static functions which manage connections to multiple SQL
databases using application-specific names.

To establish a single connection to a SQL database, use the
QSqlDatabase::addDatabase() function.  If a database is added without
a name, it becomes the application 'default' database connection.  The
default connection is used by other Qt SQL classes in the event a
database connection is not provided to them.  A database connection
can be retrieved by passing the database name to
QSqlDatabase::database().  If no name is given, the default connection
is returned.  For example:

\code
    // create an ODBC connection, which is the default database connection
    // for the application
    QSqlDatabase* defaultConnection = QSqlDatabase::addDatabase( "QODBC" );
    if ( defaultConnection ) {
        defaultConnection->setDatabaseName( "sales" );
        defaultConnection->setUserName( "Dave" );
        defaultConnection->setPassword( "dolphin" );
        defaultConnection->setHostName( "saleshost" );
        ...
    }
\endcode

At least one QSqlDatabase must be created and opened in order to use
the other Qt SQL classes, since those classes communicate to the
database through QSqlDatabase.  QSqlDatabase provides information
about objects within the database such as tables, views and
indexes.  For example:

\code
    // get the default database connection
    QSqlDatabase* db = QSqlDatabase::database();
    // list all tables and views
    QStringList list = db->tables();
    // find out some information on the 'Employee' table
    QSqlRecord r = QSqlDatabase::record( "Employee" );
    // 
\endcode

QSqlDatabase also manages transactions for the database connection (if
the driver supports transactions):

\code
    QSqlDatabase* db = QSqlDatabase::database();
    if ( db->driver()->hasTransactionSupport() ) {
        // start a transaction
        db->transaction();
        // update the database...
        ...
        // commit all changes
        db->commit();
    }
\endcode

Login parameters such as the user name and password, database name and
hostname must be set before a connection can be opened.  To open a
connection to the database, use the open() function.  In the event of
an error, lastError() will return error information.  For example:

\code
    QSqlDatabase* db = QSqlDatabase::database();
    // set connection parameters...
    if ( !db->open() ) {
	QSqlError err = db->lastError();
        ...
        return;
    }
\endcode

If a Qt SQL class attempts to use the default database connection
(returned by QSqlDatabase::database()), and the database is not yet
opened, an open() is attempted before the database is used.  If a
database connection is no longer needed, QSqlDatabase::close() will
close the database.  Or, the static function
QSqlDatabase::removeDatabase() will close and permanently remove the
database from the list of available connections.  Note that there
should be no active queries left in your application when closing a
database.

<h2>Fields, Records and Indexes</h2>

Field, record and index classes are non-visual classes that are
primarily used to represent information about the database, and to
generate SQL statements that can be executed on the database.  For
example. QSqlCursor (see below) makes heavy use of these classes to
generate SQL.  In addition, database GUI classes such as QSqlTable and
QSqlForm use fields, records and indexes to display data returned by
SQL queries on screen.

The QSqlField class encapsulates the functionality and characteristics
of a column in a database field, such as the data type, field name,
etc.  The field's value can also be viewed and changed.

The QSqlRecord class encapsulates the functionality and
characteristics of a database record (usually a table or view within
the database), such as adding or removing fields, setting and
retrieving field values, etc.  In addition, there are several
functions which alter other characteristics of the record, for
example, changing the display label associated with a particular field
when displaying that field on screen.

\code
    QSqlRecord r = QSqlDatabase::database()->record( "Employee" );
    r.setDisplayLabel( "name", "Employee Name" );
    r.setValue( "name", "Dave" );
    ...
    QLabel* l = new QLabel( r.displayLabel( "name" ), myFormWidget );
    QLineEdit* le = new QLineEdit( myFormWidget );
    le->setText( r.value( "name ).toString() );
\endcode

The QSqlIndex class represents an index or key within the database. An
index is a record with some additional functionality, such as the
ability to specify ascending or descending sorting for fields in the
index.

<h2>Queries</h2>

Once a connection to a SQL database has been established, it is very
straightforward to begin using the Qt SQL classes.  For example,
updating a record in e.g. the 'Employee' table can be done with the
following code:

\code
    QSqlQuery q;
    q.exec( "update Employee set name='Dave' where id=1" );
\endcode

SQL statements can also be executed directly from an open database
connection.  These statements are sent to the QSqlDatabase::exec()
function, which returns a QSqlQuery object.  Queries can also be
created independant of any database connection (these queries will use
the application default connection in this case).  For example:

\code
    QSqlDatabase* db = QSqlDatabase::database();
    QSqlQuery employeeCount = db->exec( "select count(*) from Employee;" );
    ...
    QSqlQuery updEmployee; // uses the default application connection
    upd.exec( "update Employee set name='db' where id=1;" );
\endcode

QSqlQuery allows any SQL statement to be passed to the database,
including database-specific SQL statements.  Primarily, however, there
are two types of SQL statements which are intended to be used with
QSqlQuery: SELECT statements and data manipulation statements (INSERT,
UPDATE and DELETE).

To use QSqlQuery with a SELECT statement, specify the statement in the
object constructor, or use the QSqlQuery::exec() method.  When a
QSqlQuery object is given a SELECT statement, the statement is
verified against the database.  If the statement contains an error,
the QSqlQuery object will remain in an inactive state, otherwise the
QSqlQuery becomes active, and data can be retrieved.  

Each active query has an internal pointer to the current valid record,
which is returned by the QSqlQuery::at() function.  The current row
in the query is the one whose values can be retrieved using the
QSqlQuery::value() function. You can change the current row by moving
the query to point to a different row.  The following methods navigate
through the rows of an active query:

<ul>
<li> <b>first()</b> - Moves to the first row in the query
<li> <b>last()</b> - Moves to the last row in the query
<li> <b>next()</b> - Moves to the next row in the query
<li> <b>prev()</b> - Moves to the previous row in the query
<li> <b>seek()</b> - Moves to a random row in the query
</ul>

In addition, the following functions can be used to describe
properties of the query which are useful when navigating the rows:

<ul>
<li> <b>isActive()</b> - Returns TRUE if the last statement was successful
<li> <b>isValid()</b> - Returns TRUE if the query is positioned on a valid record
<li> <b>at()</b> - Returns the current row (can be used with seek())
<li> <b>isSelect()</b> - Returns TRUE if the last statement was a SELECT statement
</ul>

For example:

\code
    // create query using the application default database
    QSqlQuery emp( "select name, deptno from Employee order by name;" );

    bool active = emp.isActive();// returns TRUE if query successful
    vool valid = emp.isValid();  // returns FALSE since we have not yet positioned to a valid record
    int at = emp.at();           // returns invalid location

    if ( active ) {    // if query successful...

        // move to the first record
        emp.first();
	valid = emp.isValid();   // returns TRUE if we are positioned on a valid record
	at = emp.at();           // returns 0, since the query is on the first record

        // ...move through the rest of the records returned by the query
        while ( emp.next() ) {  
	     ... // do something with the result
        }

        valid = emp.isValid();   // returns FALSE since the query is positioned after the last record
        at = emp.at();           // returns invalid location

        // go to a random record
        emp.seek( 10 );
	valid = emp.isValid();   // returns TRUE if we are positioned on a valid record

        // reset the query
        emp.exec( "select name from dept where id=10;" );
        active = emp.isActive();// returns TRUE if last query successful
        valid = emp.isValid();  // returns FALSE since we have yet not positioned to a valid record
    }
\endcode

A query is positioned on an invalid record when it is first given a
new SQL statement to execute.  Moving to a valid record within the
result will allow you to access the data returned by the query.  Data
is returned by the QSqlQuery::value() function using QVariant.  For
example:

\code
    QSqlQuery emp( "select name, deptno from Employee order by name;" );
    while ( emp.next() ) {
        QString name = emp.value(0).toString();
        QVariant deptno = emp.value(1);
        ...
    }
\endcode

Applications that use QSqlQuery do so mainly to browse, or scroll,
through records returned by the query.  To use a QSqlQuery with a data
manipulation statement (INSERT, UPDATE and DELETE), just specify the
statement to the object constructor or use the QSqlQuery::exec()
method.  Data manipulation statements will execute on the database
immediately (unless a transaction is started), and the query will be
positioned to an invalid record.  Use QSqlQuery::isActive() to
determine if the statement was successful.  Note that you cannot
scroll through any records with these types of SQL statements, since
data manipulation statements do not return any result records.  You
can check the number of rows affected by the statement using
QSqlQuery::numRowsAffected().  For example:

\code
    QSqlQuery emp;
    emp.exec( "update Employee set name='foo' where name='bar';" );
    bool active = emp.isActive();     // returns TRUE if query successful
    vool valid = emp.isValid();       // returns FALSE since an UPDATE statement returns no records
    int rows = emp.numRowsAffected(); // returns number of rows updated
\endcode

By default, when you create queries (or cursors, see below), the
default database connection is used.  To specify a different database
connection, pass a pointer to the desired QSqlDatabase. For example:

\code
    QSqlDatabase* alternateDb = QSqlDatabase::database( "alternate" );
    QSqlQuery q;
    q.exec( "update Employee set name='Trond' where id=2", alternateDb );
\endcode
	
<h2>Cursors</h2>

You can perform operations on tables or views within the database as a
whole using QSqlCursor.  A 'cursor' is a database record (see above)
which coresponds to a table or view within the database.  To position
to a valid record, cursors can be navigated in the same way as a
QSqlQuery (see above).  Once positioned on a valid record, data can be
retrieved from the record fields directly.  In addition, for cursors
that correspond to tables or views that contain primary indexes, data
can be edited directly using the edit functions of QSqlCursor.

For example, to create a list of all employee names from department #10
of the Employee table:

\code
    QSqlCursor emp( "Employee" ); // uses the default application database
                                  // and constructs a record of all 'Employee' fields
    emp.select( "deptno=10" );    // select everyone in deparment #10
    while( emp.next() )           // for each valid record
	myListBox->insertItem( emp.value( "name" ).toString() );
\endcode

Records in the cursor can be selected in several ways using the
overloaded select() method.  For example, to select a subset of
records based upon an index:

\code
    QSqlCursor emp( "Employee" );
    QStringList fields = QStringList() << "name" << "deptno";
    QSqlIndex nameIndex = emp.index( fields ); // create an index based on fields
    emp.select( nameIndex );                   // selects all records sorted by nameIndex
    while ( emp.next ) {
        ...;
    }

\endcode

If the underlying table or view has a primary index which identifies a
unique record, a cursor can also edit records in the database.  Before
inserting, updating or deleting records in a cursor, functions should
be called which prepare the cursor for edit operations.  The following
lists methods for returning a pointer to an internal buffer used for editing:

<ul>
<li> <b>insertBuffer()</b> - returns a pointer to the insert record buffer
<li> <b>updateBuffer()</b> - returns a pointer to the update record buffer
</ul>

The edit buffer of a cursor is independant of the current cursor
record buffer which contains the values of the current fields from the
database.  After getting a pointer to the internal edit buffer, values
can be manipulated, and then saved to the database.  For example:

\code
    QSqlCursor emp( "Employee" );
    emp.setValue( "id", 10 );
    emp.select( emp.primaryIndex(), emp.primaryIndex() );  // select unique record 
    if ( emp.next() ) {
        QSqlRecord* upd = emp.updateBuffer(); // get the update buffer for the current cursor record
        upd->setValue( "name", "Trond" );     // change the value of a field in the update buffer
        QString n1 = emp.value( "name" ).toString();
        QString n2 = buf->value( "name" ).toString(); // note: n1 != n2
        
        emp.update(); // updates the Employee table using the table's primary index
                      // and invalidates the current cursor record (i.e., at() returns an invalid position)
        bool active = emp.isActive(); // returns TRUE if update succeeded
        int rows = emp.numRowsAffected(); // returns 1 if query successful

        emp.select( emp.primaryIndex(), emp.primaryIndex() );  // re-select the record 
        if ( emp.next() ) 
            n1 = emp.value( "name" ).toString(); // note: n1 == n2
    }
\endcode

<h2>GUI Components</h2>

<h2>Drivers</h2>

*/

