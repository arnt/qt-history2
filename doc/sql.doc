/****************************************************************************
** $Id: //depot/qt/main/doc/sql.doc#1 $
**
** Documentation for sql programming
**
** Copyright (C) 1992-2000 Trolltech AS.  All rights reserved.
**
** This file is part of the Qt GUI Toolkit.
**
** This file may be distributed under the terms of the Q Public License
** as defined by Trolltech AS of Norway and appearing in the file
** LICENSE.QPL included in the packaging of this file.
**
** This file may be distributed and/or modified under the terms of the
** GNU General Public License version 2 as published by the Free Software
** Foundation and appearing in the file LICENSE.GPL included in the
** packaging of this file.
**
** Licensees holding valid Qt Enterprise Edition or Qt Professional Edition
** licenses may use this file in accordance with the Qt Commercial License
** Agreement provided with the Software.
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
**   information about Qt Commercial License Agreements.
** See http://www.trolltech.com/qpl/ for QPL licensing information.
** See http://www.trolltech.com/gpl/ for GPL licensing information.
**
** Contact info@trolltech.com if any conditions of this licensing are
** not clear to you.
**
**********************************************************************/
/*! \file sql/overview/connect1/main.cpp */
/*! \file sql/overview/create_connections/main.cpp  */
/*! \file sql/overview/basicbrowsing/main.cpp */
/*! \file sql/overview/basicbrowsing2/main.cpp */
/*! \file sql/overview/basicdatamanip/main.cpp */
/*! \file sql/overview/navigating/main.cpp */
/*! \file sql/overview/retrieve1/main.cpp */
/*! \file sql/overview/retrieve2/main.cpp */
/*! \file sql/overview/order1/main.cpp */
/*! \file sql/overview/order2/main.cpp */
/*! \file sql/overview/extract/main.cpp */
/*! \file sql/overview/insert/main.cpp */
/*! \file sql/overview/update/main.cpp */
/*! \file sql/overview/del/main.cpp */
/*! \file sql/overview/table1/main.cpp */
/*! \file sql/overview/table2/main.cpp */
/*! \file sql/overview/table3/main.h */
/*! \file sql/overview/table3/main.cpp */
/*! \file sql/overview/table4/main.h */
/*! \file sql/overview/table4/main.cpp */
/*! \file sql/overview/form1/main.cpp */
/*! \file sql/overview/form2/main.h */
/*! \file sql/overview/custom1/main.h */
/*! \file sql/overview/custom1/main.cpp */
/*! \file sql/overview/subclass1/main.cpp */
/*! \file sql/overview/subclass2/main.h */
/*! \file sql/overview/subclass2/main.cpp */
/*! \file sql/overview/subclass3/main.h */
/*! \file sql/overview/subclass3/main.cpp */
/*! \file sql/overview/subclass4/main.h */
/*! \file sql/overview/subclass4/main.cpp */
/*! \file sql/overview/subclass5/main.h */
/*! \file sql/overview/subclass5/main.cpp */

/*! \page sql.html
 
\title Qt SQL Module

<ul>
<li><a href="#Introduction">Introduction</a></li>
<li><a href="#Architecture">SQL Module Architecture</a></li>
<li><a href="#Plugins">SQL Driver Plugins</a></li>
<li><a href="#Connecting_to_Databases">Connecting to Databases</a></li> 
    <ul>
    <li><a href="#Connecting_to_a_Single_Database">
    Connecting to a Single Database</a></li>
    <li><a href="#Connecting_to_Multiple_Databases">
    Connecting to Multiple Databases</a></li>
    </ul>
<li><a href="#Executing_SQL_commands">
Executing SQL Commands Using QSqlQuery</a></li> 
    <ul>
    <li><a href="#Basic_Browsing">Basic Browsing</a></li> 
    <li><a href="#Basic_Data_Manipulation">Basic Data Manipulation</a></li> 
    <li><a href="#Navigating_Result_Sets">Navigating Result Sets</a></li> 
    </ul>
<li><a href="#Using_QSqlCursor">Using QSqlCursor</a></li> 
    <ul>
    <li><a href="#Retrieving_Records">Retrieving Records</a></li>
	<ul>
	<li><a href="#Sorting_Data">Sorting and Filtering Records</a></li>
	<li><a href="#Extracting_Data">Extracting Data</a></li>
	</ul>
    <li><a href="#Manipulating_Records">Manipulating Records</a></li>
	<ul>
	<li><a href="#Inserting_Records">Inserting Records</a></li>
	<li><a href="#Updating_Records">Updating Records</a></li>
	<li><a href="#Deleting_Records">Deleting Records</a></li>
	</ul>
    </ul>
<li><a href="#Data-Aware_Widgets">Data-Aware Widgets</a></li> 
    <ul>
    <li><a href="#Data-Aware_Tables">Data-Aware Tables</a></li> 
    <li><a href="#Creating_Forms">Creating Data-Aware Forms</a></li> 
	<ul>
	<li><a href="#Displaying_a_Record">Displaying a Record</a></li>
	<li><a href="#Editing_a_Record">Editing a Record</a></li>
	</ul>
    <li><a href="#Custom_Editor_Widgets">Custom Editor Widgets</a></li> 
	<ul>
	<li><a href="#Custom_Editor_Widgets_for_Tables">
	Custom Editor Widgets for QTables</a></li>
	</ul>
    </ul>
<li><a href="#Subclassing_QSqlCursor">Subclassing QSqlCursor</a></li> 
<li><a href="#Appendix_1_Tables">Appendix 1: The Example Tables</a></li> 
</ul>

<h1><a name="Introduction">Introduction</a></h1>

Qt's SQL classes help you provide seamless database integration to
your Qt applications.

<blockquote>
This overview assumes that you have at least a basic knowledge of SQL.
You should be able to understand simple \c SELECT, \c INSERT, \c UPDATE
and \c DELETE commands. Although the \l QSqlCursor class provides an
interface to database browsing and editing that does not \e require a
knowledge of SQL, a basic understanding of SQL is highly recommended. A
standard text covering SQL databases is <em>An Introduction to Database
Systems (7th ed.)</em> by C. J. Date, ISBN 0201385902.
</blockquote>

Whilst this module overview presents the classes from a purely
programmatic point of view the <em>Qt Designer</em> manual's "Creating
Database Applications" chapter takes a higher-level approach
demonstrating how to set up master-detail relationships between widgets,
perform drilldown and handle foreign key lookups.

This document is divided into six sections:

<a href="#Architecture">SQL Module Architecture</a>. This describes the
how the classes fit together.

<a href="#Connecting_to_Databases">Connecting to Databases</a>. 
This section explains how to set up database connections using the \l
QSqlDatabase class.

<a href="#Executing_SQL_commands">Executing SQL Commands</a>. This
section demonstrates how to issue the standard data manipulation
commands, \c SELECT, \c INSERT, \c UPDATE and \c DELETE on tables in
the database (although any valid SQL statement can be sent to the
database). The focus is purely on database interaction using \l
QSqlQuery.

<a href="#Using_QSqlCursor">Using Cursors</a>. This section explains
how to use the QSqlCursor class which provides a more structured and
powerful API than the raw SQL used with \l QSqlQuery.

<a href="#Data-Aware_Widgets">Data-Aware Widgets</a>. This section shows
how to programmatically link your database to the user interface. In
this section we introduce the \l QDataTable, \l QSqlForm, \l
QSqlPropertyMap and QSqlEditorFactory classes and demonstrate how to use
custom data-aware widgets. <em>Qt Designer</em> provides an easy visual
way of achieving the same thing.  See the <em>Qt Designer</em> manual,
\l QDataBrowser and \l QDataView for more information.

<a href="#Subclassing_QSqlCursor">Subclassing QSqlCursor</a>. This
section gives examples of subclassing QSqlCursor. Subclassing can be
used to provide default and calculated values for fields (such as
auto-numbered primary index fields), and to display calculated data,
e.g. showing names rather than ids of foreign keys. 

<h1><a name="Architecture">SQL Module Architecture</a></h1>

The SQL classes are divided into three layers:

<em>User Interface Layer.</em> These classes provide data-aware
widgets that can be connected to tables or views in the database. End
users can interact directly with these widgets to browse or edit
data. <em>Qt Designer</em> is fully integrated with the SQL classes
and can be used to create data-aware forms. The data-aware widgets can
also be programmed directly with your own C++ code. The classes that
support this layer include \l QSqlEditorFactory, \l QSqlForm, \l
QSqlPropertyMap, \l QDataTable, \l QDataBrowser and \l QDataView.

<em>SQL API Layer.</em> These classes provide access to databases.
Connections are made using the \l QSqlDatabase class. Database
interaction is achieved either by using the QSqlQuery class and
executing SQL commands directly or by using the higher level \l
QSqlCursor class which composes SQL commands automatically. In
addition to \l QSqlDatabase, \l QSqlCursor and \l QSqlQuery, the SQL
API layer is supported by QSqlError, QSqlField, QSqlIndex and
QSqlRecord.

<em>Driver Layer.</em> This comprises three classes, \l QSqlResult, \l
QSqlDriver and QSqlDriverInterface. This layer provides the low level
bridge between the database and the SQL classes. This layer is
documented separately since it is only relevant to driver writers, and
is rarely used in standard database application programming.

<h1><a name="Plugins">SQL Driver Plugins</a></h1>

The Qt SQL module can dynamically load new drivers at runtime using
the <a href="component.html">Qt component model</a>.

To compile plugins for a supported database, it may be necessary to
customize the command line given to <a
href="qmake.html"><em>qmake</em></a> in order to match the setup on your system.

For example, when building the MySQL plugin on unix:

\code
cd $QTDIR/src/sql/src/mysql
qmake -o Makefile "INCLUDEPATH=/usr/local/include" "LIBS=-L/usr/local/libs -lmysql" mysql.pro 
make
\endcode

To do the same thing on Windows:

\code
cd c:\qt\src\sql\src\mysql
qmake -o Makefile "INCLUDEPATH=c:\path\to\mysql\include" "LIBS=c:\path\to\mysql\lib\libmysql.lib" mysql.pro 
nmake
\endcode

The above examples ensures that the proper include and library paths
are used by <em>qmake</em> when generating the makefile for the MySQL
plugin.  Of course, you will need the proper development headers and
libraries for MySQL installed before compiling the plugin.

Once a plugin is built, Qt will automatically load it, and the driver
will be available for use by QSqlDatabase (see QSqlDatabase::drivers()
for more information).

<h1><a name="Connecting_to_Databases">Connecting to Databases</a></h1> 

At least one database connection must be created and opened before the
\l QSqlQuery or \l QSqlCursor classes can be used.

If the application only needs a single database connection, the \l
QSqlDatabase class can create a connection which is used by default
for all SQL operations. If multiple database connections are required
these can easily be set up.

\l QSqlDatabase requires the \c qsqldatabase.h header file.

<h2><a name="Connecting_to_a_Single_Database">
Connecting to a Single Database</a></h2>

Making a database connection is a simple three step process: activate
the driver, set up the connection information, and open the
connection.

\walkthrough sql/overview/connect1/main.cpp
\skipto include
\printline include
\printuntil return 0
\printline
<h5 align="center">From \l sql/overview/connect1/main.cpp </h5>

First we activate the driver by calling \l QSqlDatabase::addDatabase(),
passing the name of the driver we wish to use for this connection. At
the time of writing the available drivers are: QODBC3 (Open Database
Connectivity), QOCI8 (Oracle), QPSQL6 (PostgreSQL 6), QPSQL7 (PostgreSQL
7) and QMYSQL3 (MySQL). The connection which is created becomes the
application's default database connection and will be used by the Qt SQL
classes if no other database is specified. 

Second we call setDatabaseName(), setUserName(), setPassword() and
setHostName() to initialize the connection information.

Third we call open() to open the database and give us access to the
data. If this call fails it will return FALSE; error information can
be determined using \l QSqlDatabase::lastError();

<h2><a name="Connecting_to_Multiple_Databases">
Connecting to Multiple Databases</a></h2>

Connecting to multiple databases is achieved using the two argument form
of \l QSqlDatabase::addDatabase() where the second argument is a unique
identifier distinguishing the connection.

<a name="create_connections"/>
\walkthrough sql/overview/create_connections/main.cpp
\skipto include
\printline include
\printuntil return TRUE 
\printline
<h5 align="center">From \l sql/overview/create_connections/main.cpp </h5>

In the example above we have moved the connections into their own
function, createConnections(), and added some basic error handling. The
static function \l QSqlDatabase::database() can be called from anywhere
to provide a pointer to a database connection. If we call it without any
parameter it will return the default connection. If called with the
identifier we've used for a connection, e.g. "ORACLE", in the above
example, it will return a pointer to the specified connection.

Note that in the code above the ODBC connection was not named and is
therefore used as the default connection.  \l QSqlDatabase maintains
ownership of the pointers returned by the addDatabase() static
function.  To remove a database from the list of maintained
connections, first close the database with QSqlDatabase::close(), and
then remove it using the static function
QSqlDatabase::removeDatabase().

<h1><a name="Executing_SQL_commands">Executing SQL Commands Using QSqlQuery</a></h1> 

The \l QSqlQuery class provides an interface for executing SQL commands.
It also has functions for navigating through the result sets of \c SELECT
queries and for retrieving individual records and field values.

The \l QSqlCursor class described in the next section inherits from \l
QSqlQuery and provides a higher level interface that composes SQL
commands for us. \l QSqlCursor is particularly easy to integrate with
on-screen widgets. Programmers unfamiliar with SQL can safely skip this
section and use the \l QSqlCursor class covered in 
<a href="#Using_QSqlCursor">"Using QSqlCursor"</a>.

<h2><a name="Basic_Browsing">Basic Browsing</a></h2> 

\walkthrough sql/overview/basicbrowsing/main.cpp
\skipto include
\printline include
\printuntil return 0 
\printline
<h5 align="center">From \l sql/overview/basicbrowsing/main.cpp
</h5>

In the example above we've added an additional header file, 
\c qsqlquery.h. The first query we create, \c target, uses the default
database and is initially empty. For the second query, \c q, we specify
the "ORACLE" database that we want to retrieve records from. Both the
database connections were set up in the createConnections() function we
wrote earlier.

After creating the initial \c SELECT statement, isActive() is checked
to see if the query executed successfully. The next() function is
used to iterate through the query results. The value() function
returns the contents of fields as QVariants. The insertions are
achieved by creating and executing queries against the default
database using the \c target QSqlQuery.

\walkthrough sql/overview/basicbrowsing2/main.cpp
\skipto count
\printline 
\printuntil numRows 
\printline
\printline
<h5 align="center">From \l sql/overview/basicbrowsing2/main.cpp
</h5>

The above code introduces a count of how many records are successfully
inserted. Note that isActive() returns FALSE if the query, e.g. the
insertion, fails. numRowsAffected() returns -1 if the number of rows
cannot be determined, e.g. if the query fails.

<h2><a name="Basic_Data_Manipulation">Basic Data Manipulation</a></h2> 

\walkthrough sql/overview/basicdatamanip/main.cpp
\skipto main
\printline main
\printuntil return ( rows 
\printline
<h5 align="center">From \l sql/overview/basicdatamanip/main.cpp
</h5>

This example demonstrates straightforward SQL DML (data manipulation
language) commands. Since we did not specify a database in the \l
QSqlQuery constructor the default database is used. \l QSqlQuery objects
can also be used to execute SQL DDL (data definition language) commands
such as <tt>CREATE TABLE</tt> and <tt>CREATE INDEX</tt>. 

<h2><a name="Navigating_Result_Sets">Navigating Result Sets</a></h2> 

Once a \c SELECT query has been executed successfully we have access
to the result set of records that matched the query criteria. We have
already used one of the navigation functions, next(), which can be
used alone to step sequentially through the records. \l QSqlQuery also
provides first(), last(), next() and prev(). After any of these
commands we can check that we are on a valid record location by
calling isValid().

We can also navigate to any arbitrary record using seek(). The
first record in the dataset is zero. The number of the last record is
<tt>size() - 1</tt>. Note that not all databases provide the size of a
\c SELECT query and in such cases size() returns -1.

\walkthrough sql/overview/navigating/main.cpp
\skipto if (
\printline if (
\printuntil i == 4 
\printline
<h5 align="center">From \l sql/overview/navigating/main.cpp
</h5>

The example above shows some of the navigation functions in use. 

Not all drivers support size(), but we can interrogate the driver to
find out:

\code
    QSqlDatabase* defaultDB = QSqlDatabase::database();
    if ( defaultDB->driver()->hasQuerySizeSupport() ) {
	// QSqlQuery::size() supported
    }
    else {
	// QSqlQuery::size() cannot be relied upon
    }
\endcode


Once we have located the record we are interested in we may wish to
retrieve data from it. 

\walkthrough sql/overview/retrieve1/main.cpp
\skipto if (
\printline if (
\printuntil qDebug 
\printline
\printline
\printline
\printline
<h5 align="center">From \l sql/overview/retrieve1/main.cpp
</h5>

Note that if you wish to iterate through the record set in order the
only navigation function you need is next().

Tip: The lastQuery() function returns the text of the last query
executed. This can be useful to check that the query you think is being
executed is the one actually being executed.

<h1><a name="Using_QSqlCursor">Using QSqlCursor</a></h1> 

The \l QSqlCursor class provides a high level interface to browsing and
editing records in SQL database tables or views without the need to
write your own SQL.

QSqlCursors can do almost everything that QSqlQuery can, with two
exceptions. Since cursors represent tables or views within the
database, by default, \l QSqlCursor objects retrieve all the fields of
each record in the table or view. If only some fields are relevant
simply confine your processing to those and ignore the others. Or,
manually disable the generation of certain fields using
QSqlRecord::setGenerated().  However, if you really don't want to
retrieve all fields in the cursor then you should use a \l QSqlQuery
instead, and customize the query to suit your needs.  You can edit
records using a \l QSqlCursor providing that the table or view has a
primary index that uniquely distinguishes each record. If this condition
is not met then you'll need to use a \l QSqlQuery for edits. (Note that
not all databases support editable views.) 

Before we can use \l QSqlCursor objects we must first create and open
a database connection. Connecting is described in the <a
href="#Connecting_to_Databases">"Connecting to Databases"</a> section
above. For the examples that follow we will assume that the
connections have been created using the createConnections() function
defined in the <a href="#create_connections">QSqlDatabase example</a>
presented earlier.

In the <a href="#Data-Aware_Widgets">data-aware widgets</a> section that
follows this one we show how to link widgets to database cursors. Once
we have a knowledge of both cursors and data-aware widgets we can
discuss <a href="#Subclassing_QSqlCursor">subclassing QSqlCursor</a>.

The \l QSqlCursor class requires the \c qsqlcursor.h header file.

<h2><a name="Retrieving_Records">Retrieving Records</a></h2>

\walkthrough sql/overview/retrieve2/main.cpp
\skipto include
\printline include
\printuntil return 0 
\printline
<h5 align="center">From \l sql/overview/retrieve2/main.cpp
</h5>

We create the \l QSqlCursor object, specifying the table or view to use.
If we need to use a database other than the default we can specify it
in the QSqlCursor constructor.

The SQL executed by the <tt>cur.select()</tt> call is<br> 
\code
    SELECT staff.id, staff.forename, staff.surname, staff.salary, staff.statusid FROM staff;
\endcode

Next, we iterate through the records returned by this select statement
using cur.next().  Field values are retrieved in in a similar way to
QSqlQuery, except that we pass field names rather than numeric indexes
to value() and setValue().

<h3><a name="Sorting_Data">Sorting and Filtering Records</a></h3>

To specify a subset of records to retrieve we can pass filtering
criteria to the select() function.  Each record that is returned will
meet the criteria of the filter (the filter corresponds to the SQL
statement's WHERE clause).

\code
    cur.select( "id > 100" );
\endcode

This select() call will execute the SQL<br>
\code
    SELECT staff.id, staff.forename, staff.surname, staff.salary, staff.statusid 
    FROM staff WHERE staff.id > 100;
\endcode

This will retrieve only those staff whose \c id is greater than 100.

In addition to retrieving selected records we often want to specify a
sort order for the returned records. This is achieved by creating a \l
QSqlIndex object which contains the names of the field(s) we wish to
sort by and pass this object to the select() call.

\code
    QSqlCursor cur( "staff" );
    QSqlIndex nameIndex = cur.index( "surname" ); 
    cur.select( nameIndex );
\endcode

Here we create a \l QSqlIndex object with one field, "surname". When
we call the select() function we pass the index object, which
specifies that the records should be returned sorted by
staff.surname. Each field in the index object is used in the ORDER BY
clause of the select statement.  The SQL executed here is 
\code
    SELECT staff.id, staff.forename, staff.surname, staff.salary, staff.statusid 
    FROM staff ORDER BY staff.surname ASC;
\endcode

Combining the retrieval of a subset of records and ordering the results
is straightforward.

\code
    cur.select( "surname LIKE 'A%'", nameIndex );
\endcode

We pass in a filter string (the WHERE clause), and the \l QSqlIndex
object to sort by (the ORDER BY clause). This produces

\code
    SELECT staff.id, staff.forename, staff.surname, staff.salary, staff.statusid
    FROM staff WHERE staff.surname LIKE 'A%' ORDER BY staff.surname ASC;
\endcode

To sort by more than one field, an index can be created which contains
multiple fields.  Ascending and descending order can be set using
QSqlIndex::setDescending(); the default is ascending.

\walkthrough sql/overview/order1/main.cpp
\skipto QSqlCursor
\printline QSqlCursor
\printuntil while 
<h5 align="center">From \l sql/overview/order1/main.cpp
</h5>

Here we create a string list containing the fields we wish to sort by,
in the order they are to be used. Then we create a \l QSqlIndex object
based on these fields, finally executing the select() call using this
index. This executes
\code
    SELECT staff.id, staff.forename, staff.surname, staff.salary, staff.statusid
    FROM staff ORDER BY staff.surname ASC, staff.forename ASC;
\endcode

If we need to retrieve records with fields that match specific criteria we
can create a filter based on an index.

\walkthrough sql/overview/order2/main.cpp
\skipto QSqlCursor
\printline QSqlCursor
\printuntil while 
<h5 align="center">From \l sql/overview/order2/main.cpp
</h5>

This executes
\code
    SELECT staff.id, staff.forename, staff.surname, staff.salary, staff.statusid 
    FROM staff WHERE staff.surname='Bloggs' ORDER BY staff.id ASC, staff.forename ASC;
\endcode

The "order" \l QSqlIndex contains two fields, "id" and "forename"
which are used to order the results. The "filter" \l QSqlIndex
contains a single field, "surname". When an index is passed as a
filter to the select() function, for each field in the filter, a
<em>fieldname=value</em> subclause is created where the value
is taken from the current cursor's value for that field. We use
setValue() to ensure the value used is the one we want.

<h3><a name="Extracting_Data">Extracting Data</a></h3>

\walkthrough sql/overview/extract/main.cpp
\skipto QSqlCursor
\printline QSqlCursor
\printuntil qDebug
\printline
<h5 align="center">From \l sql/overview/extract/main.cpp
</h5>

In this example we begin by creating a cursor on the creditors table. We
create two \l QSqlIndex objects. The first, "order", is created from the
"orderFields" string list. The second, "filter", is created from the
"filterFields" string list. We set the values of the two fields used in
the filter, "surname" and "city", to the values we're interested in. Now
we call select() which generates and executes the following SQL:
\code
    SELECT creditors.city, creditors.surname, creditors.forename, creditors.id 
    FROM creditors 
    WHERE creditors.surname = 'Chirac' AND creditors.city = 'Paris' 
    ORDER BY creditors.surname ASC, creditors.forename ASC;
\endcode
The filter fields are used in the WHERE clause. Their values are taken
from the cursor's current values for those fields; we set these values
ourselves with the setValue() calls. The order fields are used in the
ORDER BY clause. 

Now we iterate through each matching record (if any). We retrieve the
contents of the id, forename and surname fields and pass them on to some
processing function, in this example a simple qDebug() call.

<h2><a name="Manipulating_Records">Manipulating Records</a></h2>

Records can be inserted, updated or deleted in a table or view using a
\l QSqlCursor providing that the table or view has a primary index
that uniquely distinguishes each record. If this is not the case a \l
QSqlQuery must be used instead. (Note that not all databases support
editable views.)

Each cursor has an internal 'edit buffer' which is used by all the edit
operations (insert, update and delete).  For example, when inserting a
record using a cursor, you must first initialize the fields in the
cursor's edit buffer.  Then, calling QSQlCursor::insert() will insert
the contents of the edit buffer into the database.  Similarly, when
updating (or deleting) a record, the values of the fields in the edit
buffer are used to update (or delete) the record in the database.  The
'edit buffer' is unaffected by any <a
href="#Navigating_Result_Sets">cursor navigation</a> functions.

The primeInsert(), primeUpdate() and primeDelete() methods all return
a pointer to the internal edit buffer, however each method can
potentially perform different operations on the edit buffer before
returning it.  By default,  QSqlCursor::primeInsert() clears all the
field values in the edit buffer (see \l QSqlRecord::clearValues()).
Both \l QSqlCursor::primeUpdate() and QSqlCursor::primeDelete()
initialize the edit buffer with the current contents of the cursor
before returning it.  All three of these functions are virtual, so you
can redefine the behavior (for example, reimplementing primeInsert() to
auto-number fields in the edit buffer). Data-aware user-interface
controls emit signals, e.g. primeInsert(), that you can connect to;
these pass a pointer to the appropriate buffer so subclassing may not be
necessary. See <a href="#Subclassing_QSqlCursor">subclassing
QSqlCursor</a> for more information on subclassing; see the <em>Qt
Designer</em> manual for more on connecting to the primeInsert()
signal.

When insert(), update() or del() is called on a cursor, it will be
invalidated and will no longer be positioned on a valid record. If we
need to move to another record after performing an insert(), update()
or del() we must make a fresh select() call.  This ensures that
changes to the database are accurately reflected in the cursor.

<h3><a name="Inserting_Records">Inserting Records</a></h3>

\walkthrough sql/overview/insert/main.cpp
\skipto QSqlCursor
\printline QSqlCursor
\printuntil } 
<h5 align="center">From \l sql/overview/insert/main.cpp
</h5>

In this example we create a cursor on the "prices" table. Next we
create a list of product names which we iterate over. For each
iteration we call the cursor's primeInsert() method. This method
returns a pointer to a \l QSqlRecord buffer in which all the fields
are set to \c NULL. (Note that QSqlCursor::primeInsert() is virtual,
and can be customized by derived classes.  See \l QSqlCursor). Next we
call setValue() for each field that requires a value. Finally we call
insert() to insert the record. The insert() call returns the number of
rows inserted.

We obtained a pointer to a \l QSqlRecord object from the primeInsert()
call. QSqlRecord objects can hold the data for a single record plus some
meta-data about the record. In practice most interaction with a
QSqlRecord consists of simple value() and setValue() calls as shown in
this and the following example. 

<h3><a name="Updating_Records">Updating Records</a></h3>

\walkthrough sql/overview/update/main.cpp
\skipto QSqlCursor
\printline QSqlCursor
\printuntil update
\printline
<h5 align="center">From \l sql/overview/update/main.cpp
</h5>

This example begins with the creation of a cursor over the prices table.
We select the record we wish to update with the select() call and
move to it with the next() call. We call primeUpdate() to get a \l
QSqlRecord pointer to a buffer which is populated with the contents of
the current record. We retrieve the value of the price field, calculate
a new price, and set the the price field to the newly calculated value.
Finally we call update() to update the record. The update() call returns
the number of rows updated.

If many identical updates need to be performed, for example increasing
the price of every item in the price list, using a single SQL statement
with \l QSqlQuery is more efficient, e.g.

\code
    QSqlQuery query( "UPDATE prices SET price = price * 1.05;"  );
\endcode

<h3><a name="Deleting_Records">Deleting Records</a></h3>

\walkthrough sql/overview/del/main.cpp
\skipto QSqlCursor
\printline QSqlCursor
\printuntil del
<h5 align="center">From \l sql/overview/del/main.cpp
</h5>

To delete records, select the record to be deleted and navigate to it.
Then call primeDelete() to populate the cursor with the primary key
of the selected record, (in this example, the \c prices.id field), and
then call QSqlCursor::del() to delete it. 

As with update(), if multiple deletions need to be made with some common
criteria it is more efficient to do so using a single SQL statement,
e.g.

\code
    QSqlQuery query( "DELETE FROM prices WHERE id >= 2450 AND id <= 2500;" );
\endcode

<h1><a name="Data-Aware_Widgets">Data-Aware Widgets</a></h1> 

Data-Aware Widgets provide a simple yet powerful means of connecting
databases to Qt user interfaces. The easiest way of creating and
manipulating data-aware widgets is with <em>Qt Designer</em>. 
For those who prefer a purely programmatic approach the following
examples and explanations provide an introduction. Note that the
"Creating Database Applications" chapter of the <em>Qt Designer</em>
manual and its accompanying examples provides additional information.

<h2><a name="Data-Aware_Tables">Data-Aware Tables</a></h2> 

\walkthrough sql/overview/table1/main.cpp
\skipto include
\printline include
\printuntil return 0
\printline
<h5 align="center">From \l sql/overview/table1/main.cpp
</h5>

Data-Aware tables require the \c qdatatable.h and \c qsqlcursor.h header
files. We create our application object, call createConnections() and
create the cursor. We create the \l QDataTable passing it a pointer to
the cursor, and set the autoPopulate flag to TRUE. Next we make our \l
QDataTable the main widget and call refresh() to populate it with data
and call show() to make it visible.

The autoPopulate flag tells the \l QDataTable whether or nor it should
create columns based on the cursor. autoPopulate does not affect the
loading of data into the table; that is achieved by the refresh()
function.

\walkthrough sql/overview/table2/main.cpp
\skipto staffCursor
\printline staffCursor
\printuntil show 
<h5 align="center">From \l sql/overview/table2/main.cpp
</h5>

We create an empty \l QDataTable which we make into our main widget and
then we manually add the columns we want in the order we wish them to
appear. For each column we specify the field name and optionally a
display label. 

We have also opted to sort the rows in the table; this could also have
been achieved by applying the sort to the cursor itself.

Once everything is set up we call refresh() to load the data from the
database and show() to make the widget visible.

QDataTables only retrieve visible rows which (depending on the driver)
allows even large tables to be displayed very quickly with minimal
memory cost.

<h2><a name="Creating_Forms">Creating Data-Aware Forms</a></h2> 

Creating data-aware forms is more involved than using data-aware
tables because we must take care of each field individually.  Most of
the code below can be automatically generated by <em>Qt Designer</em>.
See the <em>Qt Designer</em> manual for more details.

<h3><a name="Displaying_a_Record">Displaying a Record</a></h3>

\walkthrough sql/overview/form1/main.cpp
\skipto include
\printline include
\printuntil app.exec
\printline
<h5 align="center">From \l sql/overview/form1/main.cpp
</h5>

We include the header files for the widgets that we need. We also
include \c qsqldatabase.h and \c qsqlcursor.h as usual, but we now add
\c qsqlform.h.

The form will be presented as a dialog so we subclass \l QDialog with
our own FormDialog class. We use a \l QLineEdit for the salary so that
the user can change it. All the widgets are laid out with a grid.

We create a cursor on the staff table, select all records and move to
the first record.

Now we create a \l QSqlForm object and set the QSqlForm's record buffer
to the cursor's update buffer. For each widget that we wish to make
data-aware we insert a pointer to the widget and the associated field
name into the \l QSqlForm. Finally we call readFields() to populate the
widgets with data from the database via the cursor's buffer.

<h3><a name="Editing_a_Record">Editing a Record</a></h3>

This example is similar to the previous one so we will focus on the
differences. 

\walkthrough sql/overview/form2/main.h
\skipto class
\printline class
\printuntil };
<h5 align="center">From \l sql/overview/form2/main.h
</h5>

The save slot will be used for a button that the user can press to
confirm their update. We also hold pointers to the \l QSqlCursor and the
\l QSqlForm since they will need to be accessed outside the constructor.

\walkthrough sql/overview/form2/main.cpp
\skipto setTrimmed
\printline setTrimmed
\printline

We call setTrimmed() on the text fields so that any spaces used to right
pad the fields are removed when the fields are retrieved. 

Properties that we might wish to apply to fields, such as alignment and
validation are achieved in the conventional way, for example, by calling
QLineEdit::setAlignment and QLineEdit::setValidator.

\skipto forenameEdit
\printline forenameEdit

\skipto saveButton
\printline saveButton
\printline connect

The FormDialog constructor is similar to the one in the previous
example. We have changed the forename and surname widgets to QLineEdits
to make them editable and have added a \l QPushButton the user can click
to save their updates.

\skipto saveButton
\printline saveButton

We add an extra row to the grid containing the save button.

\skipto staffCursor
\printline staffCursor
\printuntil first

We create a \l QSqlIndex object and then execute a select() using the
index. We then move to the first record in the result set.

\skipto new QSqlForm
\printline 
\printline 

We create a new QSqlForm object and set it's record buffer to the
cursor's update buffer.

\skipto insert
\printline insert
\printuntil readFields

Now we link the buffer's fields to the \l QLineEdit controls. (In the
previous example we linked the cursor's fields.) The edit controls are
populated by the readFields() call as before.

\skipto FormDialog::
\printline FormDialog::
\printuntil }

In the destructor we don't have to worry about the widgets or QSqlForm
since they are children of the form and will be deleted by Qt at the
right time.

\skipto save
\printline save
\printuntil }

Finally we add the save functionality for when the user presses the save
button. We write back the data from the widgets to the \l QSqlRecord
buffer with the writeFields() call. Then we update the database with the
updated version of the record with the cursor's update() function. At
this point the cursor is no longer positioned at a valid record so we
reissue the select() call using our \l QSqlIndex and move to the first
record.

Link to \l sql/overview/form2/main.cpp

<h2><a name="Custom_Editor_Widgets">Custom Editor Widgets</a></h2> 

QSqlForm uses QSqlPropertyMap to handle the transfer of data between
widgets and database fields. Custom widgets can also be used in a form
by installing a property map that contains information about the
properties of the custom widget which should be used to transfer the
data.

This example is based on the form2 example in the previous section so we
will only cover the differences here. The full source is in
\l sql/overview/custom1/main.h and \l sql/overview/custom1/main.cpp

\walkthrough sql/overview/custom1/main.h
\skipto CustomEdit
\printline CustomEdit
\printuntil };

We've created a simple subclass of QLineEdit and added a property,
upperLineText, which will hold an uppercase version of the text. We also
created a slot, changed.

\skipto propMap
\printline propMap

We will be using a property map so we add a pointer to a property map to
our FormDialog's private data.

\walkthrough sql/overview/custom1/main.cpp
\skipto CustomEdit
\printline CustomEdit
\printuntil }

In the CustomEdit constructor we use the QLineEdit constructor and add a
connection between the textChanged signal and our own changed slot.

\skipto changed
\printline changed
\printuntil }

The changed() slot calls our setUpperLine() function.

\skipto setUpperLine
\printline setUpperLine
\printuntil }

The setUpperLine() function places an uppercase copy of the text in the
upperLineText buffer and then sets the text of the widget to this text. 

Our CustomEdit class ensures that the text entered is always uppercase
and provides a property that can be used with a property map to link
CustomEdit instances directly to database fields.

\skipto FormDialog
\skipto CustomEdit
\printline CustomEdit

\skipto CustomEdit
\printline CustomEdit

We use the same FormDialog as we did before, but this time replace two
of the QLineEdit widgets with our own CustomEdit widgets. 

Laying out the grid and setting up the cursor is the same as before.

\skipto propMap
\printline propMap
\printline propMap

We create a new property map on the heap and register our CustomEdit
class and its upperLine property with the property map.

\skipto QSqlForm
\printline QSqlForm
\printline
\printline propMap

The final change is to install the property map into the QSqlForm once
the QSqlForm has been created. This passes responsibility for the
property map's memory to QSqlForm which itself is owned by the
FormDialog, so Qt will delete them at the right time.

The behaviour of this example is identical to the previous one except
that the forename and surname fields will be uppercase since they use
our CustomEdit widget.

<h3><a name="Custom_Editor_Widgets_for_Tables">
Custom Editor Widgets for QTables</a></h3>

We must reimpliment QSqlEditorFactory to use custom editor widgets in
tables. In the following example we will create a custom editor based on
QComboBox and a QSqlEditorFactory subclass to show how a QTable can use
a custom editor.

\walkthrough sql/overview/table3/main.h
\skipto StatusPicker
\printline StatusPicker
\printuntil }; 
<h5 align="center">From \l sql/overview/table3/main.h
</h5>

We create a property, statusid, and define our READ and WRITE methods
for it. The statusid's in the status table will probably be different
from the combobox's indexes so we create a QMap to map combobox indexes
to/from the statusids that we will list in the combobox.

\skipto CustomSqlEditor
\printline CustomSqlEditor
\printuntil }; 

We also need to subclass QSqlEditorFactory declaring a createEditor()
function since that is the only function we need to reimplement. 

\walkthrough sql/overview/table3/main.cpp
\skipto StatusPicker
\printline StatusPicker
\printuntil index2id
\printline
\printline
<h5 align="center">From \l sql/overview/table3/main.cpp </h5>

In the StatusPicker's constructor we create a cursor over the status
table indexed by the name field. We then iterate over each record in the
status table inserting each name into the combobox. We store the
statusid for each name in the index2id QMap using the same QMap index as
the combobox index.

\skipto StatusPicker
\printline StatusPicker
\printuntil } 

The statusid property READ function simply involves looking up the
combobox's index for the currently selected item in the index2id QMap
which maps combobox indexes to statusids.

\skipto StatusPicker
\printline StatusPicker
\printuntil } 
\printline
\printline

The statusId() function implements the statusid property's WRITE
function. We create an iterator over a QMap and iterate over the
index2id QMap. We compare each index2id element's data (statusid) to the
id parameter's value. If we have a match we set the combobox's current
item to the index2id element's key (the combobox index), and leave the
loop.

When the user edits the status field in the QDataTable they will be
presented with a combobox of valid status names taken from the status
table. However the status displayed is still the raw statusid. To
display the status name when the field isn't being edited requires us to
subclass QDataTable and reimplement the paintField() function.

\walkthrough sql/overview/table4/main.h
\skipto CustomTable
\printline CustomTable
\printuntil };
<h5 align="center">From \l sql/overview/table4/main.h </h5>

We simply call the original QDataTable constructor without changing
anything. We also declare the paintField function.

\walkthrough sql/overview/table4/main.cpp
\skipto CustomTable
\printline CustomTable
\printuntil QDataTable
\printline
<h5 align="center">From \l sql/overview/table4/main.cpp </h5>

The paintField code is based on QDataTable's source code. We need to make
three changes. Firstly add an if clause <tt>field-&gt;name() ==
"statusid"</tt> and look up the textual value for the id with a
straighforward QSqlQuery. Secondly call the superclass to handle other
fields. The last change is in our main function where we change
staffTable from being a QDataTable to being a CustomTable. 

<h2><a name="Subclassing_QSqlCursor">Subclassing QSqlCursor</a></h2>

\walkthrough sql/overview/subclass1/main.cpp
\skipto include
\printline include
\printuntil return 1
\printline
<h5 align="center">From \l sql/overview/subclass1/main.cpp
</h5>

This example is very similar to the table1 example presented earlier. We
create a cursor, add the fields and their display labels to a QDataTable,
call refresh() to load the data and call show() to show the widget.

Unfortunately this example is unsatisfactory. It is tedious to set the
table name and any custom characteristics for the fields every time we
need a cursor over this table. And it would be far better if we
displayed the name of the product rather than its pricesid. Since we
know the price of the product and the quantity we could also show the
product cost and the cost of each invoiceitem. Finally it would be
useful (or even essential for primary keys) if we could default some of
the values when the user adds a new record. 

\walkthrough sql/overview/subclass2/main.h
\skipto InvoiceItem
\printline InvoiceItem
\printuntil };
\printline
<h5 align="center">From \l sql/overview/subclass2/main.h
</h5>

We have created a separate header file and subclassed QSqlCursor.

\walkthrough sql/overview/subclass2/main.cpp
\skipto InvoiceItem
\printline InvoiceItem
\printuntil }
<h5 align="center">From \l sql/overview/subclass2/main.cpp
</h5>

In our class's constructor we call the QSqlCursor constructor with the
name of the table. We don't have any other characteristics to add at this
stage.

\skipto InvoiceItemCursor
\printline InvoiceItemCursor

Whenever we require a cursor over the invoiceitem table we can create an
InvoiceItemCursor instead of a generic QSqlCursor. 

We still need to show the product name rather than the pricesid.

\walkthrough sql/overview/subclass3/main.h
\skipto protected
\printline protected
\printline
<h5 align="center">From \l sql/overview/subclass3/main.h
</h5>

The change in the header file is minimal: we simply add the signature of
the calculateField() function since we will be reimplementing it.

\walkthrough sql/overview/subclass3/main.cpp
\skipto InvoiceItem
\printline InvoiceItem
\printuntil return QVariant
\printline
<h5 align="center">From \l sql/overview/subclass3/main.cpp
</h5>

We have changed the InvoiceItemCursor constructor. We now create a new
QSqlField called productname and append this to the InvoiceItemCursor's
set of fields. We call setCalculated() on productname to identify it as
a calculated field. The first argument to setCalculated() is the field
name, the second a bool which if TRUE signifies that calculateField()
must be called to get the field's value.

\skipto addColumn
\printline addColumn

We add our new fields with addColumn() which adds them to the form and
sets their display names.

We have to define our own calculateField() function. In our example
database the pricesid in the invoiceitem table is a foreign key into the
prices table. We find the name of the product by executing a query on
the prices table using the pricesid. This returns the product's name.

We are now able to extend the example to include calculated fields which
perform real calculations.

The header file, \l sql/overview/subclass4/main.h, remains unchanged
from the previous example, but the constructor and calculateField()
function require some simple expansion. We'll look at each in turn.

\walkthrough sql/overview/subclass4/main.cpp
\skipto InvoiceItem
\printline InvoiceItem
\printuntil }
<h5 align="center">From \l sql/overview/subclass4/main.cpp
</h5>

We create two extra fields, price and cost, and append them to the
cursor's set of fields. Both are registered as calculated fields with
calls to setCalculated().

\skipto InvoiceItem
\printline InvoiceItem
\printuntil QString::null
\printline
<h5 align="center">From \l sql/overview/subclass4/main.cpp
</h5>

The calculateField() function has expanded slightly because now we must
calculate the value of three different fields. The productname and price
fields are produced by looking up the corresponding values in the prices
table keyed by pricesid. The cost field is calculated simply by
multiplying the price by the quantity. Note that we cast the cost to a
QVariant since that is the type that calculateField() must return.

We've written three separate queries rather than one to make the example
more like a real application where it is more likely that each
calculated field would be a lookup against a different table or view.

The last feature that we need to add is defaulting values when the user
attempts to insert a new record. 

\walkthrough sql/overview/subclass5/main.h
\skipto primeInsert
\printline primeInsert
<h5 align="center">From \l sql/overview/subclass5/main.h
</h5>

We declare our own primeInsert() function since we will need to
reimplement this.

The constructor and the calculateField() function remain unchanged.

\walkthrough sql/overview/subclass5/main.cpp
\skipto primeInsert
\printline primeInsert
\printuntil }
<h5 align="center">From \l sql/overview/subclass5/main.cpp
</h5>

We get a pointer to the internal edit buffer that the cursor uses for
inserts and updates. The id field is a unique integer that we generate
using the invoiceitem_seq. We default the value of the paiddate field to
today's date and default the quantity to 1. Finally we return a pointer
to the buffer. The rest of the code is unchanged from the previous
version.

<h2><a name="Appendix_1_Tables">Appendix 1: The Example Tables</a></h2> 

The example tables used can be recreated with the following standard SQL.
You may need to modify the SQL to match that used by your particular
database. 

\code
create table people (id integer primary key, name char(40));

create table staff (id integer primary key, forename char(40),
		    surname char(40), salary float, statusid integer);

create table status (id integer primary key, name char(30));

create table creditors (id integer primary key, forename char(40),
			surname char(40), city char(30));

create table prices (id integer primary key, name char(40), price float);

create table invoiceitem (id integer primary key, 
			  pricesid integer, quantity integer,
			  paiddate date);
\endcode 

A sequence was used in the calculateField() example above.  Note that
sequences are not supported in all databases.

\code
create sequence invoiceitem_seq;
\endcode

*/
