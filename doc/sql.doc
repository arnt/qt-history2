/****************************************************************************
** $Id: //depot/qt/main/doc/sql.doc#1 $
**
** Documentation for sql programming
**
** Copyright (C) 1992-2000 Trolltech AS.  All rights reserved.
**
** This file is part of the Qt GUI Toolkit.
**
** This file may be distributed under the terms of the Q Public License
** as defined by Trolltech AS of Norway and appearing in the file
** LICENSE.QPL included in the packaging of this file.
**
** This file may be distributed and/or modified under the terms of the
** GNU General Public License version 2 as published by the Free Software
** Foundation and appearing in the file LICENSE.GPL included in the
** packaging of this file.
**
** Licensees holding valid Qt Enterprise Edition or Qt Professional Edition
** licenses may use this file in accordance with the Qt Commercial License
** Agreement provided with the Software.
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
**   information about Qt Commercial License Agreements.
** See http://www.trolltech.com/qpl/ for QPL licensing information.
** See http://www.trolltech.com/gpl/ for GPL licensing information.
**
** Contact info@trolltech.com if any conditions of this licensing are
** not clear to you.
**
**********************************************************************/
/*! \example sql/overview/connect1/main.cpp */
/*! \example sql/overview/create_connections/main.cpp  */
/*! \example sql/overview/basicbrowsing/main.cpp */
/*! \example sql/overview/basicbrowsing2/main.cpp */
/*! \example sql/overview/basicdatamanip/main.cpp */
/*! \example sql/overview/navigating/main.cpp */
/*! \example sql/overview/retrieve1/main.cpp */
/*! \example sql/overview/retrieve2/main.cpp */
/*! \example sql/overview/order1/main.cpp */
/*! \example sql/overview/order2/main.cpp */
/*! \example sql/overview/extract/main.cpp */
/*! \example sql/overview/insert/main.cpp */
/*! \example sql/overview/update/main.cpp */
/*! \example sql/overview/del/main.cpp */
/*! \example sql/overview/table1/main.cpp */
/*! \example sql/overview/table2/main.cpp */
/*! \example sql/overview/form1/main.cpp */
/*! \example sql/overview/form2/main.h */

/*! \page sql.html

\title SQL Overview [DRAFT #1]

<ul>
<li><a href="#Introduction">Introduction</a></li>
<li><a href="#Connecting_to_Databases">Connecting to Databases</a></li> 
    <ul>
    <li><a href="#Connecting_to_a_Single_Database">
    Connecting to a Single Database</a></li>
    <li><a href="#Connecting_to_Multiple_Databases">
    Connecting to Multiple Databases</a></li>
    </ul>
<li><a href="#Executing_SQL_commands">
Executing SQL Commands Using QSqlQuery</a></li> 
    <ul>
    <li><a href="#Basic_Browsing">Basic Browsing</a></li> 
    <li><a href="#Basic_Data_Manipulation">Basic Data Manipulation</a></li> 
    <li><a href="#Navigating_Result_Sets">Navigating Result Sets</a></li> 
    </ul>
<li><a href="#Using_QSqlCursor">Using QSqlCursor</a></li> 
    <ul>
    <li><a href="#Retrieving_Records">Retrieving Records</a></li>
	<ul>
	<li><a href="#Sorting_Data">Sorting and Filtering Records</a></li>
	<li><a href="#Extracting_Data">Extracting Data</a></li>
	</ul>
    <li><a href="#Manipulating_Records">Manipulating Records</a></li>
	<ul>
	<li><a href="#Inserting_Records">Inserting Records</a></li>
	<li><a href="#Updating_Records">Updating Records</a></li>
	<li><a href="#Deleting_Records">Deleting Records</a></li>
	</ul>
    </ul>
<li><a href="#Data-Aware_Widgets">Data-Aware Widgets</a></li> 
    <ul>
    <li><a href="#Data-Aware_Tables">Data-Aware Tables</a></li> 
    <li><a href="#Creating_Forms">Creating Data-Aware Forms</a></li> 
	<ul>
	<li><a href="#Displaying_a_Record">Displaying a Record</a></li>
	<li><a href="#Editing_a_Record">Editing a Record</a></li>
	</ul>
    <li><a href="#Custom_Editor_Widgets">Custom Editor Widgets</a></li> 
    </ul>
<li><a href="#Appendix_1_Tables">Appendix 1: The Example Tables</a></li> 
</ul>

<h1><a name="Introduction">Introduction</a></h1>

Qt's SQL classes help you provide seamless database integration with
your Qt applications.

<blockquote>
This overview assumes that you have at least a basic knowledge of SQL.
You should be able to understand simple \c SELECT, \c INSERT, \c UPDATE
and \c DELETE commands. Although the \l QSqlCursor class provides an
interface to database browsing and editing that does not \e require a
knowledge of SQL, a basic understanding of SQL is highly recommended. A
standard text covering SQL databases is <em>An Introduction to Database
Systems (7th ed.)</em> by C. J. Date, ISBN 0201385902.
</blockquote>

The SQL classes are divided into three layers:

<em>User Interface Layer.</em> These classes provide data-aware
widgets that can be connected to tables or views in the database. End
users can interact directly with these widgets to browse or edit
data. <em>Qt Designer</em> is fully integrated with the SQL classes and
can be used to create data-aware forms. The data-aware widgets can also
be programmed directly with your own C++ code. 

<em>SQL API Layer.</em> These classes provide access to databases.
Connections are made using the \l QSqlDatabase class. Database
interaction is achieved either by writing SQL commands and using the \l
QSqlQuery class or by using the high level \l QSqlCursor class which
composes SQL commands automatically.

<em>Driver Layer.</em> This comprises three classes, \l QSqlResult,
\l QSqlDriver and \l QSqlDriverInterface. This layer provides the low
level bridge between the database and the SQL classes. This layer is
documented separately since it is only relevant to driver writers.

This overview comprises four sections:

<a href="#Connecting_to_Databases">Connecting to Databases</a>. 
This section explains how to set up database connections using the \l
QSqlDatabase class.

<a href="#Executing_SQL_commands">Executing SQL Commands Using QSqlQuery</a>. 
This section demonstrates how to issue the standard data manipulation
commands, \c SELECT, \c INSERT, \c UPDATE and \c DELETE on tables in the
database. The focus is purely on database interaction using \l
QSqlQuery.

<a href="#Using_QSqlCursor">Using QSqlCursor</a>. This section explains
how to use QSqlCursors which provide a simpler API than the raw SQL used
with \l QSqlQuery. 

<a href="#Data-Aware_Widgets">Data-Aware Widgets</a>. This section shows
how to programmatically link your database to the user interface. In
this section we introduce the \l QSqlTable, \l QSqlForm, \l QSqlDialog,
\l QSqlNavigator, \l QSqlPropertyMap and QSqlWidget classes. Also
covered are custom data-aware widgets and the \l QSqlEditorFactory
class. <em>Qt Designer</em> provides an easy visual way of achieving the
same thing and this is documented in the <em>Qt Designer</em> manual.

<h1><a name="Connecting_to_Databases">Connecting to Databases</a></h1> 

If the application only needs a single database connection the
\l QSqlDatabase class can create a connection which is used by default
for all SQL operations. If multiple database connections are required
these can easily be set up. 

At least one database connection must be created and opened before the
\l QSqlQuery or \l QSqlCursor classes can be used.

\l QSqlDatabase requires the \c qsqldatabase.h header file.

<h2>Connecting to a Single Database</h2>

Making a database connection is a simple three step process: activate
the driver, set up the connection information, open the connection.

\dontinclude sql/overview/connect1/main.cpp
\skip include
\line include
\until return 0
\line
<h5 align="center">From \l sql/overview/connect1/main.cpp </h5>

First we activate the driver by calling \l QSqlDatabase::addDatabase().
We pass the name of the driver we wish to use. The drivers currently
available are: QODBC (Open Database Connectivity), QOCI (Oracle), QPSQL6
(PostgreSQL 6), QPSQL7 (PostgreSQL 7) and QMYSQL (MySQL). This
connection is the application's default database connection and will be
used if no database is specified in \l QSqlCursor or \l QSqlQuery calls.
If the driver is not available the application will print a warning to
\c stderr.

Second we call setDatabaseName(), setUserName(), setPassword() and
setHostName() to set up the connection information. These calls always
succeed.

Third we call open() to give us access to the data. If this call fails
it will return FALSE. 

<h2>Connecting to Multiple Databases</h2>

Connecting to multiple databases is achieved using the two argument form
of \l QSqlDatabase::addDatabase() where the second argument is a unique
identifier distinguishing the connection.

<a name="create_connections"/>
\dontinclude sql/overview/create_connections/main.cpp
\skip include
\line include
\until return true 
\line
<h5 align="center">From \l sql/overview/create_connections/main.cpp 
</h5>

In the example above we have moved the connections into their own
function, create_connections(), and added some basic error handling. The
static function \l QSqlDatabase::database() can be called from anywhere
to provide a pointer to a database connection. If we call it without any
parameter it will return the default connection. If called with the
identifier we've used for a connection, e.g. "ORACLE", in the above
example, it will return a pointer to the specified connection.

Note that in the code above we did not need to retrieve a pointer to the
ODBC connection. This connection was not named and is therefore used as
the default connection. 

<h1><a name="Executing_SQL_commands">Executing SQL Commands Using QSqlQuery</a></h1> 

The \l QSqlQuery class provides an interface for executing SQL commands.
It also has functions for navigating through the result sets of \c SELECT
queries and for retrieving individual records and fields.

The \l QSqlCursor class described in the next section inherits from \l
QSqlQuery and provides a higher level interface that composes the SQL
commands for us. \l QSqlCursor is particularly easy to integrate with
on-screen widgets. Programmers unfamiliar with SQL can safely skip this
section and use the \l QSqlCursor class covered in 
<a href="#Using_QSqlCursor">"Using QSqlCursor"</a>.

<h2><a name="Basic_Browsing">Basic Browsing</a></h2> 

\dontinclude sql/overview/basicbrowsing/main.cpp
\skip include
\line include
\until return 0 
\line
<h5 align="center">From \l sql/overview/basicbrowsing/main.cpp
</h5>

In the example above we've added an additional header file, 
\c qsqlquery.h. The first query we create, \c target, uses the default
database and is initially empty. For the second query, \c q, we specify
the "ORACLE" database that we want to retrieve records from. Both the
database connections were set up in the create_connections() function we
wrote earlier.

After creating the initial \c SELECT statement we call \l isActive() to
see if it executed successfully. The \l next() function is used to
iterate through the query results. The value() function returns the
contents of fields as \l QVariants. The insertions are achieved by
creating and executing queries against the default database using the \c
target QSqlQuery.

\dontinclude sql/overview/basicbrowsing2/main.cpp
\skip count
\line 
\until numRows 
\line
\line
<h5 align="center">From \l sql/overview/basicbrowsing2/main.cpp
</h5>

The above code introduces a count of how many records are successfully
inserted. Note that \l isActive() returns FALSE if the query, e.g. the
insertion, fails. \l numRowsAffected() returns -1 if the number of rows
cannot be determined, e.g. if the query fails.

<h2><a name="Basic_Data_Manipulation">Basic Data Manipulation</a></h2> 

\dontinclude sql/overview/basicdatamanip/main.cpp
\skip main
\line main
\until return ( rows 
\line
<h5 align="center">From \l sql/overview/basicdatamanip/main.cpp
</h5>

This example demonstrates straightforward SQL DML (data manipulation
language) commands. Since we did not specify a database in the \l
QSqlQuery constructor the default database is used. \l QSqlQuery objects
can also be used to execute SQL DDL (data definition language) commands
such as <tt>CREATE TABLE</tt> and <tt>CREATE INDEX</tt>. 

<h2><a name="Navigating_Result_Sets">Navigating Result Sets</a></h2> 

Once a \c SELECT query has been executed successfully we will have
access to the result set of records that matched the query criteria. We
have already used one of the navigation functions, next(), which can be
used alone to step sequentially through the records. \l QSqlQuery also
provides \l first(), \l last(), \l next() and \l prev(). After any of
these commands we can check that we are on a valid record by calling \l
isValid(). 

We can also navigate to any arbitrary record using \l seek(). The first
record in the dataset is zero. The number of the last record is 
<tt>size() - 1</tt>. Not all databases provide the size of a \c SELECT
query and in such cases \l size() returns -1.

\dontinclude sql/overview/navigating/main.cpp
\skip if (
\line if (
\until i == 4 
\line
<h5 align="center">From \l sql/overview/navigating/main.cpp
</h5>

The example above shows some of the navigation functions in use. 

Once we have located the record we are interested in we may wish to
retrieve data from it. 

\dontinclude sql/overview/retrieve1/main.cpp
\skip if (
\line if (
\until debug 
\line
\line
\line
\line
<h5 align="center">From \l sql/overview/retrieve1/main.cpp
</h5>

Note that if you wish to iterate through the record set in order the
only navigation function you need is next().

Tip: The \l lastQuery() function returns the text of the last query
executed. This can be useful to check that the query you think is being
executed is the one actually being executed.

<h1><a name="Using_QSqlCursor">Using QSqlCursor</a></h1> 

The \l QSqlCursor class provides a high level interface to browsing and
editing records in SQL databases without the need to write your own SQL.

QSqlCursors can do almost everything that QSqlQuery can, with two
exceptions. \l QSqlCursor objects retrieve all the fields of each
record. If only some fields are relevant simply confine your processing
to those and ignore the others. However, if you really don't want to
retrieve some fields then you will need to use a \l QSqlQuery instead.
You can edit records using a \l QSqlCursor providing that the table or
view has a primary index that uniquely distinguishes each record. If
this condition is not met then you'll need to use a \l QSqlQuery for
edits.

Before we can use \l QSqlCursor objects we must first
create and open a database connection. Connecting is described in the 
<a href="#Connecting_to_Databases">"Connecting to Databases"</a> section
earlier. For the examples that follow we will assume that the
connections have been created using the create_connections() function
defined in the <a href="#create_connections">QSqlDatabase example</a>
presented earlier.

The \l QSqlCursor class requires the \c qsqlcursor.h header file.

<h2><a name="Retrieving_Records">Retrieving Records</a></h2>

\dontinclude sql/overview/retrieve2/main.cpp
\skip include
\line include
\until return 0 
\line
<h5 align="center">From \l sql/overview/retrieve2/main.cpp
</h5>

We create the \l QSqlCursor object, specifying the table or view to use.
If we need to use a database other than the default we can specify that
in the constructor too, e.g.
\code
    QSqlCursor cur( "staff", "MYSQL" ); 
\endcode
This assumes that we have successfully opened and created a connection
which we've called "MYSQL". 

The SQL executed by this <tt>cur.select()</tt> call is<br> 
\code
    SELECT * FROM staff;
\endcode

<h3><a name="Sorting_Data">Sorting and Filtering Records</a></h3>

To specify a subset of records to retrieve we can pass some criteria
to the select() call that the records must meet.
\code
    cur.select( "id > 100" );
\endcode
This select() call will execute the SQL<br>
\code
    SELECT * FROM staff WHERE id > 100;
\endcode

This will retrieve only those staff whose \c id is greater than 100.

In addition to retrieving selected records we often want to specify a
sort order. We achieve this by creating a \l QSqlIndex object which
contains the names of the field(s) we wish to sort by and pass this
object to the select() call.

\code
    QSqlCursor cur( "staff" );
    QSqlIndex nameIndex = cur.index( "surname" ); 
    cur.select( nameIndex );
\endcode

Here we create a \l QSqlIndex object with one field, "surname". When we
call the select() function we pass in the index object. Each field in
the index object is used in the ORDER BY clause of the select statement.
The SQL executed here is 
\code
    SELECT * FROM staff ORDER BY surname;
\endcode

Combining the retrieval of a subset of records and ordering the results
is straightforward.
\code
    cur.select( "surname LIKE 'A%'", nameIndex );
\endcode
We pass in a criteria string (the WHERE clause), and the \l QSqlIndex
object to sort by. This produces
\code
    SELECT * FROM staff WHERE surname LIKE 'A%' ORDER BY surname;
\endcode

To use more than one ordering field create a \l QStringList and pass
that to the cursor object's index() function.

\dontinclude sql/overview/order1/main.cpp
\skip QSqlCursor
\line QSqlCursor
\until while 
<h5 align="center">From \l sql/overview/order1/main.cpp
</h5>

Here we create a string list containing the fields we wish to sort by,
in the order they are to be used. Then we create a \l QSqlIndex object
based on these fields, finally executing the select() call using this
index. This executes
\code
    SELECT * from staff ORDER BY surname, forename;
\endcode

If we need to retrieve records with fields that match specific criteria we
can create a filter.

\dontinclude sql/overview/order2/main.cpp
\skip QSqlCursor
\line QSqlCursor
\until while 
<h5 align="center">From \l sql/overview/order2/main.cpp
</h5>

This executes
\code
    SELECT * FROM staff WHERE surname='Bloggs' ORDER BY id, forename;
\endcode

The "order" \l QSqlIndex contains two fields, "id" and "forename" which
are used to order the results. The "filter" \l QSqlIndex contains a
single field, "surname". When a filter is passed to the select()
function for each field in the filter a <em>fieldname=value</em>
subclause is created with the value being the current cursor's value for
that field. We use setValue() to ensure the value used is the one we
want.

<h3><a name="Extracting_Data">Extracting Data</a></h3>

\dontinclude sql/overview/extract/main.cpp
\skip QSqlCursor
\line QSqlCursor
\until debug
\line
<h5 align="center">From \l sql/overview/extract/main.cpp
</h5>

In this example we begin by creating a cursor on the creditors table. We
create two \l QSqlIndex objects. The first, "order", is created from the
"orderFields" string list. The second, "filter", is created from the
"filterFields" string list. We set the values of the two fields used in
the filter, "surname" and "city", to the values we're interested in. Now
we call select() which generates and executes the following SQL:
\code
    SELECT * FROM creditors WHERE surname='Chirac' AND city='Paris' 
			    ORDER BY surname, forename;
\endcode
The filter fields are used in the WHERE clause. Their values are taken
from the cursor's current values for those fields; we set these values
ourselves with the setValue() calls. The order fields are used in the
ORDER BY clause. 

Now we iterate through each matching record (if any). We retrieve the
contents of the id, forename and surname fields and pass them on to some
processing function, in this example a simple debug() call.

<h2><a name="Manipulating_Records">Manipulating Records</a></h2>

Records can be inserted, updated or deleted in a table using a \l
QSqlCursor providing that the table or view has a primary index that
uniquely distinguishes each record. If this is not the case a \l
QSqlQuery must be used instead.

Once we've called insert(), update() or del() the cursor will no longer
be positioned on a valid record. If we need to move to a record we must
make a fresh select() call.

<h3><a name="Inserting_Records">Inserting Records</a></h3>

\dontinclude sql/overview/insert/main.cpp
\skip QSqlCursor
\line QSqlCursor
\until } 
<h5 align="center">From \l sql/overview/insert/main.cpp
</h5>

In this example we create a cursor on the "prices" table. Next we create
a list of product names which we iterate over. For each iteration we
call the cursor's \l primeInsert() method. This method returns a pointer
to a \l QSqlRecord buffer in which all the fields are set to \c NULL. Next
we call setValue() for each field that requires a value. Finally we call
insert() to insert the record. The insert() call returns the number of
rows inserted.

In this example we obtain a pointer to a \l QSqlRecord object from the
primeInsert() call. QSqlRecord objects can hold the data for a single
record plus some meta-data about the record. In practice most
interaction with a QSqlRecord consists of simple value() and setValue()
calls as shown in this and the following example. 

<h3><a name="Updating_Records">Updating Records</a></h3>

\dontinclude sql/overview/update/main.cpp
\skip QSqlCursor
\line QSqlCursor
\until update
\line
<h5 align="center">From \l sql/overview/update/main.cpp
</h5>

This example begins with the creation of a cursor over the prices table.
We select the record we wish to update with the select() call and
move to it with the next() call. We call primeUpdate() to get a \l
QSqlRecord pointer whose buffer is populated with the contents of the
current record. We retrieve the value of the price field, calculate a
new price, and set the the price field to the newly calculated value.
Finally we call update() to update the record. The update() call returns
the number of rows updated.

If many identical updates need to be performed, for example increasing
the price of every item in the price list, using a single SQL statement
with \l QSqlQuery is more efficient, e.g.

\code
    QSqlQuery q( "UPDATE prices SET price = price * 1.05;"  );
\endcode

<h3><a name="Deleting_Records">Deleting Records</a></h3>

\dontinclude sql/overview/del/main.cpp
\skip QSqlCursor
\line QSqlCursor
\until del
\line
<h5 align="center">From \l sql/overview/del/main.cpp
</h5>

We create the cursor, select the record we want to delete, move to the
record, and call del(). 

As with update(), if multiple deletions need to be made with some common
criteria it is more efficient to do so using a single SQL statement,
e.g.

\code
    QSqlQuery q( "DELETE FROM prices WHERE id >= 2450 AND id <= 2500;" );
\endcode

<h1><a name="Data-Aware_Widgets">Data-Aware Widgets</a></h1> 

Data-Aware Widgets provide a simple yet powerful means of connecting
databases to Qt user interfaces. The easiest way of creating and
manipulating data-aware widgets is with <em>Qt Designer</em>. However,
for those who prefer a purely programmatic approach the following
examples and explanations provide the introduction you need. 

<h2><a name="Data-Aware_Tables">Data-Aware Tables</a></h2> 

\dontinclude sql/overview/table1/main.cpp
\skip include
\line include
\until return 1
\line
<h5 align="center">From \l sql/overview/table1/main.cpp
</h5>

Data-Aware tables require the \c qsqltable.h and \c qsqlcursor.h header
files. We create our application object, call create_connections() and
create the cursor. We create the \l QSqlTable passing it a pointer to
the cursor, and set the autoPopulate flag to TRUE. Next we make our \l
QSqlTable the main widget and call refresh() to populate it with data
and call show() to make it visible.

The autoPopulate flag tells the \l QSqlTable whether or nor it should
create columns based on the cursor. autoPopulate does not affect the
loading of data into the table; that is achieved by the refresh()
function.

Although the example above demonstrates how simple it is to link a
database cursor to a \l QSqlTable widget, in a real application we would
want to specify the order in which the columns appear and the label
each column is given.

\dontinclude sql/overview/table2/main.cpp
\skip staffCursor
\line staffCursor
\until show 
<h5 align="center">From \l sql/overview/table2/main.cpp
</h5>

Once we've created the cursor we set up the display labels for the
fields we wish to show using \l setDisplayLabel(). Columns align left by
default but numeric fields are normally shown aligned right. We call
setAlignment() to make the salary field align correctly. 

Once we've set up the display characteristics we create a \l QSqlTable,
this time setting autoPopulate to FALSE so that no columns are created.
We make the table our main widget.

We manually add the columns we want in the order we wish them to appear.
We have also opted to sort the rows in the table; this could also have
been achieved by applying the sort to the cursor itself.

Once everything is set up we call refresh() to load in the data and
show() to make the widget visible.

QSqlTables only retrieve visible rows which allows even large tables to
be displayed with minimal memory cost.

<h2><a name="Creating_Forms">Creating Data-Aware Forms</a></h2> 

Creating data-aware forms is more involved that using data-aware tables
because we must take care of each field individually. 

<h3><a name="Displaying_a_Record">Displaying a Record</a></h3>

\dontinclude sql/overview/form1/main.cpp
\skip include
\line include
\until app.exec
\line
<h5 align="center">From \l sql/overview/form1/main.cpp
</h5>

We include the header files for the widgets that we need. We also
include \c qsqldatabase.h and \c qsqlcursor.h as usual, but we now add
\c qsqlform.h.

The form will be presented as a dialog so we subclass \l QDialog with
our own FormDialog class. In FormDialog's constructor we create some
labels to show the forename and surname. We use a \l QLineEdit for the
salary so that the user can change it. All the widgets are laid out with
a grid.

We create a cursor on the staff table, select all records and move to
the first record.

Now we create a \l QSqlForm object. For each widget that we wish to make
data-aware we insert a pointer to the widget and the associated field
into the \l QSqlForm. Finally we call the QSqlForm's readFields()
function to populate the widgets with data from the database.

<h3><a name="Editing_a_Record">Editing a Record</a></h3>

This example is similar to the previous one so we will focus on the
differences.

\dontinclude sql/overview/form2/main.h
\skip class
\line class
\until };
<h5 align="center">From \l sql/overview/form2/main.h
</h5>

The save slot will be used for a button that the user can press to
confirm their update. We also hold pointers to the \l QSqlCursor and \l
QSqlForm since they will need to be accessed outside the constructor.


\dontinclude sql/overview/form2/main.cpp
\skip forenameEdit
\line forenameEdit

\skip saveButton
\line saveButton
\line connect

The FormDialog constructor is similar to the one in the previous
example. We have changed the forename and surname widgets to QLineEdits
to make them editable and have added a \l QPushButton the user can click
to save their updates.

\skip saveButton
\line saveButton

We add an extra row to the grid containing the save button.

\skip staffCursor
\line staffCursor
\until first

We create the \l QSqlCursor dynamically, create a \l QSqlIndex object
and then execute a select() using the index. We then move to the first
record in the result set.

\skip buffer
\line buffer

We get a pointer to the cursor's update buffer by calling primeUpdate().
This buffer is populated with the current record's data. 

\skip insert
\line insert
\until readFields

Now we link the buffer's fields to the \l QLineEdit controls. (In the
previous example we linked the cursor's fields.) The edit controls are
populated by the readFields() call as before.

\skip FormDialog::
\line FormDialog::
\until }

In the destructor we delete the \l QSqlCursor and \l QSqlForm we created
in the constructor. We don't have to worry about the widgets since they
are children of the form and will be deleted by Qt at the right time.

\skip save
\line save
\until }

Finally we add the save functionality for when the user presses the save
button. We write back the data from the widgets to the \l QSqlRecord
buffer with the writeFields() call. Then we update the database with the
updated version of the record with the cursor's update() function. At
this point the cursor is no longer positioned at a valid record so we
reissue the select() call using our \l QSqlIndex and move to the first
record.

<em>Listing of \l form2/main.cpp </em>

<h2><a name="Custom_Editor_Widgets">Custom Editor Widgets</a></h2> 

<h2><a name="Appendix_1_Tables">Appendix 1: The Example Tables</a></h2> 

The example tables used can be recreated with the following standard SQL.
You may need to modify the SQL to match that used by your particular
database.

\code
create table people (id integer primary key, name char(40));

create table staff (id integer primary key, forename char(40),
		    surname char(40), salary float);

create table creditors (id integer primary key, forename char(40),
			surname char(40), city char(30));

create table prices (id integer primary key, name char(40), price float);
\endcode

*/

/*! \page sql-old.html

\title Qt SQL Module

The Qt SQL module provides classes to access SQL databases in a
uniform way across different platforms and across different SQL
database servers. 

The Qt SQL module contains three layers of classes:

<em>Driver Layer</em>

Connections to SQL database servers at a low level are handled by the
\l QSqlDriver and \l QSqlResult abstract classes.  These classes
provide an interface for database-specific derived classes to
implement the actual connections to specific SQL servers.  All
low-level interaction with the SQL servers is handled by these
drivers.

<em>SQL Layer</em>

At a higher level, QSqlQuery and QSqlCursor provide functionality to
send SQL queries (\c INSERT, \c UPDATE, \c DELETE, etc.) to a database
and to return results (i.e., data) from those queries.  \l QSqlField,
\l QSqlRecord and \l QSqlIndex are helper classes which represent SQL
fields, records and indexes respectively.

<em>Widget Layer</em>

\l QSqlTable and \l QSqlForm display data from SQL databases.  There are
also helper classes such as \l QSqlPropertyMap and \l QSqlEditorFactory
which help 'glue' together the GUI to the SQL database in your
applications.

An <a href="sql-walkthrough.html">example application walkthrough</a> is
provided.

<h2>Connecting to the database</h2>

Connections to SQL databases are encapsulated by the QSqlDatabase
class.  QSqlDatabase can establish a connection to a single database
using a QSqlDriver appropriate for that database.  There are also
QSqlDatabase static functions which manage connections to multiple SQL
databases using application-specific names.

To establish a single connection to a SQL database, use the
QSqlDatabase::addDatabase() function.  If a database is added without a
name, it becomes the application's 'default' database connection.  The
default connection is used by other Qt SQL classes if a database
connection is not passed to them.  A database connection can be
retrieved by passing the database name to QSqlDatabase::database().  If
no name is given, the default connection is returned.  For example:

\code
    // create an ODBC connection, which is the default database connection
    // for the application
    QSqlDatabase* defaultConnection = QSqlDatabase::addDatabase( "QODBC" );
    if ( defaultConnection ) {
        defaultConnection->setDatabaseName( "sales" );
        defaultConnection->setUserName( "Dave" );
        defaultConnection->setPassword( "dolphin" );
        defaultConnection->setHostName( "saleshost" );
        ...
    }
\endcode

To establish multiple connections to different databases, use
QSqlDatabase::addDatabase() repeatedly, specifying unique database
names which will be used by application code.  For example:

\code
    QSqlDatabase* defaultConnection = QSqlDatabase::addDatabase( "QODBC" );
    QSqlDatabase* oracleConnection = QSqlDatabase::addDatabase( "QOCI", "oracle" );
    QSqlDatabase* mysqlConnection = QSqlDatabase::addDatabase( "QMYSQL", "mysql" );
\endcode

These connections can be used later by calling the
QSqlDatabase::database() static function, and passing the name of the
desired connection:

\code
    QSqlDatabase* db = QSqlDatabase::database( "oracle" ); // get the oracle connection
    QSqlQuery q1( "select * from emp;", db );              // and use it in a query
    QSqlQuery q2( "select name from Employee;" );          // uses the default application connection
\endcode

At least one QSqlDatabase must be created and opened in order to use
the other Qt SQL classes (such as \l QSqlQuery and \l QSqlCursor),
since these classes communicate with the database through QSqlDatabase.
QSqlDatabase provides information about objects within the database
such as tables, views and indexes.  For example:

\code
    // get the default database connection
    QSqlDatabase* db = QSqlDatabase::database();
    // list all tables and views
    QStringList list = db->tables();
    // find out some information on the 'Employee' table
    QSqlRecord r = QSqlDatabase::record( "Employee" );
    // 
\endcode

QSqlDatabase also manages transactions for the database connection (if
the driver supports transactions):

\code
    QSqlDatabase* db = QSqlDatabase::database();
    if ( db->driver()->hasTransactionSupport() ) {
        // start a transaction
        db->transaction();
        // update the database...
        ...
        // commit all changes
        db->commit();
    }
\endcode

Login parameters such as the user name and password, database name and
hostname must be set before a connection can be opened.  The calls to \c
setDatabaseName(), and the other "set" functions always succeed. To open
a connection to the database, use the open() function.  In the event of
an error, lastError() will return error information.  For example:

\code
    QSqlDatabase* db = QSqlDatabase::database();
    db->setDatabaseName( "sales" );
    db->setUserName( "Dave" );
    db->setPassword( "dolphin" );
    db->setHostName( "saleshost" );
    if ( !db->open() ) {
	QSqlError err = db->lastError();
        ...
        return;
    }
\endcode

If a Qt SQL class attempts to use the default database connection
(returned by QSqlDatabase::database()), and the database is not yet
opened, an open() is attempted before the database is used.  If a
database connection is no longer needed, QSqlDatabase::close() will
close the database.  Or, the static function
QSqlDatabase::removeDatabase() will close and permanently remove the
database from the list of available connections.  Note that there
should be no active queries left in your application when closing a
database otherwise there will be a resource leak.

<h2>Fields, Records and Indexes</h2>

Field, record and index classes are non-visual classes that are
primarily used to represent information about the database, and to
generate SQL statements that can be executed on the database.  For
example. QSqlCursor (see below) makes heavy use of these classes to
generate SQL.  In addition, database GUI classes such as QSqlTable and
QSqlForm use fields, records and indexes to display data returned by
SQL queries on screen.

The QSqlField class encapsulates the functionality and characteristics
of a column in a database field, such as the data type, field name,
etc.  The field's value can also be viewed and changed.

The QSqlRecord class encapsulates the functionality and
characteristics of a database record (a table or view within the
database), such as adding or removing fields, setting and retrieving
field values, etc.  In addition, there are several functions which
alter other characteristics of the record, for example, changing the
display label associated with a particular field when displaying that
field on screen.

\code
    QSqlRecord r = QSqlDatabase::database()->record( "Employee" );
    r.setDisplayLabel( "name", "Employee Name" );
    r.setValue( "name", "Dave" );
    ...
    QLabel* l = new QLabel( r.displayLabel( "name" ), myFormWidget );
    QLineEdit* le = new QLineEdit( myFormWidget );
    le->setText( r.value( "name ).toString() );
\endcode

The QSqlIndex class represents an index or key within the database. An
index is a record with some additional functionality, such as the
ability to specify ascending or descending sorting for fields in the
index.

<h2>Queries</h2>

Once a connection to a SQL database has been established, it is very
straightforward to begin using the Qt SQL classes.  For example,
updating a record in e.g. the 'Employee' table can be done with the
following code:

\code
    QSqlQuery q;
    q.exec( "update Employee set name='Dave' where id=1;" );
\endcode

SQL statements can also be executed directly from an open database
connection.  These statements are sent to the QSqlDatabase::exec()
function, which returns a QSqlQuery object.  Queries can also be
created without explicitly specifying a database connection (these
queries will use the application default connection in this case).
For example:

\code
    QSqlDatabase* db = QSqlDatabase::database();
    QSqlQuery employeeCount = db->exec( "select count(*) from Employee;" );
    ...
    QSqlQuery updEmployee; // automatically uses the default application connection
    updEmployee.exec( "update Employee set name='Eirik' where id=1;" );
\endcode

QSqlQuery allows any SQL statement to be passed to the database,
including database-specific SQL statements.  Primarily, however, there
are two types of SQL statements which are intended to be used with
QSqlQuery: \c SELECT statements and data manipulation statements (\c INSERT,
\c UPDATE and \c DELETE).

To use QSqlQuery with a \c SELECT statement, specify the statement in the
object constructor, or use the QSqlQuery::exec() method.  When a
QSqlQuery object is given a \c SELECT statement, the statement is
verified against the database.  If the statement contains an error,
the QSqlQuery object will remain in an inactive state, otherwise the
QSqlQuery becomes active, and data can be retrieved.  

Each active query has an internal pointer to the current valid record,
which is returned by the QSqlQuery::at() function.  The current row
in the query is the one whose values can be retrieved using the
QSqlQuery::value() function. You can change the current row by moving
the query to point to a different row.  The following methods navigate
through the rows of an active query:

<ul>
<li> \c first() - Moves to the first row in the query; this is row 0
<li> \c last() - Moves to the last row in the query
<li> \c next() - Moves to the next row in the query
<li> \c prev() - Moves to the previous row in the query
<li> \c seek(int) - Moves to the given row number in the query
</ul>

In addition, the following functions can be used to describe
properties of the query which are useful when navigating the rows:

<ul>
<li> \c isActive() - Returns TRUE if the last statement was successful
<li> \c isValid() - Returns TRUE if the query is positioned on a valid record
<li> \c at() - Returns the current row number (can be used with seek()); the
first row is 0
<li> \c isSelect() - Returns TRUE if the last statement was a \c SELECT statement
</ul>

For example:

\code
    // create query using the application default database
    QSqlQuery emp( "select name, deptno from Employee order by name;" );

    bool active = emp.isActive();// returns TRUE if query successful
    bool valid = emp.isValid();  // returns FALSE since we have not yet positioned to a valid record
    int at = emp.at();           // returns invalid location

    if ( active ) {    // if query successful...

        // move to the first record
        emp.first();
	valid = emp.isValid();   // returns TRUE if we are positioned on a valid record
	at = emp.at();           // returns 0, since the query is on the first record

        // ...move through the rest of the records returned by the query
        while ( emp.next() ) {  
	     ... // do something with the result
        }

        valid = emp.isValid();   // returns FALSE since the query is positioned after the last record
        at = emp.at();           // returns invalid location

        // go to row 10, the 11th record in the query
        emp.seek( 10 );
	valid = emp.isValid();   // returns TRUE if we are positioned on a valid record

        // reset the query
        emp.exec( "select name from dept where id=10;" );
        active = emp.isActive();// returns TRUE if last query successful
        valid = emp.isValid();  // returns FALSE since we have yet not positioned to a valid record
    }
\endcode

A query is positioned on an invalid record when it is first given a
new SQL statement to execute.  Moving to a valid record within the
result will allow you to access the data returned by the query.  Data
is returned by the QSqlQuery::value() function using QVariant.  For
example:

\code
    QSqlQuery emp( "select name, deptno from Employee order by name;" );
    while ( emp.next() ) {
        QString name = emp.value(0).toString();
        QVariant deptno = emp.value(1);
        ...
    }
\endcode

Applications that use QSqlQuery do so mainly to browse, or scroll,
through records returned by the query.  To use a QSqlQuery with a data
manipulation statement (\c INSERT, \c UPDATE and \c DELETE), just specify the
statement to the object constructor or use the QSqlQuery::exec()
method.  Data manipulation statements will execute on the database
immediately (unless a transaction is in progress), and the query will be
positioned on an invalid record.  Use QSqlQuery::isActive() to
determine if the statement was successful.  Note that you cannot
scroll through any records with these types of SQL statements, since
data manipulation statements do not return any result records.  You
can check the number of rows affected by the statement using
QSqlQuery::numRowsAffected().  For example:

\code
    QSqlQuery emp;
    emp.exec( "update Employee set name='foo' where name='bar';" );
    bool active = emp.isActive();     // returns TRUE if query successful
    vool valid = emp.isValid();       // returns FALSE since an UPDATE statement returns no records
    int rows = emp.numRowsAffected(); // returns number of rows updated
\endcode

By default, when you create queries (or cursors, see below), the
default database connection is used.  To specify a different database
connection, pass a pointer to the desired QSqlDatabase. For example:

\code
    QSqlDatabase* alternateDb = QSqlDatabase::database( "alternate" );
    QSqlQuery q;
    q.exec( "update Employee set name='Trond' where id=2;", alternateDb );
\endcode
	
<h2>Cursors</h2>

You can perform operations on tables or views within the database
using QSqlCursor.  A 'cursor' is a reference to a database record (see
above) that corresponds to a table or view within the database.
Cursors can be navigated in the same way as a QSqlQuery (see above) to
position them at a valid record.  Once positioned on a valid record,
data can be retrieved from the record's fields directly.  In addition,
for cursors that correspond to tables or views that contain primary
indexes, data can be edited directly using the edit functions of
QSqlCursor.

For example, to create a list of all employee names from department #10
of the Employee table:

\code
    QSqlCursor emp( "Employee" ); // uses the default application database connection
                                  // and constructs a record of all 'Employee' fields
    emp.select( "deptno=10" );    // select everyone in deparment #10
    while( emp.next() )           // for each valid record
	myListBox->insertItem( emp.value( "name" ).toString() );
\endcode

Records in the cursor can be selected in several ways using the
overloaded select() function.  For example, to select a subset of
records based upon an index:

\code
    QSqlCursor emp( "Employee" );
    QStringList fields = QStringList() << "name" << "deptno";
    QSqlIndex nameIndex = emp.index( fields ); // create an index based on fields
    emp.select( nameIndex );                   // selects all records sorted by nameIndex
    while ( emp.next() ) {
        ...;
    }

\endcode

<em> Editing Records in a Cursor </em>

If the underlying table or view has a primary index which identifies a
unique record, a cursor can also be used to edit records in the
database.  Before inserting, updating or deleting records in a cursor,
the cursor must be prepared for edit operations.  Cursors use separate
internal record buffers for inserting and updating records in the cursor.
The following functions prepare the cursor's internal record buffer
for editing:

<ul>
<li> \c insertBuffer() - returns a pointer to the edit buffer, primed for insert
<li> \c updateBuffer() - returns a pointer to the edit buffer, primed for update
</ul>

\l QSqlCursor::insertBuffer() will prepare the edit buffer for an
insert operation: the record buffer will be cleared and the virtual
QSqlCursor::primeInsert() function will be invoked to 'prime' the edit
buffer values.  Derived classes can reimplement this function in order
to, for example, auto-number any relevant fields, or supply fields
with default values.  QSqlCursor::updateBuffer() will prepare the edit
buffer for an update operation: the record buffer will be primed with
the values of the current cursor record.  The edit buffer of a cursor
is independent of the current cursor record buffer which contains the
values of the current fields from the database.  After getting a
pointer to the internal edit buffer, values can be manipulated, and
then saved to the database.  For example:

\code
    QSqlCursor emp( "Employee" );
    emp.setValue( "id", 10 );
    emp.select( emp.primaryIndex(), emp.primaryIndex() );  // select unique record 
    if ( emp.next() ) {
        QSqlRecord* upd = emp.updateBuffer(); // get the update buffer for the current cursor record
        upd->setValue( "name", "Trond" );     // change the value of a field in the update buffer
        QString n1 = emp.value( "name" ).toString();
        QString n2 = buf->value( "name" ).toString(); // note: n1 != n2
        
        emp.update(); // updates the Employee table using the table's primary index
                      // and invalidates the current cursor record (i.e., at() returns an invalid position)
        bool active = emp.isActive(); // returns TRUE if update succeeded
        int rows = emp.numRowsAffected(); // returns 1 if query successful

        emp.select( emp.primaryIndex(), emp.primaryIndex() );  // re-select the record 
        if ( emp.next() ) 
            n1 = emp.value( "name" ).toString(); // note: n1 == n2
    }
\endcode

Note the calls to:
\code
    emp.select( emp.primaryIndex(), emp.primaryIndex() );
\endcode

When primaryIndex() is used as the first argument (filter) it is being
used to provide the field names which will populate the WHERE clause.
Their values are taken from the current cursor record. In this example
the field name passed is "id" so the WHERE clause that is created is
<em>WHERE id=10</em>. When primaryIndex() is used as the second argument
(sort) its use is to provide field names for the ORDER BY clause, i.e.
which fields to sort the results by. In this example the field name
passed is again, "id", so the resulting ORDER BY clause is <em>ORDER BY
id</em>.

<h2>GUI Components</h2>

<em> Displaying Data in a Table </em>

There are several classes which can display and edit data from
cursors.  

\l QSqlTable is a flexible table widget which displays the data from a
QSqlCursor.  It has an API for sorting records, finding records and
editing records (for cursors which allow editing).

To use QSqlTable, create one as you would any other QWidget.  Then,
associate a cursor with the table using QSqlTable::setCursor():

\code
    QSqlCursor cursor( "Employee" );
    ...
    QSqlTable* table = new QSqlTable( this );
    table->setCursor( &cursor );
\endcode

QSqlTable will adjust itself to the column formatting and editing
capabilities of the cursor.  However, all of these properties can be
overriden (see \l QSqlTable for the complete API).

<em> Creating Database Forms </em>

\l QSqlForm can link QSqlFields with QWidgets, and using the <a
href="properties.html">property system</a>, can transfer data from the
database to widgets on screen, and vice versa.

A form is responsible for linking GUI components (QLineEdit, QSpinBox,
etc) to database fields (typically a field that is part of a
QSqlCursor).  For example:

\code
    QSqlCursor cursor( "Employee" );
    ...
    QSqlForm* form = new QSqlForm( this );
    QLineEdit* edit = new QLineEdit( this );
    form->insert( edit, cursor.field( "name" ) );
\endcode

Once a form is created, widgets that have been inserted into the form
can be updated with the values of the associated fields:

\code
    cursor.select();    // select all records
    cursor.first();     // move to the first record
    form->readFields(); // the line edit now contains the value of the 'name'
                        // field from the database record
\endcode

Cursor field values can also be updated directly from the associated
widgets.

\code
    edit->setText( "Dave" );            // change the line edit contents
    form->writeFields();                // write the data to the cursor field
    QString s = cursor.value( "name" ); // now s == "Dave"
\endcode

See \l QSqlForm for complete API documentation.

QSqlForm uses QSqlPropertyMap to handle the transfer of data between
widgets and database fields.  Custom widgets can also be used in a
form by installing a property map that contains information about the
properties of the custom widget which should be used to transfer the
data.  For example:

\code
    MyCustomEditor* myedit = new MyCustomEditor( this ); // create a custom widget editor
    QSqlPropertyMap* pm = new QSqlPropertyMap();         // create a property map
    pm->insert( myedit->className(), "foo" );            // use the "foo" property of this class
                                                         // to transfer data to and from database fields
    form->installPropertyMap( pm );                      // use the new property map in the form
    form->insert( myedit, cursor.field( "deptno" ) );
    ...
    form->readFields();	                                 // read data from the "deptno" field 
                                                         // and put it in myedit
    ...
    form->writeFields();                                 // read data from myedit and put it
                                                         // in the "deptno" field
\endcode

See \l QSqlPropertyMap for complete API documentation.

<h2>Drivers</h2>

The Qt SQL classes provide drivers for several popular SQL
databases. A 'driver' is used by QSqlQuery and QSqlDatabase to handle
the native API to the various backends.

Drivers can be linked in directly with the Qt library, or they can be
dynamically loaded using the Qt plugin system.  To write your own
driver, reimplement the QSqlDriver and QSqlResult classes for your
database, and then compile your driver as a Qt plugin.  Make sure you
give your driver a unique 'interface' name which will be used by the
plugin system to locate the proper library which contains your driver.
For example, the Qt database drivers use names such as 'QPSQL6',
'QODBC', etc.

All the Qt database drivers can be compiled as plugins as well.  See
the driver source code in QTDIR/src/sql/src for examples.  At runtime,
QSqlDatabase will attempt to load database drivers for your plugin if
it cannot load a standard driver (either compiled into the Qt library
or through a standard Qt driver plugin).

*/

