/*!
    \page interview-overview.html
    \title The Interview Classes

    The Interview classes provide a Model/View framework for Qt
    applications based on the well known Model-View-Controller design
    pattern. In this document, we will describe Qt's Model/View
    architecture, discuss the current state of the implementation,
    provide some examples, show the improvements offered over Qt 3,
    and indicate the future direction of the implementation.

    \tableofcontents

    \section1 Overview of the Model/View architecture

    Model-View-Controller (MVC) is a design pattern originating from
    Smalltalk that is often used when building user interfaces.
    In \l{http://www.amazon.com/exec/obidos/ASIN/0201633612/103-8144203-3273444}
    {Design Patterns}, Gamma et al. write:

    \quote
    MVC consists of three kinds of objects. The Model is the
    application object, the View is its screen presentation, and the
    Controller defines the way the user interface reacts to user
    input. Before MVC, user interface designs tended to lump these
    objects together. MVC decouples them to increase flexibility and
    reuse.
    \endquote

    If the view and the controller objects are combined, the result is
    the Model/View architecture. This still separates the data in the
    model from its presentation to the user, but simplifies both the
    design and implementation of a framework based on these
    principles. In Interview, we also introduce the concept of the \e
    delegate to provide further user input functionality. The
    advantage of using a delegate is that it allows input methods to
    be defined in addition to those provided by the view.

    Interview defines the interfaces and common functionality for the
    models, views, and delegates at the \bold{abstract level}. All
    implementations subclass the relevant abstract class: \c
    QAbstractItemModel, \c QAbstractItemView, or \c
    QAbstractItemDelegate. This approach ensures a common set of
    interfaces for interoperability between each of the components.

    Interview provides ready-to-use implementations of views for the
    common table, tree, and list widgets. These reimplement and extend
    the interfaces provided by the abstract views to provide features
    for particular use cases. 
    
    Two specialized abstract models are provided for use with the
    view classes: \c QAbstractTableModel is a useful starting point for
    providing a model to use with \c QTableView; \c QAbstractListModel
    can be subclassed to produce a list-based model to use with
    \c QListView.
    
    The \c QDirModel is provided as an example model, providing
    directory information for use with the \c QListView and \c
    QTreeView.

    At the \bold{convenience level}, we find classes that are provided
    to help those who are familiar with the conventional list, tree,
    and table widgets. These present a simplified interface to the
    developer that does not explicitly require a knowledge of the
    underlying Model/View architecture.

    The view widgets provided interact with selection objects to
    ensure that items are selected in a consistent way, and that
    selections can be shared between views of the same model.


    \section1 The current state of Interview

    The following features are provided with the technology preview.

    Model classes that provide common interfaces, or that manage and store
    data:

    \list
    \i \c QAbstractItemModel
    \i \c QAbstractListModel and \c QAbstractTableModel
    \i \c QModelIndex and \c QPersistentModelIndex
    \i \c QDirModel -- a predefined subclass providing a model for
    viewing files and directories
    \endlist

    View classes that provide common interfaces, or that present data
    from models in a standard way:

    \list
    \i \c QAbstractItemView
    \i \c QListView, \c QTableView, \c QTreeView -- ready-to-use view
       classes that are suitable for subclassing
    \endlist

    Delegate and controller classes that provide common interfaces, or
    that provide editing and control facilities for views:

    \list
    \i \c QAbstractItemDelegate
    \i \c QItemSelectionModel, \c QItemSelection, \c
    QItemSelectionRange -- classes to handle selections of items
    \i \c QItemDelegate
    \endlist


    \section1 Examples

    To illustrate how the Interview classes are used, we present two
    examples that show different aspects of the Model/View
    architecture.

    \section2 Sharing a model between two views

    In this example, we display the contents of a model using two
    different views, and share the user's selection between
    them. We will use the \c QDirModel supplied with Qt because it
    requires very little configuration, and provides existing data to
    the views.

    The \c main() function for this example demonstrates all the
    principles involved in setting up the model, the views, and the
    selection:

    \code
    int main(int argc, char *argv[])
    {
        QApplication app(argc, argv);

        QHBox *hbox = new QHBox;

        // Create the model
        QDirModel *model = new QDirModel(QDir(), hbox);

        // Create the views
        QTreeView *tree = new QTreeView(hbox);
        QListView *list = new QListView(hbox);

        // Set the model
        tree->setModel(model);
        list->setModel(model);

        // Share the selections
        QItemSelectionModel *selection = new QItemSelectionModel(model, model);
        list->setSelectionModel(selection);
        tree->setSelectionModel(selection);

        hbox->show();

        app.setMainWidget(hbox);
        return app.exec();
    }
    \endcode

    In the above function, we constructed a directory model to display
    the contents of a default directory. The two views are constructed
    and given the same model to work with. By default, each view will
    maintain and display its own selection of items from the model,
    but we explicitly share the tree view's selection with the list
    view. As a result, changes to the selection in either of these
    views will automatically cause the selection in the other to
    change.
    
    The Model/View architecture allows us to replace the \c QDirModel in
    this example with a completely different model, one that will perhaps
    obtain data from a remote server, or from a database.

    \section2 Creating a custom model

    In this example, we display the contents of a simple read-only
    model using a ready-made view class.

    Creating a custom model for the existing views requires us
    to subclass \c QAbstractListModel and reimplement a number of
    functions. Our model will take a list of strings when constructed,
    and supply these to a view. Since we only require a simple
    read-only model, the number of functions we need to provide are
    very few.

    The complete declaration of our model is as follows:

    \code
    class StringListModel : public QAbstractListModel
    {
        Q_OBJECT
    public:
        StringListModel(const QStringList &strings, QObject *parent=0)
            : QAbstractListModel(parent), stringList(strings) {}

        int rowCount() const;
        QVariant data(const QModelIndex &index, int role) const;

    private:
        QStringList stringList;
    };
    \endcode

    Since the underlying data structure contains one row for each
    string, and one column of strings, only the \c rowCount() function
    needs to be implemented; by default, the \c columnCount() function
    provided by \c QAbstractListModel will return a value of 1. The \c
    data() function returns the data that corresponds to each model
    index specified. In this way, the model controls access to the
    underlying data. We do not need to provide a function to \e set the
    data in the model because the string list is supplied to the
    constructor, and this model is read-only.

    These functions are implemented quite simply:

    \code
    int StringListModel::rowCount() const
    {
        return stringList.count();
    }

    QVariant StringListModel::data(const QModelIndex &index, int role) const
    {
        if (!index.isValid())
            return QVariant();
        if (index.type() == QModelIndex::HorizontalHeader)
            return index.column();
        if (index.type() == QModelIndex::VerticalHeader)
            return index.row();
        return stringList.at(index.row());
    }
    \endcode

    The \c data() function returns a \c QVariant containing the
    information referred to by the model index. If the view requests
    an item from the string list, this is returned to the view, but
    only after a number of checks are performed on the model index. If
    the view specified an invalid model index, the model indicates
    this by returning an invalid \c QVariant. Vertical and horizontal
    headers are identified by the model index's type; the value
    returned for these items is the row or column number, depending on
    the header.

    We only include an excerpt from the \c main() function for this
    example:

    \code
    QStringList numbers;
    numbers << "One" << "Two" << "Three" << "Four";
    QAbstractItemModel *model = new StringListModel(numbers);
    QAbstractItemView *view = new QTableView();
    view->setModel(model);
    \endcode

    We created a string list to use with the model, and this is
    supplied to the model when it is constructed. The information in
    the string list is then made available to the view via the model.

    If we require an editable model, we only need to define the following
    functions in the class declaration:
    
    \code
    bool isEditable(const QModelIndex &index) const;
    bool setData(const QModelIndex &index, int role, const QVariant &value);
    \endcode

    These are implemented in the following way:
    
    \code
    bool StringListModel::isEditable(const QModelIndex &index) const
    {
        return true;
    }

    bool StringListModel::setData(const QModelIndex &index, int role,
                                  const QVariant &value)
    {
        if (!index.isValid() || index.type() != QModelIndex::View
            || role != EditRole)
            return false;
        stringList.replace(index.row(), value.toString());
        emit dataChanged(index, index);
        return true;
    }
    \endcode

    In the \c isEditable() function, we ensure that the model is always
    editable by returning true for all indices. The \c setData() function
    updates the data in the string list, but only if the specified index
    refers to an item that is valid, can be shown, and is editable. The
    \c dataChanged() signal ensures that the view is kept up-to-date.

    This example shows that it can be easy to populate views with data
    from a simple model, although it is expected that the convenience
    models and views provided with Qt 4 (and which weren't ready for
    the preview) will make the process even easier.

    \section1 What's changed since Qt 3?

    The table and item view classes in Qt 3 implemented widgets that
    served both as containers and as views onto their contents. These
    classes were designed to be easy-to-use and consistent. The
    equivalent classes in Qt 4 are designed to be extensible while
    remaining easy-to-use; the introduction of the Model/View
    architecture ensures that they will be more consistent than their
    predecessors. The view classes provided can be summarized
    in the following way:

    \list
    \i The \c QListView class provides a view widget that is
    similar to Qt 3's \c QListBox widget, but displays data from a
    model.
    \i The \c QTableView class is a view widget that displays
    data from a model of tablular data, similar to Qt 3's \c QTable
    widget.
    \i The \c QTreeView class provides a view widget that
    behaves like Qt 3's \c QListView widget, except that the data
    items are provided by a model.
    \endlist

    For developers who wish to continue to use old-style item views,
    there are a number of convenience classes that will provide
    familiar interfaces without requiring the use of compatibility
    classes. The \c QListView class provides a widget to display a
    list of items, as found in Qt 3's \c QListBox class, and the \c
    QTreeView class implements the equivalent of Qt 3's \c QListView
    class. User's of Qt 3's \c QTable class will find that \c
    QTableView provides comparable functionality with a familiar
    interface.

    The move towards a Model/View architecture presents both
    challenges and opportunities for developers. Although the approach
    may appear to be rather powerful for simple applications, it
    encourages greater reuse of components, both within the library
    and within applications. For example, \c QFileDialog now displays
    the contents of a \c QDirModel using the \c QListView and
    \c QTreeView widgets.


    \section1 Future work

    We plan to introduce the following features in the Qt 4 release:

    \list
    \i Support for right-to-left languages
    \i Convenience models (supporting SQL, for example) to allow views to be
       populated easily
    \i Convenience views for common kinds of widgets
    \i Support for freezing rows/columns in view widgets
    \i Persistent index-based selections
    \endlist

    \link tech-preview.html [Back to the Technology Preview page] \endlink

*/
