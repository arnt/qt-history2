/****************************************************************************
** $Id: collect.doc,v 2.13 1999/09/25 14:45:45 ettrich Exp $
**
** Qt collection classes documentation
**
** Copyright (C) 1992-1999 Troll Tech AS.  All rights reserved.
**
** This file is part of the Qt GUI Toolkit.
**
** This file may be distributed under the terms of the Q Public License
** as defined by Troll Tech AS of Norway and appearing in the file
** LICENSE.QPL included in the packaging of this file.
**
** Licensees holding valid Qt Professional Edition licenses may use this
** file in accordance with the Qt Professional Edition License Agreement
** provided with the Qt Professional Edition.
**
** See http://www.troll.no/pricing.html or email sales@troll.no for
** information about the Professional Edition licensing, or see
** http://www.troll.no/qpl/ for QPL licensing information.
**
*****************************************************************************/

/*!
\page collection.html

<title>Qt Collection Classes</title>
</head><body bgcolor="#ffffff">

\postheader

<h1 align=center>Collection Classes</h1><br clear="all">

A collection class is a class that can contain a number of items in a
certain data structure and perform operations on the contained items;
insert, remove, find etc.

Qt has many collection classes:
<ul>
<li> \link QCache QCache\endlink and \link QIntCache QIntCache\endlink;
	LRU (least recently used) cache structures.
<li> \link QDict QDict\endlink, \link QIntDict QIntDict\endlink, and
	    \link QPtrDict QPtrDict\endlink; reference based dictionary structures.
<li> \link QList QList\endlink; a reference based doubly linked list structure.
<li> \link QQueue QQueue\endlink; a FIFO (first in, first out) queue structure.
<li> \link QStack QStack\endlink; a LIFO (last in, first out) stack structure.
<li> \link QVector QVector\endlink; a vector structure.
<li> \link QValueList QValueList\endlink; a value based list
<li> \link QValueStack QValueStack\endlink; a value based stack structure
<li> \link QMap QMap\endlink; a value based dictionary structure
<li> \link QArray QArray\endlink;
</ul>

Some of these classes have corresponding iterators.  An iterator
is a class for safely traversing the items in a collection:
<ul>
<li> \link QCacheIterator QCacheIterator\endlink and
	\link QIntCacheIterator QIntCacheIterator\endlink
<li> \link QDictIterator QDictIterator\endlink,
	\link QIntDictIterator QIntDictIterator\endlink, and
	\link QPtrDictIterator QPtrDictIterator\endlink
<li> \link QListIterator QListIterator\endlink
<li> \link QValueListIterator QValueListIterator\endlink, and
	\link QValueListConstIterator QValueListConstIterator\endlink
<li> \link QMapIterator QMapIterator\endlink, and
	\link QMapConstIterator QMapConstIterator\endlink
</ul>

The refrence based collection classes work with pointers to items
while the value based one store copies instead of pointers.

<h2>Architecture</h2>

There are three internal base
classes for the reference based containers; \link QGCache QGCache\endlink, \link QGDict QGDict\endlink and
\link QGList QGList\endlink that operate on \c void* pointers.  A thin
template layer implements the actual collections by casting item pointers
to and from \c void*.

This strategy allows Qt's templates to be very economical on space
(instantiating one of these templates adds only inline-able calls to
the base classes), while it does not hurt performance too much.
The Qt Template Library in contrast is more like the STL. It does not store
pointers, instead it stores real copies. This is faster for small
values like integers or QRect for example. But the value based containers
can not be used with everything derived from QObject since it is impossible
to make a copy of a QObject

<h2>A QList Example</h2>

This example shows how to store Employee items in a list and prints
them out in the reverse order:

\code
    #include <qlist.h>
    #include <qstring.h>
    #include <stdio.h>

    class Employee
    {
    public:
        Employee( const char *name, int salary ) { n=name; s=salary; }
        const char *name()   const		 { return n; }
        int	    salary() const		 { return s; }
    private:
        QString     n;
        int         s;
    };

    void main()
    {
	QList<Employee> list;		// list of pointers to Employee
	list.setAutoDelete( TRUE );	// delete items when they are removed

	list.append( new Employee("Bill", 50000) );
	list.append( new Employee("Steve",80000) );
	list.append( new Employee("Ron",  60000) );

	QListIterator<Employee> it(list); // iterator for employee list
	for ( it.toLast(); it.current(); --it) ) {
	    Employee *emp = it.current();
	    printf( "%s earns %d\n", emp->name(), emp->salary() );
        }
    }
\endcode

Program output:
\code
	Ron earns 60000
	Steve earns 80000
	Bill earns 50000
\endcode

<h2>A QValueList Example</h2>

This example shows something compareable to the above QList example.
It especially shows the value based semantics.

\code
    #include <qvaluelist.h>
    #include <qstring.h>
    #include <stdio.h>

    class Employee
    {
    public:
        Employee( const QString& name, int salary ) { n=name; s=salary; }
        Employee( const Employee& _e ) { n = _e.name; s = _e.s; }

        QString     name()   const		 { return n; }
        int	    salary() const		 { return s; }
	void	    setSalary( int _s ) const	 { s = _s; }
    private:
        QString     n;
        int         s;
    };

    void main()
    {
	typedef QValueList<Employee> EmployeeList;
	EmployeeList list;		// list of Employee

	list.append( Employee("Bill", 50000) );
	list.append( Employee("Steve",80000) );
	list.append( Employee("Ron",  60000) );

	Employee joe( "Joe", 50000 );
	list.append( joe );
	joe.setSalary( 4000 );
	
	EmployeeList::Iterator it;
	for( it = list.begin(); it != list.end(); ++it )
	    printf( "%s earns %d\n", (*it).name(), (*it).salary() );
    }
  \endcode

  Program output:
  \code
	Bill earns 50000
	Steve earns 80000
	Ron earns 60000
	Joe earns 50000
  \endcode

As you can see, the latest changes to Joes salary did not affect the value
in the list because the list created a copy of Joes entry.

For more informations about value based containers see <a href="qtl.html">The Qt Template Library</a>.

<h2>Managing Collection Items</h2>

All reference based collections inherit the \link QCollection QCollection\endlink base
class.  This class knows only the number of items in the collection and
the delete strategy.

Items in a collection are by default not deleted when they are removed
from the collection. The \link QCollection::setAutoDelete()
QCollection::setAutoDelete()\endlink function specifies the delete
strategy. In the list example, we enable auto-deletion to make the list
delete the items when they are removed from the list.

When inserting an item into a collection, only the pointer is copied, not
the item itself. This is called a shallow copy. It is possible to make the
collection copy all of the item's data (known as a deep copy) when an item
is inserted.  All collection functions that insert an item call the
virtual function \link QCollection::newItem()
QCollection::newItem()\endlink for the item to be inserted.  Inherit a
collection and reimplement it if you want to have deep copies in your
collection.

When removing an item from a list, the virtual function \link
QCollection::deleteItem() QCollection::deleteItem()\endlink is called.
The default implementation in all collection classes is to delete the item
if auto-deletion is enabled.


<h2>Usage</h2>

A reference based collection class, for instance QList\<type\>, defines a
collection of \e pointers to \e type objects.  The pointer (*) is
implicit.

We discuss \link QList QList\endlink here, but the same applies for all
reference based collection classes and all collection class iterators.

Template instantiation:
\code
  QList<Employee> list;		// wherever the list is used
\endcode

The item's class or type, Employee in our example, must be defined prior
to the list definition.

\code
  // Does not work: Employee is not defined
  class Employee;
  QList<Employee> list;

  // This works: Employee is defined before it is used
  class Employee {
    ...
  };
  QList<Employee> list;
\endcode

<h2>Iterators</h2>

Although \link QList QList\endlink has member functions to traverse the
list, it can often be better to make use of an iterator. \link
QListIterator QListIterator\endlink is very safe and can traverse lists
that are being modified at the same time.  Multiple iterators can work
independently on the same collection.

A QList has an internal list of all iterators that are currently operating
on the list.  When a list entry is removed, the list updates all iterators
to point to this entry.

The \link QDict QDict\endlink and \link QCache QCache\endlink collections
have no traversal functions. To traverse these collections, you must
use \link QDictIterator QDictIterator\endlink or \link QCacheIterator
QCacheIterator\endlink.

The value based containers do not have internal iterators. The reason is
that these iterators are only 32 or 64 bit large depending in your CPU
architecture. This means that the CPU can hold such an iterator in one of
its registers and that in turn makes these iterators very quick.

<h2>Predefined Collections</h2>

Qt has the following predefined collection classes:
<ul>
<li> String lists; \link QStrList QStrList\endlink and
	\link QStrIList QStrIList\endlink (\link qstrlist.h qstrlist.h\endlink) and
	\link QStringList QStringList\endlink (\link qstringlist.h qstringlist.h\endlink)
<li> String vectors; \link QStrVec QStrVec\endlink and
	\link QStrIVec QStrIVec\endlink (\link qstrvec.h qstrvec.h\endlink)
</ul>

In almost all cases you should use QStringList. It is a value based container
which as QString instances as elements. That implies that QStringList
can deal with unicode very efficient. QStrList and QStrIList only store
pointers to usual strings. That means that they can not store unicode
data directly.

<h2>Comparison with the STL</h2>

We often get questions about why Qt does not use the STL, and why Qt's
container templates are provided at all.  Here are the major factors
why we use and provide these templates: <ul>

<li>Qt's reference based container templates add less space when instantiated than the
STL ones do.  Size is important for a library, and Qt contains many
instantiations of QDict, QList etc.

<li>Qt's reference based containers are often not as fast as the STL's, for several
reasons.  This is however not very important for Qt, as they are used
in code that doesn't need to be very fast.  (The speed-critical data
structures in Qt are mostly caches - either QCache instantiations or
custom-written, custom-optimized ones.)

<li>Qt's containers are much more portable than the STL.  When we
started writing Qt, STL was far away in the future, and when we
released Qt 1.0, no widely-used compilers could compile the STL.  For
a library such as Qt, it is of course very important to compile on the
widest possible variety of compilers.

<li>Qt's containers are documented because we document our APIs, and
the containers and their documentation are provided as parts of Qt's
external API because we saw no reason to hide them.

<li>The STL provides only value based containers. You can for example
not store a QObject directly in a STL list. You have to store a pointer
instead. But if you like to delete the QObject when it is removed from
the list, then you have to use smart pointers or something like that.
In addition you should notice that putting pointers in a value based container
breaks the value semantics of such a container. However, in many cases
value based containers are more efficient. This is the case when a single
value is small and a copy can be made very quickly. Since the STL is still
not portable across all of Qts supported plattforms we added value based
containers, too. These containers have a well documented interface
and the names of the functions and classes match the naming rules
of Qt. That is not the case for STL.
<ul>

There are also other differences, but the ones above are the important
reasons behind our decision to write, use and provide these classes.

*/
