/****************************************************************************
** $Id: collect.doc,v 1.3 1995/12/11 18:49:45 hanord Exp $
**
** Qt Collection Classes Documentation
**
** Copyright (C) 1995 by Troll Tech AS.  All rights reserved.
**
*****************************************************************************/

/*!
\page collect.html

<title>Qt Collection Classes</title>  <a name=collectionclasses>
</head><body>
<h1>Collection Classes</h1>
<hr>

<h2>Introduction</h2>

A collection class holds a set of object in a data structure and has
member functions to access the objects in the collection.

Qt has several collection classes:
<ul>
<li> QCache and QIntCache;LRU (least recently used) cache structures.
<li> QDict and QIntDict; dictionary structures.
<li> QList; a doubly linked list structure.
<li> QQueue; a queue structure.
<li> QStack; a FIFO (first in, first out) stack structure.
<li> QVector; a vector structure.
</ul>

Some of these classes have corresponding iterators.  An \e iterator
is a class for safely traversing the objects in a collection:
<ul>
<li> QCacheIterator and QIntCacheIterator
<li> QDictIterator and QIntDictIterator
<li> QListIterator
</ul>


<h2>Architecture</h2>

Basically, there are two different implementation strategies for
collection classes.
<ol>
<li> The collection can only contain objects that inherit a special
     collectable class and must reimplement a number of virtual
     functions.  This is the Smalltalk way of doing it.
<li> The collection is a template class.  Specific collections must
     be instantiated from the template.  This allows any class to be
     stored in a collection.
</ol>

In Qt, we have chosen the second approach.  There are three internal
base classes; QGCache, QGDict and QGList that operate on \c void*
objects.  A thin template layer implements the actual collections
by casting object pointers to and from \c void*.

Some compilers do not support C++ templates. For those compilers,
we have implemented macro expansions that emulate templates.


<h2>A List Example</h2>

This example shows how to store Employee objects in a list and
prints them out in the reverse order.

\code
  #include <qlist.h>		// QList template/macro definition
  #include <qstring.h>
  #include <stdio.h>

  class Employee
  {
  public:
      Employee( const char *name, int salary )
	  { empname = name;  empsal = salary; }

      const char *name()   const	{ return empname; }
      int	  salary() const	{ return empsal; }
  private:
      QString     empname;
      int         empsal;
  };

  #if defined(USE_TEMPLATECLASS)
  typedef QList<Employee>	  EmployeeList;
  typedef QListIterator<Employee> EmployeeListIt;
  #else
  typedef declare(QList,Employee)	  EmployeeList;
  typedef declate(QListIterator,Employee) EmployeeListIt;
  #endif

  int main()
  {
      EmployeeList list;		// list of Employees
      list.setAutoDelete( TRUE );	// auto-delete objects

      list.append( new Employee("Bill", 50000) );
      list.append( new Employee("Steve",80000) );
      list.append( new Employee("Ron",  60000) );

      EmployeeListIt it( list );	// list iterator
      it.toLast();			// go to the last list element
      while ( it.current() ) {		// for all list elements...
	  Employee *emp = it.current();
	  printf( "%s earns %d\n", emp->name(), emp->salary() );
	  --it;				// one element backwards
      }

      return 0;
  }
\endcode

The output is:
<code>
  Ron earns 60000
  Steve earns 80000
  Bill earns 50000
</code>

The \c USE_TEMPLATECLASS is defined if the compiler has template support.
Then we choose to instantiate a template list.  If the compiler does not
support templates, we create a macro-expanded class.  Its works just like
a template list, except that the syntax for instantiating the list is
somewhat different.

QListT refers to the QList template and QListM refers to the QList macro.
QList defaults to QListT if templates are supported, QListM otherwise.
The same applies for all other collection classes.


<h2>Collections Basics</h2>

All collections inherit the QCollection base class.  This class knows
only the number of objects in the collection and the delete strategy.

Objects in a collection are by default not deleted when they are removed
from the collection. The QCollection::setAutoDelete() functions spesifies
the delete strategy. In the list example, we set auto-deletion to make
the list delete the list entries when they are removed from the list.

A template-based collection instantiated by for instance \c QList<type> to
define a collection of \e pointers to \e type objects.  The pointer (*) is
implicit.

Template instantiation:
\code
  QList<MyClass>  myList;	// wherever the list is used
\endcode

Macro instantiation:
\code
  declare(QListM,MyClass);	// do this once (for instance in a .h file)
  QListM(MyClass)  myList;	// wherever the list is used
\endcode

We recommend using templates, because macro collections are harder to
debug.  C++ debuggers understand templates but not macros.


<h2>Using Iterators</h2>

Although QList has functions to traverse the list, it can often be
advantageous to make use of an iterator.  List iterators are very safe and
can traverse lists that are constantly modifies.  Multiple iterators can
work independently on the same list.

A list has an internal list of all iterators that are currently operating
on the list.  When a list entry is removed, the list updates all iterators
to point to this entry.

The QDict and QCache collections have no traversal functions. To traverse
the those collection, you must use QDictIterator or QCacheIterator.


<h2>Predefined Collections</h2>
*/
