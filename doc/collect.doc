/****************************************************************************
** $Id: collect.doc,v 1.6 1995/12/17 14:00:25 agulbra Exp $
**
** Qt Collection Classes Documentation
**
** Copyright (C) 1995 by Troll Tech AS.  All rights reserved.
**
*****************************************************************************/

/*!
\page collectionclasses.html

<title>Qt Collection Classes</title>
</head><body>
<h1>Collection Classes</h1>
<hr>

<h2>Introduction</h2>

A collection class is a class that can contain a number of items in a
certain data structure and perform operations on the contained items;
insert, remove, find etc.

Qt has many collection classes:
<ul>
<li> QCache and QIntCache; LRU (least recently used) cache structures.
<li> QDict and QIntDict; dictionary structures.
<li> QList; a doubly linked list structure.
<li> QQueue; a FIFO (first in, first out) queue structure.
<li> QStack; a LIFO (last in, first out) stack structure.
<li> QVector; a vector structure.
</ul>

Some of these classes have corresponding iterators.  An iterator
is a class for safely traversing the items in a collection:
<ul>
<li> QCacheIterator and QIntCacheIterator
<li> QDictIterator and QIntDictIterator
<li> QListIterator
</ul>

The collection classes work with pointers to items.  Qt has an array
template class, QArray, which stores the items directly in the array.
QArray only works for classes that do not have a constructor, a
destructor or any virtual functions.


<h2>Architecture</h2>

Basically, there are two different implementation strategies for
collection classes.
<ol>
<li> The collection can only contain objects that inherit a special
     collectable class.  This is the Smalltalk way of doing it.
<li> The collection is a template (generic) class.
     Specific collections must be instantiated from the template.
     This allows any object to be stored in a collection.
</ol>

In Qt, we have chosen the second approach.  There are three internal
base classes; QGCache, QGDict and QGList that operate on \c void*
pointers.  A thin template layer implements the actual collections
by casting item pointers to and from \c void*.

Some compilers do not support C++ templates. For those compilers,
we have implemented macro expansions that emulate templates.


<h2>A List Example</h2>

This example shows how to store Employee items in a list and prints
them out in the reverse order:

\code
    #include <qlist.h>
    #include <qstring.h>
    #include <stdio.h>

    class Employee
    {
    public:
        Employee( const char *name, int salary ) { n=name; s=salary; }
        const char *name()   const		 { return n; }
        int	    salary() const		 { return s; }
    private:
        QString     n;
        int         s;
    };

    void main()
    {
	QList<Employee> list;		// list of pointers to Employee
	list.setAutoDelete( TRUE );	// delete items when they are removed

	list.append( new Employee("Bill", 50000) );
	list.append( new Employee("Steve",80000) );
	list.append( new Employee("Ron",  60000) );

	QListIterator<Employee> it(list); // iterator for employee list
	for ( it.toLast(); it.current(); --it) ) {
	    Employee *emp = it.current();
	    printf( "%s earns %d\n", emp->name(), emp->salary() );
        }
    }
\endcode

Program output:
\code
	Ron earns 60000
	Steve earns 80000
	Bill earns 50000
\endcode


<h2>Managing Collection Items</h2>

All collections inherit the QCollection base class.  This class knows
only the number of items in the collection and the delete strategy.

Items in a collection are by default not deleted when they are removed
from the collection. The QCollection::setAutoDelete() function specifies
the delete strategy. In the list example, we enable auto-deletion to make
the list delete the items when they are removed from the list.

When inserting an item into a collection, only the pointer is copied, not the
item itself. This is called a shallow copy. It is possible to make the
collection copy all of the item's data (known as a deep copy) when an item is
inserted.  All collection functions that insert an item call the virtual
function QCollection::newItem() for the item to be inserted.
Reimplement it if you want to have deep copies in your collection.

When removing an item from a list, the virtual function
QCollection::deleteItem() is called.  The default implementation in all
collection classes is to delete the item if auto-deletion is enabled.


<h2>Templates vs. Macros</h2>

A template-based collection, for instance QList\<type\>, defines a
collection of \e pointers to \e type objects.  The pointer (*) is
implicit.

Template instantiation:
\code
  QList<MyClass>  myList;	// wherever the list is used
\endcode

Macro instantiation:
\code
  declare(QListM,MyClass);	// do this once (for instance in a .h file)
    ...
  QListM(MyClass)  myList;	// wherever the list is used
\endcode

We recommend using templates, because macro collections are harder to
debug.  C++ debuggers understand templates but not macros.


<h2>Iterators</h2>

Although QList has member functions to traverse the list, it can often be
better to make use of an iterator.  List iterators are very safe and can
traverse lists that are being modified at the same time.  Multiple
iterators can work independently on the same list.

A QList has an internal list of all iterators that are currently operating
on the list.  When a list entry is removed, the list updates all iterators
to point to this entry.

The QDict and QCache collections have no traversal functions. To traverse
the those collection, you must use QDictIterator or QCacheIterator.


<h2>Predefined Collections</h2>

Qt has the following predefined collection classes:
<ul>
<li> String lists; QStrList and QStrIList (qstrlist.h)
<li> String vectors; QStrVec and QStrIVec (qstrvec.h)
</ul>

*/
