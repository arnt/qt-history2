/****************************************************************************
** $Id: xml-sax.doc,v 2.45 1999/10/05 12:12:08 arnt Exp $
**
** Documentation on the sax interface of the xml module
**
** Copyright (C) 2000 Trolltech AS.  All rights reserved.
**
** This file is part of the Qt GUI Toolkit.
**
** This file may be distributed under the terms of the Q Public License
** as defined by Trolltech AS of Norway and appearing in the file
** LICENSE.QPL included in the packaging of this file.
**
** This file may be distributed and/or modified under the terms of the
** GNU General Public License version 2 as published by the Free Software
** Foundation and appearing in the file LICENSE.GPL included in the
** packaging of this file.
**
** Licensees holding valid Qt Enterprise Edition or Qt Professional Edition
** licenses may use this file in accordance with the Qt Commercial License
** Agreement provided with the Software.
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
**   information about Qt Commercial License Agreements.
** See http://www.trolltech.com/qpl/ for QPL licensing information.
** See http://www.trolltech.com/gpl/ for GPL licensing information.
**
** Contact info@trolltech.com if any conditions of this licensing are
** not clear to you.
**
**********************************************************************/

/*! \page small-table-demo-walkthrough.html

\ingroup walkthroughs

\title Walkthrough: A short demonstration of the Qt table module

The following example shows how to populate the cells of a spreadsheet with
pixmaps and text, combo boxes and check boxes.

Our aim is a table that consists of 100 columns and 100 rows, 
with the entire second column filled with check boxes and
the sixth column filled with combo boxes where
users might choose between four items.
The third cell in the fourth row contains a pixmap and a string.

<h3>A simple table with some special cell entries</h3>

\walkthrough table/small-table-demo/main.cpp
\skipto include
\printuntil qstringlist.h

All we need to implement this are five classes: \l QApplication
(overall it's a GUI program), \l QTable for the spreadsheet, \l QImage to
load and scale the icon, \l QPixmap for the icon to show and \l QStringList
to store the combo box items.

\skipto qtlogo.xpm
\printline qtlogo.xpm

\e qtlogo.xpm contains the \e qtlogo_xpm pixmap we're going to use.

\skipto 100
\printuntil numCols

Next we define the table size: 100 columns and 100 rows.

\skipto main
\printuntil QApplication

In the main program the first thing for us to do is to create 
"the application" itself.

\printline table

Then we create a \e table widget of the defined size.

\printline img

Next we load the pixmap we want to show. We use a QImage for this purpose
since we have to scale it first so that it will fit into the table cell.
Such an operation should always be done in QImage because this is more
efficient: a QPixmap is stored by the windowing system and if you do the
transformation on the QPixmap, Qt has to get it first, then do the
transformation and put the transformed pixmap back again.

\printline pix

Then we scale it that it will fit into the cell. We want to put it into the
fourth row, so the limiting factor is the height of the row (keep in mind
that row and column numbering in QTable start with zero so that the fourth
row is denoted by 3). We assign the resulting QImage to a QPixmap. This
puts the pixmap to the windowing system, so that we can use it finally for
displaying purposes.

\printline table.setPixmap

The scaled pixmap now becomes the content of the cell where fourth 
row and third column meet.

\printline table.setText  

Then we add the text string \e{A Pixmap} 
to the right of the pixmap.

\printline QStringList

We mentioned earlier that we intend to populate the entire sixth
column with combo boxes. A combo box with no entries to choose from 
is quite boring. 
Thus we define a string list \e comboEntries to store them.

\printline comboEntries

The combo boxes will hold four entries, boringly named \e one to
\e four.

\printline < numRows

Beginning with the first row, row after row, until we are done
with the last row (i.e. no. \e{numRows-1}) ...

\printuntil TRUE

... we populate the sixth column with identical combo boxes that
show the entries \e one, \e two, \e three and \e four. With
the last parameter set to TRUE the user has the possibility to
change the text of the combo box entries. \l QComboTableItem
is a special class to fill table cells with combo boxes.

\printline for
\printline QCheckTableItem

The same way the entire second column is filled with unchecked
check boxes of the title \e{Check me}. 

\printline app

So we are done with creating the table. We make it the main window of
the Qt application,

\printline show

show it,

\printuntil }

and start the event loop of the GUI.

*/
