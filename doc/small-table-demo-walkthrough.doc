/****************************************************************************
** $Id: xml-sax.doc,v 2.45 1999/10/05 12:12:08 arnt Exp $
**
** Documentation on the sax interface of the xml module
**
** Copyright (C) 2000 Trolltech AS.  All rights reserved.
**
** This file is part of the Qt GUI Toolkit.
**
** This file may be distributed under the terms of the Q Public License
** as defined by Trolltech AS of Norway and appearing in the file
** LICENSE.QPL included in the packaging of this file.
**
** This file may be distributed and/or modified under the terms of the
** GNU General Public License version 2 as published by the Free Software
** Foundation and appearing in the file LICENSE.GPL included in the
** packaging of this file.
**
** Licensees holding valid Qt Enterprise Edition or Qt Professional Edition
** licenses may use this file in accordance with the Qt Commercial License
** Agreement provided with the Software.
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
**   information about Qt Commercial License Agreements.
** See http://www.trolltech.com/qpl/ for QPL licensing information.
** See http://www.trolltech.com/gpl/ for GPL licensing information.
**
** Contact info@trolltech.com if any conditions of this licensing are
** not clear to you.
**
**********************************************************************/

/*! \page small-table-demo-walkthrough.html

\ingroup walkthroughs

\title Walkthrough: A short demonstration of the Qt table module

The \link small-table-demo-example.html following example \endlink
shows how to populate the cells of a spreadsheet with
pixmaps and text, combo boxes and check boxes.

Our aim is a table that consists of 100 columns and 100 rows, 
with the entire second column filled with check boxes.
The sixth column is filled with combo boxes where
users might choose between four items.
The third cell in the fourth row contains a pixmap and a string.

<h3>A simple table with some special cell entries</h3>

\walkthrough table/small-table-demo/main.cpp
\skipto include
\printuntil qstringlist.h

All we need to implement this are five classes: \l QApplication
(overall it's a GUI program), \l QTable for the spreadsheet, \l QImage to
load and scale the icon, \l QPixmap to show it, and \l QStringList
to store the combo box items.

\skipto qtlogo.xpm
\printline qtlogo.xpm

\e qtlogo.xpm contains the \e qtlogo_xpm pixmap we're going to use.

\skipto 100
\printuntil numCols

Next we define the table size: 100 columns and 100 rows.

\skipto main
\printuntil QApplication

In the main program the first thing for us to do is to create 
"the application" itself.

\printline table

Then we create a \e table widget of the defined size.

\printline img

Next we load the pixmap we want to show. We use a QImage for this purpose
because we don't know whether the icon fits into the table cell.

Scaling and other transformation operations are efficiently applied to 
QImage objects whilst to transform
a QPixmap Qt has to obtain it from the windowing system where
QPixmaps are stored, do the
transformation, and hand the transformed pixmap back 
to the windowing system.

\printline pix

We scale the image to fit into the cell. As we want to place it in the
fourth row, the limiting factor is the height of this row (keep in mind
that row and column numbering in QTable starts with zero so that the fourth
row is denoted by \e{3}). 

We assign the resulting QImage to a QPixmap. This
hands the pixmap over to the windowing system, so that we can use it for
displaying purposes.

\printline table.setPixmap

The scaled pixmap now becomes the content of the cell where fourth 
row and third column meet.

\printline table.setText  

Then we add the text string \e{A Pixmap} 
to the right of the pixmap.

\printline QStringList

We mentioned earlier that we intend to populate the entire sixth
column with combo boxes. A combo box with no entries to choose from 
is quite boring. 
Thus we define a string list \e comboEntries to store them.

\printline comboEntries

The combo boxes will hold four entries, boringly named \e one to
\e four.

\printline < numRows

Beginning with the first row, row after row, until we are done
with the last row (i.e. no. \e{numRows-1}) ...

\printuntil TRUE

... we wish to populate the sixth column with identical combo boxes 
showing the entries \e one, \e two, \e three and \e four. 
Fortunately there is a special class to fill table cells with combo boxes
named QComboTableItem.

Thus we create a QComboTableItem object for every column.
As we set the last parameter to TRUE the user has the possibility to
change the text of the combo box entries. 

\printline setCurrentItem

Although all of the combo table items are the same we want them
to show different initial values: Instead of having an entire column
boringly showing a \e one as current value of each cell, we prefer
\e one, \e two, \e three, \e four, \e one, \e two etc. top-down.

To achieve this we define that the first and every fourth combo box
initially show the first menu entry (the row number modulo 4 equals 
0 and therefore uses the \e one entry), the second and every fourth
combo table item show \e two, and so forth.

\printline setItem
\printline }

Finally we fill the 5th column with the prepared combo box items. 

\printline for
\printline QCheckTableItem

Similarly the entire second column is filled with unchecked
check boxes of the title \e{Check me}. 

\printline app

So we are done with creating the table. We make it the main window of
the Qt application,

\printline show

show it,

\printuntil }

and start the event loop of the GUI.

*/
