/****************************************************************************
** $Id: porting.doc,v 1.8 1998/09/27 19:33:36 agulbra Exp $
**
** Help with porting from Qt 1.x to Qt 2.0
**
** Copyright (C) 1998 by Troll Tech AS.  All rights reserved.
**
*****************************************************************************/

/*! \page porting.html

<title>Qt 2.0 - Porting</title></head><body bgcolor="#ffffff">

\postheader

<h1 align=center> Porting to Qt 2.0 </h1><br clear="all">

<h2>How</h2>

 - Read all the notes to get an idea of what to expect
 - Recompile.  For each error, search below for related identifiers
    (eg. function names, class names)

<h2>Notes</h2>
<p>
QApplication::setColorSpec()
PrivateColor and TrueColor are obsolete.  Use ManyColor.

<p>
QDataStream &operator<<( QDataStream &s, const QRegion &r )
QRegion data files now write in a more efficient form.  The new form
cannot be read by Qt 1.x, but Qt 2.0 can still read old 1.x data.

<p>
QWidget::recreate()
This function is now called reparent().

<p>
paintEvent() crashes
Never pass 0 as the argument to paintEvent().

<p>
QLabel::setMovie()
No longer changes the text.

<p>
QString
Now uses Unicode.  data() is obsolete - you cannot directly access the
 string as an array of bytes, because it isn't one.  Often, ascii() is
 what you want rather than data(), or just leave it to convert to
 const char* automatically.  data() is only used now to aide porting to Qt 2.0
In qt/src/tools/qstring.cpp there is a Q2HELPER - define it for some
 extra debugging features (don't leave it it - it kills performance).
detach() is obsolete - QString is always shared.  It is now a no-op.
size() should be replaced by length()+1.
Code that uses QString as an array of bytes should use QByteArray
 or char[].  THEN convert that to a QString if needed.
Assigning 0 to a QString should be assigning the empty string QString()
A BIG advantage of the new QString is that it automatically expands
 when you write to an indexed position.
Try to always use QString.  If you MUST, use Q1String which is the
 implementation used in Qt 1.x.
Every conversion to and from ascii is wasted time, so try to use QString
 as much as possible rather than const char*.  This also ensures you have
 full 16-bit support. [should we have a warning feature/copy count?]
The return value from operator const char*() is transient - don't expect
 it to remain valid while you make deep function calls.
Expect your code to become simpler with the new QString, especially
 places where you have used a char* to wander over the string rather
 than using indexes into the string.
This hack:
  use_sub_string( &my_string[index] )
 should be replaced by:
  use_sub_string( my_string.mid(index) )
You may find yourself needing ascii() for passing to the operating system
 or other libraries, and be tempted to use Q1String to save the conversion,
 but you are better off using unicode throughout, then when the operating
 system supports unicode, you'll be prepared.
toShort() returns 0 (and sets *ok to false) on error.
toUInt() now works for big valid uints
insert() now works into the same string
When converting "const char*" usage to QString in order to make your
 application fully unicode-aware, use QString::null for the null value
 where you would have used 0 with char pointers.
When converting, set a breakpoint in QString::ascii() to catch places where
 you are losing Unicode information.
Many signal/slots have changed from const char* to QString.  You will
 get run-time errors when you try to QObject::connect() to the old
 signals and slots.
QString is not null terminated.  This means that inserting a 0-character
 in the middle of the string does NOT change the length().  ie.
   QString s = "fred";
   s[1] = '\0';
     s.length() == 4
     s == "f\0ed";
     s.ascii() == "f";
   s[1] = 'r';
     s == "fred";
     s.ascii() == "fred";
 Especially look out for this type of code:
   QString s(2);
   s[0] = '?';
   s[1] = 0;
 This creates a string 2 characters long.
 To find these problems while converting, ASSERT(strlen(d->ascii)==d->len)
  inside QString::ascii().

<p>
QLayout, QBoxLayout, QGridLayout
Doesn't set minimumSize(), resize(0,0) or resize(1,1) will work unless
QT_NO_LAYOUT_COMPAT is defined.
The layout classes will use sizeHint() if minimumSize() is not set.
The class QGManager is removed. Subclasses of QLayout need to be rewritten
to use the new, much simpler API.

<p>
QMultiLineEdit::textWidth(QString*)
changed to QMultiLineEdit::textWidth(QString)
 Should be no problem.

<p> 
Some repaint problems problems might occur with subclasses on QFrame,
 QPushButton, and QComboBox, which now use WResizeNoErase to improve
 resize repainting.  Be sure to call the resizeEvent() of your base
 class if your derive a widget subclass.  The quickest fix is to add:
   resizeEvent(QResizeEvent* e)
   {
       repaint( e->rect(), TRUE );
   }

<p>
QClipboard::pixmap() now returns a QPixmap, not a QPixmap*.

<p>
The following virtual functions have changed signature in Qt 2.0.
If you override them, you must change your code.
[can we provide assistance in the code for this?]
[GENERATE THE LIST]
Easy for const char* -> QString - there are about 20 in total.

<p> The global #define macros in qevent.h have been replaced by an
enum in QEvent.  Use e.g. QEvent::Paint instead of Event_Paint.

<p> The Q_*_EVENT macros in qevent.h have been deleted.  Use an
explicit cast instead.

<p> QChildEvents are now sent for all QObjects, not just QWidgets.
You may need to add extra checking if you use QChildEvent without
much testing of its values.

<p> The Q_DECLARE macro and qgeneric.h are obsolete.  Use real
template instantiations instead.  (e.g. QCache<QPixmap> instead of
Q_DECLARE(QCache,QPixmap).)

<p> The GrayText painter flag has ben removed.  use
setPen( palette().disabled().foreground() ) instead.

<p> Many previously global identifiers have been moved into our new
namespace class, Qt (qnamespace.h).  The <code>qt/bin/qt20fix</code>
script helps to fix the code that needs adaption.  Most code does not
need any change.

*/
