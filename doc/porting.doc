/****************************************************************************
** $Id: porting.doc,v 1.4 1998/08/17 03:32:23 warwick Exp $
**
** Help with porting from Qt 1.x to Qt 2.0
**
** Copyright (C) 1998 by Troll Tech AS.  All rights reserved.
**
*****************************************************************************/

/*! \page porting.html

<title>Qt 2.0 - Porting</title></head><body bgcolor="#ffffff">

\postheader

<h1 align=center> Porting to Qt 2.0 </h1><br clear="all">

<h2>How</h2>

 - Read all the notes to get an idea of what to expect
 - Recompile.  For each error, seach below for related idetifiers
    (eg. function names, class names)

<h2>Notes</h2>
<p>
QApplication::setColorSpec()
PrivateColor and TrueColor are obsolete.  Use ManyColor.

<p>
QDataStream &operator<<( QDataStream &s, const QRegion &r )
QRegion data files now write in a more efficient form.  The new form
cannot be read by Qt 1.x, but Qt 2.0 can still read old 1.x data.

<p>
QWidget::recreate()
This function is now called reparent().

<p>
paintEvent() crashes
Never pass 0 as the argument to paintEvent().

<p>
QLabel::setMovie()
No longer changes the text.

<p>
QString
Now uses Unicode.  data() is obsolete - you cannot directly access the
 string as an array of bytes, because it isn't one.  Often, ascii() is
 what you want rather than data(), or just leave it to convert to
 const char* automatically.  data() is only used now to aide porting to Qt 2.0
detach() is obsolete - QString is always shared.  It is now a no-op.
size() should be replaced by length()+1.
Code that uses QString as an array of bytes should use QByteArray
 or char[].  THEN convert that to a QString if needed.
Assigning 0 to a QString should be assigning the empty string QString()
A BIG advantage of the new QString is that it automatically expands
 when you write to an indexed position.
Try to always use QString.  If you MUST, use Q1String which is the
 implementation used in Qt 1.x.
Every conversion to and from ascii is wasted time, so try to use QString
 as much as possible rather than const char*.  This also ensures you have
 full 16-bit support. [should we have a warning feature/copy count?]
The return value from operator const char*() is transient - don't expect
 it to remain valid while you make deep function calls.
Expect your code to become simpler with the new QString, especially
 places where you have used a char* to wander over the string rather
 than using indexes into the string.
This hack:
  use_sub_string( &my_string[index] )
 should be replaced by:
  use_sub_string( my_string.mid(index) )
You may find yourself needing ascii() for passing to the operating system
 or other libraries, and be tempted to use Q1String to save the conversion,
 but you are better off using unicode throughout, then when the operating
 system supports unicode, you'll be prepared.
toShort() returns 0 (and sets *ok to false) on error.
toUInt() now works for big valid uints
insert() now works into the same string
When converting "const char*" usage to QString in order to make your
 application fully unicode-aware, use QString::null for the null value
 where you would have used 0 with char pointers.
When converting, set a breakpoint in QString::ascii() to catch places where
 you are losing Unicode information.
Many signal/slots have changed from const char* to QString.  You will
 get run-time errors when you try to QObject::connect() to the old
 signals and slots.


<p>
QMultiLineEdit::textWidth(QString*)
changed to QMultiLineEdit::textWidth(QString)
 Should be no problem.

<p> 
Some repaint problems problems might occur with subclasses on QFrame,
 QPushButton, and QComboBox, which now use WResizeNoErase to improve
 resize repainting.  Be sure to call the resizeEvent() of your base
 class if your derive a widget subclass.  The quickest fix is to add:
   resizeEvent(QResizeEvent* e)
   {
       repaint( e->rect(), TRUE );
   }

<p>
QClipboard::pixmap() now returns a QPixmap, not a QPixmap*.
*/
