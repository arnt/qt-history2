/****************************************************************************
** $Id: porting.doc,v 1.17 1999/01/15 16:30:52 warwick Exp $
**
** Help with porting from Qt 1.x to Qt 2.0
**
** Copyright (C) 1998 by Troll Tech AS.  All rights reserved.
**
*****************************************************************************/

/*! \page porting.html

<title>Qt 2.0 - Porting</title></head><body bgcolor="#ffffff">

\postheader

<h1 align=center> Porting to Qt 2.0 </h1><br clear="all">

<h2>How to port code using Qt 1.x to use Qt 2.0</h2>

<ul>
 <li> Read all the notes to get an idea of what to expect
 <li> Recompile.  For each error, search below for related identifiers
	(eg. function names, class names).  Where possible, we have tried
	to make problem code cause compile-time errors when compiled 
	with Qt 2.0.
</ul>

<h2>Notes</h2>



<h3>General</h3>


<p>
The following virtual functions have changed signature in Qt 2.0.
If you override them, you must change your code.
[can we provide assistance in the code for this?]
[GENERATE THE LIST]
Easy for const char* -> QString - there are about 20 in total.

<p> The Q_DECLARE macro and qgeneric.h are obsolete.  Use real
template instantiations instead.  (e.g. QCache<QPixmap> instead of
Q_DECLARE(QCache,QPixmap).)

<p> The GrayText painter flag has ben removed.  use
setPen( palette().disabled().foreground() ) instead.

<p> Compiling with -DQT1COMPATIBILITY will help you get going with
Qt 2.0 - it allows all the old "dirty namespace" identifiers from
Qt 1.x to continue working.  Without it, you'll get errors that
can easily be fixed by searching this page for the clean identifiers.

<p> Many previously global identifiers have been moved into our new
namespace class, Qt (qnamespace.h).  The <code>qt/bin/qt20fix</code>
script helps to fix the code that needs adaption.  Most code does not
need any change.


<h3>QApplication</h3>


<p>
QApplication::setColorSpec()
PrivateColor and TrueColor are obsolete.  Use ManyColor.


<h3>QColor</h3>

<p>
All colors (red, white, blue, black, color0, etc.) are in the Qt namespace.
In members of classes that inherit the Qt namespace-class (eg. QWidget
subclasses), you can use the unqualified names as usual, but in global
functions (eg. main()), you need to qualify them:  Qt::red, Qt::white, etc.

<h3>QRegion</h3>


<p>
QDataStream &operator<<( QDataStream &s, const QRegion &r )
QRegion data files now write in a more efficient form.  The new form
cannot be read by Qt 1.x, but Qt 2.0 can still read old 1.x data.


<h3>QWidget</h3>


<p>
QWidget::recreate()
This function is now called reparent().

<p>
paintEvent(0) crashes.
Never pass 0 as the argument to paintEvent().

<p> 
Some repaint problems problems might occur with subclasses on QFrame,
 QPushButton, and QComboBox, which now use WResizeNoErase to improve
 resize repainting.  Be sure to call the resizeEvent() of your base
 class if your derive a widget subclass.  The quickest fix is to add:
 \code
   resizeEvent(QResizeEvent* e)
   {
       repaint( rect() );
   }
 \endcode


<h3>QLabel</h3>


<p>
QLabel::setMovie()
No longer changes the text.

<h3>QDialog</h3>

<p> The semantics of the parent pointer changed for non-modal dialogs:
In Qt-2.x, dialogs are always toplevel windows. The parent, however,
takes the ownership of the dialog, i.e. he will delete the dialog on
destruction time. Furthermore, the window system will be able to tell
that both the dialog and the parent belong together. Some X11 window
managers will for instance provide a common taskbar entry in that
case. To sum it up: If the dialogs belongs to a toplevel main window
of your application, pass this main window as parent to the dialog's
constructor. Old code (with 0 pointer) will still run. Old code that
included QDialogs as simple widget will no longer work (but was broken
anyway).

<p>

<h3>QString</h3>

QString has undergone major changes internally, and although it is highly
backward compatible, it is worth studying in detail when porting to Qt 2.0.

<dl compact>
<dt><b>QString or STL string?</b></dt>
<dd>
<p>
STL string is not Unicode, and is inefficient when used with Qt.
For example, when using:
<pre>
    QLabel::setText( const QString& )
</pre>
if you use STL string, like this:
<pre>
    void myclass::dostuffwithtext( const string& str )
    {
	mylabel.setText( QString(str.c_str()) );
    }
</pre>
that will create a (ASCII only) copy of str, stored in mylabel.
But this:
<pre>
    void myclass::dostuffwithtext( const QString& str )
    {
	mylabel.setText( str );
    }
</pre>
will make an implicitly shared reference to str in the QLabel - no copying
at all.  This function might be 10 nested function calls away from something
like this:
<pre>
    void toplevelclass::initializationstuff()
    {
	doStuff( tr("Okay") );
    }
</pre>
At this point, in Qt 2.0, the tr() does a very fast dictionary lookup
through memory-mapped message files, returning some Unicode QString for
the appropriate language (the default being to just make a QString out
of the text, of course - you're not FORCED to use any of these features),
and that SAME memory mapped Unicode will be passed though the system.
All occurrences of the translation of "Okay" will be shared.

<dd>
Now uses Unicode.  data() is obsolete - you cannot directly access the
 string as an array of bytes, because it isn't one.  Often, ascii() is
 what you want rather than data(), or just leave it to convert to
 const char* automatically.  data() is only used now to aide porting to Qt 2.0
<dt><b>Signals and Slots</b></dt>
<dd>
Many signal/slots have changed from const char* to QString.  You will
 get run-time errors when you try to QObject::connect() to the old
 signals and slots.
<dt><b>Optimize with Q2HELPER</b></dt>
<dd>
In qt/src/tools/qstring.cpp there is a Q2HELPER - define it for some
 extra debugging/optimizing features (don't leave it it - it kills performance).
<dt><b>QString::detach() is obsolete</b></dt>
<dd>
QString is always shared.  It is now a no-op.
<dt><b>QString::size() is obsolete</b></dt>
<dd>
should be replaced by length()+1.
<dt><b>QString is not an array of bytes</b></dt>
<dd>
Code that uses QString as an array of bytes should use QByteArray
 or char[].  THEN convert that to a QString if needed.
<dt><b>"string = 0"</b></dt>
<dd>
Assigning 0 to a QString should be assigning the empty string QString()
<dt><b>Automatic-expanding</b></dt>
<dd>
A big advantage of the new QString is that it automatically expands
 when you write to an indexed position.
<dt><b>Use QString</b></dt>
<dd>
Try to always use QString.  If you MUST, use QCString which is the
 implementation used in Qt 1.x.
<dt><b>Unicode vs. ASCII</b></dt>
<dd>
Every conversion to and from ascii is wasted time, so try to use QString
 as much as possible rather than const char*.  This also ensures you have
 full 16-bit support. [should we have a warning feature/copy count?]
<dt><b>Convestion to ASCII</b></dt>
<dd>
The return value from operator const char*() is transient - don't expect
 it to remain valid while you make deep function calls.  The value is
 in Latin1 characters.
<dt><b>QString is simpler</b></dt>
<dd>
Expect your code to become simpler with the new QString, especially
 places where you have used a char* to wander over the string rather
 than using indexes into the string.
<dt><b>Some hacks don't work</b></dt>
<dd>
This hack:
  use_sub_string( &my_string[index] )
 should be replaced by:
  use_sub_string( my_string.mid(index) )
<dt><b>System functions</b></dt>
<dd>
You may find yourself needing ascii() for passing to the operating system
 or other libraries, and be tempted to use QCString to save the conversion,
 but you are better off using unicode throughout, then when the operating
 system supports unicode, you'll be prepared.
<dt><b>Bugs removed</b></dt>
<dd>
toShort() returns 0 (and sets *ok to false) on error.
toUInt() now works for big valid uints
insert() now works into the same string
<dt><b>NULL pointers</b></dt>
<dd>
When converting "const char*" usage to QString in order to make your
 application fully unicode-aware, use QString::null for the null value
 where you would have used 0 with char pointers.  0 will usually work,
 but it wastes memory (more allocations are done).
<dt><b>How to be Unicode-clean</b></dt>
<dd>
When converting, set a breakpoint in QString::ascii() to catch places where
 you are losing Unicode information.
<dt><b>QString is not null terminated</b></dt>
<dd>
This means that inserting a 0-character
 in the middle of the string does NOT change the length().  ie.
 \code
   QString s = "fred";
   s[1] = '\0';
     s.length() == 4
     s == "f\0ed";
     s.ascii() == "f";
   s[1] = 'r';
     s == "fred";
     s.ascii() == "fred";
 \endcode
 Especially look out for this type of code:
 \code
   QString s(2);
   s[0] = '?';
   s[1] = 0;
 \endcode
 This creates a string 2 characters long.
 To find these problems while converting, ASSERT(strlen(d->ascii)==d->len)
  inside QString::ascii().
</dl>


<h3>QLayout</h3>


<p>
QLayout, QBoxLayout, QGridLayout
Don't set minimumSize(). resize(0,0) or resize(1,1) will work unless
QT_NO_LAYOUT_COMPAT is defined.
The layout classes will use sizeHint() if minimumSize() is not set.
The class QGManager is removed. Subclasses of QLayout need to be rewritten
to use the new, much simpler API.


<h3>QMultiLineEdit</h3>


<p>
QMultiLineEdit::textWidth(QString*)
changed to QMultiLineEdit::textWidth(QString)
 Should be no problem.


<h3>QClipboard</h3>


<p>
QClipboard::pixmap() now returns a QPixmap, not a QPixmap*.


<h3>QDropSite</h3>


<P>
QDropSite is obsolete.  If you passed anything other than <tt>this</tt>
to the constructor for QDropSite, your code will not work.  If you passed
the viewport() of a QListView, simply override the viewportDragMoveEvent(),
etc.  functions rather than QListView's dragMoveEvent() etc.  For other
cases, you will need to use an event filter to act on the drag/drop events
of another widget (as is the usual way to intercept foreign events).


<h3>QTextStream</h3>

<p>
operator>>(QTextStream&, QChar&) does not skip whitespace.
operator>>(QTextStream&, char&) does, as was the case with Qt 1.x.


<h3>QPixmap</h3>

QPixmap::convertToImage() with bitmaps now guarantees that color0 pixels
become color(0) in the resulting QImage.  If you worked around the lack of
this, you many need to simplify your code.  The symptom will be inverted
bitmaps (eg. inside-out masks).


<h3>QMenuData / QPopupMenu</h3>

In 1.4x, new menu items have been assigned either an application
unique id or an id equal to the index of the item, depending on the
insertItem(...) function you have been using. In 2.0 this confusing
situation has been cleaned up: generated identifiers are always unique
within the entire application. If your code depends on generated ids
equal to the item's index, a quick fix is to use QMenuData::indexOf(
int id) in the handling function instead. You may as well pass
QMenuData::count() as identifier when you insert the items.

<h3>QWindow</h3>

This class (which was just QWidget under a different name) has been
removed.  If you used it, do a global search-and-replace or the word
"QWindow" by "QWidget".  

<h3>QEvent</h3>

<p> The global #define macros in qevent.h have been replaced by an
enum in QEvent.  Use e.g. QEvent::Paint instead of Event_Paint.

<p> The Q_*_EVENT macros in qevent.h have been deleted.  Use an
explicit cast instead.

<p> QChildEvents are now sent for all QObjects, not just QWidgets.
You may need to add extra checking if you use QChildEvent without
much testing of its values.

*/
