/****************************************************************************
** $Id: porting.doc,v 1.23 1999/01/30 13:06:47 aavit Exp $
**
** Help with porting from Qt 1.x to Qt 2.0
**
** Copyright (C) 1992-1999 Troll Tech AS.  All rights reserved.
**
** This file is part of the Qt GUI Toolkit.
**
** This file may be distributed under the terms of the Q Public License
** as defined by Troll Tech AS of Norway and appearing in the file
** LICENSE.QPL included in the packaging of this file.
**
** Licensees with valid Qt Professional Edition licenses may distribute and
** use this file in accordance with the Qt Professional Edition License
** provided at sale or upon request.
**
** See http://www.troll.no/pricing.html or email sales@troll.no for
** information about the Professional Edition licensing, or see
** http://www.troll.no/qpl/ for QPL licensing information.
**
*****************************************************************************/

/*! \page porting.html

<title>Qt 2.0 - Porting</title></head><body bgcolor="#ffffff">

\postheader

<h1 align=center> Porting to Qt 2.0 </h1><br clear="all">

<h2>How to port code using Qt 1.x to use Qt 2.0</h2>

<ul>
 <li> Briefly read the notes below to get an idea of what to expect.
 <li> Be sure your code compiles on all your target platforms with Qt 1.x.
 <li> Recompile with Qt 2.0.  For each error, search below for related
	identifiers (eg. function names, class names).  Changes in Qt 2.0 are
	arranged so that almost all prolem code will cause compile-time
	errors when compiled with Qt 2.0.
</ul>

<p> To take full advantage of the new Internationalization
functionality in Qt 2.0, the following steps are required:

    <ul>
     <li> Start converting all uses of "const char*" in parameters to
            "const QString&" - this can often be done mechanically, eg.
            using Perl.  Convert uses of char[] for temporary string
            building to QString (much software already uses QString for
            this purpose as it offers many more facilities).  
     <li> Put a breakpoint in QString::ascii() to catch places where
	    Unicode information is being converted to ASCII (loosing
	    information if your user in not using Latin1).  Qt has
	    a small number of calls to this - ignore those.
     <li> Convert all <em>user-visible</em> strings to be calls to
	    QObject::tr().  Note that a few strings, in particular
	    object/widget names are <em>programmer-space</em> strings -
	    translating these is pointless.  As your application matures,
	    start producing translation files for other languages.
     <li> See the Qt \link i18n.html Internationalization page\endlink 
	    for more tips.
    </ul>


<h2>Notes</h2>


<h3>Namespace</h3>

<p> Qt 2.0 is much more namespace-clean than 1.x, relying far less on
global identifiers. Identifiers like <code>red, blue, LeftButton,
AlignRight, Key_Up, Key_Down, NoBrush</code> etc. are now part of a
special class <code>Qt</code> (qnamespace.h), which is inherited by
most Qt classes.  This means that in any code you have that is
<em>not</em> in functions of classes inherited from <code>Qt</code>,
you must qualify these identifiers like this: <code>Qt::red,
Qt::LeftButton, Qt::AlignRight</endcode>, etc.

<p>The <code>qt/bin/qt20fix</code> script helps to fix the code that
needs adaption. Most code does not need any change.

Compiling with -DQT1COMPATIBILITY will help you get going with Qt 2.0
- it allows all the old "dirty namespace" identifiers from Qt 1.x to
continue working.  Without it, you'll get compile errors that can
easily be fixed by searching this page for the clean identifiers.


<h3>Virtual Functions</h3>

<p> The following virtual functions have changed signature in Qt 2.0.
If you override them in derived classes, you must change the signature
of your functions accordingly.

[can we provide assistance in the code for this?]
[GENERATE THE LIST]
Easy for const char* -> QString - there are about 20 in total.


<h3>Collection classes</h3>

<p> The macro-based Qt collection classes are obsolete; use the
template-based classes instead. I.e. the Q_DECLARE macro and
qgeneric.h are obsolete. Replace e.g. Q_DECLARE(QCache,QPixmap) with
QCache<QPixmap>.



<h3>QApplication</h3>


<p>
QApplication::setColorSpec()
PrivateColor and TrueColor are obsolete.  Use ManyColor.


<h3>QColor</h3>

<p>
All colors (red, white, blue, black, color0, etc.) are in the Qt namespace.
In members of classes that inherit the Qt namespace-class (eg. QWidget
subclasses), you can use the unqualified names as usual, but in global
functions (eg. main()), you need to qualify them:  Qt::red, Qt::white, etc.

<h3>QRegion</h3>


<p>
QDataStream &operator<<( QDataStream &s, const QRegion &r )
QRegion data files now write in a more efficient form.  The new form
cannot be read by Qt 1.x, but Qt 2.0 can still read old 1.x data.


<h3>QWidget</h3>


<p>
QWidget::recreate()
This function is now called reparent().

<p>
paintEvent(0) crashes.
Never pass 0 as the argument to paintEvent().

<p> 
Some repaint problems problems might occur with subclasses on QFrame,
 QPushButton, and QComboBox, which now use WResizeNoErase to improve
 resize repainting.  Be sure to call the resizeEvent() of your base
 class if your derive a widget subclass.  The quickest fix is to add:
 \code
   resizeEvent(QResizeEvent* e)
   {
       repaint( rect() );
   }
 \endcode


<h3>QLabel</h3>


<p>
QLabel::setMovie()
No longer changes the text.

<h3>QDialog</h3>

<p> The semantics of the parent pointer changed for non-modal dialogs:
In Qt-2.x, dialogs are always toplevel windows. The parent, however,
takes the ownership of the dialog, i.e. he will delete the dialog on
destruction time. Furthermore, the window system will be able to tell
that both the dialog and the parent belong together. Some X11 window
managers will for instance provide a common taskbar entry in that
case. To sum it up: If the dialogs belongs to a toplevel main window
of your application, pass this main window as parent to the dialog's
constructor. Old code (with 0 pointer) will still run. Old code that
included QDialogs as simple widget will no longer work (but was broken
anyway).

<p>

<h3>QString</h3>

QString has undergone major changes internally, and although it is highly
backward compatible, it is worth studying in detail when porting to Qt 2.0.
The Qt 1.x QString class has been renamed to QCString in Qt 2.0.

<dl compact>
<dt><b>Unicode</b></dt>
<dd>
Now uses Unicode.  data() is obsolete - you cannot directly access the
 string as an array of bytes, because it isn't one.  Often, ascii() is
 what you want rather than data(), or just leave it to convert to
 const char* automatically.  data() is only used now to aide porting to Qt 2.0
<dt><b>QString(int) is private</b></dt>
<dd>
The QString constructor taking an integer is now private.  This function
is not meaningful anymore, since QString does all space allocation
automatically.  99% of cases can simple be changed to use the
default constructor, QString().
<p>
In Qt 1.x the constructor was used in two ways:  accidentally,
by attempting to convert a char to a QString (the char converts to int!!) -
giving strange bugs, and as a way to make a QString big enough prior to
calling QString::sprintf().  Now in Qt 2.0, the accidental bug case is
prevented (you will get a compilation error) and QString::sprintf has
been made safe - you no longer need to pre-allocate space (though for
other reasons, sprintf is still a poor choice - eg. it doesn't pass Unicode).
The only remaining common case is conversion of 0 (NULL) to QString, which
would usually give expected results in Qt 1.x.  For Qt 2.0 the correct
syntax is to use QString::null, though this is rarely required since
the default constructor, QString(), creates a null string, but you will
need to change "const QString& param = 0" default constructors and
"return 0" in functions returning a QString.
<dt><b>Signals and Slots</b></dt>
<dd>
Many signal/slots have changed from const char* to QString.  You will
 get run-time errors when you try to QObject::connect() to the old
 signals and slots.
<dt><b>Optimize with Q2HELPER</b></dt>
<dd>
In qt/src/tools/qstring.cpp there is a Q2HELPER - define it for some
 extra debugging/optimizing features (don't leave it it - it kills performance).
<dt><b>QString::detach() is obsolete</b></dt>
<dd>
QString is always shared.  It is now a no-op.
<dt><b>QString::size() is obsolete</b></dt>
<dd>
should be replaced by length()+1.
<dt><b>QString is not an array of bytes</b></dt>
<dd>
Code that uses QString as an array of bytes should use QByteArray
 or char[].  THEN convert that to a QString if needed.
<dt><b>"string = 0"</b></dt>
<dd>
Assigning 0 to a QString should be assigning the empty string QString()
<dt><b>Automatic-expanding</b></dt>
<dd>
A big advantage of the new QString is that it automatically expands
 when you write to an indexed position.
<dt><b>Use QString</b></dt>
<dd>
Try to always use QString.  If you MUST, use QCString which is the
 implementation used in Qt 1.x.
<dt><b>Unicode vs. ASCII</b></dt>
<dd>
Every conversion to and from ascii is wasted time, so try to use QString
 as much as possible rather than const char*.  This also ensures you have
 full 16-bit support. [should we have a warning feature/copy count?]
<dt><b>Convestion to ASCII</b></dt>
<dd>
The return value from operator const char*() is transient - don't expect
 it to remain valid while you make deep function calls.  The value is
 in Latin1 characters.
<dt><b>QString is simpler</b></dt>
<dd>
Expect your code to become simpler with the new QString, especially
 places where you have used a char* to wander over the string rather
 than using indexes into the string.
<dt><b>Some hacks don't work</b></dt>
<dd>
This hack:
  use_sub_string( &my_string[index] )
 should be replaced by:
  use_sub_string( my_string.mid(index) )
<dt><b>System functions</b></dt>
<dd>
You may find yourself needing ascii() for passing to the operating system
 or other libraries, and be tempted to use QCString to save the conversion,
 but you are better off using unicode throughout, then when the operating
 system supports unicode, you'll be prepared.
<dt><b>Bugs removed</b></dt>
<dd>
toShort() returns 0 (and sets *ok to false) on error.
toUInt() now works for big valid uints
insert() now works into the same string
<dt><b>NULL pointers</b></dt>
<dd>
When converting "const char*" usage to QString in order to make your
 application fully unicode-aware, use QString::null for the null value
 where you would have used 0 with char pointers.  0 will usually work,
 but it wastes memory (more allocations are done).
<dt><b>How to be Unicode-clean</b></dt>
<dd>
When converting, set a breakpoint in QString::ascii() to catch places where
 you are losing Unicode information.
<dt><b>QString is not null terminated</b></dt>
<dd>
This means that inserting a 0-character
 in the middle of the string does NOT change the length().  ie.
 \code
   QString s = "fred";
   s[1] = '\0';
     s.length() == 4
     s == "f\0ed";
     s.ascii() == "f";
   s[1] = 'r';
     s == "fred";
     s.ascii() == "fred";
 \endcode
 Especially look out for this type of code:
 \code
   QString s(2);
   s[0] = '?';
   s[1] = 0;
 \endcode
 This creates a string 2 characters long.
 To find these problems while converting, ASSERT(strlen(d->ascii)==d->len)
  inside QString::ascii().
<dt><b>QString or STL string?</b></dt>
<dd>
<p>
STL string is not Unicode, and though it is possible to convert between STL string to QString, it is less efficient than using QString throughout.
For example, when using:
<pre>
    QLabel::setText( const QString& )
</pre>
if you use STL string, like this:
<pre>
    void myclass::dostuffwithtext( const string& str )
    {
	mylabel.setText( QString(str.c_str()) );
    }
</pre>
that will create a (ASCII only) copy of str, stored in mylabel.
But this:
<pre>
    void myclass::dostuffwithtext( const QString& str )
    {
	mylabel.setText( str );
    }
</pre>
will make an implicitly shared reference to str in the QLabel - no copying
at all.  This function might be 10 nested function calls away from something
like this:
<pre>
    void toplevelclass::initializationstuff()
    {
	doStuff( tr("Okay") );
    }
</pre>
At this point, in Qt 2.0, the tr() does a very fast dictionary lookup
through memory-mapped message files, returning some Unicode QString for
the appropriate language (the default being to just make a QString out
of the text, of course - you're not FORCED to use any of these features),
and that SAME memory mapped Unicode will be passed though the system.
All occurrences of the translation of "Okay" will be shared.

</dl>


<h3>QLayout</h3>


<p>
QLayout, QBoxLayout, QGridLayout
Don't set minimumSize(). resize(0,0) or resize(1,1) will work unless
QT_NO_LAYOUT_COMPAT is defined.
The layout classes will use sizeHint() if minimumSize() is not set.
The class QGManager is removed. Subclasses of QLayout need to be rewritten
to use the new, much simpler API.


<h3>QMultiLineEdit</h3>


<p>
QMultiLineEdit::textWidth(QString*)
changed to QMultiLineEdit::textWidth(QString)
 Should be no problem.


<h3>QClipboard</h3>


<p>
QClipboard::pixmap() now returns a QPixmap, not a QPixmap*.


<h3>QDropSite</h3>


<P>
QDropSite is obsolete.  If you passed anything other than <tt>this</tt>
to the constructor for QDropSite, your code will not work.  If you passed
the viewport() of a QListView, simply override the viewportDragMoveEvent(),
etc.  functions rather than QListView's dragMoveEvent() etc.  For other
cases, you will need to use an event filter to act on the drag/drop events
of another widget (as is the usual way to intercept foreign events).


<h3>QTextStream</h3>

<p>
operator>>(QTextStream&, QChar&) does not skip whitespace.
operator>>(QTextStream&, char&) does, as was the case with Qt 1.x.


<h3>QPainter</h3>

<p> The GrayText painter flag has been removed. Use setPen(
palette().disabled().foreground() ) instead.


<h3>QPixmap</h3>

QPixmap::convertToImage() with bitmaps now guarantees that color0 pixels
become color(0) in the resulting QImage.  If you worked around the lack of
this, you many need to simplify your code.  The symptom will be inverted
bitmaps (eg. inside-out masks).
<p>
QPixmap::optimize(TRUE) is replaced by
QPixmap::setOptimization(QPixmap::NormalOptim)
and QPixmap::setOptimization(QPixmap::BestOptim).


<h3>QMenuData / QPopupMenu</h3>

In 1.4x, new menu items have been assigned either an application
unique id or an id equal to the index of the item, depending on the
insertItem(...) function you have been using. In 2.0 this confusing
situation has been cleaned up: generated identifiers are always unique
within the entire application. If your code depends on generated ids
equal to the item's index, a quick fix is to use QMenuData::indexOf(
int id) in the handling function instead. You may as well pass
QMenuData::count() as identifier when you insert the items.

<h3>QValidator (QLineEdit, QComboBox, QSpinBox) </h3>

QValidator::validate(...) and QValidator::fixup( QString & ) are const
functions now. In case your subclass reimplements validate as
non-const you'll get a compile error (validate was pure virtual).

XXX::setValidator(...) now takes a const pointer to a QValidator,
XXX::validator() returns a const pointer, resp.. This is correct since
the widgets don't take the ownership of the validator (a validator is
a QObject on its own, with it's own parent), so changing the state of
such an object or deleting it is very likely a bug.

<h3>QWindow</h3>

This class (which was just QWidget under a different name) has been
removed.  If you used it, do a global search-and-replace or the word
"QWindow" by "QWidget".  

<h3>QEvent</h3>

<p> The global #define macros in qevent.h have been replaced by an
enum in QEvent.  Use e.g. QEvent::Paint instead of Event_Paint.

<p> The Q_*_EVENT macros in qevent.h have been deleted.  Use an
explicit cast instead.

<p> QChildEvents are now sent for all QObjects, not just QWidgets.
You may need to add extra checking if you use QChildEvent without
much testing of its values.

*/
