/****************************************************************************
** $Id: tutorial.doc,v 1.5 1995/12/20 18:51:49 hanord Exp $
**
** Tutorial
**
** Copyright (C) 1995 by Troll Tech AS.  All rights reserved.
**
*****************************************************************************/

/*! \page tutorial.html

<title>
Qt Tutorial - Introduction
</title></head><body>

<h1>The 14 Steps</h1>

This tutorial is meant to give an introduction to GUI programming
using the Qt toolkit.  It introduces some of the most important
features, but the emphasis is on the programming philosophy in Qt.

It starts with a five-line hello-world and builds gradually,
introducing one or a few concepts at a time, into a simple, 600-line
game.

To compile and run the tutorial programs, you need the Qt toolkit, gcc
version 2.7.0 or later, and X11R6.  You do not need libg++ or
libstdc++.

Each chapter explains what 


*/


------------------------------------------------------------------------------


/*! \page t1.html

<title>
Qt Tutorial - Chapter 1
</title></head><body>

<h1>Chapter 1: Hello, World!</h1>

<img src=t1.gif>

This first program is a simple hello-world example.  It contains only
the bare minimum you need to get a Qt application up and running.

\include t1/main.cpp

<h2>Line by Line Walk-Through</h2>

\skip include
\line qapp

This line includes the QApplication class definition.  There has to be
exactly one QApplication object in every application that uses Qt.
QApplication manages various application-wide resources, such as the
default font and cursor.

\line qpushbt

This line includes the QPushButton class definition.  The <a
href=hierarchy.html>reference documentation</a> for each class
mentions at the top which file needs to be included to use that class.

QPushButton is a classical GUI push button, which the user can press and
release.  It manages its own look and feel, like every other \link QWidget
widget\endlink (a widget is a user interface object).  The programmer can
change both the overall \link QApplication::setStyle() look and feel
\endlink, many minor aspects of it such as color, and the widget's content.
A QPushButton can show both a text and a pixmap.

\line main
\line {

The \c main() function is the entry point to the program.  When using
Qt, it almost always just does some initialization before it passes
control over to the Qt library, which then tells the program about the
user's actions via events.  If you are new to event-driven GUI
programming, you should probably read our \link event-driven.html
introduction \endlink to this.

\e argc is the number of command-line arguments and \e argv is the
array of command-line arguments, as always.

\line QApplication

\c a is this program's QApplication.  Here it is created and processes
some of the command-line arguments (such as -display on X).  Note that
all command-line arguments processed are \e removed.  It is essential
that the QApplication object is created before any window-system parts
of Qt are used.

\line QPushButton

Here, \e after the QApplication, comes the first window-system code: A
push button is created.

The button is set up to display the text "Hello world!" and be a
window of its own (since the constructor does not specify another
window which the button should be part of).

\line resize

The button is set up to be 100 pixels wide and 30 pixels high (plus
the window system frame).

\line setMainWidget

The push button is chosen as the main widget for the application.  If
the user closes a main widget, the application exits.

You don't have to have a main widget, but most programs have one.

\line show

A widget is never visible when you create it.  You must call show() to
make it visible.

\line exec

This is where \c main() passes control to Qt.  exec() will return when
the application exits.

In exec(), events are received from the user and passed on to the
appropriate widgets.

\line }

That's it.

<h2>Behavior</h2>

You should now try to \link makefiles.html compile \endlink and \link
QApplication::QApplication() run \endlink this program.

When you run it, you will see a small window filled with a single
button, and on it you can read the famous words, Hello World!

Try to resize the window.  Press the button.  If you're running X, try
running the program with the -geometry option (e.g. -geometry
100x200+10+20)

You may now go on to \link t2.html chapter two. \endlink

*/


------------------------------------------------------------------------------


/*! \page t2.html

<title>
Qt Tutorial - Chapter 2
</title></head><body>

<h1>Chapter 2: Calling it Quits</h1>

<img src=t2.gif>

Having \e created a window in \link chapter one, \endlink we will now
go on to close it properly and make the application quit properly when
the user tells it to.

We will also use a font that is more exciting than the default one.

\include t2/main.cpp

<h2>Line by Line Walk-Through</h2>

\skipline qfont

Since this program uses QFont, it needs to include qfont.h.  Qt's font
abstraction is rather different from the horror provided by X, and
loading and using fonts has been highly optimized.

\skipline QPushButton

This time, the button says "Quit" and that's exactly what the program
will do when the user clicks the button.  This is not a coincidence.

\line resize

Since "Quit" is rather shorter than "Hello World!" we've made the
button a bit smaller.  We could also have used
QPushButton::setAutoResize(), or even QFontMetrics if the built-in
resizing wasn't quite right for our taste.

\line setFont

Here we choose a new font for the button, an 18-point bold font from
the Times family.  Note that we create the font on the spot.  If the
same font is used several times in one program, Qt will cache it.

It is also possible to \link QApplication::setDefaultFont() change the
default font \endlink for the whole application.

\line connect

connect() is perhaps \e the most central feature of Qt.
Note that connect() is a static function in QObject. Do not confuse it
with the connect function in the socket library.

This line establishes a one-way connection between two Qt objects
(objects that inherit QObject, directly or indirectly).  Every Qt
object can have both \c signals (to send messages) and \c slots (to
receive messages). (All widgets are Qt objects.)

Here, the \e clicked() signal of \e quit is connected to the \e
quitApp() slot of \e a, so that when the button is clicked, the
application quits.

\link metaobjects.html Signals and Slots \endlink covers this topic
more thoroughly.

<h2>Behavior</h2>

When you run this program, you will see an even smaller window than in
chapter one, filled with an even smaller button.

Try to resize the window.  Press the button.  Oops!  That connect()
would seem to make some difference :)

<h2>Excercises</h2>

Are there any other signals in QPushButton you can connect to quitApp?
Hint: The QPushButton inherits most of its behavior from QButton.

You may now go on to \link t3.html chapter three. \endlink

*/


------------------------------------------------------------------------------


/*! \page t3.html

<title>
Qt Tutorial - Chapter 3
</title></head><body>

<h1>Chapter 3: Family Values</h1>

<img src=t3.gif>

This example shows how to create mother and child widgets.

We'll keep it simple and use just a single mother (uh, family values?)
and a lone child.

\include t3/main.cpp

<h2>Line by Line Walk-Through</h2>

\skipline QWidget

Here we simply create a widget.  Note that we did not bother to
include \c qwidget.h, because we have included qpushbt.h and
QPushButton is a subclass of QWidget (see <a href=hierarchy.html>
Class Hierarchy</a>).

A QWidget does not handle any events, it simply displays itself using
its \link QWidget::setBackgroundColor() background color \endlink and
\link QWidget::setCaption() caption. \endlink

\line resize

We set the width to 200 pixels and the height to 120 pixels.

\line quit

A child is born.

This QPushButton is created with both a text, "Quit", and a mother, w.
A child widget is always on top of its mother.  When displayed, it is
clipped by its mother's bounds.

\line move

The child is moved to a position of 62,40, relative to its mother's
top left corner.  The coordinate is as usual for a visual display, x
increases to the right and y increases downwards.

\skipline show

When a widget is shown, it will call show for all its children (except
those you have done an explicit \link QWidget::hide hide() \endlink
on).

<h2>Behavior</h2>

Note that if you resize the window, the button is not resized, unlike
the programs in the first two chapters.  That's because the top level
widget is a QWidget, which does not react to resizing.

If you're using X-windows, you will see the same effect if you invoke
the program with -geometry.

<h2>Excercises</h2>

Try changing the arguments to quit.move() and/or quit.resize().  What
happens if quit is partly "outside" w?

Also try moving the w.resize() to after the quit.move/resize, and to
after \link QApplication::setMainWidget() a.setMainWidget()\endlink.
Does -geometry still work?

You may now go on to \link t4.html chapter four. \endlink

*/


------------------------------------------------------------------------------


/*! \page t4.html

<title>
Qt Tutorial - Chapter 4
</title></head><body>

<h1>Chapter 4: Let There Be Widgets</h1>

<img src=t4.gif>

This example shows how to create your own widget, how to control the
minimum and maximum sizes of a window, and introduces widget names.

\include t4/main.cpp

<h2>Line by Line Walk-Through</h2>

\skip MyWidget
\until }

Here we create a new class.  Since this class inherits from QWidget,
the new class is a widget, and may be a top level window or a child
widget (like the push button in chapter three).

This class has only one member, a constructor (in addition to the
members it inherits from QWidget).  The constructor is a standard Qt
widget constructor; you should always include a similar constructor
when you create widgets.

The first argument is its parent widget.  To create a top level window
you specify a null pointer as the parent.  As you can see, the widget
defaults to be a top level window.

The second argument is the widget's name.  This is \e not what appears
in the title bar.  For now, just think of it as a descriptive name for
this object.

\line MyWidget
\line QWidget

The implementation of the constructor starts here.  Like all widgets,
it just passes on the \c parent and \c name to the QWidget
constructor.

\until setMaximumSize

Since this widget doesn't know how to handle resizing, we fix its size
by setting the minimum and maximum to be equal.  In the next chapter,
we will show how a widget can respond to resize event from the user.

\until setFont

Here we create a child widget of this widget (the new widget's parent
is <code>this</code) which has the widget name "quit".  The widget
name has nothing to do with the button text, they just happen to be
similar in this case.

\c quit is a local variable in the constructor.  MyWidget does not
keep track of it, but Qt does, and will by default delete it when
MyWidget is deleted.  This is why MyWidget doesn't need a destructor.
There is no harm in deleting a child when you choose to, the child
will automatically tell Qt about its imminent death.

The setGeometry() call does the same as move() and resize() did in the
previous chapters.

\line qApp
\line }

Since the MyWidget class doesn't know about the application object, it
has to connect to Qt's pointer to it, \c qApp.  See the QApplication
documentation for details.

A widget is a <a link=components.html>software component</a> and
should know as little as possible about its environment in order to be
as general and reusable as possible.

Knowing the name of the application object would break this principle,
so Qt offers an alias, qApp, for the rare cases where a component such
as MyWidget needs to talk to the application object.

\until }

Here we instantiate our new baby, set it to be the main widget, and
execute the application.

<h2>Behavior</h2>

This program is very similar in behavior to the previous one.  The difference
lies in the way we have implemented it.  It does behave slightly different.
Just try to resize it to see.

<h2>Excercises</h2>

Try to add more buttons, or put in widgets other than QPushButton.

The \link QWidget::setBackgroundColor background color \endlink can be
changed.

Try creating two or more MyWidgets in main.

You may now go on to \link t5.html chapter five. \endlink

*/


------------------------------------------------------------------------------


/*! \page t5.html

<title>
Qt Tutorial - Chapter 5
</title></head><body>

<h1>Chapter 5: Lego</h1>

<img src=t5.gif>

This example shows how to create and connect together several widgets
using signals and slots, and how to handle resize events.

\include t5/main.cpp

<h2>Line by Line Walk-Through</h2>

\skip qapp
\until qfont

Two new include files here, qscrbar.h and qlcdnum.h, because we use two
new classes.

\skip MyWidget
\until parent=0

Nothing new compared to the previous chapter.

\until resize

MyWidget now gains the ability to handle resize event.

resizeEvent() is one of a dozen-odd virtual functions in QWidget which
are used to pass events of various kinds to widgets.  These \link
event-system.html event functions \endlink are one of the the central
control flow mechanisms in Qt, the other is the \link metaobjects.html
signal/slot mechanism. \endlink

This one is called, unsurprisingly, whenever the user or a part of the
program resizes the widget.

\until }

In chapter three, MyWidget didn't remember its child widget.  Now it
does (so it can resize them).

\until setMinimumSize

Since we want MyWidget to handle all sizes greater than 200 by 200
pixels, we only set a minimum size.

<a name=constructor></a>
\skip lcd
\until move

\c lcd is a QLCDNumber, a widget which displays numbers in an LCD-like
fashion.  This instance is set up to display two digits, be a child of
\e this and is named "lcd".

It is located at x position 10 and a y position giving 10 pixels between the
quit button and the LCD number.  It is a good idea to take a look at
\link coordsys.html The Coordinate System\endlink.
Note that its size is not set here, resizeEvent() will do that when
MyWidget's own size is set.

Hardcoding positions like this is tedious when you have many widgets,
but Qt does not include a nice designer yet.  Stay tuned.

\line QScrollBar
\until scrollbar

QScrollBar is a classical window system scrollbar.  This is one of
several possible constructors, there are other constructors that take
fewer arguments but then we'd have to set up the same state using
several function calls.

We don't set up the scrollbar's geometry, the resize event will handle
it.

\line connect

Here we use the \link metaobjects.html signal/slot mechanism \endlink
to connect the scrollbar's valueChanged() signal to the LCD number's
display() slot.

Whenever the scrollbar's value changes, it broadcasts the new value by
emitting the valueChanged() signal.  Since that signal is connected to
the LCD number's display() slot, the slot is called when the signal is
broadcast.  Neither of the objects know about the other.  This is
essential in component programming.

Slots are otherwise normal C++ member functions and follow the normal
C++ access rules.

<a name=resize></a>
\skip resizeEvent
\until }

The scrollbar's geometry is set so there is a 10-pixel border to the
left, right and below it, and its height is fixed at 16 pixels, which
is recommended by most style guides.

Remember that the order of arguments to setGeometry() is left, top,
width, height.

The LCD number is resized in the same way.  Its position was set in
the constructor.  We use the same width as for the scrollbar, and
leave five pixels between it and the scrollbar.

<!-- geometry management -->

<h2>Behavior</h2>

The LCD number reflects everything you do to the scrollbar, and the
widget handles resizing well.

<h2>Excercises</h2>

Try changing the LCD number to add more digits or \link
QLCDNumber::setMode() change mode. \endlink You can even add four push
buttons to set mode.

You can also change the scrollbar's range.

Try to make the application quit when the number overflows.

You may now go on to \link t6.html chapter six. \endlink

*/


------------------------------------------------------------------------------


/*! \page t6.html

<title>
Qt Tutorial - Chapter 6
</title></head><body>

<h1>Chapter 6: Lego Galore!</h1>

<img src=t6.gif>

This example shows how to encapsulate two widgets into a new component and
how easy it is to use many widgets.  For the first time, we use a custom
widget as a child widget.

\include t6/main.cpp

<h2>Line by Line Walk-Through</h2>

\skip LCDRange
\until };

The LCDRange widget is an encapsulation of a QScrollBar and a
QLCDNumber, connected together.

\until }

This is essentially lifted straight from the <a
href=t5.html#constructor>MyWidget constructor</a> in chapter five.
The only difference is that \c lcd is now placed at coordinate 0,0
(the top left corner of the LCDRange widget) since we're making a new
widget and don't want a border.  If the widget's user wants a border,
he/she can make a border around the LCDRange.

\until }

Since LCDRange doesn't have either a border or quit button, the resize
event is simpler than <a href=t5.html#resize>the one in MyWidget.</a>

\skip private
\until }

MyWidget now contains the familiar quit button and an array of 16
LCDRange pointers.

\skip for
\line 16
\line value

In MyWidget's constructor, we create 16 LCDRanges, all with \c this as
parent.  Remember that these will be deleted by Qt when MyWidget is
destroyed.

\skip resizeEvent
\until }

In the resize event, we calculate and set the geometry of all 16
LCDRanges in a simple for loop.

First we calculate the top left position of the top left LCDRange.
We give it a 10 pixel border to the left and a 10 pixel border up
to the quit button (see \link coordsys.html The Coordinate System
\endlink)

We then calculate the size of each LCDRange. We want a grid of 4x4
widgets with a 10 pixel border to the right and 5 pixels between 
each one (i.e. 3 borders of 5 pixels in each direction).
Note that since we divide by the integer 4, we will get small roundoff
errors.

Next, we set each individual geometry in a simple loop. We calculate
the position using integer modulo and divide and remember to add 5
for the border between each one. 

<h2>Behavior</h2>

This program shows how easy it is to use many widgets at a time.
Each single one behaves like the scroll bar and LCD number in the 
previous chapter.  Again, the difference lies in the implementation.

<h2>Excercises</h2>

Change MyWidget so each LCDRange is guaranteed to be square.

Initialize each scrollbar with a different/random value on startup.

You may now go on to \link t7.html chapter seven. \endlink

*/


------------------------------------------------------------------------------


/*! \page t7.html

<title>
Qt Tutorial - Chapter 7
</title></head><body>

<h1>Chapter 7: One Thing Leads to Another</h1>

<img src=t7.gif>

This example shows how to create custom widgets with signals and
slots, and how to connect them together in more complex ways.  For the
first time, the source is split among several files.

<ul>
<li> \link t7/lcdrange.h lcdrange.h \endlink contains the LCDRange
class definition
<li> \link t7/lcdrange.cpp lcdrange.cpp \endlink contains the LCDRange
implementation
<li> \link t7/main.cpp main.cpp \endlink contains MyWidget and main.
<li> \link t7/Makefile Makefile \endlink contains some rules for
generating the metaobject information necessary for <a
href=metaobjects.html>signal/slot creation.</a>
</ul>

<h2>Line by Line Walk-Through</h2>

<h3>lcdrange.h</h3>

This file is mainly lifted from \link t6/main.cpp main.cpp \endlink and
only the changes are noted here.

\dontinclude t7/lcdrange.h

\skip ifndef
\until define

This is the classical C construction to avoid errors if a header file
happens to be included more than once.  If you don't use it already:
It is a very good habit.  The #ifndef should enclose \e all of the
header file.

\line include
\line QScrollBar
\line QLCDNumber

\c qwidget.h is included.  LCDRange inherits QWidget, and the header
file of a parent class must always be included.  Until now, \c
qwidget.h has been included indirectly via other header files like \c
qpushbt.h.

Since the class declaration only uses pointers to QScrollBar and
QLCDNumber it does not need their definitions, so we merely declare
their names in the header files.  This makes the job a little easier
for the compiler.

\skip LCDRange
\until parent=0

Note the Q_OBJECT.  This macro must be included in \e all classes that
contain signals and/or slots.  For the curious, it defines the
functions that are implemented in the <a
href=metaobject.html>metaobject file</a>.

\line value
\until valueChanged

These three members make up an interface between this widget and other
components in a program.  Until now, LCDRange didn't really have an
interface at all.

value() is a public function for accessing the value of the LCDRange.
setValue() is our first custom slot and valueChanged() is our first
custom signal.

Slots must be implemented in the normal way (remember, a slot is also
a C++ member function).  Signals are automatically implemented in the
\link metaobjects.html meta object\endlink file.

<h3>lcdrange.cpp</h3>

\dontinclude t7/lcdrange.cpp

This file is mainly lifted from \link t6/main.cpp main.cpp \endlink and
only the changes are noted here.

\skip connect
\line connect
\line connect

The first connect is the same you've seen in the previous
chapter.  The second is new: It connects sBar's valueChanged() signal
to this object's valueChanged \e signal. connect() with 3 arguments
always connect to signals or slots in \c this object.

Yes, that's right.  Signals can be connected to other signals.  When
the first is emitted, the second signal is also emitted.

Let's look at what happens when the user operates the scrollbar: The
scrollbar sees that its value has changed, and emits the valueChanged()
signal.  That signal is connected both to the display() slot of the
QLCDNumber and to the valueChanged() signal of the LCDRange.

Thus, when the signal is emitted, LCDRange emits its own
valueChanged() signal.  In addition, QLCDNumber::display() is called
and shows the new number.

Note that you're not guaranteed any particular order of execution.

\skip LCDRange::value
\until }

The implementation of value() is straightforward, it simply returns
the scrollbar's value.

\line setValue
\until }

The implementation of setValue() is equally straightforward.  Note that
since the scrollbar and LCD number is connected, setting the
scrollbar's value automatically updates the LCD number as well.
In addition the scroll bar will automatically adjust the value if it is
outside the scroll bar's legal range.

<h3>main.cpp</h3>
\dontinclude t7/main.cpp

\skip setMinimumSize
\skip for(
\line 16
\until }

Apart from moving LCDRange into two separate files, these lines are the
only changes to the main.cpp file. As in the previous chapter, we create
16 LCDRange objects. In addition, we now connect them together using
the \link metaobjects.html signal/slot\endlink mechanism.
Each one has its valueChanged() signal connected to the setValue()
slot in the previous one.  Since LCDRange emits the signal valueChanged()
when its value changes (surprise!), we are here creating a "chain" of
signals and slots.

\dontinclude maa fikse make og gytta!!!!

<h2>Behavior</h2>

On startup, the program's appearance is identical to the previous one.
Try operating the scroll bar to the bottom right...

<h2>Excercises</h2>

Use the bottom right scroll bar to set all LCDs to 30. Then set the
top half to 29 by using the rightmost scroll bar on the 2nd row.
Now, use the one to the left of the last one operated to set the first seven
LCDs back to 30. Click on the left arrow on the bottom right scroll bar.
What happens? Why is this the correct behavior?

You may now go on to \link t8.html chapter seven. \endlink

*/


------------------------------------------------------------------------------


/*! \page t8.html

<title>
Qt Tutorial - Chapter 8
</title></head><body>

<h1>Chapter 8: Preparing for Battle</h1>

<img src=t8.gif>

In this example, we introduce the first custom widget that can paint
itself.

<ul>
<li> \link ../t8/lcdrange.h lcdrange.h \endlink contains the LCDRange
class definition
<li> \link tutorial/t8/lcdrange.cpp lcdrange.cpp \endlink contains the LCDRange
implementation
<li> \link t8/cannon.h cannon.h \endlink contains the CannonField
class definition
<li> \link t8/cannon.cpp cannon.cpp \endlink contains the CannonField
implementation
<li> \link t8/main.cpp main.cpp \endlink contains MyWidget and main.
<li> \link t8/Makefile Makefile \endlink contains some rules for
generating the metaobject information necessary for <a
href=metaobjects.html>signal/slot creation.</a>
</ul>

<h2>Line by Line Walk-Through</h2>

<h3>lcdrange.h</h3>

This file is very similar to the lcdrange.h in chapter 7.  We have added
one slot, setRange().

\dontinclude t8/lcdrange.h

\skip setRange
\line setRange

We now add the possibility of setting the range of the LCDRange.
Until now, it has fixed at 0..99.

<h3>lcdrange.cpp</h3>

\dontinclude t8/lcdrange.cpp

\skip ::setRange
\until sBar->setRange
\line }

setRange() sets the range of the scroll bar in the LCDRange.  Since we
have set up the QLCDNumber to always display two digits, we want to
limit the possible range of \c minVal and \c maxVal to 0..99 to avoid
overflow of the QLCDNumber.  We could have allowed values in -9..99
but choose not to.  If the arguments are illegal, we use Qt's warning()
function to issue a warning to the user and return immediately.
warning() is a printf-like function that by default sends its output
to \c stderr. You can install your own
\link qInstallMsgHandler() handler function\endlink if you want.


<h3>cannon.h</h3>

CannonField is a new custom widget that knows how to display itself.

\dontinclude t8/cannon.h

\skip class
\until parent=0

CannonField inherits QWidget and we use the same idiom as for LCDRange.

\until angleChanged

For the time being, CannonField only contains an angle value for which we
provide an interface using the same idiom as for value in LCDRange.

\line protected
\line paintEvent

This is the second of the many \link event-system.html event handler\endlink
in QWidget that we encounter.  This virtual function is called by Qt
whenever a widget needs to update itself (i.e. paint the widget's surface).


<h3>cannon.cpp</h3>

CannonField is a new custom widget that knows how to display itself.

\dontinclude t8/cannon.cpp

\skip ::CannonField
\until {

Again, we use the same idiom as for LCDRange in the previous chapter.

\until }

The constructor simply initializes the angle value to 45 degrees.

\skip ::setAngle
\until emit
\line }

This function sets the angle value. We have chosen a legal range 5..70
and adjust the given number of degrees accordingly.
We have chosen not to issue a warning if the new angle is out of range.

If the new angle equals the old one, we return immediately.
It is impotrant to only emit the signal angleChanged() when the
angle \e really has changed.

Then we set the new angle value and repaint our widget. The
\link QWidget::repaint() repaint()\endlink function will clear
the widget (i.e. fill it with its \link QWidget::setBackgroundColor()
background color\endlink) and send a
\link QWidget::paintEvent() paint event\endlink to the widget.

Finally, we emit the angleChanged() signal to tell the outside world
that the angle has changed.  The \c emit keyword is unique to Qt and
not regular C++ syntax.  In fact, it is a macro.

\skip ::paintEvent
\until drawText
\line }

This is our first attempt to write a paint event handler.
The event argument contains a \link QPaintEvent description\endlink
of the paint event.  QPaintEvent contains the rectangular area in the
widget that must be updated.  For the time being, we will be lazy and
always update the entire widget.

Our code displays the angle value in the widget at a fixed position.
First we create a QString object. QString is a Qt's string class (see the
\link QString documentation\endlink for details).  Then set the string
using the QString::sprintf() function, which is similar to sprintf().
Finally, we draw the text at position 200,100 (relative to the baseline of
the text) in the widget using the QWidget::drawText() function.
Normally, you will use a QPainter to draw in a widget, but drawText() is
a convenience function to draw text. In the next chapter, you'll see
how QPainter works.


<h3>main.cpp</h3>

CannonField is a new custom widget that knows how to display itself.

\dontinclude t8/main.cpp

\skip #include "cannon.h"
\line cannon.h

We include our new class.

\skip MyWidget
\until };

This time, we include a single LCDRange and a CannonField in our top level
widget.

\skip angle
\until angle->setGeometry

We create and set up our LCDRange with a range 5..70 and put it
10 pixels below the quit button and fix its size to 75x130.

\skip cannonField
\until cannonField->setBackgroundColor

We create and set up our CannonField. Its position is 10 pixels to the
right of the LCDRange and the same y position as LCDRange.  The size
will be set by the resize event.

Then we set the background color of the CannonField. QColor is Qt's
color class.  Here we hard code it to the RGB value red=250, green=250
and blue=200 (which gives an easter-like yellow pastel color).
The range of the RGB values is 0..255.

\skip connect
\line connect

Here we connect the valueChanged() signal of the LCDRange to the
setAngle() slot of the CannonField.  This will update CannonField's angle
value whenever the user operates the LCDRange.  We also make the reverse
connection, so that changing the angle in the CannonField will update the
LCDRange value.  In our example, we never change the angle of the
CannonField directly, but by doing the last connect(), we ensure that no
future changes will disrupt the synchronization between those two values.

This illustrates the power of component programming and proper
encapsulation.

Notice how important it is to only emit the angleChanged() signal when
the angle actually changes.  If both the LCDRange and the CannonField
had had this design flaw, the program would have entered an infinite
loop upon the first change of one of the values.

\skip angle->setValue
\line angle->setValue

Finally, we set an initial angle value.  Note that this will trigger the
connection from LCDRange to CannonField.

\skip ::resizeEvent
\line ::resizeEvent

We give the CannonField all the space we can, except for the 10 pixel
border to the bottom and to the right.

<h2>Behavior</h2>

When the scroll bar is operated, the CannonField displays the new angle
value.  Upon resize, CannonField is gives as much space as possible.

<h2>Excercises</h2>

Make the position of the printed text dependent of the angle value.

Change the resize event to give maximum space to the LCDRange instead
of the CannonField.

You may now go on to \link t9.html chapter nine. \endlink

*/


------------------------------------------------------------------------------


/*! \page t9.html

<title>
Qt Tutorial - Chapter 9
</title></head><body>

<h1>Chapter 9: With Cannon You Can</h1>

<img src=t9.gif>

In this example, we use a QPainter for the first time.
It is used to draw a cute little blue cannon.
Only cannon.cpp differs from the previous chapter.

<ul>
<li> \link t9/lcdrange.h lcdrange.h \endlink contains the LCDRange
class definition
<li> \link t9/lcdrange.cpp lcdrange.cpp \endlink contains the LCDRange
implementation
<li> \link t9/cannon.h cannon.h \endlink contains the CannonField
class definition
<li> \link t9/cannon.cpp cannon.cpp \endlink contains the CannonField
implementation
<li> \link t9/main.cpp main.cpp \endlink contains MyWidget and main.
<li> \link t9/Makefile Makefile \endlink contains some rules for
generating the metaobject information necessary for <a
href=metaobjects.html>signal/slot creation.</a>
</ul>

<h2>Line by Line Walk-Through</h2>

<h3>cannon.cpp</h3>

CannonField is a new custom widget that knows how to display itself.

\dontinclude t9/cannon.cpp

\skip ::paintEvent
\until QPen

In order to paint our widget, we use a QPainter.  QPainter is Qt's
painting engine.  It can paint 2D graphics on several types of
\link QPaintDevice paint devices\endlink.  QWidget is a paint device.
See the QPainter documentation for details. \link SJEKKIT\endlink

QPainter uses a QPen and a QBrush. The pen specifies a line style and a
text color while the brush specifies a fill color and/or a fill pattern.
In our paintEvent, we want to use a blue brush and an invisible pen.

\skip begin
\line begin

Calling \link QPainter::begin() begin()\endlink tells the painter to start
painting on a paint device.  Here we start painting on the CannonField
widget.

\line setBrush
\line setPen

Here we set the brush and pen created above.

\skip translate
\line translate

The \link QPainter::translate() translate()\endlink function translates the
coordinate system of the QPainter, i.e. moves it by an offset.  Here we
set the (0,0) point to the bottom left corner of the widget.  The x and y
directions remain unchanged, i.e. all the y coordinates inside the widget
are now negative (see \link coordsys.html The Coordinate System\endlink).

\line drawPie

The \link QPainter::drawPie() drawPie()\endlink function draws a pie shape
inside the specified rectangle using a start angle and an arc length.  The
angles are specified in 1/16th of a degree. The drawing direction is
always counter-clockwise.  Here we draw a quarter of a circle in the
bottom left corner of the widget.  The pie is filled with blue and has no
outline.

\line rotate

The \link QPainter::rotate() rotate()\endlink function rotates the
coordinate system of the QPainter around the point (0,0).  The rotation
argument is a \c float given in degrees (not given in 1/16th of a degree
as above) and clockwise.  Here we rotate the coordinate system \c ang
degrees counter-clockwise.

\line drawRect

The \link QPainter::drawRect() drawRect()\endlink function draws the
specified rectangle.  Here we draw the barrel of the cannon.

It can often be difficult to envision the resulting drawing when the
coordinate system has been transformed (translated, rotated, scaled or
sheared) as above.

In this case, the coordinate system is first translated, then rotated.
If the rectangle QRect(33, -4, 15, 8) had been drawn in the translated
coordinate system, it would have looked like this:

<img src=t9_1.gif>

Note that the rectangle is clipped by the border of the CannonField widget.
When we rotate the coordinate system, for instance 60 degrees, the
rectangle will be rotated around (0,0), which is the bottom left corner.
The result looks like this:

<img src=t9_2.gif>

\skip end
\line end

Calling \link QPainter::end() end()\endlink tells the painter to end
painting on a paint device.  We're done.


<h2>Behavior</h2>

When the scroll bar is operated, the angle of the drawn cannon changes
accordingly.

You may notice that the cannon flickers annoyingly, especially on a
slow machine.  We'll fix this in the next chapter.


<h2>Excercises</h2>

Make the cannon shoot a bullet (or read on).

Make a macho barrel 12 inches long.

You may now go on to \link t10.html chapter ten. \endlink

*/


------------------------------------------------------------------------------


/*! \page t10.html

<title>
Qt Tutorial - Chapter 10
</title></head><body>

<h1>Chapter 10: Smooth as Silk</h1>

<img src=t10.gif>

In this example, we introduce painting in a pixmap to remove flickering.
We also add a force control.

<ul>
<li> \link t10/lcdrange.h lcdrange.h \endlink contains the LCDRange
class definition
<li> \link t10/lcdrange.cpp lcdrange.cpp \endlink contains the LCDRange
implementation
<li> \link t10/cannon.h cannon.h \endlink contains the CannonField
class definition
<li> \link t10/cannon.cpp cannon.cpp \endlink contains the CannonField
implementation
<li> \link t10/main.cpp main.cpp \endlink contains MyWidget and main.
<li> \link t10/Makefile Makefile \endlink contains some rules for
generating the metaobject information necessary for <a
href=metaobjects.html>signal/slot creation.</a>
</ul>

<h2>Line by Line Walk-Through</h2>

<h3>cannon.h</h3>

The CannonField now has a force value in addition to the angle.

\dontinclude t10/cannon.h

\skip angle
\until forceChanged

The interface to the force follows the same practice as for angle.

\skip private
\until cannonRect

We have moved the painting of the cannon to a separate function and have
also put the defintion of the cannon's enclosing rectangle in a separate
function.

\skip ang
\until };

The force is stored in the integer f.

<h3>cannon.cpp</h3>

\dontinclude t10/cannon.cpp

\skip include
\skip pixmap
\line pixmap

We include the QPixmap class definition.

\skip ::CannonField
\until }

The force (f) is initialized to zero.

\skip ::setAngle
\skip repaint
\line repaint

We have made a slight change in the setAngle() function. It repaints
only the portion of the widget that contains the cannon.  The FALSE
argument indicates that the specified rectangle should not be erased
before a paint event is sent to the widget.

\skip ::setForce
\until }

The implementation of setForce() is quite similar to that of setAngle().
The only difference is that we don't show the force value, hence we
don't need to repaint the widget.

\skip ::paintEvent
\until end
\line }

We have now optimized the paint event to repaint only the parts of the
widget that need updating.  First we fetch the update rectangle parameter
from the QPaintEvent.  Then we begin painting on this widget.  We check if
the update rectangle intersects with the cannon rectangle. If it does, we
paint the cannon.  Note that we pass a pointer to the painter to the
paintCannon() function.

\skip barrel_rect
\line barrel_rect

We have chosen to define the barrel rectangle as a constant.

\skip ::paintCannon
\until pix

Here we encounter a new class; the QPixmap.  QPixmap is an off-screen
paint device which is handy for flicker-free painting.  Here we
create a pixmap with the same size as the cannot.  We want to draw the
cannon in this pixmap and then move the pixmap to the screen in one
operation.  This technique is called double-buffering and virtually
removes flickering.

\line tmp

We create a temporary painter \c tmp for drawing in the pixmap.

\skip fill
\line fill

Upon creation, a pixmap is filled with arbitrary pixels, thus we first
fill it with the widget's background color.

\skip begin
\until setPen

Here we start painting on the pixmap.  We set a blue brush and an
invisible pen, as in the previous chapter.  This time we use a shortcut.
\link QPainter::setPen() setPen() and \link QPainter::setBrush()
setBrush() are overloaded functions in QPainter.

\skip translate
\until end

The code that draws the cannon is very similar to the code in the previous
example.  The only difference is the translation which now is relative to
the pixmap height and that we have moved the barrel rectangle into a
constant.

\skip drawPixmap
\line drawPixmap

Finally, we call \link QPainter::drawPixmap() drawPixmap()\endlink to
zip the pixmap onto the screen in one lightning fast operation.

\skip cannonRect
\until }

This function returns the rectangle enclosing the cannon.
First we create a rectangle with the size 50x50, then we set its bottom
left corner equal to the widget's bottom left corner.



<h3>main.cpp</h3>

\dontinclude t10/main.cpp

\skip class
\until };

We add a second LCDRange which will be used to set the force.

\skip force
\until setGeometry

We place the \c force LCDRange widget below the \c angle widget and
specify the range to 10..50.

\skip force
\line connect
\line connect

We connect the \c force widget and the \c cannonField widget just like
we did for the \c angle widget.

\skip force
\line setValue

We initialize the force value to 25.


<h2>Behavior</h2>

The flicker has gone and we have a force control.


<h2>Excercises</h2>

Make the size of the cannon barrel be dependent on the force.

Put the cannon in the bottom right corner.

You may now go on to \link t11.html chapter eleven. \endlink

*/


------------------------------------------------------------------------------


/*! \page t11.html

<title>
Qt Tutorial - Chapter 11
</title></head><body>

<h1>Chapter 11: Giving It a Shot</h1>

<img src=t11.gif>

In this example, we introduce timer events to implement shooting.

<ul>
<li> \link t11/lcdrange.h lcdrange.h \endlink contains the LCDRange
class definition
<li> \link t11/lcdrange.cpp lcdrange.cpp \endlink contains the LCDRange
implementation
<li> \link t11/cannon.h cannon.h \endlink contains the CannonField
class definition
<li> \link t11/cannon.cpp cannon.cpp \endlink contains the CannonField
implementation
<li> \link t11/main.cpp main.cpp \endlink contains MyWidget and main.
<li> \link t11/Makefile Makefile \endlink contains some rules for
generating the metaobject information necessary for <a
href=metaobjects.html>signal/slot creation.</a>
</ul>

<h2>Line by Line Walk-Through</h2>

<h3>cannon.h</h3>

The CannonField now has a shooting capabilities.

\dontinclude t11/cannon.h

\skip isShooting
\line isShooting

Returns TRUE if a shot is underway.

\skip shoot
\line shoot

Calling this slot will make the cannon shoot if a shot is not in the air.

\skip protected
\until timerEvent

The timer event is the third type of widget event we encounter.
You can make Qt call this event handler at regular intervals.

\skip private
\until stopShooting

This private function stops a shot in mid-air.

\line paintShot

This private function paints the shot.

\skip shotRect
\line shotRect

This private function returns the shot's enclosing rectangle if
one is in the air, otherwise the returned rectangle is undefined.

\skip shooting
\line shooting

This private variable is TRUE when there's a shot in the air.

\skip timerCount
\until shoot_f
\lien };

These private variables contain information that describes the shot.  The
\c timerCount keeps track of the time passed since the shot was fired.
The \c shoot_ang is the cannon angle and \c shoot_f is the cannon force
when the shot was fired.


<h3>cannon.cpp</h3>

\dontinclude t11/cannon.cpp

\skip include
\skip math
\line math

We include the math library because we need the sin() and cos() functions.

\skip ::CannonField
\until }

We initialize our new private variables.

\skip ::shot
\until startTimer
\line }

This function shoots a shot unless a shot is in the air. The \c timerCount
is reset to zero.  The \c shoot_ang and \c shoot_f are set to the current
cannon angle and force. \c shooting is set to TRUE to indicate that a shot
is in the air. Finally we start timer events.

Calling \link QObject::startTimer() startTimer()\endlink will make Qt send
us \link QObject::timerEvent() timer events\endlink at regular intervals.
In this case, we want timer events every 50 milliseconds.

\skip ::timerEvent
\until repaint
\line }

The timerEvent() function is an event handler that receives timer events
from Qt.  In our case, it is called every 50 milliseconds when a shot is
in the air.

First we erase the old shot. Note that this is not strictly necessary the
first time the timerEvent() is called after a shot has been fired (but it
does no harm).  The \c shotRect() function (explained below) returns the
enclosing rectangle of the shot at the current position.

Then we increment the \c timerCount, which has the effect of moving the
shot one step along its trajectory.

Next, we fetch the new shot rectangle.

If the shot has moved beyond the right or bottom edge of the widget, we
stop shooting and return.

If not, we paint the new shot by repainting the portion of the widget that
contains the shot.  The FALSE argument indicates that the specified
rectangle should not be erased before a paint event is sent to the widget.

\skip ::paintEvent
\until end
\line }

This paint event function is basically the same as the one in the
previous chapter. The only difference is that we also paint the shot
if necessary.

\skip ::stopShooting
\until killTimers
\line }

Peace...  This private function stops a shot in mid-air.  First it resets
the \c shooting variable, then it \link QObject::killTimers() kills all
timer events\endlink for this widget.  It is also possible to \link
QObject::killTimer() kill a single timer\endlink.

\skip ::paintShot
\until drawRect
\line }

This private function paints the shot by drawing a black filled rectangle.

\skip ::shotRect
\until return
\line }

This private function calculates the center point of the shot and returns
the enclosing rectangle of the shot.  It uses the initial cannon force and
angle in addition to \c timerCount, which increases when time passes.

The formula used is the classical Newtonian formula for frictionless
movement in a gravity field.  For simplicity, we've chosen to disregard
any Einsteinian effects.

We calculate the center point in a coordinate system where y coordinates
increase upwards.  After we have calculated the center point, we construct
a QRect with size 6x6 and move its center point to the point calculated
above. In the same operation, we convert the point into the widget's
coodinate system (see \link coordsys.html The Coordinate System\endlink).


<h3>main.cpp</h3>

\dontinclude t11/main.cpp

\skip class
\until };

The only addition is the shoot button.

\skip ::MyWidget
\skip shoot
\until setFont

We create and set up the shoot button exactly like we did with the quit
button.  Note that the first argument to the constructor is the button
text and the third is the widget's name.

\skip connect
\line connect

Connects the clicked() signal of the shoot button to the shoot() slot
of the CannonField.


<h2>Behavior</h2>

The cannon can shoot, but there's nothing to shoot at.


<h2>Excercises</h2>

Make the shot a filled circle

Change the color of the cannon when a shot is in the air.

You may now go on to \link t12.html chapter twelve. \endlink

*/



------------------------------------------------------------------------------


/*! \page t12.html

<title>
Qt Tutorial - Chapter 12
</title></head><body>

<h1>Chapter 12: Something To Die For</h1>

<img src=t12.gif>

In this example, we extend our LCDRange class to include a text label.
We also provide something to shoot at.

<ul>
<li> \link t12/lcdrange.h lcdrange.h \endlink contains the LCDRange
class definition
<li> \link t12/lcdrange.cpp lcdrange.cpp \endlink contains the LCDRange
implementation
<li> \link t12/cannon.h cannon.h \endlink contains the CannonField
class definition
<li> \link t12/cannon.cpp cannon.cpp \endlink contains the CannonField
implementation
<li> \link t12/main.cpp main.cpp \endlink contains MyWidget and main.
<li> \link t12/Makefile Makefile \endlink contains some rules for
generating the metaobject information necessary for <a
href=metaobjects.html>signal/slot creation.</a>
</ul>

<h2>Line by Line Walk-Through</h2>


<h3>lcdrange.h</h3>

The LCDRange now has a text label.

\dontinclude t12/lcdrange.h

\skip QLabel
\line QLabel

We name declare QLabel since we want to use a pointer to it in the class
definition.

\skip class
\until parent=0
\line name=0

We have added a new constructor that sets the label text in addition to
the parent and name.

\skip text
\line text

This function returns the label text.

\skip setText
\line setText

This slot sets the label text.

\skip private
\until init

Since we now have two constructors, we have chosen to put the common
initialization in the private init() function.

\skip QLabel
\line label

We also have a new private variable; a QLabel.  QLabel is one of Qt's
standard widgets and can show a text or a pixmap with or without a frame.


<h3>lcdrange.cpp</h3>

\dontinclude t12/lcdrange.cpp

\skip qlabel
\line include

Here we include the QLabel class definition.

\skip ::LCDRange
\until }

This constructor calls the init() function, which contains the common
initialization code.

\skip ::LCDRange
\until }

This constructor first calls init(), then sets the label text.

\skip ::init
\until }

The set up of \c lcd and \c sBar is the same as in the previous chapter.
Next, we create a QLabel and tell it to align the contents centered
(both vertically and horizontally). The connect() statements have also
been taken from the previous chapter.

\skip ::text
\until }

This function returns the label text.

\skip ::setText
\until }

This function sets the label text.

\skip ::resizeEvent
\until }

This event handler is similar to the one in the previous chapter, except
that we also must make room for the label.  The number 41 in the lcd
resize statment is the height of the scroll bar plus the height of the
label plus the spacing between them (16+20+5).


<h3>cannon.h</h3>

The CannonField now has two new signals: hit() and missed(). In addition
it contains a target.

\dontinclude t12/cannon.h

\skip slots
\skip newTarget
\line newTarget

This slot creates a target at a new position.

\skip signals
\until missed

The hit() signal is emitted when a shot hits the target.  The missed()
signal is emitted when the shot moves beyond the right or bottom edge of
the widget (i.e. it has not hit the target).

\skip paintTarget
\line paintTarget

This private function paints the target.

\skip targetRect
\line targetRect

This private function returns the enclosing rectangle of the target.

\skip target
\line target

This private variable contains the center point of the target.


<h3>cannon.cpp</h3>

\dontinclude t12/cannon.cpp

\skip qdatetm
\line qdatetm

We include the QDate, QTime and QDateTime class definitions.

\skip stdlib
\line stdlib

We include the stdlib library because we need the rand() function.

\skip newTarget
\line newTarget

This line has been added to the constructor. It creates a "random"
position for the target. In fact, the newTarget() function will try to
paint the target.  Since we are in a constructor, the CannonField widget
is invisible.  Qt guarantees that no harm is done when painting a hidden
widget.

\skip ::newTarget
\until height
\line }

This private function creates a target center point at a new "random"
position.

We use the rand() function to fetch random integers.  The rand() function
normally returns the same series of numbers each time you run a program.
To avoid this, we must set a random seed the first time this function
is called. The random seed must also be random in order to avoid equal 
random number series.  The solution is to use the number of seconds that
have passed since midnight as a pseudo-random value.

First we create a static bool local variable.  A static variable like
this one is guaranteed to keep its value between calls to the function.

The if test will only succeed the first time this function is called,
because we set \c first_time to FALSE.

Then we create the QTime object \c midnight which represents the time
00:00:00. Next, we fetch the number of seconds from midnight until now
and use it as a random seed.

Finally, we calculate the target's center point. We keep it withing
the rectangle (x=200,y=35,width=190,height=255), i.e. the possible
x and y values are x = 200..390 and y = 35..290.

By experimentation, we have found this to always be in reach of the shot.

Note that rand() return a random integer >= 0.


\skip ::timerEvent
\until QRect

This part of the timer event has not changed from the previous chapter.

\skip targetRect
\until }

This \c if statement checks if the shot rectangle intersects the target
rectangle.  If it does, the shot has hit the target (ouchh!).  We stop
shooting and emit the hit() signal to tell the outside world that a target
was destroyed and return.

Note that we could have created a new target on the spot, but since the
CannonField is a component, we leave such decisions to the user of the
component.

\skip shotR
\until }

This \c if statement is the same as in the previous chapter, except that
it now emits the missed() signal to tell the outside world about the
failure.

\skip repaint
\until }

No changes here.

\skip ::paintEvent
\skip targetRect
\line updateR
\line paintTarget

These two lines have been added to the paintEvent() to paint the
target if necessary.

\skip ::paintTarget
\until }

This private function paints the target; a rectangle filled with red and
with a black outline.

\skip ::targetRect
\until }

This private function returns the enclosing rectangle of the target.
Remember from newTarget() the \c target point uses y coordinate 0 at the
bottom of the widget.  We calculate the point in widget coordinates before
we call \link QRect::setCenter() setCenter()\endlink.

The reason we have chosen this coordinate mapping is to fix the distance
between the target and the bottom of the widget.  Remember that the widget
can be resized by the user or the program at any time.

<h3>main.cpp</h3>

\dontinclude t12/main.cpp

There are no new members in the MyWidget class, but we have slightly
changed the constructor to set the new LCDRange text labels.

\skip ::MyWidget
\skip angle
\line ANGLE

We set the angle text label to "ANGLE".


\skip force
\line FORCE

We set the force text label to "FORCE".

Note that we have not changed the position or the size of the LCDRanges.
The QLCDNumber in LCDRange will become a bit smaller to make room for the
label.  MyWidget doesn't care about that, because it uses LCDRange as a
component and trust that it will show its value in the best way possible.


<h2>Behavior</h2>

The cannon can shoot at a target and automatically creates a new target
when one has been hit.


<h2>Excercises</h2>

Make a cheat button that when pressed makes the CannonField display
the shot trajectory for 5 seconds.

Make a moving target.

Make it possible to have several shots in the air at the same time.
Hint: make a Shot object.

You may now go on to \link t13.html chapter thirteen. \endlink

*/


------------------------------------------------------------------------------


/*! \page t13.html

<title>
Qt Tutorial - Chapter 13
</title></head><body>

<h1>Chapter 13: Game Over</h1>

<img src=t13.gif>

In this example we give MyWidget a new name; GameBoard and added some
slots.  We put the definition in gamebrd.h and the implementation in
gamebrd.cpp.

The CannonField now has a game over state.

<ul>
<li> \link t13/lcdrange.h lcdrange.h \endlink contains the LCDRange
class definition
<li> \link t13/lcdrange.cpp lcdrange.cpp \endlink contains the LCDRange
implementation
<li> \link t13/cannon.h cannon.h \endlink contains the CannonField
class definition
<li> \link t13/cannon.cpp cannon.cpp \endlink contains the CannonField
implementation
<li> \link t13/gamebrd.h gamebrd.h \endlink contains the GameBoard
class definition
<li> \link t13/gamebrd.cpp gamebrd.cpp \endlink contains the GameBoard
implementation
<li> \link t13/main.cpp main.cpp \endlink contains main.
<li> \link t13/Makefile Makefile \endlink contains some rules for
generating the metaobject information necessary for <a
href=metaobjects.html>signal/slot creation.</a>
</ul>

<h2>Line by Line Walk-Through</h2>


<h3>cannon.h</h3>

The CannonField now has a game over state and a few new slots/functions.

\dontinclude t13/cannon.h

\skip gameOver
\line gameOver

This function returns TRUE if the game is over, or FALSE if a game
is going on.

\skip newTarget
\until restartGame

Here are two new slots; setGameOver() and restartGame().
In addition, the private function newTarget() has become a slot, to
give the outside world better control of the game.

\skip gameEnded
\line gameEnded

This private variable contains the game state. TRUE means that the
game is over, and FALSE means that a game is going on.

<h3>cannon.cpp</h3>

\dontinclude t13/cannon.cpp

\skip qfont
\line qfont

We include the QFont class definition.

\skip ::CannonField
\skip gameEnded
\line gameEnded

This line has been added to the constructor. Initially, the game is not
over.

\skip ::setGameOver
\until }

This slot ends the game. It must be called from outside CannonField,
because this widget does not know when to end the game.  This is is an
important design principle in component programming.  We choose to
make the component as flexible as possible to make it usable for
different games with different rules.

If the game has already been ended, we return immediately.  If a game is
going on, we stop the shot, set the game over flag and repaint the widget.

\skip ::restartGame
\until }

This slot starts a new game.

\skip ::paintEvent


This part of the timer event has not changed from the previous chapter.

\skip targetRect
\until }

This if statement checks if the shot rectangle intersects the target
rectangle.  If it does, the shot has hit the target (ouchh!).  First we
erase the target, then we stop the shot, create a new target position and
paint the new target.  Finally we emit the hit() signal to tell the
outside world that a target was destroyed and return.

\skip shotR
\until }

This if statement is the same as in the previous chapter, except that
it now emits the missed() signal to tell the outside world about the
failure.

\skip repaint
\until }

No changes here.

\skip ::paintEvent
\skip targetRect
\line updateR
\line paintTarget

These two lines have been added to the paintEvent() to paint the
target if necessary.

\skip ::paintTarget
\until }

This private function paints the target; a rectangle filled with red and
with a black outline.

\skip ::targetRect
\until }

This private function returns the enclosing rectangle of the target.

\skip ::newTarget
\until height
\line }

This slot creates a target center point at a new "random" position.

We use the rand() function to fetch random integers.  The rand() function
always returns the same series of numbers, and this would make the target
appear on the same aposition each time you run the program.  To avoid
this, we set a random seed the first time this function is called. The
random seed must also be random, in order to avoid equal random number
series.  The solution is to use the number of seconds that have passed
since midnight as a pseudo-random value.

First we create a static bool local variable.  A static variable like this
one is guaranteed to keep its value between calls to the function.

The if test will only succeed the first time this function is called,
because we set \c first_time to FALSE inside the \c if block.

Then we create the QTime object \c midnight which represents the time
00:00:00. Next, we fetch the number of seconds from midnight until now
and use it as a random seed.

See the documentation of QDate, QTime and QDateTime for more information
on date and time support.

Finally, we calculate the target's center point. We keep it withing the
rectangle (x=200,y=35,width=290,height=310) (i.e. the possible x and y
values are x = 200..490 and y = 35..345) in a coordinate system where we
put y position 0 at the bottom edge of the widget and let y values
increase upwards.  X is as normal, with 0 at the left edge and with x
increasing to the right.

Note that rand() return a random integer >= 0.


<h3>main.cpp</h3>

\dontinclude t13/main.cpp

There are no new members in the MyWidget class, but we have slightly
changed the constructor to set the new LCDRange text labels.

\skip ::MyWidget
\skip angle
\line ANGLE

We set the angle text label to "ANGLE".


\skip force
\line FORCE

We set the force text label to "FORCE".

Note that we have not changed the position or the size of the LCDRanges.
The QLCDNumber in LCDRange will become a bit smaller to make room for the
label.  MyWidget doesn't care about that, because it uses LCDRange as a
component and trust that it will show its value in the best way possible.


<h2>Behavior</h2>

The cannon can shoot at a target and automatically creates a new target
when one has been hit.


<h2>Excercises</h2>

Make a cheat button that when pressed makes the CannonField display
the shot trajectory for 5 seconds.

Make a moving target.

Make it possible to have several shots in the air at the same time.

You may now go on to \link t13.html chapter thirteen. \endlink

*/














------------------------------------------------------------------------------



/*! \page t.html

<title>
Qt Tutorial - Chapter 
</title></head><body>

<h1>Chapter : </h1>

<img src=t.gif>


<ul>
<li> \link t \endlink contains MyWidget and main.
<li> \link t7/lcdrange.h lcdrange.h \endlink contains the LCDRange
class definition
<li> \link t7/lcdrange.cpp lcdrange.cpp \endlink contains the LCDRange
implementation
<li> 
</ul>

<h2>Line by Line Walk-Through</h2>


<h2>Behavior</h2>


<h2>Excercises</h2>


You may now go on to \link t7.html chapter seven. \endlink

 */



























/*! \page t13.html

<title>
Qt Tutorial - Chapter 13
</title></head><body>

<h1>Chapter 13: Game Over</h1>

<h2>Introduction</h2>

<img src=t13.gif>

\link t13/main.cpp \endlink
\link t13/lcdrange.h \endlink
\link t13/lcdrange.cpp \endlink
\link t13/cannon.h \endlink
\link t13/cannon.cpp \endlink
\link t13/gamebrd.h \endlink
\link t13/gamebrd.cpp \endlink

<h2>Introduction</h2>

This example shows 

Rename MyWidget to a more descriptive name and put it files of its own.

Add slots.

Process shots internally to count down

Add two QLCDNums to display hits and shots left.

Add two labels to describe the LCDNums.

This is what mother and child look like (with the \e fvwm window
manager on an X display):


\dontinclude t13/main.cpp



\dontinclude t13/lcdrange.h



\dontinclude t13/lcdrange.cpp
\dontinclude t13/cannon.h
\dontinclude t13/cannon.cpp
\dontinclude t13/gamebrd.h
\dontinclude t13/gamebrd.cpp




<h2>Behavior</h2>

Compoment programming; flexibility, complexity and .. design requirements.


You may now go on to \link t14 chapter fourteen. \endlink

 */
