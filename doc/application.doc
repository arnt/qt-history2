/****************************************************************************
** $Id: application.doc,v 2.8 1999/10/01 11:37:51 arnt Exp $
**
** Application example documentation
**
** Copyright (C) 1992-2000 Trolltech AS.  All rights reserved.
**
** This file is part of the Qt GUI Toolkit.
**
** This file may be distributed under the terms of the Q Public License
** as defined by Trolltech AS of Norway and appearing in the file
** LICENSE.QPL included in the packaging of this file.
**
** This file may be distributed and/or modified under the terms of the
** GNU General Public License version 2 as published by the Free Software
** Foundation and appearing in the file LICENSE.GPL included in the
** packaging of this file.
**
** Licensees holding valid Qt Enterprise Edition or Qt Professional Edition
** licenses may use this file in accordance with the Qt Commercial License
** Agreement provided with the Software.
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
**   information about Qt Commercial License Agreements.
** See http://www.trolltech.com/qpl/ for QPL licensing information.
** See http://www.trolltech.com/gpl/ for GPL licensing information.
**
** Contact info@trolltech.com if any conditions of this licensing are
** not clear to you.
**
**********************************************************************/

/*! \page simple-application.html

\title Walkthrough: A Simple Application

This walkthrough shows simple use of \l QMainWindow, \l QMenuBar, \l
QPopupMenu, \l QToolBar and \l QStatusBar - classes that every
modern application window tends to use.

It further illustrates some aspects of \l QWhatsThis (for simple help) and a
typical main() using \l QApplication.

Finally, it shows a typical printout function based on \l QPrinter.

<h2>The declaration of ApplicationWindow</h2>

Here's the header file in full:

\include application/application.h

It declares a class that
inherits QMainWindow, with slots and private variables.
The class predeclarations at the beginning help to speed up compiles: \c
QTextEdit, \c QToolBar and \c QPopupMenu are declared, not
included. With this trick, make depend won't insist on
recompiling every .cpp file that
includes application.h when e.g. qpopupmenu.h
changes.

<a name="simplemain"></a>
<h2>A simple main()</h2>

Let's have a look at examples/main.cpp, in full.

\include application/main.cpp

We'll go over main() in detail.

\skipto argc
\printline argc
\printline QApplication

With the above line, we create a QApplication object with the usual 
constructor and let it
parse \e argc and \e argv. QApplication itself takes care of X11-specific
command-line options like \e -geometry, thus the program automatically
behaves the way X clients are expected to.

\printline ApplicationWindow
\printline setCaption
\printline show

We create an ApplicationWindow as a top-level widget, set its window
system caption to "Document 1", and show() it.

<a name="close"></a>
\printline connect

When the application's last window is closed, it should quit. Both,
the signal and the slot are predefined members of QApplication.

\printline exec

Having completed the application's initialization, we start the main
event loop (the GUI), and eventually return the error code
QApplication returns when it leaves the event loop.

\printline }

<h2>The implementation of ApplicationWindow</h2>

\dontinclude application/application.cpp

Since the implementation is much larger (almost 300 lines) we won't
include it all at once but comment on bits and pieces instead.
We skip the preliminary #include, and start
with the constructor.

<a name="ApplicationWindow"></a>
\skipto ApplicationWindow::ApplicationWindow
\printline ApplicationWindow::ApplicationWindow
\printuntil {

ApplicationWindow inherits QMainWindow, the Qt class that provides
typical application main windows, with menu bars, toolbars, etc.

\printuntil QPrinter

The application example can print things, and we chose to have a
QPrinter object lying around so that when the user changes a setting
during one printing, the new setting will be the default next time.

\printline QPixmap

For simplicity reasons, our example has no more than three commands
in the toolbar.
The above variables are used to hold an icon for each of them.

\printline QToolBar

We create a toolbar in \e this window ...

\printline "File Operations"

... and define a title for it. When a user drags the toolbar out 
of its location and drops it somewhere on the desktop, the 
toolbar-window will show "File Operations" as caption.

\printline fileopen
\printuntil SLOT(choose())

Now we create the first tool-button for the fileTools-toolbar
with the appropriate icon and the tool-tip text "Open File".
One of the #includes we skipped at the beginning included a
xpm-file containing the definition of a xpm named fileopen.
This we use as the icon to illustrate our first tool-button.  

\printuntil SLOT(print())

Likewise we create two more tool-buttons in this toolbar, each with 
appropriate icons and tool-tip text.  All three buttons are connected
to appropriate slots in this object, for example the "Print File" button 
to <A HREF="#printer">ApplicationWindow::print()</A>.

\printline whatsThisButton

The fourth button in the toolbar is somewhat special: it's the one that
provides "What's This?" help.  This must be set up using a special
function, as its mouse interface is different from usual.

\printuntil fileOpenText )

With the above line we add the "What's This?" help-text to the 
fileOpen-button...

\printline openIcon

... and tell the
rich-text engine that when a help-text (like the one saved in
fileOpenText) requests an image named "fileopen", 
the openIcon pixmap is used.


\printuntil fileSaveText )
\printuntil filePrintText )

The "What's This?" help of the remaining two buttons doesn't make use
of pixmaps, therefore all we have to do is to add the help-text to the button.
Be however careful: To invoke the rich-text elements in fileSaveText,
the entire string must be surrounded by \<p\> and \</p\>. In filePrintText,
we don't have rich-text elements, so this is not necessary.

\printuntil &File

Next we create a QPopupMenu for the File menu and 
add it to the menu bar. With the ampersand previous to the letter F,
we allow the user to use the shortcut Alt+F to open this menu.

\printline &New

Its first entry is connected to the -- yet to implement -- 
slot newDoc(). When the user chooses this New entry (e.g. via 
typing the letter N as marked by the ampersand) or uses the
Ctrl-N accelerator, a new editor-window will pop up.  

\printuntil &Open
\printuntil &Save
\printuntil Save &as
\printuntil fileSaveText

We populate the File-menu with three more commands (Open, Save, and
Save as), and set "What's This?" help for them. 
Note in particular how "What's This?" help and pixmaps are used in both
the toolbar (above) and the menu bar (here).


\printline insertSeparator(

Then we insert a separator, ... 

\printline &Print
\printuntil &Close
\printline &Quit

... the Print command with "What's This?" help, another separator and
two more commands (Close and Quit) without "What's This?" and pixmaps.
In case of the Close command, the signal is connected 
to the close() slot of the respective ApplicationWindow object whilst
the Quit command affects the entire application.

Because ApplicationWindow is a QWidget, the close() function triggers 
a call to <A HREF="#closeEvent">closeEvent()</A> which we will implement later.

\printline insertSeparator

Now that we are done with the File menu we shift our focus back to the
menu bar and insert a separator. From now on 
further menu bar entries will be aligned to the right if the windows system style 
suggests so.

\printline help
\printuntil whatsThis

We create a Help menu, add it to the menu bar, and insert a few
commands. Depending on the style it will appear on the right hand 
side of the menu bar or not.

\printline QTextEdit
\printline setFocus
\printline setCentralWidget

Now we create a simple text-editor, set the initial focus to it,
and make it the central widget of this window.

QMainWindow::centralWidget() is the heart of the entire application: 
It's what menu bar,
statusbar and toolbars are all arranged around.  Since the central 
widget is a text editing widget, we reveal at this line that our
simple application is a text-editor. :)

\printline "Ready"

We make the statusbar say "Ready" for two seconds at startup, just to
tell the user that this window has finished initialization and can be
used.

\printline resize

Finally it's time to resize the new window to a a nice default size.

\printline }

At this stage, we are done with the constructor and 
can have a look at the destructor.

\printline ::~
\printuntil }

The only thing an ApplicationWindow widget needs to do in its destructor 
is  to delete the
printer it created.  All other objects are child widgets, which Qt
will delete as appropriate.

Now our task is to implement all the slots mentioned in the header file
and used in the constructor.

\printline ::newDoc
\printuntil }

This slot, connected to the File->New menu item, simply creates a 
new ApplicationWindow and shows it.

\printline ::choose
\printuntil getOpenFileName
\printuntil }

The choose() slot is connected to the Open menu item and tool-button.
With a little help from getOpenFileName() , it asks the user for a 
file name and then either loads
that file or gives an error message in the statusbar.

\printline ::load
\printuntil statusBar
\printline }

This function loads a file into the editor. When
it's done, it sets the window system caption to the file name and
displays a success message in the statusbar -- two seconds long.
With files that exist but are not readable, nothing happens.

\printline ::save
\printuntil close

As its name suggests, this function saves the current file. 
If no filename has been
specified so far, the saveAs() routine is called. 
Unwritable files cause the ApplicationWindow object to provide
an error-message in the statusbar. Note that there are more than
one possibilities 
to achieve this: compare the above statusBar()->message() line 
with the appropriate code in the load() function.

\printline setModified

Tell the editor that the contents haven't been edited since the last
save.  When the user does some further editing and wishes 
to close the window without explicit saving, 
<A HREF="#closeEvent">ApplicationWindow::closeEvent()</A>  will ask about it.

\printline setCaption

It may be that the document was saved under a different name than the
old caption suggests, so we set the window caption just to be sure.

\printuntil }

With a message in the statusbar, we inform the user that the file
was saved successfully.

\printline ::saveAs
\printuntil message
\printline }
\printline }

This function asks for a new name, saves the document under that name,
and implicitly changes the window system caption to the new name.

<a name="printer"></a>

\printuntil {
\skipto Margin
\printuntil pageNo

print() is called by the File->Print menu item and the filePrint 
tool-button.

Since we don't want to print to the very edges of the paper, we use a
little margin: 10 points.  Furthermore we keep track of the page count.

\printline setup

QPrinter::setup() invokes a print dialog, configures the printer
object, and returns TRUE if the user wants to print or FALSE if not.
So, we test the return value, and if it's TRUE, we...

\printline message

... set a statusbar message in case printing takes a while.

\printline QPainter
\printuntil return

We create a painter for the output and decide that we wish to paint
on the printer or do nothing at all.

\printuntil surface

Then we select the font our QTextEdit object returns as the current 
one, and set up some variables we'll need.

\printline for

As long as the text editing widget contains lines, we want to print them.

\printline if

Before we print a line, we make sure that there is space for it on 
the current page.  If not, we start a new page:

\printline QString
\printuntil yPos

Four lines to tell the user what we're doing, two lines to do it.

\printline }

Now we know that there's space for the current line ...

\printuntil DontClip
\printuntil e->text(

... and we use the painter to print it. 

In Qt, output to printers uses the exact same code as output to screen,
pixmaps and picture metafiles.  Therefore, we don't call a QPrinter
function to draw text, instead we call a QPainter function.  QPainter works on
all the output devices mentioned and has a device independent API.  Most of its
code is device independent, too, therefore it is less likely
that your application will have odd bugs.  (If the same code is used
to print and to draw on the screen, it's less likely that you'll have
print-only or screen-only bugs.)

\printline yPos

With this line, we keep count of how much of the paper we've used
so far.

\printline }
\printline end

At this point we've printed all of the text in the editing widget 
and told the printer to finish off the last page. 

\printline message

Finally the user receives the message that we're done.

\printline else
\printline message
\printline }

If the user did not want to print (and \l QPrinter::setup() returned
FALSE), we inform him or her about it.

\printline }

With this little effort we have printed a text document.
So let's care about what happens when a user wishes to close()
an ApplicationWindow.

<a name="closeEvent"></a>
\printline ::closeEvent
\printline {

This event get to process window system close events.  A close event
is subtly different from a hide event: hide often means "iconify"
whereas close means that the window is going away for good.

\printline isModified
\printline accept
\printline return
\printline }

If the text hasn't been edited, we just accept the event.  The window
will be closed, and since we used the \c WDestructiveClose widget
flag in the <a href="#ApplicationWindow">ApplicationWindow() constructor</a>, 
the widget will be deleted.

\printline QMessageBox
\printuntil {

Otherwise we ask the user: What do you want
to do?  

\printuntil break

If he/she wants to save and then exit, we do that.  


\printuntil break

If the
user however doesn't want to exit, we ignore the close event (there is a chance
that we can't block it but we try).  

\printuntil break

The last case -- the user wants to exit 
abandoning the edits -- is very simple.

\printline }
\printline }

Last but not least we implement the slots used by the help menu entries.

\printline ::about
\printuntil aboutQt
\printuntil }

These two slots use ready-made about functions to provide some
information about
this program and the GUI toolkit it uses.  (You don't need to provide
an About Qt in your programs, but if you use Qt for free we'd
appreciate it if you tell people what you're using.)

That was all we needed to write a complete, almost useful application with 
nice help-functions,
almost as good as the "editors" some computer vendors ship
with their desktops, in less than 300 lines of code. As we promised - a simple
application.

*/
