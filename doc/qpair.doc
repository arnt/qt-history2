/****************************************************************************
**
** QPair class documentation.
**
** Copyright (C) 1992-$THISYEAR$ Trolltech AS. All rights reserved.
**
** This file is part of the Qt GUI Toolkit.
** EDITIONS: FREE, PROFESSIONAL, ENTERPRISE
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
****************************************************************************/

/*****************************************************************************
  QPair documentation
 *****************************************************************************/


/*!
    \class QPair qpair.h
    \brief The QPair class is a value-based template class that provides a pair of elements.

    \ingroup qtl
    \ingroup tools
    \ingroup shared
    
    QPair is a Qt implementation of an STL-like pair. It can be used
    in your application if the standard pair\<\> is not available on
    your target platforms.

    QPair\<T1, T2\> defines a template instance to create a pair of
    values that contains two values of type T1 and T2. Please note
    that QPair does not store pointers to the two elements; it holds a
    copy of every member. This is why these kinds of classes are
    called \e{value based}. If you're interested in \e{pointer based}
    classes see, for example, QPtrList and QDict.

    QPair holds one copy of type T1 and one copy of type T2, but does
    not provide iterators to access these elements. Instead, the two
    elements (\c first and \c second) are public member variables of
    the pair. QPair owns the contained elements. For more relaxed
    ownership semantics, see QPtrCollection and friends which are
    pointer-based containers.

    Some classes cannot be used within a QPair: for example, all
    classes derived from QObject and thus all classes that implement
    widgets. Only "values" can be used in a QPair. To qualify as a
    value the class must provide:

    \list
    \i A copy constructor
    \i An assignment operator
    \i A constructor that takes no arguments
    \endlist

    Note that C++ defaults to field-by-field assignment operators and
    copy constructors if no explicit version is supplied. In many
    cases this is sufficient.

    QPair uses an STL-like syntax to manipulate and address the
    objects it contains. See the \link qtl.html QTL
    documentation\endlink for more information.

    Functions that need to return two values can use a QPair.
*/

/*! \enum QPair::first_type
	The type of the first element in the pair. */

/*! \enum QPair::second_type
	The type of the second element in the pair. */


/*!
    \fn QPair::QPair()

    Constructs an empty pair. The \c first and \c second elements are
    default constructed. 
*/

/*!
    \fn QPair::QPair( const T1& t1, const T2& t2 )

    Constructs a pair and initializes the \c first element with \a t1
    and the \c second element with \a t2.
*/

/*!
    \fn QPair<T1, T2>& QPair::operator=( const QPair<T1, T2>& other )

    Assigns the \a other's values to this pair.
*/

/*!
    \fn QPair qMakePair(T1 t1, T2 t2)

    \overload

    \relates QPair

    This is a template convenience function. It is used to create a
    QPair\<\> object that contains \a t1 and \a t2. For example:
    \code
	QMap<QString,QString> m;
	m.insert( qMakePair("Clinton", "Bill") );
    \endcode

    The above code is equivalent to:
    \code
	QMap<QString,QString> m;
	QPair<QString,QString> p( "Clinton", "Bill" );
	m.insert( p );
    \endcode
*/
