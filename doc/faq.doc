/****************************************************************************
** $Id: faq.doc,v 2.1 1998/09/09 22:16:54 warwick Exp $
**
** Miscellaneous index pages
**
** Copyright (C) 1995-1997 by Troll Tech AS.  All rights reserved.
**
*****************************************************************************/

#if defined(DEBUG)
static char ident[] = "$Id: faq.doc,v 2.1 1998/09/09 22:16:54 warwick Exp $";
#endif

/*! \page faq.html

<title> Qt Technical FAQ </title>

<body>
<h1> Qt Technical FAQ </h1>

<ol>

<li><strong>Why doesn't \link QWidget::setBackgroundColor() QWidget::setBackgroundColor() \endlink do what I expect?</strong>
<p>
There are several variations of this question.  The answer to most of
them is to use either QPalette or
QColorGroup instead.  The details
vary, but the documentation for those classes explain them.

<p>

<li><strong>How do I get a nonrectangular or transparent widget?</strong>
<p>
Use QWidget::setMask().
Warning: Nonrectangular widgets are slow on some platforms.
<p>

<li><strong>How can I write threaded programs?</strong>
<p>
You must have a thread library and a libc which is compatible with
that thread library, and you must run the GUI in one thread, reacting
to incoming events as usual.
<p>
We know that people have done this on both Windows NT and on several
Unixes.
<p>
Brian P. Theodore has written some code to help with threading on
X11/Unix.  He sent a <a href="http://www.troll.no/qt-interest/aix7.html#aiy1">message
about it</a> to Qt-interest.
<p>

<li><strong>I have problems compiling &lt;Qt or something related to
it&gt; on &lt;platform&gt;</strong>
<p>
Our <a href="http://www.troll.no/platforms/">list of platforms and compilers</a> has links
to pages for each supported platform and compiler.  We add all known
platform-specific problems to the relevant page.
<p>

<li><strong>Can I have several top level widgets?</strong>
<p>
Yes, just create several widgets with <code>parent == 0</code>.
<p>

<li><strong><a name="bincomp">You frequently say that you cannot add
this or that feature because it would break binary compatibility.
What does this mean, really?</strong>

<p>Binary compatibility means that you can safely distribute your Qt
programs dynamically linked to the Qt library. If the users of your
program have a newer version of the Qt dynamic library installed (or
later upgrade to one), your program will still work. This can save
much time, network, disk, and memory resources and adminstration work,
for both you and the users of your Qt-based programs.

<p>Technically, this means, roughly ordered from least to most
obvious:<ul>

<li> We cannot add reimplementations of virtual functions, unless it
it safe for older binaries to call the original implemenation.  This
is because the compiler evaluates SuperClass::virtualFunction() calls
at compile-time, not at link-time.

<li>We cannot add or remove virtual member functions.  This would
change the size and layout of the vtbl of every subclass.

<li>We cannot change the type of any data members or move any data
members that can be accessed via inline member functions.

<li>We cannot change the class hierarchy, except to add new leaves.

<li>We cannot add or remove private data members.  This would
change the size and layout of every subclass.

<li>We cannot remove public or protected member functions unless they
are inline.

<li>We cannot make a public or protected member function inline.

<li>We cannot change what an inline function does, unless the old
version continues working.

<li>We cannot change the access rights (i.e. public, protected or private)
of a member function.  Some compilers mangle the access rights into the
function name.

</ul>

<p><li><strong>When I compile my Qt based program I get a
parse/syntax error in one of Qt's header files. What's wrong?</strong><p>

We do a lot of testing before we release a new version of Qt, so an
error like this almost certainly lies in your program somewhere.  The
most common cause is that a header file you have included before the
Qt header file defines a macro with a name that is used in the Qt
header file.  Examples we have encountered include Ok, ButtonMask,
list, red, black, bool, raise and connect.

<p>A standard trick for tracking down these kind of problems is to
look at compiler output after preprocessing has been done (often done
with a -E option) and compare the output with the header file where
you get the error.

<p>There are three common strategies for dealing with such problems,
which may often be combined:<ul>

<li>Include the Qt header file first.  This allows the other header
file to #define the macro, and you cannot use Qt's function or enum.

<li>Include the other header files, then #undef the relevant macro,
then include the Qt header files.  For example:

<pre>
    #define ButtonMask ButtonMask_hack
    #include &lt;offender.h&gt;
    #undef ButtonMask

    #include &lt;qmsgbox.h&gt;
</pre>

<p>This allows you to use the function or enum in Qt, but not the
macro in the other header file.

<li>Include the other header file in just one .cpp file (and no .h
files) in your application and encapsulate the functionality you need.
This limits the scope of the conflict to just one .cpp file.  Since
this limits the system dependent code to one file, it also increases
the portability of your code.

</ul>

<p>GNU STL is a special case.  It defines two global enums, red and
black, which are used by their internal red-black tree class.
Unfortunately, they crash with Qt's global color objects named red and
black.  Here's a workaround:

<p><pre>
    #define red   stl_red
    #define black stl_black
    #include &lt;stl.h&gt;
    #undef red
    #undef black
    #include &lt;qcolor.h&gt;
</pre>

<p>
<li><strong> Purify complains about UMRs (Uninitialized Memory Reads) in
the QGDict constructor?  Is this a bug in Qt?</strong>

<p>This is not a bug in Qt.  You can safely ignore this message.

<p>QGDict uses bit field members to save space.  When QGDict
initializes its members, bits are either set or cleared.  To clear a
bit on assembly level, a byte is first read, AND'ed with a mask and
written back. Purify reports a UMR when reading the byte.  The UMR
depends on your compiler and compiler options.

<p>We've seen such false UMRs these places in Qt:

<ul>
<li>QGDict::QGDict()
<li>QMenuData::QMenuData()
<li>QPushButton::init()
<li>QMenuItem::QMenuItem()
<li>QScrollbar::QScrollbar()
</ul>

<p>We've been in contact with PureAtria (now Rational) and they say
this is a problem which cannot easily be solved.  The only solution
would be that the compiler first sets all bytes to zero before
accessing the bits.


<p>
<li><strong> Purify found a memory leak in qapp_x11.cpp.  Why don't you
clean up the XIM (X Input Method) structure?</strong>
<p>
This is to work around a bug in some versions of Xlib.  The leak isn't
harmful - it concerns only 400 bytes of memory which will be deallocated
anyway when the application terminates.


<p>
<li><strong> I want to pop up a popup menu when I get a mouse event, but the
menu pops up at wild places. (How do I convert local coordinates to
global ones?)  </strong>

<p>
The QPoint argument to the QPopupMenu::popup() function takes global
screen coordinates as its argument. The position sent to a mouse event is
always in the widgets local coordinates. You must transform it using the
QWidget::mapToGlobal() function. Here is one way of doing it:
<p>
<pre>
void CustomWidget::mousePressEvent( QMouseEvent *event )
{
    if ( event->button() == RightButton )
	menu->popup( mapToGlobal( event->pos() ) );
}
</pre>
<p>

<li><strong> When a signal is emitted, will all of the slots attached to it be
executed before the emit returns?  Or are the slots just scheduled to be
executed whenever convienient?</strong>

<p>All of the slots will be executed before the emit returns. The
order of execution of the slots is undefined.
<p>

<li><strong> Will you add the Next/Amiga/BeOS/myfavorite GUI style in
the next version of Qt?</strong>

<p>Adding a new GUI style to Qt can be a great deal of work, both for us
and for all authors of third-party widgets.  The QStyle class provides
a balance of flexibility and maintainability that is sufficient for
many interesting GUI styles, while not placing a great burden on
third-party widgets developers.

<li><strong>Why does Opaque Resize cause so much flicker?</strong>

<p>
By default, widgets are completely repainted after they are resized,
but if you use the WResizeNoErase widget flag, and put explicit calls
to QWidget::update() in your \link QWidget::resizeEvent() resize event\endlink,
you can reduce flicker considerably.

<p>

</ol>

*/
