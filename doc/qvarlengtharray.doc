/*! \class QVarLengthArray

    ### does not initialize the data for basic types
*/

/*! \fn QVarLengthArray::QVarLengthArray(int size)

    Constructs an array with an initial size of \a size elements.

    If the value type is a primitive type (e.g., char, int, float) or
    a pointer type (e.g., QWidget *), the elements are not
    initialized. For other types, the elements are initialized with a
    \l{default-constructed value}.
*/

/*! \fn QVarLengthArray::~QVarLengthArray()

    Destroys the array.
*/

/*! \fn int QVarLengthArray::size() const

    Returns the number of items in the array.

    \sa isEmpty(), resize()
*/

/*! \fn int QVarLengthArray::count() const

    Same as size().

    \sa isEmpty(), resize()
*/

/*! \fn bool QVarLengthArray::isEmpty() const

    Returns true if the array has size 0; otherwise returns false.

    \sa size(), resize()
*/

/*! \fn void QVarLengthArray::resize(int size)

    Sets the size of the array to \a size. If \a size is greater than
    the current size, elements are added to the end. If \a size is
    less than the current size, elements are removed from the end.

    If the value type is a primitive type (e.g., char, int, float) or
    a pointer type (e.g., QWidget *), new elements are not
    initialized. For other types, the elements are initialized with a
    \l{default-constructed value}.

    \sa size()
*/

/*! \fn void QVarLengthArray::reserve(int size)

    Asks QVarLengthArray to allocate memory for at least \a size
    elements. If you know in advance how large the array can get, you
    can call this function and if you call resize() often, you are
    likely to get better performance. If \a size is an underestimate,
    the worst that will happen is that the QVarLengthArray will be a
    bit slower.

    If you want to change the size of the array, call resize(), not
    reserve().

    \sa capacity()
*/

/*! \fn int QVarLengthArray::capacity() const

    Returns the maximum number of items that can be stored in the
    array without forcing a reallocation.

    If you want to get the number of items currently in the array,
    call size(), not capacity().

    \sa reserve()
*/

/*! \fn T &QVarLengthArray::operator[](int i)

    Returns a reference to the item at index position \a i.

    \a i must be a valid index position in the array (i.e., 0 <= \a i
    < size()).

    \sa data()
*/

/*! \fn const T &QVarLengthArray::operator[](int i)

    \overload
*/

/*! \fn QVarLengthArray::operator T *()

    Same as data().
*/

/*! \fn QVarLengthArray::operator const T *() const

    \overload

    Same as constData().
*/

/*! \fn T *QVarLengthArray::data()

    Returns a pointer to the data stored in the array. That pointer
    can be used to access and modify the items in the array.

    \code
	QVarLengthArray<int> array(10);
        int *data = array.data();
        for (int i = 0; i < 10; ++i)
	    data[i] = 2 * i;
    \endcode

    The pointer remains valid as long as the array isn't reallocated.

    This function is mostly useful to pass an array to a function
    that accepts a plain C++ array.

    \sa operator[]()
*/

/*! \fn const T *QVarLengthArray::data() const

    \overload
*/

/*! \fn const T *QVarLengthArray::constData() const

    Returns a const pointer to the data stored in the array. That
    pointer can be used to access the items in the array. The
    pointer remains valid as long as the array isn't reallocated.

    This function is mostly useful to pass an array to a function
    that accepts a plain C++ array.

    \sa operator[]()
*/
