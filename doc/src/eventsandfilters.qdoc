/*!
    \page eventsandfilters.html

    \title Events and Event Filters

    In Qt, an event is an object that inherits QEvent. Events are
    delivered to objects that inherit QObject through calling
    QObject::event(). Event delivery means that an event has
    occurred, the QEvent indicates precisely what, and the QObject
    needs to respond. Most events are specific to QWidget and its
    subclasses, but there are important events that aren't related to
    graphics (e.g., \l{QTimer}{timer events}).

    Some events come from the window system (e.g., QMouseEvent), some
    from other sources (e.g., QTimerEvent), and some come from the
    application program. Qt is symmetric, as usual, so you can send
    events in exactly the same ways as Qt's own event loop does using
    QCoreApplication::sendEvent() and QCoreApplication::postEvent().

    Most events types have special classes, notably QResizeEvent,
    QPaintEvent, QMouseEvent, QKeyEvent, and QCloseEvent. Each class
    subclasses QEvent and adds event-specific functions; see for
    example QResizeEvent, which adds QResizeEvent::size() and
    QResizeEvent::oldSize().

    Some classes support more than one actual event type. QMouseEvent
    supports mouse button presses, double-clicks, moves, etc. The
    event type is available as QEvent::type().

    Since programs need to react in varied and complex ways, Qt's
    event delivery mechanisms are flexible. The documentation for
    QCoreApplication::notify() concisely tells the whole story; the
    \e{Qt Quarterly} article
    \l{http://doc.trolltech.com/qq/qq11-events.html}{Another Look at Events}
    rehashes it less concisely; here we
    will explain enough for 95% of applications.

    The normal way for an event to be delivered is by calling a virtual
    function. For example, QPaintEvent is delivered by calling
    QWidget::paintEvent(). This virtual function is responsible for
    reacting appropriately, normally by repainting the widget. If you
    do not perform all the necessary work in your implementation of the
    virtual function, you may need to call the base class's
    implementation. For example:

    \quotefromfile snippets/events/events.cpp
    \skipto MyCheckBox::mousePressEvent
    \printuntil /^\}/

    If you want to replace the base class's function, you must
    implement everything yourself; but if you only want to extend the
    base class's functionality, then you implement what you want and
    then call the base class.

    Occasionally there isn't such an event-specific function, or the
    event-specific function isn't sufficient. The most common example
    is tab key presses. Normally, those are interpreted by QWidget to
    move the keyboard focus separately from the other keys, but a few
    widgets need the \key{Tab} key for themselves.

    These objects can reimplement QObject::event(), the general event
    handler, and either do their event handling before or after the usual
    handling, or replace it completely. A very unusual widget that both
    interprets tab and has an application-specific custom event might
    contain the following \l{QObject::event()}{event()} function:

    \skipto MyWidget::event
    \printuntil /^\}/

    More commonly, an object needs to look at another's events. Qt
    supports this using QObject::installEventFilter() (and the
    corresponding remove). For example, dialogs commonly want to filter
    key presses for some widgets, e.g. to modify \key{Return}-key handling.

    An event filter gets to process events before the target object does.
    The filter's QObject::eventFilter() implementation is called, and
    can accept or reject the filter, and allow or deny further processing
    of the event. If all the event filters allow further processing of an
    event, the event is sent to the target object itself. If one of them
    stops processing, the target and any later event filters don't get to
    see the event at all.

    It's also possible to filter \e all events for the entire application,
    by installing an event filter on the QApplication or QCoreApplication
    object. This is very powerful, but it also slows down event delivery
    of every single event in the entire application, so it's best avoided.

    The global event filters are called before the object-specific
    filters.

    Finally, many applications want to create and send their own events.

    Creating an event of a built-in type is very simple: create an object
    of the relevant type, and then call QCoreApplication::sendEvent() or
    QCoreApplication::postEvent().

    sendEvent() processes the event immediately. When sendEvent()
    returns, the event filters and/or the object have already
    processed the event. For many event classes there is a function
    called isAccepted() that tells you whether the event was accepted
    or rejected by the last handler that was called.

    postEvent() posts the event on a queue for later dispatch. The next
    time Qt's main event loop runs, it dispatches all posted events, with
    some optimization. For example, if there are several resize events,
    they are are compacted into one. The same applies to paint events:
    QWidget::update() calls postEvent(), which eliminates flickering and
    increases speed by avoiding multiple repaints.

    postEvent() is also often used during object initialization, since the
    posted event will typically be dispatched very soon after the
    initialization of the object is complete.

    To create events of a custom type, you need to define an event
    number, which must be greater than \c QEvent::User, and probably
    you also need to subclass QEvent in order to pass characteristics
    about your custom event. See the \l QEvent documentation for
    details.
*/
