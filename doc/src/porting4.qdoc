/****************************************************************************
**
** Copyright (C) 1992-$THISYEAR$ Trolltech AS. All rights reserved.
**
** This file is part of the Qt GUI Toolkit.
** EDITIONS: FREE, PROFESSIONAL, ENTERPRISE
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
****************************************************************************/

/*!
    \page porting4.html

    \title Porting to Qt 4

    This document describes porting applications from Qt 3 to Qt 4.

\omit
    ### refer to porting4-renamedfunctions.qdoc
    ### QApplication library mutex is gone
    ### no integral conversion for containers? strings?
    ### QVector etc. are initialized to 0 by default?
    ### How to port from Qt 2.3 to Qt 4.
    ### missing sort() functions?
    ### QToolTipGroup
    ### QServerSocket -> Q3ServerSocket

    ### remove these when the classes are re-ported

    ### QApplication::eventLoop()

    \row \o void QCheckListItem::paintCell(QPainter *, const QColorGroup &, int, int, int)\row \o void Q3CheckListItem::paintCell(QPainter *, const QPalette &, int, int, int)
    \row \o void QCheckListItem::paintFocus(QPainter *, const QColorGroup &, const QRect &) \o void Q3CheckListItem::paintFocus(QPainter *, const QPalette &, const QRect &)
    \row \o QDataTable: a whole bunch of virtual functions have a different signature

    <     Function: void QIconViewItem::paintFocus(QPainter *, const QColorGroup &)
    >     Function: void QIconViewItem::paintFocus(QPainter *, const QPalette &)

    <     Function: void QIconViewItem::paintItem(QPainter *, const QColorGroup &)
    >     Function: void QIconViewItem::paintItem(QPainter *, const QPalette &)

    <     Function: QVariant QSqlCursor::calculateField(const QString &)
    >     Function: QCoreVariant QSqlCursor::calculateField(const QString &)

    <     Function: bool QUrlOperator::checkValid()

    <     Function: void QWSInputMethod::setFont(const QFont &)

    ### OpenMode or OpenMode

    ### QWSDecoration
\endomit

    If you haven't yet made the decision about porting, or are unsure
    about whether it is worth it, take a look at the \link
    qt4-intro.html key features\endlink offered by Qt 4.

    The Qt 4 series is not binary compatible with the 3 series. This
    means programs compiled for Qt 3 must be recompiled to work with
    Qt 4. Qt 4 is also not completely \e source compatible with 3,
    however nearly all points of incompatibility cause compiler
    errors or run-time messages (rather than mysterious results). Qt
    4 includes many additional features and discards obsolete
    functionality. Porting from Qt 3 to Qt 4 is straightforward, and
    once completed makes the considerable additional power and
    flexibility of Qt 4 available for use in your applications.

    To port code from Qt 3 to Qt 4:

    \list 1

    \o Briefly read the porting notes below to get an idea of what to expect.

    \o Be sure that your code compiles and runs well on all your target
       platforms with Qt 3, with QT_NO_COMPAT defined.

    \o Run the \l{qt3to4.html}{qt3to4} tool.

    \o Recompile with Qt 4. For each error, search below for related
       identifiers (e.g. function names, class names). This document
       mentions all relevant identifiers to help you get the information
       you need at the cost of being a little verbose.

    \o If you get stuck, ask on the \link http://qt-interest.trolltech.com/
       qt-interest \endlink mailing list, or Trolltech Technical Support if
       you're a registered licensee.

    \endlist

\omit
    ### what to do with slots that aren't slots anymore
    ### what to do with virtual functions that aren't virtual anymore
    ### what to do with virtual functions that changed signature
\endomit

\omit
    ### <qtl.h> -- stuff that vanished?
    ### implicit sharing
    ### uint -> int indexes
\endomit

    Table of contents:

    \tableofcontents{4}

\omit
    \section1 Header Files

    ### New style of headers

    \table
    \header \o Old header \o New header
    \row \o \c{<qtl.h>} \o \c{<qalgorithms.h>} or \c{<QtAlgorithms>}
    \endtable

    ### Some headers don't include each other anymore...
\endomit

\omit
    \section1 Global Functions

    \table
    \header \o Qt 3 function \o Qt 4 function
    \row \o cstrcmp() \o strcmp()
    \row \o cstrcpy() \o strcpy()
    \row \o cstrlen() \o strlen()
    \row \o cstrncmp() \o strncmp()
    \row \o qmemmove() \o memmove()
    \endtable

    qGLVersion() ###

    copyBlt() ###
    bitBlt()

    #ifdef compat classes:
        * QLayoutIterator
        * QColorGroup
        * QMenuItem

    QWidget visibleRect property compat
    QWidget::BackgroundOrigin compat
\endomit

    \section1 Type Names

    The table below lists the classes that have been renamed in Qt 4.
    If you compile your applications with \c QT_COMPAT defined, the
    old names will be available.

    Whenever you see an occurrence of the name on the left, you can
    safely replace it with the Qt 4 equivalent in your program. The
    \l{qt3to4.html}{qt3to4} tool handles performs the conversion
    automatically.

    \table
    \header \o Qt 3 class name \o Qt 4 class name
    \input porting4-renamedclasses.qdocinc
    \endtable

    The table below lists the enums and typedefs that have been
    renamed in Qt 4. If you compile your applications with \c
    QT_COMPAT defined, the old names will be available.

    Whenever you see an occurrence of the name on the left, you can
    safely replace it with the Qt 4 equivalent in your program. The
    \l{qt3to4.html}{qt3to4} tool handles performs the conversion
    automatically.

    \table
    \header \o Qt 3 type name \o Qt 4 type name
    \input porting4-renamedtypes.qdocinc
    \endtable

    ###

    \row \o QButton::ToggleState \o Use QCheckBox::ToggleState instead.

    \section1 Enum Values

    The table below lists the enum values that have been renamed in
    Qt 4. If you compile your applications with \c QT_COMPAT defined,
    the old names will be available.

    Whenever you see an occurrence of the name on the left, you can
    safely replace it with the Qt 4 equivalent in your program. The
    \l{qt3to4.html}{qt3to4} tool handles performs the conversion
    automatically.

    \table
    \header \o Qt 3 enum value name \o Qt 4 enum value name
    \input porting4-renamedenumvalues.qdocinc
    \endtable

    In addition, the following \l{Qt::WFlag}{window flags} have been
    either replaced with \l{Qt::WidgetAttribute}{widget attributes}
    or have been deprecated:

    \table
    \header \o Qt 3 type \o Qt 4 equivalent
    \row \o Qt::WDestructiveClose \o Use QWidget::setAttribute(Qt::WA_DeleteOnClose) instead.
    \row \o Qt::WStaticContents \o{1,2} Use QWidget::setAttribute(Qt::WA_StaticContents) instead.
    \row \o Qt::WNorthWestGravity
    \row \o Qt::WNoAutoErase \o{1,3} Use QWidget::setAttribute(Qt::WA_NoBackground) instead.
    \row \o Qt::WResizeNoErase
    \row \o Qt::WRepaintNoErase 
    \row \o Qt::WPaintClever \o Unnecessary in Qt 4.
         \omit ### Check with Matthias \endomit
    \row \o Qt::WMacNoSheet \o Unnecessary in Qt 4.
         \omit ### Check with Sam \endomit
    \endtable

    \target properties
    \section1 Properties

    Some properties have been renamed in Qt 4, to make Qt's API more
    consistent and more intuitive. For example, QWidget's \c caption
    property has been renamed \c windowTitle to make it clear that it
    refers to the title shown in the window's title bar.

    The table below lists the Qt properties that have been renamed in
    Qt 4. Occurrences of these in \e{Qt Designer} \c .ui files are
    automatically converted to the new name by \c uic.

    \table
    \header \o Qt 3 name \o Qt 4 name
    \row \o QButton::accel \o QButton::shortcut
    \row \o QButton::on \o QButton::checked
    \row \o QButton::toggleButton \o QAbstractButton::checkable
    \row \o QDial::lineStep \o QDial::singleStep
    \row \o QDial::maxValue \o QDial::maximum
    \row \o QDial::minValue \o QDial::minimum
    \row \o QDialog::modal \o QDialog::isModal
    \row \o QLineEdit::edited \o QLineEdit::modified
    \row \o QLineEdit::hasMarkedText \o QLineEdit::hasSelectedText
    \row \o QLineEdit::markedText \o QLineEdit::selectedText
    \row \o QObject::name \o QObject::objectName
    \row \o QProgressDialog::progress \o QProgressDialog::value
    \row \o QProgressDialog::totalSteps \o QProgressDialog::maximum
    \row \o QProgressDialog::wasCancelled \o QProgressDialog::wasCanceled
    \row \o QPushButton::iconSet \o QPushButton::icon
    \row \o QScrollBar::draggingSlider \o QScrollBar::sliderDown
    \row \o QScrollBar::lineStep \o QScrollBar::singleStep
    \row \o QScrollBar::maxValue \o QScrollBar::maximum
    \row \o QScrollBar::minValue \o QScrollBar::minimum
    \row \o QSlider::lineStep \o QSlider::singleStep
    \row \o QSlider::maxValue \o QSlider::maximum
    \row \o QSlider::minValue \o QSlider::minimum
    \row \o QSpinBox::lineStep \o QSpinBox::singleStep
    \row \o QSpinBox::maxValue \o QSpinBox::maximum
    \row \o QSpinBox::minValue \o QSpinBox::minimum
    \row \o QTabBar::currentTab \o QTabBar::currentIndex
    \row \o QTabWidget::currentPage \o QTabWidget::currentIndex
    \row \o QToolButton::iconSet \o QToolButton::icon
    \row \o QToolButton::textLabel \o QToolButton::text
    \row \o QWidget::caption \o QWidget::windowTitle
    \row \o QWidget::icon \o QWidget::windowIcon
    \row \o QWidget::iconText \o QWidget::windowIconText
    \endtable

    A handful of properties in Qt 3 are no longer properties in Qt 4,
    but the access functions still exist as part of the Qt 4 API.
    These are not used by \e{Qt Designer}; the only case where you
    need to worry about them is in highly dynamic applications that
    use Qt's meta-object system to access properties. Here's the list
    of these properties with the read and write functions that you
    can use instead:

    \table
    \header \o Qt 3 property \o Qt 4 read function \o Qt 4 write function
    \row \o QGrid::margin \o QGridWidget::margin() \o QGridWidget::setMargin()
    \row \o QHBox::margin \o QHBoxWidget::margin() \o QHBoxWidget::setMargin()
    \row \o QSqlDatabase::connectOptions \o QSqlDatabase::connectOptions() \o QSqlDatabase::setConnectOptions()
    \row \o QSqlDatabase::databaseName \o QSqlDatabase::databaseName() \o QSqlDatabase::setDatabaseName()
    \row \o QSqlDatabase::hostName \o QSqlDatabase::hostName() \o QSqlDatabase::setHostName()
    \row \o QSqlDatabase::password \o QSqlDatabase::password() \o QSqlDatabase::setPassword()
    \row \o QSqlDatabase::port \o QSqlDatabase::port() \o QSqlDatabase::setPort()
    \row \o QSqlDatabase::userName \o QSqlDatabase::userName() \o QSqlDatabase::setUserName()
    \endtable

    Some properties have been removed from Qt 4, but the associated
    access functions are provided if \c QT_COMPAT is defined to help
    porting to Qt 4. When converting Qt 3 \c .ui files to Qt 4, \c
    uic generates calls to the Qt compatibility functions.

    The table below lists these properties with the read and write
    functions that you can use instead. The documentation for the
    individual functions explains how to replace them with
    non-compatibility Qt 4 functions.

    \table
    \header \o Qt 3 property \o Qt 4 read function (\c QT_COMPAT)\o Qt 4 write function (\c QT_COMPAT)
    \row \o QMenuBar::separator \o QMenuBar::separator() \o QMenuBar::setSeparator()
    \row \o QPushButton::menuButton \o QPushButton::isMenuButton() \o N/A
    \row \o QTabWidget::margin \o QTabWidget::margin() \o QTabWidget::setMargin()
    \row \o QWidget::backgroundBrush \o QWidget::backgroundBrush() \o N/A
    \row \o QWidget::backgroundMode \o QWidget::backgroundMode() \o QWidget::setBackgroundMode()
    \row \o QWidget::backgroundOrigin \o QWidget::backgroundOrigin() \o QWidget::setBackgroundOrigin()
    \row \o QWidget::colorGroup \o QWidget::colorGroup() \o QWidget::setColorGroup()
    \row \o QWidget::customWhatsThis \o QWidget::customWhatsThis() \o QWidget::setCustomWhatsThis()
    \row \o QWidget::inputMethodEnabled \o QWidget::inputMethodEnabled() \o QWidget::setInputMethodEnabled()
    \row \o QWidget::ownCursor \o QWidget::ownCursor() \o N/A
    \row \o QWidget::ownFont \o QWidget::ownFont() \o N/A
    \row \o QWidget::ownPalette \o QWidget::ownPalette() \o N/A
    \row \o QWidget::paletteBackgroundColor \o QWidget::paletteBackgroundColor() \o QWidget::setPaletteBackgroundColor()
    \row \o QWidget::paletteBackgroundPixmap \o QWidget::paletteBackgroundPixmap() \o QWidget::setPaletteBackgroundPixmap()
    \row \o QWidget::paletteForegroundColor \o QWidget::paletteForegroundColor() \o QWidget::setPaletteForegroundColor()
    \row \o QWidget::underMouse \o QWidget::underMouse() \o N/A
    \endtable

    The following Qt 3 properties and their access functions are no
    longer available in Qt 4. In most cases, Qt 4 provides similar
    functionality.

    \table
    \header \o Qt 3 property \o Qt 4 equivalent
    \row \o QButton::autoRepeat \o N/A
    \row \o QButton::autoResize \o N/A
    \row \o QButton::exclusiveToggle \o See \l QButton::autoExclusive.
    \row \o QButton::pixmap \o Use QAbstractButton::icon instead.
    \row \o QButton::toggleState \o Use QCheckBox::setState() and QCheckBox::state() instead.
    \row \o QButton::toggleType \o Use QCheckBox::setTristate() instead.
    \row \o QComboBox::autoResize \o N/A
    \row \o QFrame::contentsRect \o Use Q3Frame::contentsRect() instead.
    \row \o QFrame::contentsRect \o Use Q3Frame::margin instead.
    \row \o QTabBar::keyboardFocusTab \o N/A
    \row \o QToolButton::offIconSet \o Use the \l{QIcon::Off}{off component} of QAbstractButton::icon instead.
    \row \o QToolButton::onIconSet \o Use the \l{QIcon::On}{on component} of QAbstractButton::icon instead.
    \row \o QWidget::microFocusHint \o N/A
    \endtable

    \section1 Inheritance Chain

    ### QMenuBar, etc.

\omit
    \section1 Null vs. Empty

    ###
\endomit

    \section1 Explicit Sharing

    Qt 4 is the first version of Qt that contains no \link
    http://doc.trolltech.com/3.3/shclass.html explicitly shared
    \endlink classes. All classes that were explicitly shared in Qt 3
    are \e implicitly shared in Qt 4:

    \list
    \o QImage
    \o QMovie
    \o QBitArray
    \o QByteArray
    \o QPointArray
    \endlist

    This means that if you took a copy of an instance of the class
    (using operator=() or the class's copy constructor), any
    modification to the copy would affect the original and vice
    versa. Needless to say, this behavior is rarely desirable.

    Fortunately, nearly all Qt 3 applications don't rely on explicit
    sharing. When porting, you typically only need to remove calls to
    detach() and/or copy(), which aren't necessary anymore.

    If you deliberately rely on explicit sharing in your application,
    you can use pointers or references to achieve the same result in
    Qt 4.

    \oldcode
        void asciify(QByteArray array)
        {
            for (int i = 0; i < (int)array.size(); ++i) {
                if ((uchar)array[i] >= 128)
                    array[i] = '?';
            }
        }
    \newcode
        void asciify(QByteArray &array)
        {
            for (int i = 0; i < (int)array.size(); ++i) {
                if ((uchar)array[i] >= 128)
                    array[i] = '?';
            }
        }
    \endcode

    (Notice the \c & in the parameter declaration.)

\omit
    \section1 Qt Designer .ui Files

    ###
\endomit

    \section1 QAccel

    The QAccel class has been moved to the \l{Qt 3 compatibility
    library}. In new applications, you have three options:

    \list 1
    \o You can use QAction and set a key sequence using QAction::setShortcut().
    \o You can use QShortcut, a class that provides similar
       functionality to QAccel.
    \o You can use QWidget::grabShortcut() and process "shortcut"
       events by reimplementing QWidget::event().
    \endlist

    The QAccel class also supported multiple accelerators using the
    same object, by calling QAccel::insertItem() multiple times. In
    Qt 4, the solution is to create multiple QShortcut objects.

    \section1 QAccessibleInterface

    The QAccessibleInterface class has undergone some API changes in
    Qt 4, to make it more consistent with the rest of the Qt API.

    If you have classes that inherit QAccessibleInterface or one of
    its subclasses (QAccessibleObject, QAccessibleWidget, etc.), you
    must port them the new QAccessibleInterface API.

    See \l{#virtual.functions}{Virtual Functions} for a list of
    QAccessibleInterface virtual member functions in Qt 3 that are
    not longer virtual in Qt 4.

    \target qaction.section
    \section1 QAction

    The QAction class has been redesigned in Qt 4 to integrate better
    with the rest of the menu system. It unifies the old QMenuItem
    class and the old QAction class into one class, avoiding
    unnecessary data duplication and the need to learn two different
    APIs.

    The old QAction and QActionGroup classes have been renamed
    Q3Action and Q3ActionGroup and moved to the \l{Qt 3 compatibility
    library}. In addition, the new QAction class has compatibility
    functions to ease transition to Qt 4.

    See \l{#virtual.functions}{Virtual Functions} for a list of
    QAction virtual member functions in Qt 3 that are not longer
    virtual in Qt 4.

    \section1 QActionGroup

    The QAction class has been completely redesigned in Qt 4 to
    integrate better with the rest of the menu system. See the
    \l{#qaction.section}{section on QAction} for details.

    \section1 QApplication

    The QApplication class has been split into two classes:
    QCoreApplication and QApplication. The new QApplication class
    inherits QCoreApplication and adds GUI-related functionality. In
    practice, this has no consequences for existing Qt applications.

    In addition, the following API change was made:

    \list 1
    \o  QApplication::allWidgets() and QApplication::topLevelWidgets()
        used to return a pointer to a QWidgetList. Now they return a
        QWidgetList.

        Also, QWidgetList has changed from being a typedef for
        QPtrList<QWidget> to being a typedef for QList<QWidget *>.
        See the \l{#qwidgetlist.section}{section on QWidgetList} below
        for details.

        \oldcode
            QWidgetList *list = QApplication::topLevelWidgets();
            QWidgetListIt it(*list);
            QWidget *widget;
            while ((widget = it.current())) {
                if (widget->inherits("MainWindow"))
                    ((MainWindow *)widget)->updateRecentFileItems();
                ++it;
            }
            delete list;
        \newcode
            QWidgetList list = QApplication::topLevelWidgets();
            for (int i = 0; i < list.size(); ++i) {
                if (MainWindow *mainWin = qt_cast<MainWindow>(list.at(i)))
                    mainWin->updateRecentFileItems();
            }
        \endcode
    \endlist

    \section1 QAquaStyle

    The QAquaStyle class first appeared in Qt 3.0, when the Qt/Mac
    port was first released. It emulated Apple's "Aqua" theme. In Qt
    3.1, QAquaStyle was obsoleted by QMacStyle, which uses Appearance
    Manager to perform its drawing.

    The QAquaStyle class is no longer provided in Qt 4. Use QMacStyle
    instead.

    \section1 QAsciiCache<T>

    QAsciiCache<T> has been moved to the \l{Qt 3 compatibility
    library}. It has been replaced by QCache<QByteArray, T>.

    For details, read the \l{#qcache.section}{section on QCache<T>},
    mentally substituting QByteArray for QString.

    \section1 QAsciiDict<T>

    QAsciiDict<T> and QAsciiDictIterator<T> have been moved to the
    \l{Qt 3 compatibility library}. They have been replaced by the
    more modern QHash<Key, T> and QMultiHash<Key, T> classes and
    their associated iterator classes.

    When porting old code that uses QAsciiDict<T> to Qt 4, there are
    four classes that you can use:

    \list
    \o QMultiHash<QByteArray, T *>
    \o QMultiHash<QByteArray, T *>
    \o QHash<QByteArray, T>
    \o QHash<QByteArray, T>
    \endlist

    For details, read the \l{#qdict.section}{section on QDict<T>},
    mentally substituting QByteArray for QString.

    \section1 QAsyncIO

    The QAsyncIO class was used internally in Qt 2.x in conjunction
    with QImageConsumer. It was obsoleted in Qt 3.0. If you use this
    mechanism in your application, contact \l qt-bugs@trolltech.com
    and we will try to find a satisfying substitute.

    \section1 QBackInsertIterator

    The undocumented QBackInsertIterator class has been removed from
    the Qt library. If you need it in your application, feel free to
    copy the source code from the Qt 3 \c <qtl.h> header file.

    \section1 QBitArray

    In Qt 3, QBitArray inherited from QByteArray. In Qt 4, QBitArray
    is a totally independent class. This makes very little difference
    to the user, except that the new QBitArray doesn't provide any of
    QByteArray's byte-based API anymore. These calls will result in a
    compile-time error, except calls to QBitArray::truncate(), whose
    parameter was a number of \e bytes in Qt 3 and a number of bits
    in Qt 4.

    QBitArray was an explicitly shared class in Qt 3. See \l{Explicit
    Sharing} for more information.

    The QBitVal class has been renamed QBitRef.

    \section1 QButton

    The QButton class has been replaced by QAbstractButton in Qt 4.
    Classes like QPushButton and QRadioButton inherit from
    QAbstractButton. As a help when porting older Qt applications,
    the \l{Qt 3 compatibility library} contains a QButton class
    implemented in terms of the new QAbstractButton.

    If you used the QButton class as a base class for your own button
    type and want to port your code to the newer QAbstractButton, you
    need to be aware that QAbstractButton has no equivalent for the
    QButton::drawButton(QPainter *) virtual function. The solution is
    to reimplement QWidget::paintEvent() in your QAbstractButton
    subclass as follows:

    \code
        void MyButton::paintEvent(QPaintEvent *)
        {
            QPainter painter(this);
            drawButton(&painter);
        }
    \endcode

    \table
    \header \o Qt 3 function \o Qt 4 equivalent
    \row \o QButton::autoResize() \o N/A
    \row \o QButton::isExclusiveToggle() \o Use QAbstractButton::group() or QAbstractButton::autoExclusive() instead.
    \row \o QButton::pixmap() const \o QAbstractButton::icon()
    \row \o QButton::setAutoResize() \o N/A
    \row \o QButton::setPixmap(const QPixmap &) \o QAbstractButton::setIcon(const QIcon &)
    \row \o QButton::setState(ToggleState) \o See remark below
    \row \o QButton::setToggleType(ToggleType) \o See remark below
    \row \o QButton::state() \o See remark below
    \row \o QButton::stateChanged(int) \o See remark below
    \row \o QButton::toggleType() \o See remark below
    \endtable

    Remarks:

    \list 1
    \o In Qt 3, QButton had a "toggle type", which could be
       QButton::SingleShot, QButton::Toggle, or QButton::Tristate.
       The new QAbstractButton class doesn't support "tristate"
       directly; this feature is implemented in QCheckBox instead.
       The two other "toggle types" (QButton::SingleShot and
       QButton::Toggle) are replaced by a QAbstractButton::checkable
       property.
    \o In Qt 3, QButton had a "toggle state", which could be
       QButton::Off, QButton::NoChange, or QButton::On. In Qt 4, this
       mechanism has been moved to QCheckBox.
    \endlist

    See \l{#virtual.functions}{Virtual Functions} for a list of
    QButton virtual member functions in Qt 3 that are not longer
    virtual in Qt 4.

    See \l{#properties}{Properties} for a list of QButton properties
    in Qt 3 that have changed in Qt 4.

    \section1 QButtonGroup

    The QButtonGroup class has been completely redesigned in Qt 4.
    For compatibility, the old QButtonGroup class has been renamed
    Q3ButtonGroup and has been moved to the \l{Qt 3 compatibility
    library}, together with the QHButtonGroup and QVButtonGroup
    convenience subclasses.

    Q3ButtonGroup could be used in two ways:

    \list 1
    \o  The button group is the parent widget of a number of buttons,
        i.e. the button group is the parent argument in the button
        constructor. The buttons are assigned identifiers 0, 1, 2, etc.,
        in the order they are created. A Q3ButtonGroup can display a frame
        and a title because it inherits Q3GroupBox.
    \o  The button group is an invisible widget and the contained
        buttons have some other parent widget. In this usage, each
        button must be manually inserted, using
        Q3ButtonGroup::insert(), into the button group and given an
        ID number.
    \endlist

    Unlike Q3ButtonGroup, the new QButtonGroup doesn't inherit
    QWidget. It is very similar to a "hidden Q3ButtonGroup".

    If you use a Q3ButtonGroup, QHButtonGroup, or QVButtonGroup as a
    widget and want to port to Qt 4, you can replace it with
    QGroupBox. In Qt 4, radio buttons with the same parent are
    automatically part of an exclusive group, so you normally don't
    need to do anything else. See also the
    \l{#qgroupbox.section}{section on QGroupBox} below.

    See \l{#virtual.functions}{Virtual Functions} for a list of
    QButtonGroup virtual member functions in Qt 3 that are not longer
    virtual in Qt 4.

    \target qbytearray.section
    \section1 QByteArray

    In Qt 3, QByteArray was simply a typedef for QMemArray<char>. In
    Qt 4, QByteArray is a class in its own right, with a higher-level
    API in the style of QString.

    Here are the main issues to be aware of when porting to Qt 4:

    \list 1
    \o  The QMemArray(int size) constructor has been replaced with
        QByteArray(int size, char ch). The second argument specifies
        which character should be used for initializing the array;
        pass '\\0' if you have no specific needs.

        \oldcode
        QByteArray ba(64);
        \newcode
        QByteArray ba(64, '\0');
        \endcode

    \o  QMemArray::at() returned a non-const reference, whereas the
        new QByteArray::at() returns a const value. Code like

        \code
        ba.at(0) = 'X';
        \endcode

        will no longer compile. Instead, use QByteArray::operator[]:

        \code
        ba[0] = 'X';
        \endcode

    \o  The QMemArray::contains(char) function has been renamed
        QByteArray::count(char). In addition, there now exists a
        QByteArray::contains(char) function that returns a boolean
        value. Replace old calls to contains() with either count() or
        contains(), depending on whether you care about the specific
        number of occurrences of a character in the byte array or
        only care about whether the array contains that character or
        not.

    \o  The new QByteArray has no assign() function. Calls to
        QMemArray::assign(const QMemArray &) can be replaced by calls
        to QByteArray::operator=(). Calls to QMemArray::assign(const
        T *, uint) have no equivalent in Qt 4; if you use it, the
        solution is either to use QByteArray::fromRawData() and to
        call free() yourself to avoid a memory leak, or to use the
        QByteArray(const char *, int) constructor, which will take a
        deep copy of the data.

    \o  QMemArray::bsearch() and QMemArray::sort() have no equivalent
        in the new QByteArray class. Use \l qBinaryFind() and \l
        qHeapSort() if you need that functionality.
    \endlist

    QByteArray was an explicitly shared class in Qt 3. See
    \l{Explicit Sharing} for more information.

    \target qcache.section
    \section1 QCache<T>

    QCache<T> has been renamed Q3Cache<T> and moved to the \l{Qt 3
    compatibility library}. The new QCache class has a different API,
    and takes different template parameters: QCache<Key, T>.

    When porting to Qt 4, QCache<QString, T> is the obvious
    substitute for Q3Cache<T>. The following table summarizes the API
    differences.

    \table
    \header \o Q3Cache<T> function \o QCache<QString, T> equivalent
    \row \o Q3Cache::Q3Cache(int maxCost, int size, bool caseSensitive) \o See remark below
    \row \o Q3Cache::autoDelete() \o N/A
    \row \o Q3Cache::count() \o QCache::count() or QCache::size() (equivalent)
    \row \o Q3Cache::setAutoDelete() \o See remark below
    \row \o Q3Cache::size() \o N/A
    \row \o Q3Cache::statistics() \o N/A
    \row \o Q3Cache::operator=() \o See remark below
    \endtable

    Remarks:

    \list 1
    \o  Q3Cache requires the user to allocate a specific number of
        buckets by passing a prime number (17 by default) to the
        constructor. In contrast, the new QCache's hash table
        automatically grows and shrinks as needed, and the
        constructor doesn't take a prime number.

    \o  Q3Cache supportes case-insensitive lookups by passing false as
        second argument to the constructor. This feature has no
        equivalent in QMultiHash. Instead, call QString::toLower()
        before you insert or lookup a key in the hash.

    \o  The Q3Cache::insert() function returns a \c bool value that
        indicates whether or not the item actually was inserted in
        the cache. If the item wasn't inserted, it was the caller's
        responsibility to delete the item. The new QCache::insert()
        function returns \c void and either adds it to the cache or
        deletes it right away. Old code like

        \code
        if (!cache.insert(key, object))
            delete object;
        \endcode

    becomes

        \code
        cache.insert(key, object);
        \endcode

    \o  The new QCache class \e always takes ownership of the items
        it stores (i.e. auto-delete is always on). If you use Q3Cache
        with auto-delete turned off (the rarely useful default), you
        cannot use QCache as a direct substitute. One unelegant trick
        that works well in practice is to use QCache<QString, T *>
        instead of QCache<QString, T>. In that case, QCache owns the
        pointers, not the objects that the pointers refer to. For
        example,

        \code
            Q3Cache<QWidget> cache;
            cache.insert(widget->name(), widget);
            ...
            QWidget *foo = cache.take("foo");
            if (foo)
                foo->show();
        \endcode

        becomes

        \code
            typedef QWidget *QWidgetPtr;
            QCache<QString, QWidgetPtr> cache;
            cache.insert(widget->name(), new QWidgetPtr(widget));
            ...
            QWidgetPtr *ptr = cache.take("foo");
            if (ptr) {
                QWidget *foo = *ptr;
                delete ptr;
                foo->show();
            }
        \endcode

        An alternative is to stick to using Q3Cache.
    \endlist

    QCacheIterator<T> has been renamed Q3CacheIterator<T> and moved
    to the \l{Qt 3 compatibility library}. The new QCache class
    doesn't offer any iterator types.

    \section1 QCanvas

    The canvas module classes (QCanvas, QCanvasView, QCanvasItem,,
    QCanvasEllipse, QCanvasItemList, QCanvasLine, QCanvasPixmap,
    QCanvasPixmapArray, QCanvasPolygon, QCanvasPolygonalItem,
    QCanvasRectangle, QCanvasSpline, QCanvasSprite, and QCanvasText)
    have been moved to the \l{Qt 3 compatibility library}.

    Qt 4 will provide a replacement module for these classes.

    \omit Fill in when the module is in place. \endomit

    \section1 QColorGroup

    In Qt 3, a QPalette consisted of three QColorGroup objects. In Qt
    4, the (rarely used) QColorGroup abstraction has been eliminated.
    For source compatibility, a QColorGroup class is available when
    \c QT_COMPAT is defined.

    The new QPalette still works in terms of color groups, specified
    through enum values (QPalette::Active, QPalette::Disabled, and
    QPalette::Inactive). It also has the concept of a \e current
    color group, which you can set using
    QPalette::setCurrentColorGroup().

    The QPalette object returned by QWidget::palette() returns a
    QPalette initialized with the correct current color group for the
    widget. This means that if you had code like

    \badcode
        painter.setBrush(colorGroup().brush(QColorGroup::Background));
    \endcode

    you can simply replace colorGroup() with palette():

    \code
        painter.setBrush(palette().brush(QColorGroup::Background));
    \endcode

    \section1 QComboBox

    ###

    See \l{#virtual.functions}{Virtual Functions} for a list of
    QComboBox virtual member functions in Qt 3 that are not longer
    virtual in Qt 4.

    \section1 QCString

    In Qt 3, QCString inherited from QByteArray. The main drawback of
    this approach is that the user had the responsibility of ensuring
    that the string is '\\0'-terminated. Another important issue was
    that conversions between QCString and QByteArray often gave
    confusing results. (See the
    \l{http://doc.trolltech.com/qq/qq05-achtung.html#qcstringisastringofchars}{Achtung!
    Binary and Character Data} article in \e{Qt Quarterly} for an
    overview of the pitfalls.)

    Qt 4 solves that problem by merging the QByteArray and QCString
    classes into one class called QByteArray. Most functions that
    were in QCString previously have been moved to QByteArray. The
    '\\0' issue is handled by having QByteArray allocate one extra
    byte that it always sets to '\\0'. For example:

    \code
        QByteArray ba("Hello");
        ba.size();             // returns 5 (the '\0' is not counted)
        ba.length();           // returns 5
        ba.data()[5];          // returns '\0'
    \endcode

    The \l{Qt 4 compatibility library} contains a class called
    QCString that inherits from the new QByteArray class and that
    extends it to provide an API that is as close to the old QCString
    class as possible. Note that the following functions aren't
    provided by the compatibility QCString class:

    \list
    \o QCString::find(const QRegExp &, int)
    \o QCString::findRev(const QRegExp &, int)
    \o QCString::contains(const QRegExp &)
    \o QCString::replace(const QRegExp &, const char *)
    \endlist

    The following functions have lost their last parameter, which
    specified whether the search was case sensitive or not:

    \list
    \o QByteArray::find(char, int)
    \o QByteArray::find(const char *, int)
    \o QByteArray::findRev(char, int)
    \o QByteArray::findRev(const char *, int)
    \o QByteArray::contains(char)
    \o QByteArray::contains(const char *)
    \endlist

    In both cases, the solution is to convert the QCString to a
    QString and use the corresponding QString functions instead.

    Also be aware that QCString::size() (inherited from QByteArray)
    used to return the size of the character data \e including the
    '\\0'-terminator, whereas the new QByteArray::size() is just a
    synonym for QByteArray::length(). This brings QByteArray
    semantics in line with QString's.

    When porting to Qt 4, occurrences of QCString should be replaced
    with QByteArray or QString. The following table summarizes the
    API differences between the QCString compatibility class and the
    Qt 4 QByteArray and QString classes:

    \table
    \header \o QCString function \o Qt 4 equivalent
    \row \o QCString::QCString(const char *, uint) \o See remark below
    \row \o QCString::QCString(int) \o QByteArray::QByteArray(int, char)
    \row \o QCString::leftJustify() \o QString::leftJustified()
    \row \o QCString::length() \o QByteArray::length() or QByteArray::size() (equivalent)
    \row \o QCString::lower() \o QByteArray::toLower()
    \row \o QCString::rightJustify() \o QString::rightJustified()
    \row \o QCString::setExpand() \o See remark below
    \row \o QCString::simplifyWhiteSpace() \o QByteArray::simplified()
    \row \o QCString::sprintf() \o QString::sprintf()
    \row \o QCString::stripWhiteSpace() \o QByteArray::trimmed()
    \row \o QCString::toDouble() \o QString::toDouble()
    \row \o QCString::toFloat() \o QString::toFloat()
    \row \o QCString::toInt() \o QString::toInt()
    \row \o QCString::toLong() \o QString::toLong()
    \row \o QCString::toShort() \o QString::toShort()
    \row \o QCString::toUInt() \o QString::toUInt()
    \row \o QCString::toULong() \o QString::toULong()
    \row \o QCString::toUShort() \o QString::toUShort()
    \row \o QCString::upper() \o QByteArray::toUpper()
    \endtable

    Remarks:

    \list 1
    \o  QCString(const char *str, uint max) constructs a string of
        length strlen(str) or \e max - 1, whichever is shorter.
        QByteArray(const char *data, int size) constructs a byte
        array containing exactly \e size bytes.

        \oldcode
            QCString str1("Hello", 4);           // "Hel"
            QCString str2("Hello world!", n);
        \newcode
            QByteArray str1("Hello", 3);
            QByteArray str2("Hello world!");
            str2.truncate(n - 1);
        \endcode

    \o  QCString::setExpand(uint index, char ch) has no equivalent in
        Qt 4.

        \oldcode
            QCString str("Hello world");
            str.setExpand(16, '\n');            // "Hello world     \n"
        \newcode
            QCString str("Hello world");
            while (str.size() < 16)
                str += ' ';
            str += '\n';
        \endcode
    \endlist

    Since the old QCString class inherited from QByteArray,
    everything that is said in the \l{#qbytearray.section}{QByteArray
    section} applies for QCString as well.

    \section1 QCustomEvent

    ### QCustomEvent is compat

    ### customEvent() signature

    \section1 QDataBrowser

    The QDataBrowser class has been moved to the \l{Qt 3 compatibility library}.

    See \l{SQL Module} for an overview of the new item SQL classes.

    \section1 QDataPump

    The QDataPump class was used internally in Qt 2.x in conjunction
    with QImageConsumer. It was obsoleted in Qt 3.0. If you use this
    mechanism in your application, contact \l qt-bugs@trolltech.com
    and we will try to find a satisfying substitute.

    \section1 QDataSink

    The QDataSink class was used internally in Qt 2.x in conjunction
    with QImageConsumer. It was obsoleted in Qt 3.0. If you use this
    mechanism in your application, contact \l qt-bugs@trolltech.com
    and we will try to find a satisfying substitute.

    \section1 QDataSource

    The QDataSource class was used internally in Qt 2.x in
    conjunction with QImageConsumer. It was obsoleted in Qt 3.0. If
    you use this mechanism in your application, contact \l
    qt-bugs@trolltech.com and we will try to find a satisfying
    substitute.

    \section1 QDataTable

    The QDataTable class has been moved to the \l{Qt 3 compatibility library}.

    See \l{SQL Module} for an overview of the new item SQL classes.

    \section1 QDataView

    The QDataView class has been moved to the \l{Qt 3 compatibility
    library}.

    See \l{SQL Module} for an overview of the new item SQL classes.

    \section1 QDateEdit

    ###

    See \l{#virtual.functions}{Virtual Functions} for a list of
    QComboBox virtual member functions in Qt 3 that are not longer
    virtual in Qt 4.

    \section1 QDateTimeEditBase

    ###

    \section1 QDateTimeEdit

    ###

    See \l{#virtual.functions}{Virtual Functions} for a list of
    QComboBox virtual member functions in Qt 3 that are not longer
    virtual in Qt 4.

    \section1 QDeepCopy<T>

    The QDeepCopy<T> class in Qt 3 provided a means of ensuring that
    implicitly shared and explicitly shared classes referenced unique
    data. This was necessary because the reference counting in Qt's
    container classes was done in a thread-unsafe manner.

    With Qt 4, QDeepCopy<T> has been moved to the \l{Qt 4
    compatibility library}. Removing it from existing code is
    straightforward.

    \oldcode
        QString str1 = "I am a string";
        QDeepCopy<QString> str2 = str1;
        QString str3 = QDeepCopy<QString>(str2);
    \newcode
        QString str1 = "I am a string";
        QString str2 = str1;
        QString str3 = str2;
    \endcode

    \section1 QDial

    ###

    See \l{#virtual.functions}{Virtual Functions} for a list of
    QComboBox virtual member functions in Qt 3 that are not longer
    virtual in Qt 4.

    See \l{#properties}{Properties} for a list of QDial properties in
    Qt 3 that have changed in Qt 4.

    \section1 QDialog

    ###

    The QDialog::modal property has been renamed QDialog::isModal.

    \target qdict.section
    \section1 QDict<T>

    QDict<T> has been moved to the \l{Qt 3 compatibility library}. It
    has been replaced by the more modern QHash<Key, T> and
    QMultiHash<Key, T> classes.

    When porting old code that uses QDict<T> to Qt 4, there are four
    classes that you can use:

    \table
    \header \o Qt 4 class \o When to use it
    \row \o QMultiHash<QString, T *>
         \o Since QDict<T> is pointer-based and allows duplicate keys, this
            is usually the most straightforward conversion.
    \row \o QMultiHash<QString, T>
         \o If type \c T is an \l{assignable data type}, you can use
            \c T as the value type rather than \c{T *}. This often leads
            to nicer code.
    \row \o QHash<QString, T *>
         \o{1,2} If you don't use duplicate keys, you can use QHash
                 instead of QMultiHash. QMultiHash inherits from
                 QHash.
    \row \o QHash<QString, T>
    \endtable

    The APIs of QDict<T> and QMultiHash<QString, T *> are quite
    similar. The main issue is that QDict supports auto-delete
    whereas QMultiHash doesn't. (See \l{What's Wrong with
    Auto-Delete} for an explanation of why the Qt 4 containers don't
    offer that feature.)

    The following table summarizes the API differences between the
    two classes:

    \table
    \header \o QDict function \o QMultiHash equivalent
    \row \o QDict::QDict(int size, bool caseSensitive) \o See remarks below
    \row \o QDict::autoDelete() \o N/A
    \row \o QDict::count() \o QMultiHash::count() or QMultiHash::size() (equivalent)
    \row \o QDict::find(const QString &) \o QMultiHash::value(const QString &)
    \row \o QDict::remove(const QString &) \o QMultiHash::take(const QString &)
    \row \o QDict::resize(uint) \o QMultiHash::reserve(int)
    \row \o QDict::setAutoDelete() \o See discussion below
    \row \o QDict::size() \o QMultiHash::capacity()
    \row \o QDict::statistics() \o N/A
    \row \o QDict::operator[](const QString &) \o See remark below
    \endtable

    Remarks:

    \list 1
    \o  QDict requires the user to allocate a specific number of
        buckets by passing a prime number (17 by default) to the
        constructor and/or calling QDict::resize() later on. In
        contrast, QMultiHash's hash table automatically grows and
        shrinks as needed, and the constructor doesn't take a prime
        number.

    \o  QDict supportes case-insensitive lookups by passing false as
        second argument to the constructor. This feature has no
        equivalent in QMultiHash. Instead, call QString::toLower()
        before you insert or lookup a key in the hash.

    \o  QDict::size() and QMultiHash::size() have different semantics.
        The former returns the number of buckets in the container, whereas
        the latter returns the number of \e items in the container.

    \o  If there are multiple items with the same key,
        QDict::remove() removes only the most recently inserted item,
        whereas QMultiHash::remove() removes all items that share a
        particular key. To remove only the most recently inserted item,
        call QMultiHash::take().

    \o  QDict has only one [] operator (QDict::operator[]()),
        providing const access to an item's value. QMultiHash also
        has a non-const overload that can be used on the left side of
        the assignment operator. If you use the [] operator on a
        non-const QHash with an unexisting item, QHash will created
        an element and initialize it to be a null pointer. For that
        reason, QDict::operator[] should be converted to
        QMultiHash::value(), not QMultiHash::operator[].

    \endlist

    If you use QDict's auto-delete feature (by calling
    QDict::setAutoDelete(true)), you need to do some more work. You
    have two options: Either you call \c delete yourself whenever you
    remove an item from the container, or you use
    QMultiHash<QString, T> instead of QMultiHash<QString, T *> (i.e.
    store values directly instead of pointers to values). Here, we'll
    see when to call \c delete.

    The following table summarizes the idioms that you need to watch
    out for if you want to call \c delete yourself.

    \table
    \header \o QDict idiom \o QMultiHash idiom
    \row
        \o
        \code
        dict.replace(key, value);
        \endcode
        \o
        \code
        delete hash.take(key);
        hash.insert(key, value);
        \endcode
    \row
        \o
        \code
        dict.remove(key, value);
        \endcode
        \o
        \code
        delete hash.take(key);
        \endcode
    \row
        \o
        \code
        dict.clear();
        \endcode

        (also called from QDict's destructor)

        \o
        \code
        while (!hash.isEmpty()) {
            T *value = *hash.begin();
            dict.erase(hash.begin());
            delete value;
        }
        \endcode

        In 99% of cases, the following idiom also works:

        \code
        qDeleteAll(hash);
        hash.clear();
        \endcode

        However, it may lead to crashes if \c hash is referenced from
        the value type's destructor, because \c hash contains
        dangling pointers until clear() is called.
    \endtable

    Be aware that QDict's destructor automatically calls clear(). If
    you have a QDict data member in a custom class and use the
    auto-delete feature, you will need to call \c delete on all the
    items in the container from your class destructor to avoid a
    memory leak.

    Finally, QDictIterator<T> must also be ported. There are no fewer
    than four iterator classes that can be used as a replacement:
    QHash::const_iterator, QHash::iterator, QHashIterator, and
    QHashMutableIterator. The most straightforward class to use when
    porting is QHashIterator<QString, T *>. The following table
    summarizes the API differences:

    \table
    \header \o QDictIterator functions \o Qt 4 equivalent
    \row \o QDictIterator::count() \o QHash::count() or QHash::size()
    \row \o QDictIterator::current() \o QHashIterator::value()
    \row \o QDictIterator::currentKey() \o QHashIterator::key()
    \row \o QDictIterator::isEmpty() \o QHash::isEmpty()
    \row \o QDictIterator::toFirst() \o QHashIterator::toFront()
    \row \o QDictIterator::operator()() \o QHashIterator::value()
    \row \o QDictIterator::operator*() \o QHashIterator::value()
    \row \o QDictIterator::operator++() \o See remark below
    \endtable

    Be aware that QHashIterator has a different way of iterating than
    QDictIterator. A typical loop with QDictIterator looks like this:

    \code
        QDictIterator<QWidget> i(dict);
        while (i.current() != 0) {
            do_something(i.currentKey(), i.current());
            ++i;
        }
    \endcode

    Here's the equivalent QHashIterator loop:

    \code
        QHashIterator<QString, QWidget *> i(hash);
        while (i.hasNext()) {
            i.next();                   // must come first
            do_something(i.key(), i.value());
        }
    \endcode

    See \l{Java-style iterators} for details.

    \section1 QDir

    The following functions used to have a boolean \c{acceptAbsPath}
    parameter that defaulted to true:

    \list
    \i QDir::filePath()
    \i QDir::absFilePath()
    \i QDir::cd()
    \i QDir::mkdir()
    \i QDir::rmdir()
    \i QDir::remove()
    \i QDir::rename()
    \i QDir::exists()
    \endlist

    In Qt 3, if \c acceptAbsPath is true, a file name starting with
    '/' is be returned without change; if \c acceptAbsPath is false,
    an absolute path is prepended to the file name. For example:

    \table
    \header \i Current directory   \i File name        \i \c acceptAbsPath \i File path
    \row    \i{1,2} /home/tsmith   \i{1,2} index.html  \i true             \i /home/tsmith/index.html
    \row                                               \i false            \i /home/tsmith/index.html
    \row    \i{1,2} /home/tsmith   \i{1,2} /index.html \i true             \i /index.html
    \row                                               \i false            \i /home/tsmith/index.html
    \endtable

    In Qt 4, this parameter is no longer available. If you use it
    in your code, you can check that QDir::isRelativePath() returns
    false instead.

    \oldcode
        QDir dir("/home/tsmith");
        QString path = dir.filePath(fileName, false);
    \newcode
        QDir dir("/home/tsmith");
        QString path;
        if (dir.isRelativePath(fileName))
            path = dir.filePath(fileName);
        else
            path = fileName;        
    \endcode

    QDir::encodedEntryList() has been removed.

    fileInfoList() and drives() now return a QList<QFileInfo> and not a
    QPtrList<QFileInfo> *. Code using these methods will have to be
    adapted.

    See \l{#virtual.functions}{Virtual Functions} for a list of
    QDir virtual member functions in Qt 3 that are not longer
    virtual in Qt 4.

    \section1 QDns

    Qt 3 used its own implementation of the DNS protocol and provided
    a low-level QDns class. Qt 4 uses the system's gethostbyname()
    function from a thread instead.

    The old QDns class has been renamed Q3Dns and moved to the \l{Qt
    3 compatibility library}. The new QDns class has a radically
    different API: It consists of two static functions, both called
    QDns::getHostByName(), one of which is blocking, the other
    non-blocking. See the QDns class documentation for details.

    \section1 QDockArea

    ###

    Q3DockArea

    \section1 QDockWindow

    ###

    Q3DockWindow

    See \l{#virtual.functions}{Virtual Functions} for a list of
    QDockWindow virtual member functions in Qt 3 that are not longer
    virtual in Qt 4.

    \section1 QDropSite

    The QDropSite class has been obsolete ever since Qt 2.0. The only
    thing it does is call QWidget::setAcceptDrops(true).

    \oldcode
    class MyWidget : public QWidget, public QDropSite
    {
    public:
        MyWidget(const QWidget *parent)
            : QWidget(parent), QDropSite(this)
        {
        }
        ...
    }
    \newcode
    class MyWidget : public QWidget
    {
    public:
        MyWidget(const QWidget *parent)
            : QWidget(parent)
        {
            setAcceptDrops(true);
        }
        ...
    }
    \endcode

    \section1 QEditorFactory

    The QEditorFactory class has been moved to the \l{Qt 3
    compatibility library}.

    See \l{SQL Module} for an overview of the new item SQL classes.

    \section1 QEventLoop

    ###

    \section1 QFileDialog

    The QFileDialog class in Qt 4 has been totally rewritten. It
    provides most of the functionality of the old QFileDialog class,
    but with a different API. Some functionality, such as the ability
    to preview files, is expected to be added in a later Qt 4
    release.

    The old QFileDialog, QFileIconProvider, and QFilePreview classes
    has been renamed Q3FileDialog, Q3FileIconProvider, and
    Q3FilePreview and have been moved to the \l{Qt 3 compatibility
    library}. You can use them if you need some functionality not
    provided yet by the new QFileDialog class.

    The following table lists which functions have been renamed or
    removed in Qt 4.

    \table
    \header \o Old function \o Qt 4 equivalent
    \row \o Q3FileDialog::addFilter(const QString &) \o See remark below
    \row \o Q3FileDialog::addLeftWidget(QWidget *) \o N/A
    \row \o Q3FileDialog::addRightWidget(QWidget *) \o N/A
    \row \o Q3FileDialog::addToolButton(QAbstractButton *, bool separator) \o N/A
    \row \o Q3FileDialog::addWidgets(QLabel *, QWidget *, QPushButton *) \o N/A
    \row \o Q3FileDialog::dir() \o QFileDialog::directory()
    \row \o Q3FileDialog::dirPath() \o QFileDialog::directory().path()
    \row \o Q3FileDialog::iconProvider() \o N/A
    \row \o Q3FileDialog::isContentsPreviewEnabled() \o N/A
    \row \o Q3FileDialog::isInfoPreviewEnabled() \o N/A
    \row \o Q3FileDialog::previewMode() \o N/A
    \row \o Q3FileDialog::rereadDir() \o N/A
    \row \o Q3FileDialog::resortDir() \o N/A
    \row \o Q3FileDialog::selectAll(bool) \o N/A
    \row \o Q3FileDialog::setContentsPreview(QWidget *, Q3FilePreview *) \o N/A
    \row \o Q3FileDialog::setContentsPreviewEnabled(bool) \o N/A
    \row \o Q3FileDialog::setDir(const QString &) \o QFileDialog::setDirectory(const QString &)
    \row \o Q3FileDialog::setFilters(const char **) \o Q3FileDialog::setFilters(const QStringList &)
    \row \o Q3FileDialog::setIconProvider(Q3FileIconProvider *) \o N/A
    \row \o Q3FileDialog::setInfoPreview(QWidget *, Q3FilePreview *) \o N/A
    \row \o Q3FileDialog::setInfoPreviewEnabled(bool) \o N/A
    \row \o Q3FileDialog::setPreviewMode(PreviewMode) \o N/A
    \row \o Q3FileDialog::setSelectedFilter(const QString &) \o QFileDialog::selectFilter(const QString &)
    \row \o Q3FileDialog::setSelectedFilter(int) \o See remark below
    \row \o Q3FileDialog::setSelection(const QString &) \o QFileDialog::selectFile(const QString &)
    \row \o Q3FileDialog::setShowHiddenFiles(bool) \o showHidden()
    \row \o Q3FileDialog::setUrl(const QUrlOperator &) \o N/A
    \row \o Q3FileDialog::showHiddenFiles() \o N/A
    \row \o Q3FileDialog::url() \o QUrl::fromLocalFile(QFileDialog::directory())
    \header \o Old signals \o Qt 4 equivalent
    \row \o Q3FileDialog::fileHighlighted(const QString &) \o N/A
    \row \o Q3FileDialog::fileSelected(const QString &) \o QFileDialog::filesSelected(const QStringList &)
    \row \o Q3FileDialog::dirEntered(const QString &) \o N/A
    \row \o Q3FileDialog::filterSelected(const QString &) \o N/A
    \endtable

    Remarks:

    \list 1
    \o  The Q3FileDialog::addFilter(const QString &) function has no
        direct equivalent in the new QFileDialog. Use
        QFileDialog::setFilters() instead.

        \oldcode
        fileDialog->addFilter(tr("JPEG files (*.jpg *.jpeg)"));
        \newcode
        QStringList filters = fileDialog->filters();
        filters << tr("JPEG files (*.jpg *.jpeg)");
        fileDialog->setFilters(filters);
        \endcode

    \o  The Q3FileDialog::setSelectedFilter(int) overload has no direct
        equivalent in the new QFileDialog. Use
        QFileDialog::selectFilter(const QString &) instead.

        \oldcode
        fileDialog->setSelectedFilter(3);
        \newcode
        fileDialog->selectFilter(fileDialog->filters().at(3));
        \endcode
    \endlist

    See \l{#virtual.functions}{Virtual Functions} for a list of
    QFileDialog virtual member functions in Qt 3 that are not longer
    virtual in Qt 4.

    \section1 QFrame

    The QFrame class has been made more lightweight in Qt 4, by
    reducing the number of properties and virtual functions. The
    reduction in the number of virtual functions is significant
    because QFrame is the base class of many Qt classes.

    Here's an overview of the changes:

    \list
    \o  QFrame no longer has a \c margin property (which wasn't
        honored by Qt's layout managers anyway).
    \o  QFrame used to have drawFrame(QPainter *),
        drawContents(QPainter *), and frameChanged() virtual
        functions. These are now gone. If you want to change the way
        QFrame paints itself, reimplement QFrame:paintEvent().
    \endlist

    As an help to porting, the \l{Qt 3 compatibility library}
    contains a Q3Frame class that inherits QFrame and provides a
    similar API to the old QFrame class. If you derived from QFrame
    in your application, you might want to use Q3Frame as a base
    class as a first step in the porting process, and later move on
    to the new QFrame class.

    See \l{#virtual.functions}{Virtual Functions} for a list of
    QFrame virtual member functions in Qt 3 that are not longer
    virtual in Qt 4.

    \section1 QFtp

    This class no longer inherits from QNetworkProtocol. See the
    \l{#qnetworkprotocol.section}{section on QNetworkProtocol} for
    details.

    \target qglayoutiterator.section
    \section1 QGLayoutIterator

    The QGLayoutIterator class no longer exists in Qt 4. This makes
    only a difference if you implemented custom layout managers
    (i.e., QLayout subclasses).

    The new approach is much simpler: It consists in reimplementing
    QLayout::itemAt() and QLayout::takeAt(). These functions operate
    on indexes, eliminating the need for a layout iterator class.

    \section1 QGrid

    The QGrid class has been renamed QGridWidget.

    \section1 QGridLayout

    See \l{#virtual.functions}{Virtual Functions} for a list of
    QGridLayout virtual member functions in Qt 3 that are not longer
    virtual in Qt 4.

\omit
    \section1 QGridView

    ###
\endomit

    \target qgroubox.section
    \section1 QGroupBox

    The QGroupBox class has been redesigned in Qt 4. The old QGroupBox
    class has been renamed Q3GroupBox and moved to the \l{Qt 3
    compatibility library}.

    The new QGroupBox is more lightweight. It doesn't attempt to
    duplicate functionality already provided by QGridLayout. For that
    reason, the following members have been removed:

    \list
    \o Q3GroupBox::setColumns(), Q3GroupBox::columns()
    \o Q3GroupBox::setOrientation(), Q3GroupBox::orientation()
    \o Q3GroupBox::setInsideMargin(), Q3GroupBox::insideMargin()
    \o Q3GroupBox::addSpace()
    \endlist

    Naturally, the \c columns and \c orientation properties have also
    been removed.

    If you rely on some of the missing functionality in your
    application, you can use Q3GroupBox instead of QGroupBox as a
    help to porting.

    See \l{#virtual.functions}{Virtual Functions} for a list of
    QGroupBox virtual member functions in Qt 3 that are not longer
    virtual in Qt 4.

    \section1 QHBox

    The QHBox class has been renamed QHBoxWidget.

\omit
    \section1 QHeader

    ###

    Q3Header
\endomit

    \section1 QHttp

    This class no longer inherits from QNetworkProtocol. See the See
    the \l{#qnetworkprotocol.section}{section on QNetworkProtocol} for
    details.

    \section1 QIconFactory

    The QIconFactory is no longer part of Qt. It has been replaced by
    a lighter mechanism based on function pointers.

    To port old code that uses QIconFactory to Qt 4, you generally
    need to turn your QIconFactory::createPixmap() reimplementation
    into a regular function and call QIconSet::setPixmapGeneratorFn()
    or QIconSet::setDefaultPixmapGeneratorFn() on it.

    \section1 QIconView

    The QIconView, QIconViewItem, QIconDrag, QIconDragItem classes
    has been moved to the \l{Qt 3 compatibility library}. New Qt
    applications should use QListWidget or its base class QListView
    instead, and call QListView::setViewMode(QListView::IconMode) to
    obtain an "icon view" look.

    See \l{Model-View Programming} for an overview of the new item
    view classes.

    \section1 QImage

    QImage::fromMimeSource(const QString &) -> qImageFromMimeSource(const QString &)

    \section1 QIntCache<T>

    QIntCache<T> has been moved to the \l{Qt 3 compatibility
    library}. It has been replaced by QCache<int, T>.

    For details, read the \l{#qcache.section}{section on QCache<T>},
    mentally substituting \c int for QString.

    \section1 QIntDict<T>

    QIntDict<T> and QIntDictIterator<T> have been moved to the \l{Qt
    3 compatibility library}. They have been replaced by the more
    modern QHash<Key, T> and QMultiHash<Key, T> classes and their
    associated iterator classes.

    When porting old code that uses QIntDict<T> to Qt 4, there are
    four classes that you can use:

    \list
    \o QMultiHash<int, T *>
    \o QMultiHash<int, T *>
    \o QHash<int, T>
    \o QHash<int, T>
    \endlist

    For details, read the \l{#qdict.section}{section on QDict<T>},
    mentally substituting \c int for QString.

    \target qiodevice.section
    \section1 QIODevice

    The QIODevice class's API has been simplified to make it easier
    to subclass and to make it work more nicely with asynchronous
    devices such as QTcpSocket and QProcess.

    The following virtual functions have changed name or signature:

    \table
    \header \o Qt 3 function \o Comment
    \row \o QIODevice::at() const \o Renamed QIODevice::pos().
    \row \o QIODevice::at(Offset) \o Renamed QIODevice::seek().
    \row \o QIODevice::open(int) \o The parameter is now of type QIODevice::OpenMode.
    \row \o QIODevice::readBlock(char *, Q_ULONG) \o QIODevice::readData(char *, Q_LONGLONG)
    \row \o QIODevice::writeBlock(const char *, Q_ULONG) \o QIODevice::writeData(const char *, Q_LONGLONG)
    \endtable

    The following functions are no longer virtual or don't exist anymore:

    \table
    \row \o QIODevice::getch() \o Renamed QIODevice::getChar() and implemented in terms of QIODevice::readData().
    \row \o QIODevice::putch(int) \o Renamed QIODevice::putChar() and implemented in terms of QIODevice::writeData().
    \row \o QIODevice::readAll() \o Implemented in terms of QIODevice::readData().
    \row \o QIODevice::readLine(char *, Q_ULONG) \o Implemented in terms of QIODevice::readData()
    \row \o QIODevice::ungetch(int) \o Renamed QIODevice::ungetChar() and simulated using an internal unget buffer.
    \endtable

    The \c IO_xxx flags have been revised. Most of them have been
    elimiated, because errors are best handled by the actual
    QIODevice subclasses than through the base classes. The file
    access flags, such as \c IO_ReadOnly and \c IO_WriteOnly, have
    been moved to the QIODevice class to avoid polluting the global
    namespace. The table below shows the correspondence between the
    Qt 3 \c IO_xxx flags and the Qt 4 API:

    \table
    \header \o Qt 3 constant \o Qt 4 equivalent
    \row \o IO_Direct \o Use !QIODevice::isSequential() instead (notice the \e not).
    \row \o IO_Sequential \o Use QIODevice::isSequential() instead.
    \row \o IO_Combined \o N/A
    \row \o IO_TypeMask \o N/A
    \row \o IO_Raw \o N/A
    \row \o IO_Async \o N/A
    \row \o IO_ReadOnly \o QIODevice::ReadOnly
    \row \o IO_WriteOnly \o QIODevice::WriteOnly
    \row \o IO_ReadWrite \o QIODevice::ReadWrite
    \row \o IO_Append \o QIODevice::Append
    \row \o IO_Truncate \o QIODevice::Truncate
    \row \o IO_Translate \o QIODevice::Translate
    \row \o IO_ModeMask \o N/A
    \row \o IO_Open \o Use QIODevice::isOpen() instead.
    \row \o IO_StateMask \o N/A
    \row \o IO_Ok \o N/A
    \row \o IO_ReadError \o N/A
    \row \o IO_WriteError \o N/A
    \row \o IO_FatalError \o N/A
    \row \o IO_ResourceError \o N/A
    \row \o IO_OpenError \o N/A
    \row \o IO_ConnectError \o N/A
    \row \o IO_AbortError \o N/A
    \row \o IO_TimeOutError \o N/A
    \row \o IO_UnspecifiedError \o N/A
    \endtable

    \section1 QIODeviceSource

    The QIODeviceSource class was used internally in Qt 2.x in
    conjunction with QImageConsumer. It was obsoleted in Qt 3.0. If
    you use this mechanism in your application, contact \l
    qt-bugs@trolltech.com and we will try to find a satisfying
    substitute.

    \section1 QIconFactory

    The QIconFactory class is no longer part of the Qt API. It has
    been replaced by a "pixmap generator function" mechanism; see
    QIcon::setPixmapGeneratorFn() for details.

    \section1 QLabel

    See \l{#virtual.functions}{Virtual Functions} for a list of
    QLabel virtual member functions in Qt 3 that are not longer
    virtual in Qt 4.

    \section1 QLayout

    QLayout setSupportsMargin()

    See also the \l{#qlayoutiterator.section}{section on
    QLayoutIterator} and the \l{#qglayoutiterator.section}{section on
    QGLayoutIterator}.

    \target qlayoutiterator.section
    \section1 QLayoutIterator

    The QLayoutIterator class is obsoleted in Qt 4. It is available
    only if \c QT_COMPAT is defined. It can be replaced by the
    QLayout::itemAt() and QLayout::takeAt() functions, which operate
    on indexes.

    \oldcode
        QLayoutIterator it = layout()->iterator();
        QLayoutItem *child;
        while ((child = it.current()) != 0) {
            if (child->widget() == myWidget) {
                it.takeCurrent();
                return;
            ++it;
        }
    \newcode
        int i = 0;
        QLayoutItem *child;
        while ((child = layout()->itemAt(i)) != 0) {
            if (child->widget() == myWidget) {
                layout()->takeAt(i);
                return;
            }
            ++i;
        }
    \endcode

    \section1 QLineEdit

    See \l{#properties}{Properties} for a list of QLineEdit
    properties in Qt 3 that have changed in Qt 4.

    \section1 QListBox

    The QListBox, QListBoxItem, QListBoxText, and QListBoxPixmap
    classes have been moved to the \l{Qt 3 compatibility library}.
    New Qt applications should use QListWidget or its base class
    QListView instead.

    See \l{Model-View Programming} for an overview of the new item
    view classes.

    \section1 QListView

    The QListView, QListViewItem, QCheckListItem, and
    QListViewItemIterator classes have been renamed Q3ListView,
    Q3ListViewItem, Q3CheckListItem, and Q3ListViewItemIterator, and
    have been moved to the \l{Qt 3 compatibility library}. New Qt
    applications should use one of the following four classes
    instead: QTreeView or QTreeWidget for tree-like structures;
    QListWidget or the new QListView class for one-dimensional lists.

    See \l{Model-View Programming} for an overview of the new item
    view classes.

    \section1 QLocalFs

    The QLocalFs class is no longer part of the public Qt API. It has
    been moved to the \l{Qt 3 compatibility library}. Use QDir,
    QFileInfo, or QFile instead.

\omit
    \section1 QMainWindow

    ###

    Q3MainWindow
\endomit

    \section1 QMemArray<T>

    QMemArray<T> has been moved to the \l{Qt 3 compatibility
    library}. It has been replaced by the QVector<T> class.

    The following table summarizes the API differences between the
    two classes.

    \table
    \row \o QMemArray::assign(const QMemArray<T> &) \o QVector::operator=()
    \row \o QMemArray::assign(const T *, uint) \o See remark below
    \row \o QMemArray::duplicate(const QMemArray &) \o QVector::operator=()
    \row \o QMemArray::duplicate(const T *, uint) \o See remark below
    \row \o QMemArray::setRawData(const T *, uint) \o N/A
    \row \o QMemArray::resetRawData(const T *, uint) \o N/A
    \row \o QMemArray::find(const T &, uint) \o QVector::indexOf(const T &, int)
    \row \o QMemArray::contains(const T &) \o QVector::count(const T &)
    \row \o QMemArray::sort() \o \l qHeapSort()
    \row \o QMemArray::bsearch(const T &d) \o \l qBinaryFind()
    \row \o QMemArray::at(uint) \o QVector::operator[]()
    \row \o QMemArray::operator const T *() \o QVector::constData()
    \endtable

    Remarks:

    \list 1
    \o  QMemArray::assign(const T *, uint) and QMemArray::duplicate(const T *, uint)
        can be replaced by QVector::resize() and qCopy().

        \oldcode
        QMemArray<QSize> array;
        ...
        array.assign(data, size);
        \newcode
        QVector<QSize> vector;
        ...
        vector.resize(size);
        qCopy(data, data + size, vector.begin());
        \endcode

    \o  QMemArray is an explicitly shared class, whereas QVector is
        implicitly shared. See \l{Explicit Sharing} for more
        information.
    \endlist

    \section1 QMenuBar

    ### Used to inherit from QFrame and QMenuData; now inherits from QWidget

    \section1 QMenuData

    ###

    \section1 QMessageBox

    The QMessageBox::iconPixmap() function used to return a "const
    QPixmap *". In Qt 4, it returns a QPixmap.

    \section1 QMimeSourceFactory

    The QMimeSourceFactory has been moved to the \l{Qt 3
    compatibility library}. New Qt applications should use Qt 4's
    \l{Resource System} instead.

    \section1 QMultiLineEdit

    The QMultiLineEdit class in Qt 3 was a convenience QTextEdit
    subclass that provided an interface compatible with Qt 2's
    QMultiLineEdit class. In Qt 4, it inherits Q3TextEdit and is part
    of the \l{Qt 3 compatibility library}. Use QTextEdit in new code.

    \target qnetworkprotocol.section
    \section1 QNetworkProtocol

    The QNetworkProtocol, QNetworkProtocolFactoryBase,
    QNetworkProtocolFactory<T>, and QNetworkOperation classes are no
    longer part of the public Qt API. They have been moved to the
    \l{Qt 3 compatibility library}.

    In Qt 4 applications, you can use classes like QFtp and QHttp
    directly to perform file-related actions on a remote host.

    \section1 QObject

    children() and QueryList now return a QObjectList instead of a pointer
    to a QObjectList. See also the comments on QObjectList.

    killTimers() has been removed. ###

    The QObject::name property has been renamed QObject::objectName.

    \section1 QObjectDictionary

    The QObjectDictionary class is a synonym for
    QAsciiDict<QMetaObject>. See the \l{#qasciidict.section}{section
    on QAsciiDict<T>}.

    \section1 QObjectList

    In Qt 3, the QObjectList class was a typedef for
    QPtrList<QObject>. In Qt 4, it is a typedef for QList<QObject *>.
    See the \l{#qptrlist.section}{section on QPtrList<T>}.

    \section1 QPaintDevice

    To reimplement painter backends one previously needed to reimplement
    the virtual function QPaintDevice::cmd(). This function is taken out
    and should is replaced with the function QPaintDevice::paintEngine()
    and the abstract class QPaintEngine. QPaintEngine provides virtual
    functions for all drawing operations that can be performed on a
    painter backend.

    bitBlt and copyBlt are now only compatibility functions. Use QPainter
    and drawPixmap instead.

    \section1 QPicture

    Probably something needs to be said about new stuff from painting? Don't know, I didn't do that part.

    QPicture::copy() is deprecated and QPicture::detach() is now a public internal
    function. In general, one should have never needed to call these functions.

    \section1 QPixmap

    QPixmap::fromMimeSource(const QString &) -> qPixmapFromMimeSource(const QString &)

    \section1 QPointArray

    In Qt 3, QPointArray inherited from QMemArray<QPoint>. In Qt 4,
    it inherits from QVector<QPoint>. Everything mentioned in the
    \l{#qmemarray.section}{section on QMemArray<T>} apply for
    QPointArray as well.

    The QPointArray::setPoints() and QPointArray::putPoints()
    functions returned a bool in Qt 3, indicating whether the array
    was successfully resized or not. In Qt 4, they return void.

\omit
    X11 Specific:

    ::appDisplay() -> QX11Info::display()
    QPaintDevice::x11Display() -> QX11Info::display()
    QPaintDevice::x11AppDisplay() -> QX11Info::display()
    QPaintDevice::x11Screen() -> QX11Info::appScreen()
    QPaintDevice::x11AppScreen() -> ???
    QPaintDevice::x11Depth() -> QX11Info::appDepth()
    QPaintDevice::x11ColorMap() -> QX11Info::appColorMap()
    QPaintDevice::x11DefaultColorMap() -> ???
    QPaintDevice::x11Visual() -> QX11Info::appVisual()
    QPaintDevice::x11DefaultVisual() -> ???

    QPaintDevice::x11AppDpiX() -> QX11Info::appDpiX()
    QPaintDevice::x11AppDpiY() -> QX11Info::appDpiY()
    QPaintDevice::x11SetAppDpiX() -> QX11Info::setAppDpiX()
    QPaintDevice::x11SetAppDpiY() -> QX11Info::setAppDpiY()

    QPaintDevice::x11AppDepth() -> ???
    QPaintDevice::x11AppCells() -> ???
    QPaintDevice::x11AppRootWindow() -> ???
    QPaintDevice::x11AppColorMap() -> ???
    QPaintDevice::x11AppDefaultColorMap() -> ???
    QPaintDevice::x11AppVisual() -> ???
    QPaintDevice::x11AppDefaultVisual() -> ???

    End of X11 Specific
\endomit

\omit
    \section1 QPopupMenu

    ###
\endomit

    \section1 QPrinter

    page setup / print setup -> Use QPrintDialog, QPageSetupDialog
    Compat functions: margins
    Killed -> setMargins

    \section1 QProgressDialog

    See \l{#properties}{Properties} for a list of QProgressDialog
    properties in Qt 3 that have changed in Qt 4.

    \section1 QPtrCollection<T>

    The QPtrCollection<T> abstract base class has been moved to the
    \l{Qt 3 compatibility library}. There is no direct equivalent in
    Qt 4.

    \section1 QPtrDict<T>

    QPtrDict<T> and QPtrDictIterator<T> have been moved to the \l{Qt
    3 compatibility library}. They have been replaced by the more
    modern QHash<Key, T> and QMultiHash<Key, T> classes and their
    associated iterator classes.

    When porting old code that uses QPtrDict<T> to Qt 4, there are
    four classes that you can use:

    \list
    \o QMultiHash<void *, T *>
    \o QMultiHash<void *, T *>
    \o QHash<void *, T>
    \o QHash<void *, T>
    \endlist

    (You can naturally use other types than \c{void *} for the key
    type, e.g. \c{QWidget *}.)

    To port QPtrDict<T> to Qt 4, read the \l{#qdict.section}{section
    on QDict<T>}, mentally substituting \c{void *} for QString.

    \target qptrlist.section
    \section1 QPtrList<T>

    QPtrList<T>, QPtrListIterator<T>, and QPtrListStdIterator<T> have
    been moved to the \l{Qt 3 compatibility library}. They have been
    replaced by the more modern QList and QLinkedList classes and
    their associated iterator classes.

    When porting to Qt 4, you have the choice of using QList<T> or
    QLinkedList<T> as alternatives to QValueList<T>. QList<T> has an
    index-based API and provides very fast random access
    (QList::operator[]), whereas QLinkedList<T> has an iterator-based
    API.

    The following table summarizes the API differences between
    QPtrList<T> and QList<T *>:

    \table
    \header \o QPtrList function \o QList equivalent
    \row \o QPtrList::contains(const T *) \o QList::count(T *)
    \row \o QPtrList::containsRef(const T *) \o QList::count(T *)
    \row \o QPtrList::find(const T *) \o See remark below
    \row \o QPtrList::findRef(const T *) \o See remark below
    \row \o QPtrList::getFirst() \o QList::first()
    \row \o QPtrList::getLast() \o QList::last()
    \row \o QPtrList::inSort(const T *) \o N/A
    \row \o QPtrList::remove(const T *) \o QList::removeAll(T *)
    \row \o QPtrList::remove(uint) \o QList::removeAt(int)
    \row \o QPtrList::removeNode(QLNode *) \o N/A
    \row \o QPtrList::removeRef(const T *) \o QList::removeAll(T *)
    \row \o QPtrList::sort() \o See remark below
    \row \o QPtrList::takeNode(QLNode *) \o N/A
    \row \o QPtrList::toVector(QGVector *) \o See remark below
    \endtable

    Remarks:

    \list 1
    \o  QPtrList::toVector(QGVector *) can be replaced by
        QVector::resize() and qCopy().

        \oldcode
        QPtrList<QWidget> list;
        ...
        QPtrVector<QWidget> vector;
        list.toVector(&vector);
        \newcode
        QList<QWidget *> list;
        ...
        QVector<QWidget *> vector;
        vector.resize(list.size());
        qCopy(list.begin(), list.end(), vector.begin());
        \endcode

    \o  QPtrList::sort() relied on the virtual comparedItems() to
        sort items. In Qt 4, you can use qHeapSort() instead and pass
        your "compare item" function as an argument.

    \o  QPtrList::find(const T *) returns an iterator, whereas
        QList::indexOf(T *) returns an index. To convert an index
        into an iterator, add the index to QList::begin().

    \o  QPtrList::removeFirst() and QPtrList::removeLast() return a \c
        bool that indicates whether the element was removed or not.
        The corresponding QList functions return \c void. You can
        achieve the same result by calling QList::isEmpty() before
        attempting to remove an item.
    \endlist

    If you use QPtrList's auto-delete feature (by calling
    QPtrList::setAutoDelete(true)), you need to do some more work.
    You have two options: Either you call \c delete yourself whenever
    you remove an item from the container, or you can use QList<T>
    instead of QList<T *> (i.e. store values directly instead of
    pointers to values). Here, we'll see when to call \c delete. (See
    \l{What's Wrong with Auto-Delete} for an explanation of why the
    Qt 4 containers don't offer that feature.)

    The following table summarizes the idioms that you need to watch
    out for if you want to call \c delete yourself.

    \table
    \header \o QPtrList idiom \o QList idiom
    \row
        \o
        \code
        list.replace(index, value);
        \endcode
        \o
        \code
        delete list[index];
        list[index] = value;
        \endcode
    \row
        \o
        \code
        list.removeFirst();
        \endcode
        \o
        \code
        delete list.takeFirst();
        \endcode
    \row
        \o
        \code
        list.removeLast();
        \endcode
        \o
        \code
        delete list.takeLast();
        \endcode
    \row
        \o
        \code
        list.remove(index);
        \endcode
        \o
        \code
        delete list.take(index);
        \endcode
    \row
        \o
        \code
        list.remove(value);
        \endcode
        \o
        \code
        int i = list.indexOf(value);
        if (i != -1)
            delete list.takeAt(i);
        \endcode
    \row
        \o
        \code
        list.remove();
        \endcode
        (removes the current item)

        \o
        \code
        QListMutableIterator<T *> i;
        ...
        delete i.value();
        i.remove();
        \endcode
    \row
        \o
        \code
        list.clear();
        \endcode

        (also called from QPtrList's destructor)

        \o
        \code
        while (!list.isEmpty())
            delete list.takeFirst();
        \endcode

        In 99% of cases, the following idiom also works:

        \code
        qDeleteAll(list);
        list.clear();
        \endcode

        However, it may lead to crashes if \c list is referenced from
        the value type's destructor, because \c list contains
        dangling pointers until clear() is called.
    \endtable

    Be aware that QPtrList's destructor automatically calls clear().
    If you have a QPtrList data member in a custom class and use the
    auto-delete feature, you will need to call \c delete on all the
    items in the container from your class destructor to avoid a
    memory leak.

    QPtrList had the concept of a "current item", which could be used
    for traversing the list without using an iterator. When porting
    to Qt 4, you can use the Java-style QListIterator<T *> (or
    QListMutableIterator<T *>) class instead. The following table
    summarizes the API differences:

    \table
    \header \o QPtrList function \o QListIterator equivalent
    \row \o QPtrList::at() \o N/A
    \row \o QPtrList::current() \o QListIterator::value()
    \row \o QPtrList::currentNode() \o N/A
    \row \o QPtrList::findNext(const T *) \o QListIterator::findNext(const T *)
    \row \o QPtrList::findNextRef(const T *) \o QListIterator::findNext(const T *)
    \row \o QPtrList::first() \o QPtrList::toFront()
    \row \o QPtrList::last() \o QPtrList::toBack()
    \row \o QPtrList::next() \o QPtrList::next()
    \row \o QPtrList::prev() \o QPtrList::previous()
    \row \o QPtrList::remove() \o QListMutableIterator::remove()
    \row \o QPtrList::take() \o QListMutableIterator::remove()
    \endtable

    Be aware that QListIterator has a different way of iterating than
    QPtrList. A typical loop with QPtrList looks like this:

    \code
        QPtrList<QWidget> list;
        ...
        while (list.current() != 0) {
            do_something(list.current());
            list.next();
        }
    \endcode

    Here's the equivalent QListIterator loop:

    \code
        QList<QWidget *> list;
        ...
        QListIterator<QWidget *> i(list);
        while (i.hasNext())
            do_something(i.next());
    \endcode

    Finally, QPtrListIterator<T> must also be ported. There are no
    fewer than four iterator classes that can be used as a
    replacement: QList::const_iterator, QList::iterator,
    QListIterator, and QListMutableIterator. The most straightforward
    class to use when porting is QListMutableIterator<T *> (if you
    modify the list through the iterator) or QListIterator<T *> (if
    you don't). The following table summarizes the API differences:

    \table
    \header \o QPtrListIterator function \o Qt 4 equivalent
    \row \o QPtrListIterator::atFirst() \o !QListIterator::hasPrevious() (notice the \c{!})
    \row \o QPtrListIterator::atLast() \o !QListIterator::hasNext() (notice the \c{!})
    \row \o QPtrListIterator::count() \o QList::count() or QList::size()
    \row \o QPtrListIterator::current() \o QListIterator::value()
    \row \o QPtrListIterator::isEmpty() \o QList::isEmpty()
    \row \o QPtrListIterator::toFirst() \o QListIterator::toFront()
    \row \o QPtrListIterator::toLast() \o QListIterator::toBack()
    \row \o QPtrListIterator::operator() \o QListIterator::value()
    \row \o QPtrListIterator::operator*() \o QListIterator::value()
    \endtable

    Again, be aware that QListIterator has a different way of
    iterating than QPtrList. A typical loop with QPtrList looks like
    this:

    \code
        QPtrList<QWidget> list;
        ...
        QPtrListIterator<QWidget> i;
        while (i.current() != 0) {
            do_something(i.current());
            i.next();
        }
    \endcode

    Here's the equivalent QListIterator loop:

    \code
        QList<QWidget *> list;
        ...
        QListIterator<QWidget *> i(list);
        while (i.hasNext())
            do_something(i.next());
    \endcode

    Finally, QPtrListStdIterator<T> must also be ported. This is
    easy, because QList also provides STL-style iterators
    (QList::iterator and QList::const_iterator).

    \section1 QPtrQueue<T>

    QPtrQueue has been moved to the \l{Qt 3 compatibility library}.
    It has been replaced by the more modern QQueue class.

    The following table summarizes the differences between
    QPtrQueue<T> and QQueue<T *>:

    \table
    \header \o QPtrQueue function \o QQueue equivalent
    \row \o QPtrQueue::autoDelete() \o See discussion below
    \row \o QPtrQueue::count() \o QQueue::count() or QQueue::size() (equivalent)
    \row \o QPtrQueue::current() \o QQueue::head()
    \row \o QPtrQueue::remove() \o QQueue::dequeue()
    \row \o QPtrQueue::setAutoDelete() \o See discussion below
    \endtable

    If you use QPtrQueue's auto-delete feature (by calling
    QPtrQueue::setAutoDelete(true)), you need to do some more work.
    You have two options: Either you call \c delete yourself whenever
    you remove an item from the container, or you can use QQueue<T>
    instead of QQueue<T *> (i.e. store values directly instead of
    pointers to values). Here, we will show when to call \c delete.
    (See \l{What's Wrong with Auto-Delete} for an explanation of why
    the Qt 4 containers don't offer that feature.)

    \table
    \header \o QPtrQueue idiom \o QQueue idiom
    \row
        \o
        \code
        queue.dequeue();
        \endcode
        \o
        \code
        delete queue.dequeue();
        \endcode
    \row
        \o
        \code
        queue.remove();
        \endcode
        \o
        \code
        delete queue.dequeue();
        \endcode
    \row
        \o
        \code
        queue.clear();
        \endcode

        (also called from QPtrQueue's destructor)

        \o
        \code
        while (!queue.isEmpty())
            delete queue.dequeue();
        \endcode

        In 99% of cases, the following idiom also works:

        \code
        qDeleteAll(queue);
        queue.clear();
        \endcode

        However, it may lead to crashes if \c queue is referenced
        from the value type's destructor, because \c queue contains
        dangling pointers until clear() is called.
    \endtable

    \section1 QPtrStack<T>

    QPtrStack has been moved to the \l{Qt 3 compatibility library}.
    It has been replaced by the more modern QStack class.

    The following table summarizes the differences between
    QPtrStack<T> and QStack<T *>:

    \table
    \header \o QPtrStack function \o QStack equivalent
    \row \o QPtrStack::autoDelete() \o See discussion below
    \row \o QPtrStack::count() \o QStack::count() or QStack::size() (equivalent)
    \row \o QPtrStack::current() \o QStack::top()
    \row \o QPtrStack::remove() \o QStack::pop()
    \row \o QPtrStack::setAutoDelete() \o See discussion below
    \endtable

    If you use QPtrStack's auto-delete feature (by calling
    QPtrStack::setAutoDelete(true)), you need to do some more work.
    You have two options: Either you call \c delete yourself whenever
    you remove an item from the container, or you can use QStack<T>
    instead of QStack<T *> (i.e. store values directly instead of
    pointers to values). Here, we will show when to call \c delete.
    (See \l{What's Wrong with Auto-Delete} for an explanation of why
    the Qt 4 containers don't offer that feature.)

    \table
    \header \o QPtrStack idiom \o QStack idiom
    \row
        \o
        \code
        stack.pop();
        \endcode
        \o
        \code
        delete stack.pop();
        \endcode
    \row
        \o
        \code
        stack.remove();
        \endcode
        \o
        \code
        delete stack.pop();
        \endcode
    \row
        \o
        \code
        stack.clear();
        \endcode

        (also called from QPtrStack's destructor)

        \o
        \code
        while (!stack.isEmpty())
            delete stack.pop();
        \endcode

        In 99% of cases, the following idiom also works:

        \code
        qDeleteAll(stack);
        stack.clear();
        \endcode

        However, it may lead to crashes if \c stack is referenced
        from the value type's destructor, because \c stack contains
        dangling pointers until clear() is called.
    \endtable

    \section1 QPtrVector<T>

    QPtrVector<T> has been moved to the \l{Qt 3 compatibility
    library}. It has been replaced by the more modern QVector class.

    When porting to Qt 4, you can use QVector<T *> as an alternative
    to QPtrVector<T>. The APIs of QPtrVector<T> and QVector<T *> are
    somewhat similar. The main issue is that QPtrVector supports
    auto-delete whereas QVector doesn't. (See \l{What's Wrong with
    Auto-Delete} for an explanation of why the Qt 4 containers don't
    offer that feature.)

    The following table summarizes the API differences between the
    two classes:

    \table
    \header \o QPtrVector function \o QVector equivalent
    \row \o QPtrVector::autoDelete() \o See discussion below
    \row \o QPtrVector::bsearch(const T *) \o qBinaryFind()
    \row \o QPtrVector::contains(const T *) \o QVector::count(T *)
    \row \o QPtrVector::containsRef(const T *) \o QVector::count(T *)
    \row \o QPtrVector::count() \o See remark below
    \row \o QPtrVector::insert(uint, T *) \o See remark below
    \row \o QPtrVector::isNull() \o N/A
    \row \o QPtrVector::remove(uint) \o See remark below
    \row \o QPtrVector::setAutoDelete() \o See discussion below
    \row \o QPtrVector::sort() \o qHeapSort()
    \row \o QPtrVector::take(uint) \o See remark below
    \row \o QPtrVector::toList(QGList *) \o QList::QList(const QVector &)
    \endtable

    Remarks:

    \list 1
    \o  QPtrVector::insert(uint, T *) sets an item to store a certain
        pointer value. This is \e not the same as QVector::insert(int, T *),
        which creates space for the item by moving following items by
        one position. Use \c{vect[i] = ptr} to set a QVector item to
        a particular value.
    \o  QPtrVector::remove(uint) sets an item to be 0. This is \e not
        the same as QVector::removeAt(int), which entirely erases the
        item, reducing the size of the vector. Use \c{vect[i] = 0} to
        set a QVector item to 0.
    \o  Likewise, QPtrVector::take(uint) sets an item to be 0 and
        returns the previous value of the item. Again, this is easy to
        achieve using QVector::operator[]().
    \o  QPtrVector::count() returns the number of non-null items in
        the vector, whereas QVector::count() (like QVector::size())
        returns the number of items (null or non-null) in the vector.
        Fortunately, it's not too hard to simulate QPtrVector::count().

        \oldcode
        int numValidItems = vect.count();
        \newcode
        int numValidItems = vect.size() - vect.count(0);
        \endcode
    \endlist

    If you use QVector's auto-delete feature (by calling
    QVector::setAutoDelete(true)), you need to do some more work. You
    have two options: Either you call \c delete yourself whenever you
    remove an item from the container, or you use QVector<T> instead
    of QVector<T *> (i.e. store values directly instead of pointers
    to values). Here, we'll see when to call \c delete.

    The following table summarizes the idioms that you need to watch
    out for if you want to call \c delete yourself.

    \table
    \header \o QPtrVector idiom \o QVector idiom
    \row
        \o
        \code
        vect.insert(i, ptr);
        \endcode
        \o
        \code
        delete vect[i];
        vect[i] = ptr;
        \endcode
    \row
        \o
        \code
        vect.remove(i);
        \endcode
        \o
        \code
        delete vect[i];
        vect[i] = 0;
        \endcode
    \row
        \o
        \code
        T *ptr = vect.take(i);
        \endcode
        \o
        \code
        T *ptr = vect[i];
        vect[i] = 0;
        \endcode
    \row
        \o
        \code
        vect.resize(n)
        \endcode
        \o
        \code
        while (n > vect.size())
            vect.append(0);
        while (n < vect.size() {
            T *ptr = vect.last();
            vect.remove(vect.size() - 1);
            delete ptr;
        }
        \endcode
    \row
        \o
        \code
        vect.clear();
        \endcode

        (also called from QPtrVector's destructor)

        \o
        \code
        for (int i = 0; i < vect.size(); ++i)
            T *ptr = vect[i];
            vect[i] = 0;
            delete ptr;
        }
        \endcode

        In 99% of cases, the following idiom also works:

        \code
        qDeleteAll(vect);
        vect.clear();
        \endcode

        However, it may lead to crashes if \c vect is referenced from
        the value type's destructor, because \c vect contains
        dangling pointers until clear() is called.
    \endtable

    Be aware that QPtrVector's destructor automatically calls
    clear(). If you have a QPtrVector data member in a custom class
    and use the auto-delete feature, you will need to call \c delete
    on all the items in the container from your class destructor to
    avoid a memory leak.

    \section1 QPushButton

    See \l{#properties}{Properties} for a list of QPushButton
    properties in Qt 3 that have changed in Qt 4.

    \section1 QRangeControl

    In Qt 3, various "range control" widgets (QDial, QScrollBar,
    QSlider, and QSpinBox) inherited from both QWidget and
    QRangeControl.

    In Qt 4, QRangeControl has been replaced with the new
    QAbstractSlider class, which inherits from QWidget and provides
    similar functionality. Apart from eliminating unnecessary
    multiple inheritance, the new design allows QAbstractSlider to
    contain signals, slots, and properties.

    The old QRangeControl class has been moved to the \l{Qt 3
    compatibility library}, together with the (undocumented)
    QSpinWidget class.

    If you use QRangeControl as a base class in your application, you
    can switch to use QAbstractSlider instead.

    \oldcode
        class VolumeControl : public QWidget, public QRangeControl
        {
            ...
        protected:
            void valueChange() {
                update();
                emit valueChanged(value());
            }
            void rangeChange() {
                update();
            }
            void stepChange() {
                update();
            }
        };
    \newcode
        class VolumeControl : public QAbstractSlider
        {
            ...
        protected:
            void sliderChange(SliderChange change) {
                update();
                if (change == SliderValueChange)
                    emit valueChanged(value());
            }
        };
    \endcode

    \section1 QRegion

    The following changes have been made to QRegion in Qt 4:

    \list
    \o  There is no longer any difference between a \e null region and
        an \e empty region. Use isEmpty() in most places where you
        would have used a null QRegion.
    \o  QRegion::rects() used to return a QMemArray<QRect>. It now returns
        a QVector<QRect>.
    \endlist

    \section1 QScrollBar

    See \l{#properties}{Properties} for a list of QScrollBar
    properties in Qt 3 that have changed in Qt 4.

    \section1 QScrollView

    The QScrollView class has been moved to the \l{Qt 3 compatibility
    library}. It has been replaced by the QViewport and QWidgetView
    classes.

    QScrollView was designed to work around the 16-bit limitation on
    widget coordinates found on most window systems. In Qt 4, this is
    done transparently for \e all widgets, so there is no longer a
    need for such functionality in QScrollView. For that reason, the
    new QViewport and QWidgetView classes are much more lightweight,
    and concentrate on handling scroll bars.

    If you used QScrollView as a base class

    \section1 QShared

    The QShared class has been obsoleted by the more powerful
    QSharedData and QSharedDataPointer as a means of creating custom
    implicitly shared classes. It has been moved to the \l{Qt 3
    compatibility library}.

    An easy way of porting to Qt 4 is to include this class into your
    project and to use it instead of QShared:

    \code
        struct Shared
        {
            Shared() : count(1) {}
            void ref() { ++count; }
            bool deref() { return !--count; }
            uint count;
        };
    \endcode

    If possible, we recommend that you use QSharedData and
    QSharedDataPointer instead. They provide thread-safe reference
    counting and handle all the reference counting behind the scenes,
    eliminating the risks of forgetting to increment or decrement the
    reference count.

    \section1 QSignal

    The QSignal class has been completely redesigned in Qt 4. For
    compatibility, the old QSignal class has been renamed Q3Signal
    and has been moved to the \l{Qt 3 compatibility library}.

    The new QSignal class is a template class, where the template
    type gives the parameter type of the signal. For example, if you
    used Q3Signal class's @C{intSignal(int)} signal, you can now use
    QSignal<int>'s @C{signal(int)} signal instead.

    The Q3Signal::setParameter(), Q3Signal::parameter(),
    Q3Signal::setValue(), and Q3Signal::value() functions have no
    direct equivalent in Qt 4. Instead, pass the value to
    QSignal::activate().

    \oldcode
        QSignal signal;
        signal.connect(target, SLOT(display(int)));
        ...
        signal.setParameter(5);
        signal.activate();
    \newcode
        QSignal<int> signal;
        signal.connect(target, SLOT(display(int)));
        ...
        signal.activate(5);
    \endcode

\omit
    \section1 QSimpleRichText

    The QSimpleRichText class has been moved to the \l{Qt 3
    compatibility library}.

    ###
\endomit

    \section1 QSlider

    The QSlider::sliderStart() and QSlider::sliderRect() functons
    have been removed. You can retrieve this information using
    QAbstractSlider::sliderPosition() and
    QStyle::querySubControlMetrics(), respectively.

    See \l{#properties}{Properties} for a list of QSlider properties
    in Qt 3 that have changed in Qt 4.

    \section1 QSortedList

    The QSortedList<T> class has been deprecated since Qt 3.0. In Qt
    4, it has been moved to the \l{Qt 3 compatibility library}.

    In new code, we recommend that you use QList<T> instead and use
    \l{qHeapSort()} to sort the items.

    \section1 QSplitter

    The function setResizeMode() has been moved into compat. Set the stretch factor
    in the widget's size policy to get equivalent functionality.

    The obsolete function drawSplitter() has been removed. Use
    QStyle::drawPrimitive() to acheive similar functionality.

    \section1 QSpinBox

    See \l{#properties}{Properties} for a list of QSpinBox properties
    in Qt 3 that have changed in Qt 4.

    \section1 QSqlCursor

    The QSqlCursor class has been moved to the \l{Qt 3 compatibility
    library}.

    See \l{SQL Module} for an overview of the new item SQL classes.

    \section1 QSqlDatabase

    QSqlDatabase is now a smart pointer that is passed around by value. Simply replace all QSqlDatabase
    pointer by QSqlDatabase objects.

    \section1 QSqlEditorFactory

    The QSqlEditorFactory class has been moved to the \l{Qt 3
    compatibility library}.

    See \l{SQL Module} for an overview of the new item SQL classes.

    \section1 QSqlError

    The enum \c{Type} was renamed to \c{ErrorType}, The values were renamed as well:

    \list
    \o None - use NoError instead
    \o Connection - use ConnectionError instead
    \o Statement - use StatementError instead
    \o Transaction - use TransactionError instead
    \o Unknown - use UnknownError instead
    \endlist

    \section1 QSqlFieldInfo

    The QSqlFieldInfo class has been moved to the \l{Qt 3
    compatibility library}. Its functionality is now provided by the
    QSqlField class.

    See \l{SQL Module} for an overview of the new item SQL classes.

    \section1 QSqlForm

    The QSqlForm class has been moved to the \l{Qt 3 compatibility
    library}.

    See \l{SQL Module} for an overview of the new item SQL classes.

    \section1 QSqlPropertyMap

    The QSqlPropertyMap class has been moved to the \l{Qt 3
    compatibility library}.

    See \l{SQL Module} for an overview of the new item SQL classes.

    \section1 QSqlQuery

    QSqlQuery::prev() was renamed to QSqlQuery::previous(). There is
    a function call for compatibility, but if you subclassed QSqlQuery,
    you have to reimplement previous() instead of prev().

    \section1 QSqlRecord

    QSqlRecord behaves like a vector now, QSqlRecord::insert() will
    actually insert a new field instead of replacing the existing
    one.

    \section1 QSqlRecordInfo

    The QSqlRecordInfo class has been moved to the \l{Qt 3
    compatibility library}. Its functionality is now provided by the
    QSqlRecord class.

    See \l{SQL Module} for an overview of the new item SQL classes.

    \section1 QSqlSelectCursor

    The QSqlSelectCursor class has been moved to the \l{Qt 3
    compatibility library}.

    See \l{SQL Module} for an overview of the new item SQL classes.

    \section1 QStr(I)List

    The QStrList and QStrIList convenience classes have been
    deprecated since Qt 2.0. In Qt 4, they have been moved to the
    \l{Qt 3 compatibility library}. If you used any of these, we
    recommend that you use QStringList or QList<QByteArray> instead.

    \section1 QStr(I)Vec

    The QStrVec and QStrIVec convenience classes have been deprecated
    since Qt 2.0. In Qt 4, they have been moved to the \l{Qt 3
    compatibility library}. If you used any of these, we recommend
    that you use QStringList or QList<QByteArray> instead.

    \section1 QString

    Here are the main issues to be aware of when porting QString to
    Qt 4:

    \list 1
    \o  The QString::QString(QChar) constructor performed implicit
        conversion in Qt 3. Now, you will need a cast to convert a
        QChar to a QString.

    \o  The QString::QString(const QByteArray &) constructor used to
        stop at the first '\\0' it encountered, for compatibility
        with Qt 1. This quirk has now been fixed; in Qt 4, the
        resulting QString always has the same length as the
        QByteArray that was passed to the constructor.

    \o  The QString::null static constant has been deprecated in Qt
        4. For compatibility, Qt 4 provides a QString::null symbol
        that behaves more or less the same as the old constant. The
        new idiom is to write QString() instead of QString::null, or
        to call clear().

        \oldcode
            str1 = QString::null;
            if (str2 == QString::null)
                do_something(QString::null);
        \newcode
            str1.clear();
            if (str2.isNull())
                do_something(QString());
        \endcode

    \o  QString::at() returned a non-const reference, whereas the
        new QString::at() returns a const value. Code like

        \code
        str.at(0) = 'X';
        \endcode

        will no longer compile. Instead, use QString::operator[]:

        \code
        str[0] = 'X';
        \endcode

    \o  The QString::contains(\e x) function (where \e x is a
        character or a string) has been renamed QString::count(\e x).
        In addition, there now exists a set of QString::contains()
        functions that returns a boolean value. Replace old calls to
        contains() with either count() or contains(), depending on
        whether you care about the specific number of occurrences of
        a character in the string or only care about whether the
        string contains that character or not.

    \o  Many functions in QString had a \c bool parameter that
        specified case sensitivity. In Qt 4, in the interest of code
        readability and maintainability, the \c bool parameters have
        been replaced by the Qt::CaseSensitivity enum, which can take
        the values Qt::CaseSensitive and Qt::CaseInsensitive.

        \oldcode
            if (url.startsWith("http:", false))
                ...
        \newcode
            if (url.startsWith("http:", Qt::CaseInsensitive))
                ...
        \endcode

    \o  The QString::setExpand(uint, QChar) function, which already
        was obsolete in Qt 3, is no longer available. Use
        QString::operator[] instead.

        \oldcode
            str.setExpand(32, '$');
        \newcode
            str[32] = '$';
        \endcode

    \o  The \c QT_NO_ASCII_CAST and \c QT_NO_CAST_ASCII macros have
        been renamed \c QT_NO_CAST_TO_ASCII and \c
        QT_NO_CAST_FROM_ASCII, respectively.

    \o  QString::ascii() and QString::latin1() now
        return "" (the empty string) rather than 0 (the null
        pointer). The new behavior prevents crashes when interfacing
        with the standard C++ library.

    \o  QString::utf8() and QString::local8Bit() used to return a
        QByteArray. They now return a \c{const char *}, to be
        consistent with QString::ascii() and QString::latin1(). Call
        QString::toUtf8() or QString::toLocal8Bit() if you want a
        QByteArray.

    \o  The QString::data() used to return the same as
        QString::ascii(). It now returns a pointer to the Unicode
        data stored in the QString object. Call QString::ascii() if
        you want the old behavior.

    \o  QString::simpleText() has been renamed
        QString::isSimpleText().

    \endlist

    \section1 QStringList

    QStringList now inherits from QList<QString> and can no longer be
    converted to a QValueList<QString>. Since QValueList inherits QList a
    cast will work as expected.

    This change implies some API incompatibilities for QStringList.
    For example, at() returns the string, not an iterator. See the
    \l{#qvaluelist.section}{section on QValueList} for details.

\omit
    \section1 QStyleSheet

    The QStyleSheet and QStyleSheetItem classes have been moved to
    the \l{Qt 3 compatibility library}.

    ###
\endomit

\omit
    \section1 QSyntaxHighlighter

    The QSyntaxHighlighter class has been moved to the \l{Qt 3
    compatibility library}.

    ###
\endomit

    \section1 QTabBar

    See \l{#properties}{Properties} for a list of QTabBar properties
    in Qt 3 that have changed in Qt 4.

    \section1 QTabDialog

    The QTabDialog class is no longer part of the public Qt API. It
    has been moved to the \l{Qt 3 compatibility library}. In Qt 4
    applications, you can easily obtain the same result by combining
    a QTabWidget with a QDialog and provide \l{QPushButton}s
    yourself.

    \omit Point to the tabdialog example when the example is ready. \endomit

    \section1 QTabWidget

    See \l{#properties}{Properties} for a list of QTabWidget
    properties in Qt 3 that have changed in Qt 4.

    \section1 QTable

    The QTable, QTableItem, QComboTableItem, QCheckTableItem, and
    QTableSelection classes have been moved to the \l{Qt 3
    compatibility library}. New Qt applications should use the new
    QTableWidget or QTableView class instead.

    See \l{Model-View Programming} for an overview of the new item
    view classes.

\omit
    \section1 QTextBrowser

    The QTextBrowser class has been moved to the \l{Qt 3
    compatibility library}.

    ###
\endomit

\omit
    \section1 QTextEdit

    The old QTextEdit has been renamed Q3TextEdit and moved to the
    \l{Qt 3 compatibility library}.

    To port to the new QTextEdit class, ###
\endomit

    \section1 QTextOStreamIterator

    The undocumented QTextOStreamIterator class has been removed from
    the Qt library. If you need it in your application, feel free to
    copy the source code from the Qt 3 \c <qtl.h> header file.

    \section1 QTextView

    The QTextView class has been moved to the \l{Qt 3 compatibility
    library}.

    ###

    \section1 QTimeEdit

    ###

    \section1 QToolBar

    ###

    Q3ToolBar

    \section1 QToolButton

    See \l{#properties}{Properties} for a list of QToolBar properties
    in Qt 3 that have changed in Qt 4.

    \section1 QUrl

    The QUrl class has been rewritten from scratch in Qt 4 to be more
    standard-compliant. The old QUrl class has been renamed Q3Url and
    moved to the \l{Qt 3 compatibility library}.

    The new QUrl class provides an extensive list of compatibility
    functions to ease porting from Q3Url to QUrl. A few functions
    require you to change your code:

    \list
    \o Q3Url::Q3Url(const Q3Url &, const QString &, bool) can be
       simulated by combining the URLs manually (using
       QString::operator+(), for example).
    \o Q3Url::setEncodedPathAndQuery(const QString &) is replaced by
       QUrl::setPath() and QUrl::setEncodedQuery().
    \o Q3Url::encodedPathAndQuery() is replaced by QUrl::path() and
       QUrl::encodedQuery().
    \o Q3Url::isLocalFile() can be simulated by checking that
       QUrl::protocol() is "file".
    \o Q3Url::toString(bool, bool) is replaced by
       QUrl::toString(int), where the \c int parameter specifies a
       combination of \l{QUrl::FormattingOptions}{formatting
       options}.
    \endlist

    \section1 QUrlOperator

    The QUrlOperator class is no longer part of the public Qt API. It
    has been moved to the \l{Qt 3 compatibility library}.

    In Qt 4 applications, you can use classes like QFtp and QHttp
    directly to perform file-related actions on a remote host.

    \target qvaluelist.section
    \section1 QValueList<T>

    The QValueList<T> class has been replaced by QList<T> and
    QLinkedList<T> in Qt 4. As a help when porting older Qt
    applications, the \l{Qt 3 compatibility library} contains a
    QValueList<T> class implemented in terms of the new
    QLinkedList<T>. Similarly, it contains QValueListIterator<T> and
    QValueListConstIterator<T> classes implemented in terms of
    QLinkedList<T>::iterator and QLinkedList<T>::const_iterator.

    When porting to Qt 4, you have the choice of using QList<T> or
    QLinkedList<T> as alternatives to QValueList<T>. QList<T> has an
    index-based API and provides very fast random access
    (QList::operator[]), whereas QLinkedList<T> has an iterator-based
    API.

    Here's a list of problem functions:

    \list
    \o  QValueList(const std::list<T> &) doesn't exist in QList or
        QLinkedList. You can simulate it by calling
        \l{QLinkedList::append()}{append()} in a loop.

    \o  QValueList::insert(iterator, size_type, const T& x) doesn't
        exist in QList or QLinkedList. Call
        \l{QLinkedList::insert()}{insert()} repeatedly instead.

    \o  QValueList::fromLast() doesn't exist in QList or QLinkedList. Use
        QValueList::end() instead.

        \oldcode
        for (QValueList<T>::iterator i = list.fromLast(); i != list.end(); ++i)
            do_something(*i);
        \newcode
        QLinkedList<T>::iterator i = list.end();
        while (i != list.begin()) {
            --i; // decrement i before using it
            do_something(*i);
        }
        \endcode

    \o  QValueList::append() and QValueList::prepend() return an
        iterator to the inserted item. QList's and QLinkedList's
        corresponding functions don't, but it's not a problem because
        QValueList::prepend() always returns begin() and append()
        always returns QValueList::end() - 1.

    \o  QValueList::at(\e i) return an iterator to the item at index
        \e i. This corresponds to QList::begin() + \e i.

    \o  QValueList::contains(const T &) corresponds to
        QList::count(const T &) and QLinkedList::count(const T &).
    \endlist

    \section1 QValueVector<T>

    The QValueVector<T> class has been replaced by QVector<T> in Qt
    4. As a help when porting older Qt applications, the \l{Qt 3
    compatibility library} contains a QValueVector<T> class
    implemented in terms of the new QVector<T>.

    When porting from QValueVector<T> to QVector<T>, you might run
    into the following incompatibilities:

    \list
    \o QValueVector(const std::vector<T> &) doesn't exist in QVector.
       You can simulate it by calling QVector::append()} in a loop.
    \o QValueVector::resize(int, const T &) doesn't exist in QVector.
       If you want the new items to be initialized with a particular
       value, use QVector::insert() instead.
    \o QValueVector::at() on a non-const vector returns a non-const
       reference. This corresponds to QVector::operator[]().
    \o Both QValueVector::at() functions have an \e ok parameter of
       type \c{bool *} that is set to true if the index is within
       bounds. This functionality doesn't exist in QVector; instead,
       check the index against QVector::size() yourself.
    \endlist

    See \l{Generic Containers} for an overview of the Qt 4 container
    classes.

    \section1 QVariant

    The QVariant class has been split into two classes: QCoreVariant
    and QVariant. The new QVariant class inherits QCoreVariant and
    adds GUI-related types. In practice, this has no consequences for
    existing Qt applications.

    In addition, some changes to the rest of the Qt library have
    implications on QVariant as well:

    \list 1
    \o The \c QCoreVariant::ColorGroup enum value is defined only
       if \c QT_COMPAT is defined.
    \o The \c QCoreVariant::IconSet enum value has been renamed
       \c QCoreVariant::Icon.
    \o The \c QCoreVariant::CString enum value is now a synonym for
       \c QCoreVariant::ByteArray.
    \endlist

    \section1 QVBox

    The QVBox class has been renamed QVBoxWidget.

\omit
    \section1 QWhatsThis

    ###

    Q3WhatsThis
\endomit


    \section1 QWidget

    Widget background painting has been greatly improved, supporting
    flickerfree updates and making it possible to have half
    transparent widgets. This renders the following background
    handling functions obsolete:

    \list
    \o QWidget::repaint(bool noErase) - the \c noErase boolean parameter is gone
    \o QWidget::setBackgroundMode(BackgroundMode m)
    \o QWidget::backgroundBrush() const
    \o QWidget::setBackgroundPixmap(const QPixmap &pm)
    \o QWidget::backgroundPixmap() const
    \o QWidget::setBackgroundColor(const QColor &c)
    \o QWidget::backgroundColor() const
    \o QWidget::foregroundColor() const
    \o QWidget::eraseColor() const
    \o QWidget::setEraseColor(const QColor &c)
    \o QWidget::erasePixmap() const
    \o QWidget::setErasePixmap(const QPixmap &p)
    \o QWidget::paletteForegroundColor()
    \o QWidget::setPaletteForegroundColor(const QColor &c)
    \o QWidget::paletteBackgroundColor()
    \o QWidget::setPaletteBackgroundColor(const QColor &c)
    \o QWidget::paletteBackgroundPixmap() const
    \o QWidget::setPaletteBackgroundPixmap(const QPixmap &p)
    \o QWidget::erase()
    \o QWidget::erase(const QRect &r)
    \o QWidget::setBackgroundOrigin( BackgroundOrigin )
    \o QWidget::BackgroundOrigin backgroundOrigin() const
    \o QWidget::backgroundOffset()
    \endlist

    A widget now receives change events in its QWidget::changeEvent()
    handler. This makes the following virtual change handlers obsolete:

    \list
    \o QWidget::styleChange - use QEvent::StyleChange
    \o QWidget::enabledChange - use QEvent::EnabledChange
    \o QWidget::paletteChange - use QEvent::PaletteChange
    \o QWidget::fontChange - use QEvent::FontChange
    \o QWidget::windowActivationChange - use QEvent::ActivationChange
    \o QWidget::languageChange - use QEvent::LanguageChange
    \endlist

    The following functions were slots, but are no more:
    \list
    \o QWidget::clearFocus()
    \o QWidget::setMouseTracking()
    \o QWidget::stackUnder(QWidget*)
    \o QWidget::move(int x, int y)
    \o QWidget::move(const QPoint &)
    \o QWidget::resize(int w, int h)
    \o QWidget::resize(const QSize &)
    \o QWidget::setGeometry(int x, int y, int w, int h)
    \o QWidget::setGeometry(const QRect &)
    \o QWidget::adjustSize()
    \o QWidget::update(int x, int y, int w, int h)
    \o QWidget::update(const QRect&)
    \o QWidget::repaint(bool erase)
    \o QWidget::repaint(int x, int y, int w, int h, bool erase)
    \o QWidget::repaint(const QRect &, bool erase)
    \o QWidget::repaint(const QRegion &, bool erase)
    \o QWidget::setCaption(const QString &)
    \o QWidget::setIcon(const QPixmap &)
    \o QWidget::setIconText(const QString &)
    \endlist

    The following functions were incorrectly marked as virtual:

    \list
    \o QWidget::close(bool alsoDelete)
    \o QWidget::create(WId, bool, bool)
    \o QWidget::destroy(bool)
    \o QWidget::move(int x, int y)
    \o QWidget::reparent(QWidget *parent, WFlags, const QPoint &, bool)
    \o QWidget::resize(int w, int h)
    \o QWidget::setAcceptDrops(bool on)
    \o QWidget::setActiveWindow()
    \o QWidget::setAutoMask(bool)
    \o QWidget::setBackgroundColor(const QColor &)
    \o QWidget::setBackgroundMode(BackgroundMode)
    \o QWidget::setBackgroundOrigin(BackgroundOrigin)
    \o QWidget::setBackgroundPixmap(const QPixmap &)
    \o QWidget::setCaption(const QString &)
    \o QWidget::setCursor(const QCursor &)
    \o QWidget::setEnabled(bool)
    \o QWidget::setEraseColor(const QColor &)
    \o QWidget::setErasePixmap(const QPixmap &)
    \o QWidget::setFocus()
    \o QWidget::setFocusPolicy(FocusPolicy)
    \o QWidget::setFocusProxy(QWidget *)
    \o QWidget::setFont(const QFont &)
    \o QWidget::setGeometry(const QRect &)
    \o QWidget::setGeometry(int x, int y, int w, int h)
    \o QWidget::setIcon(const QPixmap &)
    \o QWidget::setIconText(const QString &)
    \o QWidget::setKeyCompression(bool)
    \o QWidget::setMask(const QBitmap &)
    \o QWidget::setMask(const QRegion &)
    \o QWidget::setMaximumSize(int maxw, int maxh)
    \o QWidget::setMicroFocusHint(int x, int y, int w, int h, bool, QFont *f)
    \o QWidget::setMinimumSize(int minw, int minh)
    \o QWidget::setMouseTracking(bool enable)
    \o QWidget::setPalette(const QPalette &)
    \o QWidget::setPaletteBackgroundColor(const QColor &)
    \o QWidget::setPaletteBackgroundPixmap(const QPixmap &)
    \o QWidget::setSizeIncrement(int w, int h)
    \o QWidget::setSizePolicy(QSizePolicy)
    \o QWidget::setUpdatesEnabled(bool enable)
    \o QWidget::setWFlags(WFlags)
    \o QWidget::setWState(uint)
    \o QWidget::showFullScreen()
    \o QWidget::showMaximized()
    \o QWidget::showMinimized()
    \o QWidget::showNormal()
    \o QWidget::unsetCursor()
    \endlist

    See \l{#properties}{Properties} for a list of QWidget properties
    in Qt 3 that have changed in Qt 4.

    \section1 QWidgetIntDict

    The QWidgetIntDict class was a synonym for QIntDict<QWidget>. It
    is no longer available in Qt 4. If you link against the \l{Qt 3
    compatibility library}, you can use QIntDict<QWidget> instead;
    otherwise, see the \l{#qdict.section}{section on QDict<T>}.

    \target qwidgetlist.section
    \section1 QWidgetList

    In Qt 3, the QWidgetList class was a typedef for
    QPtrList<QWidget>. In Qt 4, it is a typedef for QList<QWidget *>.
    See the \l{#qptrlist.section}{section on QPtrList<T>}.

    \section1 QWidgetStack

    ###

    The QWidgetStack class is no longer part of the Qt public API. It
    has been moved to the \l{Qt 3 compatibility library}.

    In Qt 4 applications, you can use QStackedWidget instead to
    obtain the same results.

    \section1 QWizard

    The QWizard class is no longer part of the Qt public API. It has
    been moved to the \l{Qt 3 compatibility library}. In Qt 4
    applications, you can easily obtain the same result by combining
    a QStackedBox with a QDialog and provide \l{QPushButton}s
    yourself.

    The dialogs/simplewizard and dialogs/complexwizard examples show
    how to create wizards without using QWizard.

    \target virtual.functions
    \section1 Virtual Functions

    Virtual functions that changed their signature in Qt 4:

    \table
    \header \o Qt 3 function signature \o Qt 4 function signature
    \input porting4-modifiedvirtual.qdocinc
    \endtable

    Virtual functions that are not virtual anymore in Qt 4:

    \table
    \header \o Qt 3 function \o Comment
    \input porting4-removedvirtual.qdocinc
    \endtable

*/

#if 0
/*! \page auto-delete.html
    \title What's Wrong with Auto-Delete?

    ###
*/
#endif
