/****************************************************************************
**
** Copyright (C) 1992-$THISYEAR$ Trolltech AS. All rights reserved.
**
** This file is part of the Qt GUI Toolkit.
** EDITIONS: FREE, PROFESSIONAL, ENTERPRISE
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
****************************************************************************/

/*!
    \page porting.html

    \title Porting to Qt 4

    This document describes porting applications from Qt 3 to Qt 4.

    ### How to port from Qt 2.3 to Qt 4.

    If you haven't yet made the decision about porting, or are unsure
    about whether it is worth it, take a look at the \link
    tech-preview.html key features\endlink offered by Qt 4.

    The Qt 4 series is not binary compatible with the 3 series. This
    means programs compiled for Qt 3 must be recompiled to work with
    Qt 4. Qt 4 is also not completely \e source compatible with 3,
    however nearly all points of incompatibility cause compiler
    errors or run-time messages (rather than mysterious results). Qt
    4 includes many additional features and discards obsolete
    functionality. Porting from Qt 3 to Qt 4 is straightforward, and
    once completed makes the considerable additional power and
    flexibility of Qt 4 available for use in your applications.

    To port code from Qt 3 to Qt 4:

    \list 1

    \i Briefly read the porting notes below to get an idea of what to expect.

    \i Be sure that your code compiles and runs well on all your target
       platforms with Qt 3, with QT_NO_COMPAT defined.

    \i Recompile with Qt 4. For each error, search below for related
       identifiers (e.g. function names, class names). This document
       mentions all relevant identifiers to help you get the information
       you need at the cost of being a little verbose.

    \i If you get stuck, ask on the \link http://qt-interest.trolltech.com/
       qt-interest \endlink mailing list, or Trolltech Technical Support if
       you're a registered licensee.

    \endlist

    ### what to do with slots that aren't slots anymore
    ### what to do with virtual functions that aren't virtual anymore
    ### what to do with virtual functions that changed signature

    ### <qtl.h> -- stuff that vanished?
    ### implicit sharing
    ### uint -> int indexes

    Table of contents:

    \tableofcontents{4}

    \section1 Header Files

    ### New style of headers

    \table
    \header \i Old header \i New header
    \row \i \c{<qtl.h>} \i \c{<qalgorithms.h>} or \c{<QtAlgorithms>}
    \endtable

    ### Some headers don't include each other anymore...

    \section1 Global Functions

    \table
    \header \i Qt 3 function \i Qt 4 equivalent
    \row \i cstrcmp() \i strcmp()
    \row \i cstrcpy() \i strcpy()
    \row \i cstrlen() \i strlen()
    \row \i cstrncmp() \i strncmp()
    \row \i qmemmove() \i memmove()
    \endtable

    qGLVersion() ###

    copyBlt() ###
    bitBlt()

    #ifdef compat classes:
        * QLayoutIterator
        * QColorGroup
        * QMenuItem

    QWidget visibleRect property \compat
    QWidget::BackgroundOrigin \compat

    \section1 Enum Values

    ###

    \section1 Null vs. Empty

    ###

    \section1 Explicit Sharing

    Qt 4 is the first version of Qt that contains no \link
    http://doc.trolltech.com/3.3/shclass.html explicitly shared
    \endlink classes. All classes that were explicitly shared in Qt 3
    are \e implicitly shared in Qt 4: 

    \list
    \i QImage
    \i QMovie
    \i QBitArray
    \i QByteArray
    \i QPointArray
    \endlist

    This means that if you took a copy of an instance of the class
    (using operator=() or the class's copy constructor), any
    modification to the copy would affect the original and vice
    versa. Needless to say, this behavior is rarely desirable.

    Fortunately, nearly all Qt 3 applications don't rely on explicit
    sharing. When porting, you typically only need to remove calls to
    detach() and/or copy(), which aren't necessary anymore.

    If you deliberately rely on explicit sharing in your application,
    you can use pointers or references to achieve the same result in
    Qt 4.

    \oldcode
        void asciify(QByteArray array)
        {
            for (int i = 0; i < (int)array.size(); ++i) {
                if ((uchar)array[i] >= 128)
                    array[i] = '?';
            }
        }
    \newcode
        void asciify(QByteArray &array)
        {
            for (int i = 0; i < (int)array.size(); ++i) {
                if ((uchar)array[i] >= 128)
                    array[i] = '?';
            }
        }
    \endcode

    (Notice the \c & in the parameter declaration.)

    \section1 QAccel

    The QAccel class has been moved to the \l{Qt 3 compatibility
    library}. In new applications, you have three options:

    \list 1
    \i You can use QAction and set a key sequence using QAction::setShortcut().
    \i You can use QShortcut, a class that provides similar
       functionality to QAccel.
    \i You can use QWidget::grabShortcut() and process "shortcut"
       events by reimplementing QWidget::event().
    \endlist

    ### Explain how to deal with multi-item QAccels

    \section1 QAction

    ###

    Q3Action, Q3ActionGroup

    \section1 QApplication

    The following functions are obsolete. Most will continue to work in
    COMPAT mode, but we recommend not using them in new code.

    \list
    \i QApplication::hasGlobalMouseTracking() - use true instead.
    \i QApplication::setGlobalMouseTracking() - no effect.
    \i QApplication::setFont() - the \c informAllWidgets boolean parameter is gone.
    \i QApplication::setPalette() - the \c informAllWidgets boolean parameter is gone.
    \i QApplication::widgetAt() - the \c child boolean parameter
       is gone. The function always returns the exact widget at a given position.
       Use QWidget::topLevelWidget() to obtain this widgets's top level widget (the window).
    \endlist

    Both allWidgets() and topLevelWidgets() return a QWidgetList (it was a
    pointer to a QWidgetList in Qt3). This resolves some memory management
    issues using these methods.

    \section1 QAsciiCache<T>

    QAsciiCache<T> has been moved to the \l{Qt 3 compatibility
    library}. It has been replaced by QCache<QByteArray, T>.

    For details, read the \l{#qcache.section}{section on QCache<T>},
    mentally substituting QByteArray for QString.

    \section1 QAsciiDict<T>

    QAsciiDict<T> and QAsciiDictIterator<T> have been moved to the
    \l{Qt 3 compatibility library}. They have been replaced by the
    more modern QHash<Key, T> and QMultiHash<Key, T> classes and
    their associated iterator classes.

    When porting old code that uses QAsciiDict<T> to Qt 4, there are
    four classes that you can use:

    \list
    \i QMultiHash<QByteArray, T *>
    \i QMultiHash<QByteArray, T *>
    \i QHash<QByteArray, T>
    \i QHash<QByteArray, T>
    \endlist

    For details, read the \l{#qdict.section}{section on QDict<T>},
    mentally substituting QByteArray for QString.

    \section1 QBitArray

    In Qt 3, QBitArray inherited from QByteArray. In Qt 4, QBitArray
    is a totally independent class. This makes very little difference
    to the user, except that the new QBitArray doesn't provide any of
    QByteArray's byte-based API anymore. These calls will result in a
    compile-time error, except calls to QBitArray::truncate(), whose
    parameter was a number of \e bytes in Qt 3 and a number of bits
    in Qt 4.

    QBitArray was an explicitly shared class in Qt 3. See \l{Explicit
    Sharing} for more information.

    The QBitVal class has been renamed QBitRef.

    \section1 QButton

    The QButton class has been replaced by QAbstractButton in Qt 4.
    Classes like QPushButton and QRadioButton inherit from
    QAbstractButton. As a help when porting older Qt applications,
    the \l{Qt 3 compatibility library} contains a QButton class
    implemented in terms of the new QAbstractButton.

    If you used the QButton class as a base class for your own button
    type and want to port your code to the newer QAbstractButton, you
    need to be aware that QAbstractButton has no equivalent for the
    QButton::drawButton(QPainter *) and
    QButton::drawButtonLable(QPainter *) virtual functions. The
    solution is to reimplement QWidget::paintEvent() in your
    QAbstractButton subclass as follows:

    \code
        void MyButton::paintEvent(QPaintEvent *)
        {
            QPainter painter(this);
            drawButton(&painter);
        }
    \endcode

    \section1 QButtonGroup

    ### QButtonGroup, QHButtonGroup, QVButtonGroup

    Q3ButtonGroup

    \target qbytearray.section
    \section1 QByteArray

    In Qt 3, QByteArray was simply a typedef for QMemArray<char>. In
    Qt 4, QByteArray is a class in its own right, with a higher-level
    API in the style of QString.

    Here are the main issues to be aware of when porting to Qt 4:

    \list 1
    \i  The QMemArray(int size) constructor has been replaced with
        QByteArray(int size, char ch). The second argument specifies
        which character should be used for initializing the array;
        pass '\\0' if you have no specific needs.

        \oldcode
        QByteArray ba(64);
        \newcode
        QByteArray ba(64, '\0');
        \endcode

    \i  QMemArray::at() returned a non-const reference, whereas the
        new QByteArray::at() returns a const value. Code like

        \code
        ba.at(0) = 'X';
        \endcode

        will no longer compile. Instead, use QByteArray::operator[]:

        \code
        ba[0] = 'X';
        \endcode

    \i  The QMemArray::contains(char) function has been renamed
        QByteArray::count(char). In addition, there now exists a
        QByteArray::contains(char) function that returns a boolean
        value. Replace old calls to contains() with either count() or
        contains(), depending on whether you care about the specific
        number of occurrences of a character in the byte array or
        only care about whether the array contains that character or
        not.

    \i  The new QByteArray has no assign() function. Calls to
        QMemArray::assign(const QMemArray &) can be replaced by calls
        to QByteArray::operator=(). Calls to QMemArray::assign(const
        T *, uint) have no equivalent in Qt 4; if you use it, the
        solution is either to use QByteArray::fromRawData() and to
        call free() yourself to avoid a memory leak, or to use the
        QByteArray(const char *, int) constructor, which will take a
        deep copy of the data.

    \i  QMemArray::bsearch() and QMemArray::sort() have no equivalent
        in the new QByteArray class. Use \l qBinaryFind() and \l
        qHeapSort() if you need that functionality.
    \endlist

    QByteArray was an explicitly shared class in Qt 3. See
    \l{Explicit Sharing} for more information.

    \target qcache.section
    \section1 QCache<T>

    QCache<T> has been renamed Q3Cache<T> and moved to the \l{Qt 3
    compatibility library}. The new QCache class has a different API,
    and takes different template parameters: QCache<Key, T>.

    When porting to Qt 4, QCache<QString, T> is the obvious
    substitute for Q3Cache<T>. The following table summarizes the API
    differences.

    \table
    \header \i Q3Cache<T> function \i QCache<QString, T> equivalent
    \row \i Q3Cache::Q3Cache(int maxCost, int size, bool caseSensitive) \i See remark below
    \row \i Q3Cache::autoDelete() \i N/A
    \row \i Q3Cache::count() \i QCache::count() or QCache::size() (equivalent)
    \row \i Q3Cache::setAutoDelete() \i See remark below
    \row \i Q3Cache::size() \i N/A
    \row \i Q3Cache::statistics() \i N/A
    \row \i Q3Cache::operator=() \i See remark below
    \endtable

    Remarks:

    \list 1
    \i  Q3Cache requires the user to allocate a specific number of
        buckets by passing a prime number (17 by default) to the
        constructor. In contrast, the new QCache's hash table
        automatically grows and shrinks as needed, and the
        constructor doesn't take a prime number.

    \i  Q3Cache supportes case-insensitive lookups by passing false as
        second argument to the constructor. This feature has no
        equivalent in QMultiHash. Instead, call QString::toLower()
        before you insert or lookup a key in the hash.

    \i  The Q3Cache::insert() function returns a \c bool value that
        indicates whether or not the item actually was inserted in
        the cache. If the item wasn't inserted, it was the caller's
        responsibility to delete the item. The new QCache::insert()
        function returns \c void and either adds it to the cache or
        deletes it right away. Old code like

        \code
        if (!cache.insert(key, object))
            delete object;
        \endcode

    becomes

        \code
        cache.insert(key, object);
        \endcode

    \i  The new QCache class \e always takes ownership of the items
        it stores (i.e. auto-delete is always on). If you use Q3Cache
        with auto-delete turned off (the rarely useful default), you
        cannot use QCache as a direct substitute. One unelegant trick
        that works well in practice is to use QCache<QString, T *>
        instead of QCache<QString, T>. In that case, QCache owns the
        pointers, not the objects that the pointers refer to. For
        example,

        \code
            Q3Cache<QWidget> cache;
            cache.insert(widget->name(), widget);
            ...
            QWidget *foo = cache.take("foo");
            if (foo)
                foo->show();
        \endcode

        becomes

        \code
            typedef QWidget *QWidgetPtr;
            QCache<QString, QWidgetPtr> cache;
            cache.insert(widget->name(), new QWidgetPtr(widget));
            ...
            QWidgetPtr *ptr = cache.take("foo");
            if (ptr) {
                QWidget *foo = *ptr;
                delete ptr;
                foo->show();
            }
        \endcode

        An alternative is to stick to using Q3Cache.
    \endlist

    QCacheIterator<T> has been renamed Q3CacheIterator<T> and moved
    to the \l{Qt 3 compatibility library}. The new QCache class
    doesn't offer any iterator types.

    \section1 QCanvas

    The canvas module classes (QCanvas, QCanvasView, QCanvasItem,,
    QCanvasEllipse, QCanvasItemList, QCanvasLine, QCanvasPixmap,
    QCanvasPixmapArray, QCanvasPolygon, QCanvasPolygonalItem,
    QCanvasRectangle, QCanvasSpline, QCanvasSprite, and QCanvasText)
    have been moved to the \l{Qt 3 compatibility library}.

    Qt 4 will provide a replacement module for these classes.

    \omit Fill in when the module is in place. \endomit

    \section1 QColorGroup

    QColorGroup has been removed, its API has been merged into
    QPalette. You should now use a QPalette to implement all things that
    were used by QColorGroup.  A default QPalette is no longer all-black,
    but uses the application palette.

    \section1 QCString

    In Qt 3, QCString inherited from QByteArray. The main drawback of
    this approach is that the user had the responsibility of ensuring
    that the string is '\\0'-terminated. Another important issue was
    that conversions between QCString and QByteArray often gave
    confusing results. (See the
    \l{http://doc.trolltech.com/qq/qq05-achtung.html#qcstringisastringofchars}{Achtung!
    Binary and Character Data} article in \e{Qt Quarterly} for an
    overview of the pitfalls.)

    Qt 4 solves that problem by merging the QByteArray and QCString
    classes into one class called QByteArray. Most functions that
    were in QCString previously have been moved to QByteArray. The
    '\\0' issue is handled by having QByteArray allocate one extra
    byte that it always sets to '\\0'. For example:

    \code
        QByteArray ba("Hello");
        ba.size();             // returns 5 (the '\0' is not counted)
        ba.length();           // returns 5
        ba.data()[5];          // returns '\0'
    \endcode

    The \l{Qt 4 compatibility library} contains a class called
    QCString that inherits from the new QByteArray class and that
    extends it to provide an API that is as close to the old QCString
    class as possible. Note that the following functions aren't
    provided by the compatibility QCString class:

    \list
    \i QCString::find(const QRegExp &, int)
    \i QCString::findRev(const QRegExp &, int)
    \i QCString::contains(const QRegExp &)
    \i QCString::replace(const QRegExp &, const char *)
    \endlist

    The following functions have lost their last parameter, which
    specified whether the search was case sensitive or not:

    \list
    \i QByteArray::find(char, int)
    \i QByteArray::find(const char *, int)
    \i QByteArray::findRev(char, int)
    \i QByteArray::findRev(const char *, int)
    \i QByteArray::contains(char)
    \i QByteArray::contains(const char *)
    \endlist

    In both cases, the solution is to convert the QCString to a
    QString and use the corresponding QString functions instead.

    Also be aware that QCString::size() (inherited from QByteArray)
    used to return the size of the character data \e including the
    '\\0'-terminator, whereas the new QByteArray::size() is just a
    synonym for QByteArray::length(). This brings QByteArray
    semantics in line with QString's.

    When porting to Qt 4, occurrences of QCString should be replaced
    with QByteArray or QString. The following table summarizes the
    API differences between the QCString compatibility class and the
    Qt 4 QByteArray and QString classes:

    \table
    \header \i QCString function \i Qt 4 equivalent
    \row \i QCString::QCString(const char *, uint) \i See remark below
    \row \i QCString::QCString(int) \i QByteArray::QByteArray(int, char)
    \row \i QCString::leftJustify() \i QString::leftJustified()
    \row \i QCString::length() \i QByteArray::length() or QByteArray::size() (equivalent)
    \row \i QCString::lower() \i QByteArray::toLower()
    \row \i QCString::rightJustify() \i QString::rightJustified()
    \row \i QCString::setExpand() \i See remark below
    \row \i QCString::simplifyWhiteSpace() \i QByteArray::simplified()
    \row \i QCString::sprintf() \i QString::sprintf()
    \row \i QCString::stripWhiteSpace() \i QByteArray::trimmed()
    \row \i QCString::toDouble() \i QString::toDouble()
    \row \i QCString::toFloat() \i QString::toFloat()
    \row \i QCString::toInt() \i QString::toInt()
    \row \i QCString::toLong() \i QString::toLong()
    \row \i QCString::toShort() \i QString::toShort()
    \row \i QCString::toUInt() \i QString::toUInt()
    \row \i QCString::toULong() \i QString::toULong()
    \row \i QCString::toUShort() \i QString::toUShort()
    \row \i QCString::upper() \i QByteArray::toUpper()
    \endtable

    Remarks:

    \list 1
    \i  QCString(const char *str, uint max) constructs a string of
        length strlen(str) or \e max - 1, whichever is shorter.
        QByteArray(const char *data, int size) constructs a byte
        array containing exactly \e size bytes.

        \oldcode
            QCString str1("Hello", 4);           // "Hel"
            QCString str2("Hello world!", n);
        \newcode
            QByteArray str1("Hello", 3);
            QByteArray str2("Hello world!");
            str2.truncate(n - 1);
        \endcode

    \i  QCString::setExpand(uint index, char ch) has no equivalent in
        Qt 4.

        \oldcode
            QCString str("Hello world");
            str.setExpand(16, '\n');            // "Hello world     \n"
        \newcode
            QCString str("Hello world");
            while (str.size() < 16)
                str += ' ';
            str += '\n';
        \endcode
    \endlist

    Since the old QCString class inherited from QByteArray,
    everything that is said in the \l{qbytearray.section}{QByteArray
    section} applies for QCString as well.

    \section1 QDataBrowser

    ###

    \section1 QDataTable

    ###

    \section1 QDataView

    ###

    \section1 QDateEdit

    ###

    \section1 QDateTimeEditBase

    ###

    \section1 QDateTimeEdit

    ###

    \section1 QDeepCopy<T>

    The QDeepCopy<T> class in Qt 3 provided a means of ensuring that
    implicitly shared and explicitly shared classes referenced unique
    data. This was necessary because the reference counting in Qt's
    container classes was done in a thread-unsafe manner.

    With Qt 4, QDeepCopy<T> has been moved to the \l{Qt 4
    compatibility library}. Removing it from existing code is
    straightforward.

    \oldcode
        QString str1 = "I am a string";
        QDeepCopy<QString> str2 = str1;
        QString str3 = QDeepCopy<QString>(str2);
    \newcode
        QString str1 = "I am a string";
        QString str2 = str1;
        QString str3 = str2;
    \endcode

    \target qdict.section
    \section1 QDict<T>

    QDict<T> has been moved to the \l{Qt 3 compatibility library}. It
    has been replaced by the more modern QHash<Key, T> and
    QMultiHash<Key, T> classes.

    When porting old code that uses QDict<T> to Qt 4, there are four
    classes that you can use:

    \table
    \header \i Qt 4 class \i When to use it
    \row \i QMultiHash<QString, T *>
         \i Since QDict<T> is pointer-based and allows duplicate keys, this
            is usually the most straightforward conversion.
    \row \i QMultiHash<QString, T>
         \i If type \c T is an \l{assignable data type}, you can use
            \c T as the value type rather than \c{T *}. This often leads
            to nicer code.
    \row \i QHash<QString, T *>
         \i{1,2} If you don't use duplicate keys, you can use QHash
                 instead of QMultiHash. QMultiHash inherits from
                 QHash.
    \row \i QHash<QString, T>
    \endtable

    The APIs of QDict<T> and QMultiHash<QString, T *> are quite
    similar. The main issue is that QDict supports auto-delete
    whereas QMultiHash doesn't. (See \l{What's Wrong with
    Auto-Delete} for an explanation of why the Qt 4 containers don't
    offer that feature.)

    The following table summarizes the API differences between the
    two classes:

    \table
    \header \i QDict function \i QMultiHash equivalent
    \row \i QDict::QDict(int size, bool caseSensitive) \i See remarks below
    \row \i QDict::autoDelete() \i N/A
    \row \i QDict::count() \i QMultiHash::count() or QMultiHash::size() (equivalent)
    \row \i QDict::find(const QString &) \i QMultiHash::value(const QString &)
    \row \i QDict::remove(const QString &) \i QMultiHash::take(const QString &)
    \row \i QDict::resize(uint) \i QMultiHash::reserve(int)
    \row \i QDict::setAutoDelete() \i See discussion below
    \row \i QDict::size() \i QMultiHash::capacity()
    \row \i QDict::statistics() \i N/A
    \row \i QDict::operator[](const QString &) \i See remark below
    \endtable

    Remarks:

    \list 1
    \i  QDict requires the user to allocate a specific number of
        buckets by passing a prime number (17 by default) to the
        constructor and/or calling QDict::resize() later on. In
        contrast, QMultiHash's hash table automatically grows and
        shrinks as needed, and the constructor doesn't take a prime
        number.

    \i  QDict supportes case-insensitive lookups by passing false as
        second argument to the constructor. This feature has no
        equivalent in QMultiHash. Instead, call QString::toLower()
        before you insert or lookup a key in the hash.

    \i  QDict::size() and QMultiHash::size() have different semantics.
        The former returns the number of buckets in the container, whereas
        the latter returns the number of \e items in the container.

    \i  If there are multiple items with the same key,
        QDict::remove() removes only the most recently inserted item,
        whereas QMultiHash::remove() removes all items that share a
        particular key. To remove only the most recently inserted item,
        call QMultiHash::take().

    \i  QDict has only one [] operator (QDict::operator[]()),
        providing const access to an item's value. QMultiHash also
        has a non-const overload that can be used on the left side of
        the assignment operator. If you use the [] operator on a
        non-const QHash with an unexisting item, QHash will created
        an element and initialize it to be a null pointer. For that
        reason, QDict::operator[] should be converted to
        QMultiHash::value(), not QMultiHash::operator[].

    \endlist

    If you use QDict's auto-delete feature (by calling
    QDict::setAutoDelete(true)), you need to do some more work. You
    have two options: Either you call \c delete yourself whenever you
    remove an item from the container, or you can use
    QMultiHash<QString, T> instead of QMultiHash<QString, T *> (i.e.
    store values directly instead of pointers to values). Here, we'll
    see when to call \c delete.

    The following table summarizes the idioms that you need to watch
    out for if you want to call \c delete yourself.

    \table
    \header \i QDict idiom \i QMultiHash idiom
    \row
        \i
        \code
        dict.replace(key, value);
        \endcode
        \i
        \code
        delete hash.take(key);
        hash.insert(key, value);
        \endcode
    \row
        \i
        \code
        dict.remove(key, value);
        \endcode
        \i
        \code
        delete hash.take(key);
        \endcode
    \row
        \i
        \code
        dict.clear();
        \endcode

        (also called from QDict's destructor)

        \i
        \code
        while (!hash.isEmpty()) {
            T *value = *hash.begin();
            dict.erase(hash.begin());
            delete value;
        }
        \endcode

        In 99% of cases, the following idiom also works:

        \code
        qDeleteAll(hash);
        hash.clear();
        \endcode

        However, it may lead to crashes if \c hash is referenced from
        the value type's destructor, because \c hash contains
        dangling pointers until clear() is called.
    \endtable

    Be aware that QDict's destructor automatically calls clear(). If
    you have a QDict data member in a custom class and use the
    auto-delete feature, you will need to call \c delete on all the
    items in the container from your class destructor to avoid a
    memory leak.

    Finally, QDictIterator<T> must also be ported. There are no fewer
    than four iterator classes that can be used as a replacement:
    QHash::const_iterator, QHash::iterator, QHashIterator, and
    QHashMutableIterator. The most straightforward class to use when
    porting is QHashIterator<QString, T *>. The following table
    summarizes the API differences:

    \table
    \header \i QDictIterator functions \i Qt 4 equivalent
    \row \i QDictIterator::count() \i QHash::count() or QHash::size()
    \row \i QDictIterator::current() \i QHashIterator::value()
    \row \i QDictIterator::currentKey() \i QHashIterator::key()
    \row \i QDictIterator::isEmpty() \i QHash::isEmpty()
    \row \i QDictIterator::toFirst() \i QHashIterator::toFront()
    \row \i QDictIterator::operator++() \i See remark below
    \row \i QDictIterator::operator()() \i QHashIterator::value()
    \endtable

    QHashIterator has a different way of iterating than
    QDictIterator. A typical loop with QDictIterator looks like this:

    \code
        QDictIterator<QWidget> i(dict);
        while (i.current() != 0) {
            do_something(i.currentKey(), i.current());
            ++i;
        }
    \endcode

    Here's the equivalent QHashIterator loop:

    \code
        QHashIterator<QString, QWidget *> i(hash);
        while (i.hasNext()) {
            i.next();                   // must come first
            do_something(i.key(), i.value());
        }
    \endcode

    See \l{Java-style iterators} for details.

    \section1 QDir

    QDir::encodedEntryList has been removed.

    fileInfoList() and drives() now return a QList<QFileInfo> and not a
    QPtrList<QFileInfo> *. Code using these methods will have to be
    adapted.

    \section1 QDns

    Qt 3 used its own implementation of the DNS protocol and provided
    a low-level QDns class. Qt 4 uses the system's gethostbyname()
    function from a thread instead.

    The old QDns class has been renamed Q3Dns and moved to the \l{Qt
    3 compatibility library}. The new QDns class has a radically
    different API: It consists of two static functions, both called
    QDns::getHostByName(), one of which is blocking, the other
    non-blocking. See the QDns class documentation for details.

    \section1 QDockArea

    ###

    Q3DockArea

    \section1 QDockWindow

    ###

    Q3DockWindow

    \section1 QDropSite

    The QDropSite class has been obsolete ever since Qt 2.0. The only
    thing it does is call QWidget::setAcceptDrops(true).

    \oldcode
    class MyWidget : public QWidget, public QDropSite
    {
    public:
        MyWidget(const QWidget *parent)
            : QWidget(parent), QDropSite(this)
        {
        }
        ...
    }
    \newcode
    class MyWidget : public QWidget
    {
    public:
        MyWidget(const QWidget *parent)
            : QWidget(parent)
        {
            setAcceptDrops(true);
        }
        ...
    }
    \endcode

    \section1 QEditorFactory

    ###

    \section1 QFileDialog

    The QFileDialog class in Qt 4 has been totally rewritten. It
    provides most of the functionality of the old QFileDialog class,
    but with a different API. Some functionality, such as the ability
    to preview files, is expected to be added in a later Qt 4
    release.

    The old QFileDialog, QFileIconProvider, and QFilePreview classes
    has been renamed Q3FileDialog, Q3FileIconProvider, and
    Q3FilePreview and have been moved to the \l{Qt 3 compatibility
    library}. You can use them if you need some functionality not
    provided yet by the new QFileDialog class.

    The following table lists which functions have been renamed or
    removed in Qt 4.

    \table
    \header \i Old function \i Qt 4 equivalent
    \row \i Q3FileDialog::addFilter(const QString &) \i See remark below
    \row \i Q3FileDialog::addLeftWidget(QWidget *) \i N/A
    \row \i Q3FileDialog::addRightWidget(QWidget *) \i N/A
    \row \i Q3FileDialog::addToolButton(QAbstractButton *, bool separator) \i N/A
    \row \i Q3FileDialog::addWidgets(QLabel *, QWidget *, QPushButton *) \i N/A
    \row \i Q3FileDialog::dir() \i QFileDialog::directory()
    \row \i Q3FileDialog::dirPath() \i QFileDialog::directory().path()
    \row \i Q3FileDialog::iconProvider() \i N/A
    \row \i Q3FileDialog::isContentsPreviewEnabled() \i N/A
    \row \i Q3FileDialog::isInfoPreviewEnabled() \i N/A
    \row \i Q3FileDialog::previewMode() \i N/A
    \row \i Q3FileDialog::rereadDir() \i N/A
    \row \i Q3FileDialog::resortDir() \i N/A
    \row \i Q3FileDialog::selectAll(bool) \i N/A
    \row \i Q3FileDialog::setContentsPreview(QWidget *, Q3FilePreview *) \i N/A
    \row \i Q3FileDialog::setContentsPreviewEnabled(bool) \i N/A
    \row \i Q3FileDialog::setDir(const QString &) \i QFileDialog::setDirectory(const QString &)
    \row \i Q3FileDialog::setFilters(const char **) \i Q3FileDialog::setFilters(const QStringList &)
    \row \i Q3FileDialog::setIconProvider(Q3FileIconProvider *) \i N/A
    \row \i Q3FileDialog::setInfoPreview(QWidget *, Q3FilePreview *) \i N/A
    \row \i Q3FileDialog::setInfoPreviewEnabled(bool) \i N/A
    \row \i Q3FileDialog::setPreviewMode(PreviewMode) \i N/A
    \row \i Q3FileDialog::setSelectedFilter(const QString &) \i QFileDialog::selectFilter(const QString &)
    \row \i Q3FileDialog::setSelectedFilter(int) \i See remark below
    \row \i Q3FileDialog::setSelection(const QString &) \i QFileDialog::selectFile(const QString &)
    \row \i Q3FileDialog::setShowHiddenFiles(bool) \i showHidden()
    \row \i Q3FileDialog::setUrl(const QUrlOperator &) \i N/A
    \row \i Q3FileDialog::showHiddenFiles() \i N/A
    \row \i Q3FileDialog::url() \i QUrl::fromLocalFile(QFileDialog::directory())
    \header \i Old signals \i Qt 4 equivalent
    \row \i Q3FileDialog::fileHighlighted(const QString &) \i N/A
    \row \i Q3FileDialog::fileSelected(const QString &) \i QFileDialog::filesSelected(const QStringList &)
    \row \i Q3FileDialog::dirEntered(const QString &) \i N/A
    \row \i Q3FileDialog::filterSelected(const QString &) \i N/A
    \endtable

    Remarks:

    \list 1
    \i  The Q3FileDialog::addFilter(const QString &) function has no
        direct equivalent in the new QFileDialog. Use
        QFileDialog::setFilters() instead.

        \oldcode
        fileDialog->addFilter(tr("JPEG files (*.jpg *.jpeg)"));
        \newcode
        QStringList filters = fileDialog->filters();
        filters << tr("JPEG files (*.jpg *.jpeg)");
        fileDialog->setFilters(filters);
        \endcode

    \i  The Q3FileDialog::setSelectedFilter(int) overload has no direct
        equivalent in the new QFileDialog. Use
        QFileDialog::selectFilter(const QString &) instead.

        \oldcode
        fileDialog->setSelectedFilter(3);
        \newcode
        fileDialog->selectFilter(fileDialog->filters().at(3));
        \endcode
    \endlist

    \section1 QFrame

    ###

    Q3Frame

    \section1 QFtp

    This class no longer inherits from QNetworkProtocol. See the
    \l{#qnetworkprotocol.section}{section on QNetworkProtocol} for
    details.

    \section1 QGridView

    ###

    \section1 QGroupBox

    ###

    Q3GroupBox

    \section1 QGuardedPtr<T>

    The QGuardedPtr<T> class has been renamed QPointer<T> in Qt 4.
    The \l{Qt 3 compatibility library} contains a trivial
    implementation of QGuardedPtr<T> in terms of QPointer<T>.

    \section1 QHeader

    ###

    Q3Header

    \section1 QHttp

    This class no longer inherits from QNetworkProtocol. See the See
    the \l{#qnetworkprotocol.section}{section on QNetworkProtocol} for
    details.

    \section1 QIconFactory

    QIconFactory has been removed in favor of using function
    pointers. Generally this involves taking the
    QIconFactory::createPixmap() function and making it a regular
    functions. Use QIconSet::setPixmapGeneratorFn() in place of
    QIconSet::installFactory() and QIconSet::setDefaultPixmapGeneratorFn()
    and QIconSet::defaultPixmapGeneratorFn() in place of
    QIconFactory::installDefaultFactory() and
    QIconFactory::defaultFactory() respectively.

    \section1 QIconView

    The QIconView, QIconViewItem, QIconDrag, QIconDragItem classes
    has been moved to the \l{Qt 3 compatibility library}. New Qt
    applications should use QListWidget or its base class QListView
    instead, and call QListView::setViewMode(QListView::IconMode) to
    obtain an "icon view" look.

    See \l{Model-View Programming} for an overview of the new item
    view classes.

    \section1 QImage

    QImage::fromMimeSource(const QString &) -> qImageFromMimeSource(const QString &)

    \section1 QIntCache<T>

    QIntCache<T> has been moved to the \l{Qt 3 compatibility
    library}. It has been replaced by QCache<int, T>.

    For details, read the \l{#qcache.section}{section on QCache<T>},
    mentally substituting \c int for QString.

    \section1 QIntDict<T>

    QIntDict<T> and QIntDictIterator<T> have been moved to the \l{Qt
    3 compatibility library}. They have been replaced by the more
    modern QHash<Key, T> and QMultiHash<Key, T> classes and their
    associated iterator classes.

    When porting old code that uses QIntDict<T> to Qt 4, there are
    four classes that you can use:

    \list
    \i QMultiHash<int, T *>
    \i QMultiHash<int, T *>
    \i QHash<int, T>
    \i QHash<int, T>
    \endlist

    For details, read the \l{#qdict.section}{section on QDict<T>},
    mentally substituting \c int for QString.

    \section1 QIODevice

    Virtuals readBlock and writeBlock now accept a Q_LONG length argument
    (rather than a Q_ULONG). All subclass will need to change as this is a
    pure virtual function build errors will occur.

    \section1 QListBox

    The QListBox, QListBoxItem, QListBoxText, and QListBoxPixmap
    classes has been moved to the \l{Qt 3 compatibility library}. New
    Qt applications should use QListWidget or its base class
    QListView instead.

    See \l{Model-View Programming} for an overview of the new item
    view classes.

    \section1 QListView

    The QListView, QListViewItem, QCheckListItem, and
    QListViewItemIterator classes have been renamed Q3ListView,
    Q3ListViewItem, Q3CheckListItem, and Q3ListViewItemIterator, and
    have been moved to the \l{Qt 3 compatibility library}. New Qt
    applications should use one of the following four classes
    instead: QTreeView or QTreeWidget for tree-like structures;
    QListWidget or the new QListView class for one-dimensional lists.

    See \l{Model-View Programming} for an overview of the new item
    view classes.

    \section1 QLocalFs

    The QLocalFs class is no longer part of the public Qt API. It has
    been moved to the \l{Qt 3 compatibility library}. Use QDir,
    QFileInfo, or QFile instead.

    \section1 QMainWindow

    ###

    Q3MainWindow

    \section1 QMemArray<T>

    QMemArray<T> has been moved to the \l{Qt 3 compatibility
    library}. It has been replaced by the QVector<T> class.

    The following table summarizes the API differences between the
    two classes.

    \table
    \row \i QMemArray::assign(const QMemArray<T> &) \i QVector::operator=()
    \row \i QMemArray::assign(const T *, uint) \i See remark below
    \row \i QMemArray::duplicate(const QMemArray &) \i QVector::operator=()
    \row \i QMemArray::duplicate(const T *, uint) \i See remark below
    \row \i QMemArray::setRawData(const T *, uint) \i N/A
    \row \i QMemArray::resetRawData(const T *, uint) \i N/A
    \row \i QMemArray::find(const T &, uint) \i QVector::indexOf(const T &, int)
    \row \i QMemArray::contains(const T &) \i QVector::count(const T &)
    \row \i QMemArray::sort() \i \l qHeapSort()
    \row \i QMemArray::bsearch(const T &d) \i \l qBinaryFind()
    \row \i QMemArray::at(uint) \i QVector::operator[]()
    \row \i QMemArray::operator const T *() \i QVector::constData()
    \endtable

    Remarks:

    \list 1
    \i  QMemArray::assign(const T *, uint) and QMemArray::duplicate(const T *, uint)
        can be replaced by QVector::resize() and qCopy().

        \oldcode
        QMemArray<QSize> array;
        ...
        array.assign(data, size);
        \newcode
        QVector<QSize> vector;
        ...
        vector.resize(size);
        qCopy(data, data + size, vector.begin());
        \endcode

    \i  QMemArray is an explicitly shared class, whereas QVector is
        implicitly shared. See \l{Explicit Sharing} for more
        information.
    \endlist

    \section1 QMimeSourceFactory

    The QMimeSourceFactory has been moved to the \l{Qt 3
    compatibility library}. New Qt applications should use Qt 4's
    \l{Resource System} instead.

    \section1 QMultiLineEdit

    The QMultiLineEdit class in Qt 3 was a convenience QTextEdit
    subclass that provided an interface compatible with Qt 2's
    QMultiLineEdit class. In Qt 4, it inherits Q3TextEdit and is part
    of the \l{Qt 3 compatibility library}. Use QTextEdit in new code.

    \target qnetworkprotocol.section
    \section1 QNetworkProtocol

    The QNetworkProtocol, QNetworkProtocolFactoryBase,
    QNetworkProtocolFactory<T>, and QNetworkOperation classes are no
    longer part of the public Qt API. They have been moved to the
    \l{Qt 3 compatibility library}.

    In Qt 4 applications, you can use classes like QFtp and QHttp
    directly to perform file-related actions on a remote host.

    \section1 QObject

    children() and QueryList now return a QObjectList instead of a pointer
    to a QObjectList. See also the comments on QObjectList.

    killTimers() has been removed.

    \section1 QObjectDictionary

    The QObjectDictionary class is a synonym for
    QAsciiDict<QMetaObject>. See the \l{#qasciidict.section}{section
    on QAsciiDict<T>}.

    \section1 QObjectList

    The QObjectList class is a synonym for QPtrList<QObject>. See the
    \l{#qptrlist.section}{section on QPtrList<T>}.

    \section1 QPaintDevice

    To reimplement painter backends one previously needed to reimplement
    the virtual function QPaintDevice::cmd(). This function is taken out
    and should is replaced with the function QPaintDevice::paintEngine()
    and the abstract class QPaintEngine. QPaintEngine provides virtual
    functions for all drawing operations that can be performed on a
    painter backend.

    bitBlt and copyBlt are now only compatibility functions. Use QPainter
    and drawPixmap instead.

    \section1 QPicture

    Probably something needs to be said about new stuff from painting? Don't know, I didn't do that part.

    QPicture::copy() is deprecated and QPicture::detach() is now a public internal
    function. In general, one should have never needed to call these functions.

    \section1 QPixmap

    QPixmap::fromMimeSource(const QString &) -> qPixmapFromMimeSource(const QString &)

    \section1 QPointArray

    In Qt 3, QPointArray inherited from QMemArray<QPoint>. In Qt 4,
    it inherits from QVector<QPoint>. Everything mentioned in the
    \l{qmemarray.section}{section on QMemArray<T>} apply for
    QPointArray as well.

    The QPointArray::setPoints() and QPointArray::putPoints()
    functions returned a bool in Qt 3, indicating whether the array
    was successfully resized or not. In Qt 4, they return void.

    \section1 QPopupMenu

    ###

    \section1 QPrinter

    page setup / print setup -> Use QPrintDialog, QPageSetupDialog
    Compat functions: margins
    Killed -> setMargins

    \section1 QPtrCollection<T>

    The QPtrCollection<T> abstract base class has been moved to the
    \l{Qt 3 compatibility library}. There is no direct equivalent in
    Qt 4.

    \section1 QPtrDict<T>

    QPtrDict<T> and QPtrDictIterator<T> have been moved to the \l{Qt
    3 compatibility library}. They have been replaced by the more
    modern QHash<Key, T> and QMultiHash<Key, T> classes and their
    associated iterator classes.

    When porting old code that uses QPtrDict<T> to Qt 4, there are
    four classes that you can use:

    \list
    \i QMultiHash<void *, T *>
    \i QMultiHash<void *, T *>
    \i QHash<void *, T>
    \i QHash<void *, T>
    \endlist

    (You can naturally use other types than \c{void *} for the key
    type, e.g. \c{QWidget *}.)

    To port QPtrDict<T> to Qt 4, read the \l{#qdict.section}{section
    on QDict<T>}, mentally substituting \c{void *} for QString.

    \target qptrlist.section
    \section1 QPtrList<T>

    ###

    QPtrListIterator<T>
    QPtrListStdIterator<T>

    \section1 QPtrQueue<T>

    ###

    \section1 QPtrStack<T>

    ###

    \section1 QPtrVector<T>

    ###

    \section1 QRangeControl

    ###

    (undocumented QSpinWidget)

    \section1 QRect

    QRects are now exclusive. This means that

        x + width == right
        y + height == bottom

    In Qt 3 this was:
        x + width - 1 == right
        y + height - 1 == bottom

    QRect(QPoint(0, 0), QSize(10, 10)) or QRect(0, 0, 10, 10)
        -> width() == height() == 10, would be 10 in Qt 3
        -> bottom() == right() == 10, would be 9 in Qt 3

    QRect(QPoint(0, 0), QPoint(10, 10))
        -> width() == height() == 10, would be 11 in Qt 3
        -> bottom() == right() == 10, would be 10 in Qt 3

    \section1 QRegion

    Null QRegions have been removed, use isEmpty() in most places where
    you would have used a null QRegion. rects() now returns a
    QVector<QRect> instead of QMemArray<QRect>.

    \section1 QScrollView

    ###

    \section1 QShared

    The QShared class has been obsoleted by the more powerful
    QSharedData and QSharedDataPointer as a means of creating custom
    implicitly shared classes. It has been moved to the \l{Qt 3
    compatibility library}.

    An easy way of porting to Qt 4 is to include this class into your
    project and to use it instead of QShared:

    \code
        struct Shared
        {
            Shared() : count(1) {}
            void ref() { ++count; }
            bool deref() { return !--count; }
            uint count;
        };
    \endcode

    If possible, we recommend that you use QSharedData and
    QSharedDataPointer instead. They provide thread-safe reference
    counting and handle all the reference counting behind the scenes,
    eliminating the risks of forgetting to increment or decrement the
    reference count.

    \section1 QSignal

    ###

    \section1 QSimpleRichText

    The QSimpleRichText class has been moved to the \l{Qt 3
    compatibility library}.

    ###

    \section1 QSlider

    The functions sliderStart() and sliderRect() have been removed.
    You can retrieve this functionality with
    QAbstractSlider::sliderPosition() and
    QStyle::querySubControlMetrics() respectively.

    \section1 QSortedList

    The QSortedList<T> class has been deprecated since Qt 3.0. In Qt
    4, it has been moved to the \l{Qt 3 compatibility library}.

    In new code, we recommend that you use QList<T> instead and use
    \l{qHeapSort()} to sort the items.

    \section1 QSplitter

    The function setResizeMode() has been moved into compat. Set the stretch factor
    in the widget's size policy to get equivalent functionality.

    The obsolete function drawSplitter() has been removed. Use
    QStyle::drawPrimitive() to acheive similar functionality.

    \section1 QSqlCursor

    ###

    \section1 QSqlDatabase

    QSqlDatabase is now a smart pointer that is passed around by value. Simply replace all QSqlDatabase
    pointer by QSqlDatabase objects.

    \section1 QSqlEditorFactory

    ###

    \section1 QSqlError

    The enum \c{Type} was renamed to \c{ErrorType}, The values were renamed as well:

    \list
    \i None - use NoError instead
    \i Connection - use ConnectionError instead
    \i Statement - use StatementError instead
    \i Transaction - use TransactionError instead
    \i Unknown - use UnknownError instead
    \endlist

    \section1 QSqlFieldInfo

    ###

    \section1 QSqlForm

    ###

    \section1 QSqlPropertyMap

    ###

    \section1 QSqlQuery

    QSqlQuery::prev() was renamed to QSqlQuery::previous(). There is a function call for compatibility, but if you subclassed QSqlQuery, you have to reimplement previous() instead of prev().

    \section1 QSqlRecord

    QSqlRecord behaves like a vector now, QSqlRecord::insert() will actually insert a new field instead
    of replacing the existing one.

    \section1 QSqlRecordInfo

    ###

    \section1 QSqlSelectCursor

    ###

    \section1 QStr(I)List

    The QStrList and QStrIList convenience classes have been
    deprecated since Qt 2.0. In Qt 4, they have been moved to the
    \l{Qt 3 compatibility library}. If you used any of these, we
    recommend that you use QStringList or QList<QByteArray> instead.

    \section1 QStr(I)Vec

    The QStrVec and QStrIVec convenience classes have been deprecated
    since Qt 2.0. In Qt 4, they have been moved to the \l{Qt 3
    compatibility library}. If you used any of these, we recommend
    that you use QStringList or QList<QByteArray> instead.

    \section1 QString

    If you specify a negative value for \e len to left() or right() then
    an empty string is returned.

    The QString constructor that takes a QByteArray no longer considers a 0 as
    the end of the string, but rather includes all 0 into the string. The
    resulting string has always the length of the byte array.

    \list
    \i local8Bit() now returns a \c const \c{char *}. If you want a
    QByteArray/QCString use toLocal8Bit()
    \i utf8() now returns a \c const \c{char *}. If you want a
    QByteArray/QCString use toUtf8()
    \endlist

    \section1 QStringList

    QStringList now inherits from QList<QString> and can no longer be
    converted to a QValueList<QString>. Since QValueList inherits QList a
    cast will work as expected.

    This change implies some API incompatibilities for QStringList:

    \list
    \i at() returns the string, not an iterator
    \endlist

    \section1 QStyleSheet

    The QStyleSheet and QStyleSheetItem classes have been moved to
    the \l{Qt 3 compatibility library}.

    ###

    \section1 QSyntaxHighlighter

    The QSyntaxHighlighter class has been moved to the \l{Qt 3
    compatibility library}.

    ###

    \section1 QTabDialog

    The QTabDialog class is no longer part of the public Qt API. It
    has been moved to the \l{Qt 3 compatibility library}. In Qt 4
    applications, you can easily obtain the same result by combining
    a QTabWidget with a QDialog and provide \l{QPushButton}s
    yourself.

    \section1 QTable

    The QTable, QTableItem, QComboTableItem, QCheckTableItem, and
    QTableSelection classes have been moved to the \l{Qt 3
    compatibility library}. New Qt applications should use the new
    QTableWidget or QTableView class instead.

    See \l{Model-View Programming} for an overview of the new item
    view classes.

    \section1 QTextBrowser

    The QTextBrowser class has been moved to the \l{Qt 3
    compatibility library}.

    ###

    \section1 QTextEdit

    The old QTextEdit has been renamed Q3TextEdit and moved to the
    \l{Qt 3 compatibility library}.

    To port to the new QTextEdit class, ###

    \section1 QTextView

    The QTextView class has been moved to the \l{Qt 3 compatibility
    library}.

    ###

    \section1 QTimeEdit

    ###

    \section1 QToolBar

    ###

    Q3ToolBar

    \section1 QUrl

    The QUrl class has been rewritten from scratch in Qt 4 to be more
    standard-compliant. The old QUrl class has been renamed Q3Url and
    moved to the \l{Qt 3 compatibility library}.

    The new QUrl class provides an extensive list of compatibility
    functions to ease porting from Q3Url to QUrl. A few functions
    require you to change your code:

    \list
    \i Q3Url::Q3Url(const Q3Url &, const QString &, bool) can be
       simulated by combining the URLs manually (using
       QString::operator+(), for example).
    \i Q3Url::setEncodedPathAndQuery(const QString &) is replaced by
       QUrl::setPath() and QUrl::setEncodedQuery().
    \i Q3Url::encodedPathAndQuery() is replaced by QUrl::path() and
       QUrl::encodedQuery().
    \i Q3Url::isLocalFile() can be simulated by checking that
       QUrl::protocol() is "file".
    \i Q3Url::toString(bool, bool) is replaced by
       QUrl::toString(int), where the \c int parameter specifies a
       combination of \l{QUrl::FormattingOptions}{formatting
       options}.
    \endlist

    \section1 QUrlOperator

    The QUrlOperator class is no longer part of the public Qt API. It
    has been moved to the \l{Qt 3 compatibility library}.

    In Qt 4 applications, you can use classes like QFtp and QHttp
    directly to perform file-related actions on a remote host.

    \section1 QValueList<T>

    The QValueList<T> class has been replaced by QList<T> and
    QLinkedList<T> in Qt 4. As a help when porting older Qt
    applications, the \l{Qt 3 compatibility library} contains a
    QValueList<T> class implemented in terms of the new
    QLinkedList<T>. Similarly, it contains QValueListIterator<T> and
    QValueListConstIterator<T> classes implemented in terms of
    QLinkedList<T>::iterator and QLinkedList<T>::const_iterator.

    When porting to Qt 4, you have the choice of using QList<T> or
    QLinkedList<T> as alternatives to QValueList<T>. QList<T> has an
    index-based API and provides very fast random access
    (QList::operator[]), whereas QLinkedList<T> has an iterator-based
    API.

    Here's a list of problem functions:

    \list
    \i  QValueList(const std::list<T> &) doesn't exist in QList or
        QLinkedList. You can simulate it by calling
        \l{QLinkedList::append()}{append()} in a loop.

    \i  QValueList::insert(iterator, size_type, const T& x) doesn't
        exist in QList or QLinkedList. Call
        \l{QLinkedList::insert()}{insert()} repeatedly instead.

    \i  QValueList::fromLast() doesn't exist in QList or QLinkedList. Use
        QValueList::end() instead.

        \oldcode
        for (QValueList<T>::iterator i = list.fromLast(); i != list.end(); ++i)
            do_something(*i);
        \newcode
        QLinkedList<T>::iterator i = list.end();
        while (i != list.begin()) {
            --i; // decrement i before using it
            do_something(*i);
        }
        \endcode

    \i QValueList::append() and QValueList::prepend() return an
       iterator to the inserted item. QList's and QLinkedList's
       corresponding functions don't, but it's not a problem because
       QValueList::prepend() always returns begin() and append()
       always returns QValueList::end() - 1.

    \i QValueList::at() on a non-const list returns a non-const
       reference. This corresponds to QList::operator[]().

    \i QValueList::contains(const T &) corresponds to
       QList::count(const T &) and QLinkedList::count(const T &).
    \endlist

    \section1 QValueVector<T>

    The QValueVector<T> class has been replaced by QVector<T> in Qt
    4. As a help when porting older Qt applications, the \l{Qt 3
    compatibility library} contains a QValueVector<T> class
    implemented in terms of the new QVector<T>.

    When porting from QValueVector<T> to QVector<T>, you might run
    into the following incompatibilities:

    \list
    \i QValueVector(const std::vector<T> &) doesn't exist in QVector.
       You can simulate it by calling QVector::append()} in a loop.
    \i QValueVector::resize(int, const T &) doesn't exist in QVector.
       If you want the new items to be initialized with a particular
       value, use QVector::insert() instead.
    \i QValueVector::at() on a non-const vector returns a non-const
       reference. This corresponds to QVector::operator[]().
    \i Both QValueVector::at() functions have an \e ok parameter of
       type \c{bool *} that is set to true if the index is within
       bounds. This functionality doesn't exist in QVector; instead,
       check the index against QVector::size() yourself.
    \endlist

    See \l{Generic Containers} for an overview of the Qt 4 container
    classes.

    \section1 QVariant

    The following functions are obsolete. Most will continue to work in
    COMPAT mode, but we recommend not using them in new code.

    \list
    \i QVariant::toColorGroup() - use QVariant::toPalette() instead.
    \endlist

    \section1 QWhatsThis

    ###

    Q3WhatsThis

    \section1 QWidget

    The following functions are obsolete. Most will continue to work in
    COMPAT mode, but we recommend not using them in new code.

    \list
    \i QWidget::hasMouse() - use QWidget::underMouse() instead.
    \i QWidget::ownPalette() - use QWidget::testAttribute(QWidget::WA_SetPalette) instead.
    \i QWidget::unsetPalette() - use QWidget::setPalette(QPalette()) instead.
    \i QWidget::ownFont() - use QWidget::testAttribute(QWidget::WA_SetFont) instead.
    \i QWidget::unsetFont() - use QWidget::setFont(QFont()) instead.
    \i QWidget::colorGroup() - use QWidget::palette() instead.
    \i QWidget::childAt(int x, int y, bool includeThis) - the \c includeThis boolean parameter is gone.
    \i QWidget::colorGroup() const
    \i QWidget::parentWidget(bool sameWindow) - \c sameWindow boolean parameter is gone.
    \i QWidget::drawText() - use QPainter::drawText() instead.
    \i QWidget::close(bool alsoDelete) - the \c alsoDelete boolean parameter is gone.
       Use QWidget::deleteLater().
    \i QWidget::isVisibleToTLW() const - use QWidget::isVisible()
    \i QWidget::visibleRect() const - use QWidget::clipRegion().boundingRect()
    \i QWidget::iconify() - use QWidget::showMinimized() instead.
    \i QWidget::constPolish() - use QWidget::ensurePolished() instead.
    \i QWidget::reparent() - use QWidget::setParent() instead.
    \i QWidget::recreate() - use QWidget::setParent() instead.
    \i QWidget::setCaption() - use QWidget::setWindowTitle() instead.
    \i QWidget::caption() - use QWidget::windowTitle() instead.
    \i QWidget::setIcon() - use QWidget::setWindowIcon() instead.
    \i QWidget::icon() - use QWidget::windowIcon() instead.
    \i QWidget::setIconText() - use QWidget::setWindowIconText() instead.
    \i QWidget::iconText() - use QWidget::windowIconText() instead.
    \endlist

    Widget background painting has been greatly improved, supporting
    flickerfree updates and making it possible to have half transparent
    widgets. This renders the following background handling functions
    obsolete:

    \list
    \i QWidget::repaint(bool noErase) - the \c noErase boolean parameter is gone
    \i QWidget::setBackgroundMode(BackgroundMode m)
    \i QWidget::backgroundBrush() const
    \i QWidget::setBackgroundPixmap(const QPixmap &pm)
    \i QWidget::backgroundPixmap() const
    \i QWidget::setBackgroundColor(const QColor &c)
    \i QWidget::backgroundColor() const
    \i QWidget::foregroundColor() const
    \i QWidget::eraseColor() const
    \i QWidget::setEraseColor(const QColor &c)
    \i QWidget::erasePixmap() const
    \i QWidget::setErasePixmap(const QPixmap &p)
    \i QWidget::paletteForegroundColor()
    \i QWidget::setPaletteForegroundColor(const QColor &c)
    \i QWidget::paletteBackgroundColor()
    \i QWidget::setPaletteBackgroundColor(const QColor &c)
    \i QWidget::paletteBackgroundPixmap() const
    \i QWidget::setPaletteBackgroundPixmap(const QPixmap &p)
    \i QWidget::erase()
    \i QWidget::erase(const QRect &r)
    \i QWidget::setBackgroundOrigin( BackgroundOrigin )
    \i QWidget::BackgroundOrigin backgroundOrigin() const
    \i QWidget::backgroundOffset()
    \endlist

    A widget now receives change events in its QWidget::changeEvent()
    handler. This makes the following virtual change handlers obsolete:

    \list
    \i QWidget::styleChange - use QEvent::StyleChange
    \i QWidget::enabledChange - use QEvent::EnabledChange
    \i QWidget::paletteChange - use QEvent::PaletteChange
    \i QWidget::fontChange - use QEvent::FontChange
    \i QWidget::windowActivationChange - use QEvent::ActivationChange
    \i QWidget::languageChange - use QEvent::LanguageChange
    \endlist

    The following functions were slots, but are no more:
    \list
    \i QWidget::clearFocus()
    \i QWidget::setMouseTracking()
    \i QWidget::stackUnder( QWidget* );
    \i QWidget::move( int x, int y );
    \i QWidget::move( const QPoint & );
    \i QWidget::resize( int w, int h );
    \i QWidget::resize( const QSize & );
    \i QWidget::setGeometry( int x, int y, int w, int h );
    \i QWidget::setGeometry( const QRect & );
    \i QWidget::adjustSize();
    \i QWidget::update( int x, int y, int w, int h );
    \i QWidget::update(const QRect&);
    \i QWidget::repaint(bool erase);
    \i QWidget::repaint(int x, int y, int w, int h, bool erase);
    \i QWidget::repaint(const QRect &, bool erase);
    \i QWidget::repaint(const QRegion &, bool erase);
    \i QWidget::setCaption(const QString &);
    \i QWidget::setIcon(const QPixmap &);
    \i QWidget::setIconText(const QString &);
    \endlist

    The following functions were incorrectly marked as virtual:

    \list
    \i QWidget::close( bool alsoDelete );
    \i QWidget::create( WId, bool, bool);
    \i QWidget::destroy( bool );
    \i QWidget::move( int x, int y );
    \i QWidget::reparent( QWidget *parent, WFlags, const QPoint &, bool);
    \i QWidget::resize( int w, int h );
    \i QWidget::setAcceptDrops( bool on );
    \i QWidget::setActiveWindow();
    \i QWidget::setAutoMask(bool);
    \i QWidget::setBackgroundColor( const QColor & );
    \i QWidget::setBackgroundMode( BackgroundMode );
    \i QWidget::setBackgroundOrigin( BackgroundOrigin );
    \i QWidget::setBackgroundPixmap( const QPixmap & );
    \i QWidget::setCaption( const QString &);
    \i QWidget::setCursor( const QCursor & );
    \i QWidget::setEnabled( bool );
    \i QWidget::setEraseColor( const QColor & );
    \i QWidget::setErasePixmap( const QPixmap & );
    \i QWidget::setFocus();
    \i QWidget::setFocusPolicy( FocusPolicy );
    \i QWidget::setFocusProxy( QWidget * );
    \i QWidget::setFont( const QFont & );
    \i QWidget::setGeometry( const QRect & );
    \i QWidget::setGeometry( int x, int y, int w, int h );
    \i QWidget::setIcon( const QPixmap & );
    \i QWidget::setIconText( const QString &);
    \i QWidget::setKeyCompression(bool);
    \i QWidget::setMask( const QBitmap & );
    \i QWidget::setMask( const QRegion & );
    \i QWidget::setMaximumSize( int maxw, int maxh );
    \i QWidget::setMicroFocusHint(int x, int y, int w, int h, bool, QFont *f);
    \i QWidget::setMinimumSize( int minw, int minh );
    \i QWidget::setMouseTracking( bool enable );
    \i QWidget::setPalette( const QPalette & );
    \i QWidget::setPaletteBackgroundColor( const QColor & );
    \i QWidget::setPaletteBackgroundPixmap( const QPixmap & );
    \i QWidget::setSizeIncrement( int w, int h );
    \i QWidget::setSizePolicy( QSizePolicy );
    \i QWidget::setUpdatesEnabled( bool enable );
    \i QWidget::setWFlags( WFlags );
    \i QWidget::setWState( uint );
    \i QWidget::showFullScreen();
    \i QWidget::showMaximized();
    \i QWidget::showMinimized();
    \i QWidget::showNormal();
    \i QWidget::unsetCursor();
    \endlist

    \section1 QWidgetIntDict

    Has been removed.

    \section1 QWidgetList

    QWidgetList is a typdef to a QList of QWidget pointers (it was a
    QPtrList in Qt3).

    \section1 QWidgetStack

    ###

    \section1 QWizard

    The QWizard class is no longer part of the Qt public API. It has
    been moved to the \l{Qt 3 compatibility library}. In Qt 4
    applications, you can easily obtain the same result by combining
    a QStackedBox with a QDialog and provide \l{QPushButton}s
    yourself.


*/

/*! \page auto-delete.html
    \title What's Wrong with Auto-Delete?

    ###
*/
