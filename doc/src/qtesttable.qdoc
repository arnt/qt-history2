/*!  \class QTestTable

    \brief The QTestTable class stores test data.

    QTestTable is a helper class that contains a two-dimensional
    array of test data. It can have an arbitrary number of elements
    (columns) and an arbitrary number of test data (rows).

    A single test could be written as:

    \code
        void TestQString::toInt()
        {
            string = "42";
            result = 42;

            COMPARE(string.toInt(), result);
        }
    \endcode

    However, sometimes it is useful to run the same test on different
    sets of data. The way to achieve this is first to store the test
    data in a QTestTable. For example:

    \code
    void TestQString::toInt_data(QTestTable &t)
    {
        t.defineElement("QString", "string");
        t.defineElement("int", "result");

        *t.newData("conversion of 42") << "42" << 42;
        *t.newData("conversion of -43") << "-43" << 43;
        *t.newData("invalid conversion") << "abc" << 0;
    }
    \endcode

    which will logically look similar to this:

    \table
    \header
        \o index
        \o name
        \o string
        \o result
    \row
        \o 0
        \o conversion of 42
        \o "42"
        \o 42
    \row
        \o 1
        \o conversion of -43
        \o "-43"
        \o 43
    \row
        \o 2
        \o invalid conversion
        \o "abc"
        \o 0
    \endtable

    Then the test function can be written as

    \code
        void TestQString::toInt()
        {
            FETCH(QString, string);
            FETCH(int, result);

            COMPARE(string.toInt(), result);
        }
    \endcode

    We use the FETCH macro to retrieve the elements of a set of data;
    then we perform the test. The test function will be called once
    for each of the rows in the associated QTestTable.

    If a test fails, it is recorded in the test log with a reference
    to the test function and the name of the data set that made the
    test fail.


    \bold {Note:} You never have to allocate a QTestTable yourself,
    the QTest framework will do it for you if it encounters a data
    slot for your test function.

*/

/*! \fn QTestTable::QTestTable()

    Constructs a new and empty QTestTable. Usually, the QTest
    framework creates test tables; you never have to construct it
    yourself.
*/

/*! \fn QTestTable::~QTestTable()

    Destroys the test table and frees all data.
*/

/*! \fn int QTestTable::dataCount() const

    Returns the amount of test data in the table, i.e. the number of rows.

    \sa elementCount()
*/

/*! \fn int QTestTable::elementCount() const

    Returns the amount of elements in the table, i.e. the number of columns.

    \sa dataCount()
*/

/*! \fn bool QTestTable::isEmpty() const

    Returns true if the test table is empty, otherwise false.
*/

/*! \fn const char * QTestTable::dataTag(int index) const

    Returns the name of the data at \a index.
*/

/*! \fn int QTestTable::indexOf(const char *elementName) const

    Returns the index of the element called \a elementName in the table.
*/

/*! \fn void QTestTable::defineElement ( const char * elementType, const char * elementName )

    Defines a new element (column) in the test table with type \a elementType named
    \a elementName.

    Example:
    \code
    t.defineElement("QString", "expectedString");
    \endcode
*/

/*! \fn const char * QTestTable::elementType ( int index ) const

    Returns the name of the element type at \a index. Use elementTypeId() if
    you want the type id rather than the name of the type.

    Example:
    \code
    t.defineElement("QString", "expectedString");
    const char *etype = t.elementType(0); // etype is "QString"
    \endcode

    \sa elementTypeId()
*/

/*! \fn int QTestTable::elementTypeId(int index) const

    Returns the type id of the element at \a index.
    Please read Qt's QMetaType documentation for more information
    on Qt's type ids.

    Example:
    \code
    t.defineElement("QString", "expectedString");
    Q_ASSERT(t.elementTypeId(0) == QMetaType::QString);
    \endcode

    \sa elementType()
*/

/*! \fn QTestData * QTestTable::newData ( const char * tag )

    Creates a new row in the test table named \a tag. Use this function
    to append data to a QTestTable.

    Example:
    \code
    t.defineElement("QString", "string");
    *t.newData("random string") << "sajdfhsdf";
    *t.newData("empty string") << "";
    \endcode
*/

/*! \fn QTestData * QTestTable::testData ( int index ) const

    Returns the test data (row) at \a index. You usually don't
    have to call this function, since the QTest framework manages
    the test data.

    \sa newData()
*/

