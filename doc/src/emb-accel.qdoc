/****************************************************************************
**
** Copyright (C) 1992-$THISYEAR$ Trolltech AS. All rights reserved.
**
** This file is part of the Qt GUI Toolkit.
** EDITIONS: FREE, PROFESSIONAL, ENTERPRISE
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
****************************************************************************/

/*!
    \page emb-accel.html

    \title Adding an Accelerated Graphics Driver to Qt/Embedded

    Qt/Embedded has the capacity to make use of hardware accelerators.
    To use a hardware accelerator for a PCI or AGP driver, you must
    perform the following steps:

    \list 1
    \i 
    \bold{Define an accelerated descendant of QLinuxFbScreen.}

    This should implement QScreen::connect() to map its
    registers. Use \c qt_probe_bus to get a pointer to the PCI config
    space. This is where you should check that you're being pointed to the
    right device (using the PCI device/manufacturer ID information). Then
    use PCI config space to locate your device's accelerator registers in
    physical memory and mmap the appropriate region from \c /dev/mem.
    There is no need to map the framebuffer, QLinuxFbScreen will do
    this for you. Return false if a problem occurs at any point. \c
    QScreen::initDevice() will be called only by the QWS server and
    is guaranteed to be called before any drawing is done (and so is a
    good place to set registers to known states). connect() will be called
    by every connecting client.

    \i 
    \bold{Define an accelerated descendant of QGfxRaster.}

    This is where the actual drawing code goes. Anything not implemented
    in hardware can be passed back to QGfxRaster to do in software. Use
    the optype variable to make sure that accelerated and unaccelerated
    operations are synchronized (if you start drawing via software into an
    area where the hardware accelerator is still drawing then your drawing
    operations will appear to be in the wrong order). optype is stored in
    shared memory and is set to 0 by unaccelerated operations; accelerated
    operations should set it to 1. When a software graphics operation is
    requested and optype is 1, QGfxRaster::sync() is called; you should
    provide your own implementation of this that waits for the graphics
    engine to go idle. lastop is also available for optimisation and is
    stored in the shared space: this will not be set by the software-only
    QGfx and can be used to store the type of your last operation (e.g.
    drawing a rectangle) so that part of the setup for the next operation
    can be avoided when many of the same operations are performed in
    sequence.

    All drawing operations should be protected via a QWSDisplay::grab()
    before any registers, lastop or optype are accessed, and
    ungrabbed() at the end. This prevents two applications trying to
    access the accelerator at once and possibly locking up the machine.
    It's possible that your source data is not on the graphics card so you
    should check in such cases and fall back to software if necessary.
    Note that QGfxRaster supports some features not directly supported
    by QPainter (for instance, alpha channels in 32-bit data and
    stretchBlt's). These features are used by Qt; stretchBlt speeds up \c
    QPixmap::xForm() and drawPixmap() into a transformed QPainter,
    alpha channel acceleration is supported for 32-bit pixmaps.

    \i
    \bold{Optionally define an accelerated descendant of \c{QScreenCursor}.}

    restoreUnder(), saveUnder(), drawCursor() and draw() should
    be defined as null operations. Implement set(), move(),
    show() and hide(). 4KB is left for your cursor at the end of the
    visible part of the framebuffer (i.e. at (width*height*depth)/8 )

    \i
    \bold{Implement \c{QScreen} functions.}

    Implement initCursor() and createGfx() in your QScreen
    descendant. Implement useOffscreen() and return true if you can
    make use of offscreen graphics memory.

    \i
    \bold{Implement \c{qt_get_screen_mychip()}.}

    Implement a small function qt_get_screen_mychip(), which simply
    returns a new QMychipScreen

\omit ### DriverTable doesn't exist anymore
    \i
    \bold{Add your to the DriverTable table}

    The DriverTable table is in qgfxraster_qws.cpp,
    e.g.
    \code
    { "MyChip", qt_get_screen_mychip,1 },
    \endcode

    The first parameter is the name used with QWS_DISPLAY to request your
    accelerated driver.
\endomit

    \i
    \bold{Use your new driver.}

    To run with your new driver,
    \code
    export QWS_DISPLAY=MyChip 
    \endcode
    (optionally MyChip:/dev/fb\e{N} to request a different Linux
    framebuffer than /dev/fb0), then run the program.

    \endlist

    If your driver is not PCI or AGP, you'll need to inherit QScreen
    instead of QLinuxFbScreen and implement similar functionality to
    QLinuxFbScreen, but otherwise the process should be similar. The
    most complete example driver is qgfxmach64_qws.cpp;
    qgfxvoodoo_qws.cpp may provide a smaller and easier-to-understand
    driver.
*/
