/****************************************************************************
**
** Copyright (C) 1992-$THISYEAR$ $TROLLTECH$. All rights reserved.
**
** This file is part of the Qt GUI Toolkit.
** EDITIONS: FREE, PROFESSIONAL, ENTERPRISE
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
****************************************************************************/

/*!
    \page qtopiacore-accel.html
    \contentspage {Qtopia Core}{Contents}

    \title Adding an Accelerated Graphics Driver
    \ingroup qtopiacore

    Painting in Qtopia Core is a pure software implementation and is
    normally performed in two steps: Each window is rendered onto a
    QWSWindowSurface using QPaintEngine, and then the server composes
    the surface images and copies them to the screen. Qtopia Core
    uses QRasterPaintEngine (a raster-based implementation of
    QPaintEngine) to implement painting operations and QScreen to
    implement window composition.

    Starting with Qtopia Core 4.2, it is possible to add an
    accelerated graphics driver to take advantage of available
    hardware resources, using the following approach:

    \tableofcontents

    \warning This feature is under development and is subject to
    change.

    \section1 Step 1: Create a Custom Screen

    Create a custom screen by deriving from the QScreen class.

    You might want to accelerate the final copying to the screen by
    reimplementing the \l {QScreen::}{blit()} and \l
    {QScreen::}{solidFill()} functions.

    \section1 Step 2: Implement a Custom Raster Paint Engine

    Implement the painting operations by subclassing the
    QRasterPaintEngine class.

    To accelerate a graphics primitive, simply reimplement it in your
    custom paint engine. If there are cases you do not want to
    implement yourself (such as certain pens, brushes, modes, etc.),
    you can just call the QRasterPaintEngine versions.

    \section1 Step 3: Make the Paint Device Aware of Your Paint Engine

    To activate your paint engine you must create a subclass of the
    QCustomRasterPaintDevice class and reimplement its \l
    {QCustomRasterPaintDevice::}{paintEngine()} function. Let this
    function return a pointer to your paint engine. In addition, the
    QCustomRasterPaintDevice::memory() function must be reimplemented
    to return a pointer to the buffer where the painting should be
    done.

    \table
    \header \o Acceleration Without a Framebuffer
    \row
    \o

    If you are writing a driver for a device with an graphic I/O
    controller and no framebuffer support, the
    QCustomRasterPaintDevice::memory() function must return 0 (meaning
    no buffer available) in which case the paint engine will call the
    QRasterPaintEngine::drawColorSpans() and
    QRasterPaintEngine::drawBufferSpan() functions instead whenever a
    color or buffer should be written into memory.

    Note that the default implementations of these functions only
    calls qFatal() with an error message; reimplement the functions
    and let them do the appropriate communication with the I/O
    controller.

    \endtable

    \section1 Step 4: Make the Window Surface Aware of Your Paint Device

    Derive from the QWSWindowSurface class and reimplement its \l
    {QWSWindowSurface::}{paintDevice()} function. Make this function
    return your custom raster paint device.

    \section1 Step 5: Enable the Screen to Create an Instance of Your Window Surface

    Finally, reimplement QScreen's \l {QScreen::}{createSurface()}
    function and make this function able to create an instance of your
    QWSWindowSurface subclass.
*/
