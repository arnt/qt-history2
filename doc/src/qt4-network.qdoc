/*!
    \page qt4-network.html
    \title Qt 4: The Network Module

    The newtork module in Qt 4 provides some new features, such as
    support for internationalized domain names, better IPv6 support,
    and better performance. And since Qt 4 allows us to break binary
    compatibility with previous releases, we took this opportunity to
    improve the class names and API to make them more intuitive to
    use.

    \tableofcontents

    \section1 General Overview

    Compared to Qt 3, the network module in Qt 4 brings the following
    benefits:

    \list
    \i  The Qt 4 network classes have more intuitive names and APIs.
        For example, QServerSocket has been renamed QTcpServer.
    \i  The entire network module is \l{reentrant}, making it
        possible to use them simultaneously from multiple threads.
    \i  It is now possible to send and receive UDP datagrams and to
        use synchronous (i.e., blocking) sockets without having to
        use a low-level API (QSocketDevice in Qt 3).
    \i  QHostAddress and QDns support internationalized domain names
        (RFC 3492).
    \i  QUrl is more lightweight and fully supports the latest URI
        specification draft.
    \i  UDP broadcasting is now supported.
    \endlist

    The Qt 4 network module provides fundamental classes for writing
    TCP and UDP applications, as well as higher-level classes that
    implement the client side of the HTTP and FTP protocols.

    Here's an overview of the TCP and UDP classes:

    \list
    \i  QTcpSocket encapsulates a TCP socket. It inherits from
        QIODevice, so you can use QTextStream and QDataStream to read
        or write data. It is useful for writing both clients and
        servers.
    \i  QTcpServer allows you to listen on a certain port on a
        server. It emits a
        \l{QTcpServer::newConnection()}{newConnection()} signal every
        time a client tries to connect to the server. Once the
        connection is established, you can talk to the client using
        QTcpSocket.
    \i  QUdpSocket is an API for sending and receiving UDP datagrams.
    \endlist
    
    QTcpSocket and QUdpSocket inherit most of their functionality
    from QAbstractSocket. You can also use QAbstractSocket directly
    as a wrapper around a native socket descriptor, or subclass
    QAbstractSocket and implement your own socket type (e.g., for
    Unix domain sockets or Windows named pipes).

    By default, the socket classes work asynchronously (i.e., they
    are non-blocking), emitting signals to notify when data has
    arrived or when the peer has closed the connection. In
    multithreaded applications and in non-GUI applications, you also
    have the opportunity of setting the socket to blocking (using
    QAbstractSocket::setBlocking()), which often results in a more
    straightforward style of programming, with the networking logic
    concentrated in one or two functions instead of spread across
    multiple slots.

    QFtp and QHttp use QTcpSocket internally to implement the FTP and
    HTTP protocols. Both classes work asynchronously and can schedule
    (i.e., queue) requests.

    The network module contains four helper classes: QHostAddress,
    QDns, QUrl, and QUrlInfo. QHostAddress stores an IPv4 or IPv6
    address, QDns resolves host names into addresses, QUrl stores a
    URL, and QUrlInfo stores information about a resource pointed to
    by a URL, such as the file size and modification date. (Because
    QUrl is used by QTextBrowser, it is part of the QtGui library and
    not of QtNetwork.)

    \section1 Example Code

    All the code snippets presented here are quoted from
    self-contained, compilable examples located in Qt's \c
    examples/network directory.

    \section2 TCP Client

    The first example illustrates how to write a TCP client using
    QTcpSocket. The client talks to a fortune server that provides
    fortune to the user. Here's how to set up the socket:

    \quotefile network/fortuneclient/client.cpp
    \skipto tcpSocket =
    \printline tcpSocket =
    \skipto connect(tcpSocket
    \printline SLOT(readFortune())
    \printline SLOT(displayError(int))

    When the user requests a new fortune, the client establishes a
    connection to the server:

    \skipto tcpSocket->connectToHost(
    \printuntil ;

    When the server answers, the following code is executed to read
    the data from the socket:

    \skipto QDataStream in(tcpSocket)
    \printuntil currentFortune = nextFortune

    The server's answer starts with a \e size field (which we store
    in \c blockSize), followed by \e size bytes of data. If the
    client hasn't received all the data yet, it waits for the server
    to send more.

    An alternative approach is to use a blocking socket. The code can
    then be concentrated in one function:

    \quotefile network/blockingfortuneclient/thread.cpp
    \skipto const int Timeout
    \printuntil emit newFortune

    \section2 TCP Server

    The following code snippets illustrate how to write a TCP server
    using QTcpServer and QTcpSocket. Here's how to set up a TCP
    server:

    \quotefile network/fortuneserver/server.cpp
    \skipto tcpServer =
    \printuntil }
    \skipto connect(tcpServer
    \printline connect(tcpServer

    When a client tries to connect to the server, the following code
    in the \c sendFortune() slot is executed:

    \skipto QByteArray block;
    \printuntil clientConnection->close()

    \section2 UDP Senders and Receivers

    Here's how to broadcast a UDP datagram:

    \quotefile network/broadcastsender/sender.cpp
    \skipto udpSocket = new QUdpSocket
    \printline udpSocket
    \skipto QByteArray datagram
    \printuntil QHostAddress::Broadcast

    Here's how to receive a UDP datagram:

    \quotefile network/broadcastreceiver/receiver.cpp
    \skipto udpSocket = new QUdpSocket
    \printline udpSocket
    \skipto connect(udpSocket
    \printuntil );

    Then in the \c processPendingDatagrams() slot:

    \skipto hasPendingDatagrams
    \printuntil }

    \section1 Comparison with Qt 3

    The main difference between Qt 3 and Qt 4 is that the very high
    level QNetworkProtocol and QUrlOperator abstraction has been
    eliminated. These classes attempted the impossible (unify FTP and
    HTTP under one roof), and unsurprisingly failed at that. Qt 4
    still provides QFtp and QHttp classes, but only with the more
    mature API that appeared in Qt 3.1.

    The QSocket class in Qt 3 has been renamed QTcpSocket. The new
    class is reentrant and supports blocking. It's also easier to
    handle closing than with Qt 3, where you had to connect to both
    the QSocket::connectionClosed() and the
    QSocket::delayedCloseFinished() signals.

    The QServerSocket class in Qt 3 has been renamed QTcpServer. The
    API has changed quite a bit. While in Qt 3 it was necessary to
    subclass QServerSocket and reimplement the newConnection() pure
    virtual function, QTcpServer now emits a
    \l{QTcpServer::newConnection()}{newConnection()} signal that you
    can connect to a slot.

    The QDns class has been redesigned to use the operating system's
    \c getaddrinfo() function instead of implementing the DNS
    protocol. Internally, QDns simply starts a thread and calls \c
    getaddrinfo() in that thread. This wasn't possible in Qt 3
    because \c getaddrinfo() is a blocking call and Qt 3 could be
    configured without multithreading support.

    The QSocketDevice class in Qt 3 is no longer part of the public
    Qt API. If you used QSocketDevice to send or receive UDP
    datagrams, use QUdpSocket instead. If you used QSocketDevice
    because it supported blocking sockets, use QTcpSocket or
    QUdpSocket instead and call
    \l{QAbstractSocket::setBlocking()}{setBlocking()}. If you used
    QSocketDevice from a non-GUI thread because it was the only
    reentrant networking class in Qt 3, use QTcpSocket, QTcpServer,
    or QUdpSocket instead.

    Internally, Qt 4 has a class called QSocketLayer that provides a
    cross-platform low-level socket API. It resembles the old
    QSocketDevice class; we might make it public in a later release
    if users ask for it.

    As an aid to porting to Qt 4, the \l{Qt 3 compatibility library}
    includes Q3Dns, QServerSocket, QSocket, and QSocketDevice
    classes.

    \section1 Future Work

    The network classes's API and implementation are mostly finished,
    with the exception of QFtp and QHttp. We plan to add support for
    proxies, user names and password, and FTP active mode transfer
    before the first Qt 4.0 beta release.
*/
