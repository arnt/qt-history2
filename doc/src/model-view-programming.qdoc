/*!
\page model-view-programming.html
\nextpage model-view-model.html Model Classes
\startpage index.html Qt Reference Documentation

\title Model/View Programming

\tableofcontents

\section1 Introduction

Qt 4 introduces a new set of item view classes that use a model/view
architecture to manage the relationship between data and the way it
is presented to the user. The separation of functionality introduced by
this architecture gives developers greater flexibility and access to
more features than was previously possible.
In this document, we give a brief introduction to the model/view paradigm,
outline the concepts involved, and describe the architecture of the item
view system. Each of the components in the architecture is explained,
and examples are given that show how to use the classes provided.

\section1 The Model/View Architecture

Model-View-Controller (MVC) is a design pattern originating from
Smalltalk that is often used when building user interfaces.
In \l{Design Patterns}, Gamma et al. write:

\quote
MVC consists of three kinds of objects. The Model is the application
object, the View is its screen presentation, and the Controller defines
the way the user interface reacts to user input. Before MVC, user
interface designs tended to lump these objects together. MVC decouples
them to increase flexibility and reuse.
\endquote

If the view and the controller objects are combined, the result is
the model/view architecture. This still separates the data in the
model from its presentation to the user, but provides a simpler
framework based on the same principles. This separation makes it
possible to display data from the same model in several different
views, and to implement new types of views, without changing the
underlying model.
To allow flexible handling of user input, we introduce the concept of
the \e delegate. The advantage of using a delegate is that it allows
input methods to be defined in addition to those provided by the view,
but does not introduce additional complexity in the common case.

Generally, the model/view classes can be separated into the three groups
described above: models, views, and delegates. Each of these components
are defined by \e abstract classes that provide common interfaces and,
in some cases, default implementations of features.
Abstract classes are meant to be subclassed in order to provide the full
set of functionality expected by other components; this also allows
specialized components to be written.
For example, all item models are based on the \l QAbstractItemModel
class. This class can be used to provide models for views that represent
data in the form of tables, lists, and trees. However, the
\l QAbstractListModel and \l QAbstractTableModel classes are better
starting points for new list and table models because they provide
appropriate default implementations of common functions. Each of these
classes can be subclassed to provide models that support specialized
kinds of lists and tables.

Complete implementations are provided for different kinds of
view widgets based on the \l QAbstractItemView class. \l QListView
provides a complete implementation of a simple list widget,
\l QTableView displays items from a model in a tabular form, and
\l QTreeView shows model items in a hierarchical list. Although
these classes are ready-to-use implementations, they can also be
subclassed to provide customized views.

The abstract base class for delegates is the \l QAbstractItemDelegate
class. A default delegate implementation is provided by the
\l QItemDelegate class which is used as the default delegate by
standard view implementations.

A number of \e convenience classes are derived from the standard view
classes for the benefit of applications that rely on Qt's item-based
item view and table classes. They are not intended to be subclassed,
but simply exist to provide a familiar interface to the equivalent classes
in Qt 3.
Examples of such classes include \l QListWidget, \l QTreeWidget, and
\l QTableWidget; these offer compatibility with the \c QListBox,
\c QListView, and \c QTable classes from Qt 3.

\section1 The Model/View Components

The following sections describe the way in which the model/view pattern
is used in Qt. Each section provides an example of use, and is followed
by a section showing how you can create new components.

\list
\i \l{model-view-model.html}{Model Classes}
\i \l{model-view-subclassing-model.html}{Creating New Models}
\i \l{model-view-view.html}{View Classes}
\i \l{model-view-selection.html}{Handling Selections}
\i \l{model-view-delegate.html}{Delegate Classes}
\i \l{model-view-convenience.html}{Convenience Classes}
\endlist

See also the \l{model-view.html}{list of model/view classes}.

*/

/*!
\page model-view-model.html
\contentspage model-view-programming.html Contents
\previouspage model-view-programming.html Model/View Programming
\nextpage model-view-subclassing-model.html Creating New Models

\title Model Classes

\tableofcontents

\section1 Basic Concepts

In the model/view architecture, the model's purpose is to manage data,
and to provide a standard representation of that data to the other
components in the framework. In Qt, the standard interface to item models
is defined by the \l QAbstractItemModel class. This class exposes a
table-like interface to other components, regardless of how the data
is actually stored in the model or presented to the user. It also
notifies any attached views of changes to the model through the signals
and slots mechanism.

This section describes some basic concepts that
are central to the way models are accessed by other components. More
advanced concepts are discussed later.

\section2 Model Indexes

To ensure that representation of the data in the model
is kept separate from the way it is accessed, the concept of a
\e{model index} is introduced. Each item of data is represented by a
model index that is provided by the model when required, and that
knows which model it belongs to.

\code
QAbstractItemModel *model = index.model();
\endcode

As a result, only the model needs to know how items are stored, and the
type of data managed by the model can be defined fairly generally.

Model indexes provide \e temporary references to items, and can be used
to retrieve or modify their data. Since models may reorganize their
internal structures from time to time, model indexes may become invalid,
and should not be stored. If a long-term reference to a model item is
required, a \e{persistent model index} must be created. This provides a
reference to the item that the model keeps up-to-date.
Temporary model indexes are provided by the \l QModelIndex class, and
persistent model indexes are provided by the \l QPersistentModelIndex
class.

To obtain a model index for an item in a model, three properties must
be specified: a row number, a column number, and the model index of a
parent item. The following sections describe and explain these
properties in detail.

\section2 Rows and Columns

In its most basic form, an item model can be accessed as a simple table
in which items are located by their row and column numbers. \e{This does
not mean that the data in the model has to be stored in a tabular
structure} - the use of row and column numbers is only a convention to
allow components to communicate with each other.
We can retrieve information about any given item by specifying its row
and column numbers to the model, and we receive an index that
represents the item:

\code
QModelIndex index = model->index(row, column, ...);
\endcode

We can ask the model for the item's data by passing it the model index
corresponding to the item:

\code
QVariant value = model->data(index, ...);
\endcode

The following diagram shows a representation of a basic model in which
each item is located by a pair of row and column numbers. 

\img modelindex-no-parent.png

By specifying the relevant row and column numbers to the model we
obtain a model index that represents an item (shown highlighted) in the
model.

\section2 Parents of Items

A simple tabular model is ideal for representing items in a table, or
for representing lists of items in just a single column of a tabular structure.
However, structures such as tree views require the model to expose a more
flexible interface to the items within. As a result, each item can also be
the parent of another table of items, in much the same way that a top-level
item in a tree view can contain another list of items.

When requesting an index for a model item, we must provide some
information about the item's parent. Outside the model, the only way to
refer to an item is through a model index, so a parent model index must
also be given:

\code
QModelIndex index = model->index(row, column, parent);
\endcode

The following diagram shows the row numbers, column numbers, and parent
indexes for two items in the model: a top-level item, and one of its
children.

\img modelindex-parent.png

The model index of the highlighted top-level item is represented by the
'X' symbol, and this is given as the parent of the highlighted child
item.
Top-level items in a model do not have a parent model index
to refer to, so we ensure that the model knows that we are referring to
a top-level item by specifying a \c Null model index.
This is a convention used by the model/view classes.
We can obtain the model indexes for both items shown in the diagram:

\code
QModelIndex topLevelIndex = model->index(2, 1, QModelIndex()); // 'X'
QModelIndex childIndex = model->index(3, 4, topLevelIndex);
\endcode

Note that we used \c QModelIndex() to construct an invalid model
index.

\section2 Item Roles

Items in a model can perform various \e roles for other components,
allowing different kinds of data to be supplied for different situations.
For example, the \l{QAbstractItemModel::Role}{DisplayRole} role is used
to access a string that can be displayed as text in a view.
Typically, items contain data for a number of different roles.

\img modelview-roles.png

The role indicates to the model which type of data is being referred to.
Views can display the roles in different ways, so it is important to
supply appropriate information for each role.
We will examine roles in more detail when we
\l{model-view-subclassing-model.html}{create an example model}.

\section2 Summary of Concepts

Model indexes contain information about the location of items within a
model. Items are referred to by their row and column numbers, and by
the model index of their parent item.
Model indexes are constructed by models at the request of other
components, such as views and delegates.

If a valid parent index is specified when an index is constructed,
the index refers to a child of the corresponding parent item; otherwise
the index refers to a top-level item in the model.

The \l{QAbstractItemModel::Role}{role} distinguishes between the
different kinds of data associated with an item.


\section1 Using an Existing Model

One of the models provided by Qt is the \l QDirModel, a model that
maintains information about the contents of a directory. This provides a
ready-to-use model to experiment with, and can be easily set up using
existing data. Using this model, we can show how to set up a model for
use with ready-made views, and explore how to manipulate data using
model indexes.

\section2 Using Views with a Model

The \l QListView and \l QTreeView classes are the most suitable views
to use with QDirModel. The example presented below displays the
contents of a directory in a tree view next to the same information in
a list view. The views share the user's selection so that the selected
items are highlighted in both views.

\img shareddirmodel.png

We set up a QDirModel so that it is ready for use, and create some
views to display the contents of a directory. This shows the simplest
pattern of use of a model. The construction and use of the model is
performed from within a single main() function:

\quotefile shareddirmodel/main.cpp
\skipto int main
\printuntil QDirModel

The model is set up to use data from a default directory, and is given
an arbitrary widget as its parent object. The parent can be any subclass
of QObject. We create two views so that we can examine the items held in
the model:

\printto QItemSelectionModel

The views are constructed in the same way as other widgets. Setting up
a view to display the items in the model is simply a matter of calling its
\l{QAbstractItemView::setModel()}{setModel()} function with the directory
model as the argument.

The rest of the function just displays the views within a splitter
widget, and runs the application's event loop:

\skipto splitter
\printuntil }

In the above example, we neglected to mention how to handle selections
of items. This subject is covered in more detail in the
\l{model-view-selection.html}{handling selections} section.

\section2 Using Model Indexes

To demonstrate how data can be retrieved from a model, using model
indexes, we set up a QDirModel without a view and display the
names of files and directories in a widget.
Although this does not show a normal way of using a model, it demonstrates
the conventions used by models when dealing with model indexes.

We construct a directory model in the same way as before:

\quotefile simplemodel-use/main.cpp
\skipto QDirModel *model
\printuntil int numRows

In this case, we ensure that all files and directories are reported by
the model by setting the file filter, and we count the number of rows
in the model using the \l{QDirModel::rowCount()}{rowCount()} function.

For simplicity, we are only interested in the items in the first column
of the model. We examine each row in turn, obtaining a model index for
the first item in each row, and reading the data stored for that item
in the model.

\skipto for (
\printuntil QModelIndex index

To obtain a model index, we specify the row number, column number (zero
for the first column), and the appropriate parent model index for
top-level model items (the default invalid model index).
The text stored in each item is retrieved using the model's
\l{QDirModel::data()}{data()} function. We specify the model index and
the \l{QAbstractItemModel::Role}{DisplayRole} to obtain data for the
item in the form of a string.

\skipto QString text
\printuntil // Display
\skipto }
\printuntil }

The above example demonstrates the basic principles used to retrieve
data from a model:

\list
\i The dimensions of a model can be found using
   \l{QAbstractItemModel::rowCount()}{rowCount()} and
   \l{QAbstractItemModel::columnCount()}{columnCount()}.
   These functions generally require a parent model index to be
   specified.
\i Model indexes are used to access items in the model. The row, column,
   and parent model index are needed to specify the item.
\i To access top-level items in a model, specify a null model index
   as the parent index with \c QModelIndex().
\i Items contain data for different roles. To obtain the data for a
   particular role, both the model index and the role must be supplied
   to the model.
\endlist


\section1 Further Reading

New models can be created by implementing the standard interface provided
by QAbstractItemModel. We will demonstrate this by
\l{model-view-subclassing-model.html}{creating a new model}
to provide a convenient ready-to-use model for holding strings.

*/

/*!
\page model-view-view.html
\contentspage model-view-programming.html Contents
\previouspage model-view-subclassing-model.html Creating New Models
\nextpage model-view-selection.html Handling Selections

\title View Classes

\tableofcontents

\section1 Concepts

In the model/view architecture, the view presents data from the model to
the user. The way in which the data is presented can be completely
different from the model's own representation of the data. This
separation of content and presentation is achieved by the use of a
\l{QAbstractItemModel}{standard interface} for the model classes,
an interface provided by the \l QAbstractItemView class, and
the use of model indexes that represent model items in a general way.
Views typically manage the overall layout of the model's representation.
They may render individual items themselves, or use
\l{model-view-delegate.html}{delegates} to handle both input and output
capabilities.

As well as presenting data, views handle navigation between items,
and some aspects of item selection. The views also implement basic
user interface features, such as context menus and drag and drop.
A view can provide default editing facilities for items, or it may
work with a \l{model-view-delegate.html}{delegate} to provide a custom
editor.

A view can be constructed without a model, but a model must be
provided before it can display useful information. Views keep track of
the items that the user has selected through the use of
\l{model-view-selection.html}{selections} which can be maintained
separately for each view, or shared between multiple views.

Some views, such as \l QTableView and \l QTreeView, display headers
as well as items. These are also implemented by a view class,
\l QHeaderView. Headers usually access the same model as the view
that displays them. They retrieve a different
\l{QModelIndex::Type}{type} of data to that shown in the rest of
the view, and usually display it in the form of a label. New headers
can be subclassed from the \l QHeaderView class to provide more
specialized labelling for views.

\section1 Using an Existing View

Qt provides three ready-to-use view classes that present data from
models in ways that are familiar to most users.
\l QListView displays items from a model in the form of a simple list;
these can be text labels or icons. \l QTreeView displays items from a
model as a hierarchy of lists, allowing deeply nested structures to be
represented in a compact way. \l QTableView presents items from a model
in the form of a table, much like the layout of a spreadsheet
application.

\img standard-views.png

The default behavior of the standard views shown above should be
sufficient for use in most applications. They provide basic editing
facilities, and can be customized to suit the needs of more specialized
user interfaces.

\section2 Using a Model 

We take the \l{model-view-subclassing-model.html}{string list model}
that we created as an example model, set it up with some data, and
construct a view to display the contents of the model. This can all
be performed within a single function:

\quotefile stringlistmodel/main.cpp
\skipto int main
\printuntil QAbstractItemModel

Note that the \c StringListModel is declared as a \l QAbstractItemModel.
This allows us to use the abstract interface to the model, and
ensures that the code will still work even if we replace the string list
model with a different model in the future.

The list view provided by \l QListView is sufficient for presenting
the items in the string list model. We construct the view, and set up
the model using the following lines of code:

\skipto QListView
\printuntil QListView
\skipto view->setModel
\printuntil view->setModel

The view is shown in the normal way:

\skipto view->show
\printuntil }

The view renders the contents of a model, accessing data via the model's
interfaces. When the user tries to edit an item, the view uses a default
delegate to provide an editor widget.

\img stringlistmodel.png

The above image shows how a \l QListView represents the data in the
string list model. Each item in the list can be edited with the default
delegate.

\section2 Using Multiple Views onto the Same Model

Providing multiple views onto the same model is simply a matter of
setting the same model for each view. In the following code, we create
two table views, each using the same simple table model which we have
created for this example:

\quotefile sharedtablemodel/main.cpp
\skipto QTableView *first
\printuntil QTableView *second
\skipto firstTableView->
\printuntil secondTableView->

The use of signals and slots in the model/view architecture means that
changes to the model can be propagated to all the attached views,
ensuring that we can always access the same data regardless of the
view being used.

\img sharedmodel-tableviews.png

The above image shows two different views onto the same model, each
containing a number of selected items. Although the data from the model
is shown consistently across view, each view maintains its own internal
selection model. This can be useful in certain situations but, for
many applications, a shared selection model is desirable.

\section1 Handling Selections of Items

The mechanism for handling selections of items within views is provided
by the \l QItemSelectionModel class. All of the standard views construct
their own selection models by default, and interact with them in the
normal way. The selection model being used by a view can be obtained
through the \l{QAbstractItemView::selectionModel()}{selectionModel()}
function, and a replacement selection model can be specified with
\l{QAbstractItemView::setSelectionModel()}{setSelectionModel()}.
The ability to control the selection model used by a view is useful
when we want to provide multiple consistent views onto the same model
data.

Generally, unless you are subclassing a model or view, you will not
need to manipulate the contents of selections directly. However, the
interface to the selection model can be accessed, if required, and
this is explored in the section on
\l{model-view-selection.html}{handling selections}.

\section2 Sharing Selections Between Views

Although it is convenient that the view classes provide their own
selection models by default, when we use more than one view onto the
same model it is often desirable that both the model's data and the
user's selection are shown consistently in all views.
Since the view classes allow their internal selection models to be
replaced, we can achieve a unified selection between views with the
following line:

\quotefile sharedtablemodel/main.cpp
\skipto secondTableView->setSelectionModel
\printuntil secondTableView->setSelectionModel

The second view is given the selection model for the first view.
Both views now operate on the same selection model, keeping both
the data and the selected items synchronized.

\img sharedselection-tableviews.png

In the example shown above, two views of the same type were used to
display the same model's data. However, if two different types of view
were used, the selected items may be represented very differently in
each view; for example, a contiguous selection in a table view can be
represented as a fragmented set of highlighted items in a tree view.

*/

/*!
\page model-view-delegate.html
\contentspage model-view-programming.html Contents
\previouspage model-view-selection.html Handling Selections
\nextpage model-view-convenience.html Convenience Classes

\title Delegate Classes

\tableofcontents

\section1 Concepts

Unlike the Model-View-Controller pattern, the model/view design does not
include a completely separate component for managing interaction with
the user. Generally, the view is responsible for the presentation of
model data to the user, and for processing user input. To allow some
flexibility in the way this input is obtained, the interaction is
performed by delegates. These components provide input capabilities
and are also responsible for rendering individual items in some views.
The standard interface for controlling delegates is defined in the
\l QAbstractItemDelegate class.

Delegates are expected to be able to render their contents themselves
by implementing the \l{QAbstractItemDelegate::paint()}{paint()}
and \l{QAbstractItemDelegate::sizeHint()}{sizeHint()} functions.
However, simple widget-based delegates can subclass \l QItemDelegate
instead of \l QAbstractItemDelegate, and take advantage of the default
implementations of those functions.
Editors for delegates can be implemented in two ways, either by using
widgets to manage the editing process, or by handling events directly.
The first approach is covered later in this section.


\section1 Using an Existing Delegate

The standard views provided with Qt use instances of \l QItemDelegate
to provide editing facilities. This default implementation of the
delegate interface renders items in the usual style for each of the
standard views: \l QListView, \l QTableView, and \l QTreeView.
The delegate being used for a view is returned by the
\l{QAbstractItemView::itemDelegate()}{itemDelegate()} function.
The \l{QAbstractItemView::setItemDelegate()}{setItemDelegate()} function
allows you to install a custom delegate for a standard view, and it is
necessary to use this function when setting the delegate for a custom
view.


\section1 A Simple Delegate

The delegate implemented here uses a \l QSpinBox to provide editing
facilities, and is mainly intended for use with models that display
integers. Although we set up a custom integer-based table model for
this purpose, we could easily have used \l QStandardItemModel instead
since the custom delegate will control data entry. We construct a
table view to display the contents of the model, and this will use
the custom delegate for editing.

\img spinboxdelegate-example.png

We subclass the delegate from \l QItemDelegate because we do not want
to write custom display functions. However, we must still provide
functions to manage the editor widget:

\quotefromfile itemviews/spinboxdelegate/delegate.h
\skipto class SpinBoxDelegate
\printuntil };

Note that no editor widgets are set up when the delegate is
constructed. We only construct an editor widget when it is needed.

\section2 Providing an Editor

In this example, when the table view needs to provide an editor, it
asks the delegate to provide an editor widget that is appropriate
for the item being modified. The
\l{QAbstractItemDelegate::createEditor()}{createEditor()} function is
supplied with everything that the delegate needs to be able to set up
a suitable widget:

\quotefromfile itemviews/spinboxdelegate/delegate.cpp
\skipto QWidget *SpinBoxDelegate::createEditor
\printuntil }

Note that we do not need to keep a pointer to the editor widget because
the view takes responsibility for destroying it when it is no longer
needed.

We install the delegate's default event filter on the editor to ensure
that it provides the standard editing shortcuts that users expect.
Additional shortcuts can be added to the editor to allow more
sophisticated behavior; these are discussed in the section on
\l{#EditingHints}{Editing Hints}.

The view ensures that the editor's data and geometry are set
correctly by calling functions that we define later for these purposes.
We can create different editors depending on the model index supplied
by the view. For example, if we have a column of integers and a column
of strings we could return either a \c QSpinBox or a \c QLineEdit,
depending on which column is being edited.

The delegate must provide a function to copy model data into the
editor. In this example, we read the data stored in the
\l{QAbstractItemModel::Role}{display role}, and set the value in the
spin box accordingly.

\skipto void SpinBoxDelegate::setEditorData
\printuntil }

In this example, we know that the editor widget is a spin box, but we
could have provided different editors for different types of data in
the model, in which case we would need to cast the widget to the
appropriate type before accessing its member functions.

\section2 Submitting Data to the Model

When the user has finished editing the value in the spin box, the view
asks the delegate to store the edited value in the model by calling the
\l{QAbstractItemDelegate::setModelData()}{setModelData()} function.

\quotefromfile itemviews/spinboxdelegate/delegate.cpp
\skipto void SpinBoxDelegate::setModelData
\printuntil /^\}/

Since the view manages the editor widgets for the delegate, we only
need to update the model with the contents of the editor supplied.
In this case, we ensure that the spin box is up-to-date, and update
the model with the value it contains using the index specified.

The standard \l QItemDelegate class informs the view when it has
finished editing by emitting the 
\l{QAbstractItemDelegate::closeEditor()}{closeEditor()} signal.
The view ensures that the editor widget is closed and destroyed. In
this example, we only provide simple editing facilities, so we need
never emit this signal.

All the operations on data are performed through the interface
provided by \l QAbstractItemModel. This makes the delegate mostly
independent from the type of data it manipulates, but some
assumptions must be made in order to use certain types of
editor widgets. In this example, we have assumed that the model
always contains integer values, but we can still use this
delegate with different kinds of models because \l{QVariant}
provides sensible default values for unexpected data.

\section2 Updating the Editor's Geometry

It is the responsibility of the delegate to manage the editor's
geometry. The geometry must be set when the editor is created, and
when the item's size or position in the view is changed. Fortunately,
the view provides all the necessary geometry information inside a
\l{QStyleOptionViewItem}{view option} object.

\skipto void SpinBoxDelegate::updateEditorGeometry
\printuntil }

In this case, we just use the geometry information provided by the
view option in the item rectangle. A delegate that renders items with
several elements would not use the item rectangle directly. It would
position the editor in relation to the other elements in the item.

\target EditingHints
\section2 Editing Hints

After editing, delegates should provide hints to the other components
about the result of the editing process, and provide hints that will
assist any subsequent editing operations. This is achieved by
emitting the \l{QAbstractItemDelegate::closeEditor()}{closeEditor()}
signal with a suitable hint. This is taken care of by the default
QItemDelegate event filter which we installed on the spin box when
it was constructed.

The behavior of the spin box could be adjusted to make it more user
friendly. In the default event filter supplied by QItemDelegate, if
the user hits \key Return to confirm their choice in the spin box,
the delegate commits the value to the model and closes the spin box.
We can change this behavior by installing our own event filter on the
spin box, and provide editing hints that suit our needs; for example,
we might emit \l{QAbstractItemDelegate::closeEditor()}{closeEditor()}
with the \l{QAbstractItemDelegate::EndEditHint}{EditNextItem} hint to
automatically start editing the next item in the view.

Another approach that does not require the use of an event
filter is to provide our own editor widget, perhaps subclassing
QSpinBox for convenience. This alternative approach would give us
more control over how the editor widget behaves at the cost of
writing additional code. It is usually easier to install an event
filter in the delegate if you need to customize the behavior of
a standard Qt editor widget.

Delegates do not have to emit these hints, but those that do not will
be less integrated into applications, and will be less usable than
those that emit hints to support common editing actions.

*/

/*!
\page model-view-selection.html
\contentspage model-view-programming.html Contents
\previouspage model-view-view.html View Classes
\nextpage model-view-delegate.html Delegate Classes

\title Handling Selections

\tableofcontents

\section1 Concepts

The selection model used in the new item view classes offers many
improvements over the selection model used in Qt 3. It provides a
more general description of selections based on the facilities of
the model/view architecture. Although the standard classes for
manipulating selections are sufficient for the item views provided,
the selection model allows you to create specialized selection models
to suit the requirements for your own item models and views.

Information about the items selected in a view is stored in an instance
of the \l QItemSelectionModel class. This maintains model indexes for
items in a single model, and is independent of any views. Since there
can be many views onto a model, it is possible to share selections
between views, allowing applications to show multiple views in a
consistent way.

Selections are made up of \e{selection ranges}. These efficiently
maintain information about large selections of items by recording
only the starting and ending model indexes for each range of selected
items. Non-contiguous selections of items are constructed by using
more than one selection range to describe the selection.

Selections are applied to a collection of model indexes held by
a selection model. The most recent selection of items applied is
known as the \e{current selection}. The effects of this selection can
be modified even after its application through the use of certain
types of selection commands. These are discussed later in this
section.

When manipulating selections, it is often helpful to think of
\l QItemSelectionModel as a record of the selection state of all the
items in an item model. Once a selection model is set up, collections
of items can be selected, deselected, or their selection states can
be toggled without the need to know which items are already selected.
The indexes of all selected items can be retrieved at any time, and
other components can be informed of changes to the selection model
via the signals and slots mechanism.


\section1 Using a Selection Model

The standard view classes provide default selection models that can
be used in most applications. A selection model belonging to one view
can be obtained using the view's
\l{QAbstractItemView::selectionModel()}{selectionModel()} function,
and shared between many views with
\l{QAbstractItemView::setSelectionModel()}{setSelectionModel()},
so the construction of new selection models is generally not required.

A selection is created by specifying a model, and a pair of model
indexes to a \l QItemSelection. This uses the indexes to refer to items
in the given model, and interprets them as the top-left and bottom-right
items in a block of selected items.
To apply the selection to items in a model requires the selection to be
submitted to a selection model; this can be achieved in a number of ways,
each having a different effect on the selections already present in the
selection model.


\section2 Selecting Items

To demonstrate some of the principal features of selections, we construct
an instance of a custom table model with 32 items in total, and open a
table view onto its data:

\quotefile itemselection/main.cpp
\skipto TableModel
\printuntil QItemSelectionModel

The table view's default selection model is retrieved for later use.
We do not modify any items in the model, but instead select a few
items that the view will display at the top-left of the table. To do
this, we need to retrieve the model indexes corresponding to the
top-left and bottom-right items in the region to be selected:

\skipto QModelIndex topLeft
\printuntil bottomRight = model->index

To select these items in the model, and see the corresponding change
in the table view, we need to construct a selection object then apply
it to the selection model. We must also specify the model that the
indexes belong to because the model indexes do not contain this
information:

\skipto QItemSelection
\printuntil selectionModel->select

The selection is applied to the selection model using a command
defined by a combination of
\l{QItemSelectionModel::SelectionFlag}{selection flags}.
In this case, the flags used cause the items recorded in the
selection object to be included in the selection model, regardless
of their previous state. The resulting selection is shown by the view.

\img selected-items1.png

The selection of items can be modified using various operations that
are defined by the selection flags. The selection that results from
these operations may have a complex structure, but will be represented
efficiently by the selection model. The use of different selection
flags to manipulate the selected items is described when we examine
how to update a selection.

\section2 Reading the Selection State

The model indexes stored in the selection model can be read using
the \l{QItemSelectionModel::selectedItems()}{selectedItems()}
function. This returns an unsorted list of model indexes that we can
iterate over as long as we know which model they are for:

\quotefile reading-selections/window.cpp
\skipto QModelIndexList indexes
\printuntil }

The above code uses Qt's convenient \l{containers.html}{foreach
keyword} to iterate over, and modify, the items corresponding to the
indexes returned by the selection model.

The selection model emits signals to indicate changes in the
selection. These notify other components about changes to both the
selection as a whole and the currently focused item in the item
model. We can connect the
\l{QItemSelectionModel::selectionChanged()}{selectionChanged()}
signal to a slot, and examine the items in the model that are selected or
deselected when the selection changes. The slot is called with two
\l{QItemSelection} objects: one contains a list of indexes that
correspond to newly selected items; the other contains indexes that
correspond to newly deselected items.

In the following code, we provide a slot that receives the
\l{QItemSelectionModel::selectionChanged()}{selectionChanged()}
signal, fills in the selected items with
a string, and clears the contents of the deselected items.

\quotefile updating-selections/window.cpp
\skipto void MainWindow::updateSelection
\printuntil model->setData
\printuntil }
\printuntil }

We can keep track of the currently focused item by connecting the
\l{QItemSelectionModel::currentChanged()}{currentChanged()} signal
to a slot that is called with two model indexes. These correspond to
the previously focused item, and the currently focused item.

In the following code, we provide a slot that receives the
\l{QItemSelectionModel::currentChanged()}{currentChanged()} signal,
and uses the information provided to update the status bar of a
\l QMainWindow:

\skipto void MainWindow::changeCurrent
\printuntil }

Monitoring selections made by the user is straightforward with these
signals, but we can also update the selection model directly.

\section2 Updating a Selection

Selection commands are provided by a combination of selection flags,
defined by \l{QItemSelectionModel::SelectionFlag}.
Each selection flag tells the selection model how to update its
internal record of selected items when either of the
\l{QItemSelection::select()}{select()} functions are called.
The most commonly used flag is the
\l{QItemSelectionModel::SelectionFlag}{Select} flag
which instructs the selection model to record the specified items as
being selected. The
\l{QItemSelectionModel::SelectionFlag}{Toggle} flag causes the
selection model to invert the state of the specified items,
selecting any deselected items given, and deselecting any currently
selected items. The \l{QItemSelectionModel::SelectionFlag}{Deselect}
flag deselects all the specified items.

Individual items in the selection model are updated by creating a
selection of items, and applying them to the selection model. In the
following code, we apply a second selection of items to the table
model shown above, using the
\l{QItemSelectionModel::SelectionFlag}{Toggle} command to invert the
selection state of the items given.

\quotefile itemselection/main.cpp
\skipto QItemSelection toggle
\printuntil selectionModel->select

The results of this operation are displayed in the table view,
providing a convenient way of visualizing what we have achieved:

\img selected-items2.png

By default, the selection commands only operate on the individual
items specified by the model indexes. However, the flag used to
describe the selection command can be combined with additional flags
to change entire rows and columns. For example if you call
\l{QItemSelectionModel::select()}{select()} with only one index, but
with a command that is a combination of
\l{QItemSelectionModel::SelectionFlag}{Select} and
\l{QItemSelectionModel::SelectionFlag}{Rows}, the
entire row containing the item referred to will be selected.
The following code demonstrates the use of the
\l{QItemSelectionModel::SelectionFlag}{Rows} and 
\l{QItemSelectionModel::SelectionFlag}{Columns} flags:

\skipto QItemSelection columnSelection
\printuntil QItemSelectionModel::Select | QItemSelectionModel::Rows

Although only four indexes are supplied to the selection model, the
use of the 
\l{QItemSelectionModel::SelectionFlag}{Columns} and
\l{QItemSelectionModel::SelectionFlag}{Rows} selection flags means
that two columns and two rows are selected. The following image shows
the result of these two selections:

\img selected-items3.png

The commands performed on the example model have all involved
accumulating a selection of items in the model. It is also possible
to clear the selection, or to replace the current selection with
a new one.

To replace the current selection with a new selection, combine
the other selection flags with the
\l{QItemSelectionModel::SelectionFlag}{Current} flag. A command using
this flag instructs the selection model to replace its current collection
of model indexes with those specified in a call to
\l{QItemSelectionModel::select()}{select()}.
To clear all selections before you start adding new ones,
combine the other selection flags with the
\l{QItemSelectionModel::SelectionFlag}{Clear} flag. This
has the effect of resetting the selection model's collection of model
indexes.

\section2 Selecting All Items in a Model

To select all items in a model, it is necessary to create a
selection for each level of the model that covers all items in that
level. We do this by retrieving the indexes corresponding to the
top-left and bottom-right items with a given parent index:

\quotefile reading-selections/window.cpp
\skipto void MainWindow::selectAll()
\skipto QModelIndex topLeft
\printuntil model->columnCount

A selection is constructed with these indexes and the model. The
corresponding items are then selected in the selection model:

\skipto QItemSelection selection
\printuntil selectionModel->select

This needs to be performed for all levels in the model.
For top-level items, we would define the parent index in the usual way:

\quotefile reading-selections/window.cpp
\skipto void MainWindow::selectAll()
\skipto QModelIndex parent
\printuntil QModelIndex parent

For hierarchical models, the
\l{QAbstractItemModel::hasChildren()}{hasChildren()} function is used to
determine whether any given item is the parent of another level of
items.

*/

/*!
    \page model-view-subclassing-model.html
    \contentspage model-view-programming.html Contents
    \previouspage model-view-model.html Model Classes
    \nextpage model-view-view.html View Classes

    \title Creating New Models

    \tableofcontents

    \section1 Introduction

    The separation of functionality between the components in the model/view
    architecture enables new models to be written that can take advantage
    of existing views. This approach lets us present data from a variety of
    sources using standard graphical user interface components.
    The interface provided by the \l QAbstractItemModel class supports
    models that arrange their data in hierarchical structures, allowing for
    the possibility that data will be inserted, removed, changed, or sorted
    in some way. It also provides support for drag and drop operations.

    In this chapter, we create a simple read-only model to explore
    the basic principles of the model/view architecture. Later in this
    chapter, we will adapt this simple model so that items can be modified
    by the user.

    For an example of a more complex model, see the
    \l{itemviews/simpletreemodel}{Simple Tree Model} example.

    \section1 A Read-Only Example Model

    The model implemented here is a simple, non-hierarchical, read-only data
    model. It has a \l QStringList as its internal data source, and
    implements only what is needed to make a functioning model. To make the
    implementation easier, we subclass \l QAbstractListModel because it
    defines sensible default behavior for list models, and it exposes a
    simpler interface than the \l QAbstractItemModel class.

    When implementing a model it is important to remember that
    \l QAbstractItemModel does not store any data itself, it merely
    presents an interface that the views use to access the data.
    For a minimal read-only model it is only necessary to implement a few
    functions as there are default implementations for most of the
    interface. The class declaration is as follows:

    \quotefile stringlistmodel/model.h

    \skipto class
    \printuntil /^\};/

    Apart from the model's constructor, we only need to implement two
    functions: \l{QAbstractItemModel::rowCount()}{rowCount()} returns the
    number of rows in the model, and \l{QAbstractItemModel::data()}{data()}
    returns an item of data corresponding to a specified model index.

    Note that this is a non-hierarchical model, so we don't have to worry
    about the parent-child relationships. If our model was hierarchical, we
    would also have to implement the
    \l{QAbstractItemModel::index()}{index()} and
    \l{QAbstractItemModel::parent()}{parent()} functions.

    \section2 Dimensions of The Model

    We want the number of rows in the model to be the same as the number of
    strings in the string list. We implement the
    \l{QAbstractItemModel::rowCount()}{rowCount()} function with this in
    mind:

    \quotefile stringlistmodel/model.cpp
    \skipto int StringListModel
    \printuntil }

    Since the model is non-hierarchical, we can safely ignore the model index
    corresponding to the parent item. By default, models derived from
    \l QAbstractListModel only contain one column, so we do not need to
    reimplement the \l{QAbstractItemModel::columnCount()}{columnCount()}
    function.

    \section2 Model Headers and Data

    For items in the view, we want to return the strings in our string list:
    The \l{QAbstractItemModel::data()}{data()} function is responsible for
    returning the data that corresponds to the index argument.

    \skipto QVariant StringListModel::data
    \printuntil }

    If our model is displayed in a view with headers, we want the headers
    to show the row and column numbers. We can provide information about
    the headers by subclassing the
    \l{QAbstractItemModel::headerData()}{headerData()} function:

    \skipto QVariant StringListModel::headerData
    \printuntil }

    An item can have several roles, giving out different data depending on the
    role specified. The items in our model only have one role,
    \l{QAbstractItemModel::Role}{DisplayRole}, so we return the data
    for items irrespective of the role specified.
    However, we could reuse the data we provide for the
    \l{QAbstractItemModel::Role}{DisplayRole} in
    other roles, such as the
    \l{QAbstractItemModel::Role}{ToolTipRole} that views can use to
    display information about items in a tooltip.

    \section1 An Editable Model

    The read-only model shows how simple choices could be presented to the
    user but, for many applications, an editable list model is much more
    useful. We can modify the read-only model to make the items editable
    by implementing two extra functions:
    \l{QAbstractItemModel::flags()}{flags()} and
    \l{QAbstractItemModel::setData()}{setData()}.
    These are added to the class declaration:

    \quotefile stringlistmodel/model.h
    \skipto ItemFlags flags
    \printuntil setData

    \section2 Making the Model Editable

    A delegate checks whether an item is editable before creating an
    editor. The model must let the delegate know that its items are
    editable. We do this by returning the correct flags for each item in
    the model; in this case, we enable all items and make them both
    selectable and editable:

    \quotefile stringlistmodel/model.cpp
    \skipto ItemFlags StringListModel::flags
    \printuntil }

    Note that we do not have to know how the delegate performs the actual
    editing process. We only have to provide a way for the delegate to set the
    data in the model. This is achieved through the
    \l{QAbstractItemModel::setData()}{setData()} function:

    \quotefile stringlistmodel/model.cpp
    \skipto bool StringListModel::setData
    \printuntil }
    \printuntil }

    In this model, the item in the string list that corresponds to the model
    index specified is replaced by the data provided by the delegate.
    However, before we actally set the data in the model, we make sure that
    the index is valid, the item is of the correct type, and that the role is
    supported. We insist that the role must be the
    \l{QAbstractItemModel::Role}{EditRole} since this indicates to us that
    the item is being modified by an editing operation. The underlying data
    in this model is the same for all roles, so this detail just makes it
    easier to integrate the model with other standard components.

    When the data has been set, the model must let the views know that the
    data in the model has changed. This is done by emitting the
    \l{QAbstractItemModel::dataChanged()}{dataChanged()} signal. Since
    only one item has changed, the range of items specified in the signal
    is limited to just one item.

    \section2 Inserting and Removing Rows

    It is possible to change the number of rows and columns in a model. In the
    string list model it only makes sense to change the number of rows, so we
    reimplement the functions for inserting and removing rows. These are
    declared in the class definition:

    \quotefile stringlistmodel/model.h
    \skipto bool insertRows
    \printuntil bool removeRows

    We implement a function to allow rows to be inserted into the model:

    \quotefile stringlistmodel/model.cpp
    \skipto bool StringListModel::insertRows
    \printuntil return true
    \printuntil }

    Since rows in this model correspond to strings in a list, this function
    inserts a number of empty strings into the list before the given position.
    The number of strings is equivalent to the number of rows specified.
    The parent index is normally used to determine which table of items in
    the model is being referred to. In this case, we only have a single
    top-level list of string, so we just insert empty strings into that list.
    We could check the parent index to see whether it corresponds to an item
    in the list, and return false to indicate failure.

    The model emits the \l{QAbstractItemModel::rowsInserted()}{rowsInserted()}
    signal to inform other components that the number of rows has changed,
    specifying the first and last rows that were inserted.
    Note that the signal is always emitted after the rows are inserted,
    allowing other components to immediately access the new rows.

    The function to remove rows from the model is also simple to write:

    \quotefile stringlistmodel/model.cpp
    \skipto bool StringListModel::removeRows
    \printuntil return true
    \printuntil }

    The rows to be removed from the model are specified by the position and
    the number of rows given. 
    We ignore the parent index to simplify our implementation, and just
    remove the corresponding items from the string list.
    The \l{QAbstractItemModel::rowsAboutToBeRemoved()}{rowsAboutToBeRemoved()}
    signal is always emitted before the rows are removed, specifying the first
    and last rows to be removed. This is to allow other components to access
    the data before it is removed.

    \section1 Next Steps

    We can display the contents of this model using the \l QListView class
    to present the model's items in the form of a vertical list. For the
    string list model, this view also provides a default editor so that
    the items can be manipulated. We examine the possibilities made
    available by the standard view classes in the
    \l{model-view-view.html}{introduction to the view classes}.

*/

/*!
    \page model-view-convenience.html
    \contentspage model-view-programming.html Contents
    \previouspage model-view-delegate.html Delegate Classes

    \title Convenience Classes

    \tableofcontents

    \section1 Overview

    Alongside the model/view classes, Qt 4 also includes standard widgets to
    provide classic item-based container widgets. These behave in a similar
    way to the item view classes in Qt 3, but have been rewritten to use the
    underlying model/view framework for performance and maintainability. The
    old item view classes are still available in the compatibility library
    (see the \l{porting4.html}{Porting Guide} for more information).

    The item-based widgets have been given names which reflect their uses:
    \c QListWidget provides a list of items, \c QTreeWidget displays a
    multi-level tree structure, and \c QTableWidget provides a table of cell
    items. Each class inherits the behavior of the \c QAbstractItemView
    class which implements common behavior for item selection and header
    management.

    \section1 List Widgets

    Single level lists of items are typically displayed using a \c QListWidget
    and a number of \c{QListWidgetItem}s. A list widget is constructed in the
    same way as any other widget:

    \quotefile snippets/qlistwidget-using/mainwindow.h
    \skipto QListWidget *
    \printuntil QListWidget *
    \quotefile snippets/qlistwidget-using/mainwindow.cpp
    \skipto listWidget = new
    \printuntil listWidget = new

    List items can be added directly to the list widget when they are
    constructed:

    \quotefile snippets/qlistwidget-using/mainwindow.cpp
    \skipto new QListWidgetItem(tr("Sycamore"
    \printuntil new QListWidgetItem(tr("Mahogany"

    They can also be constructed without a parent list widget and added to
    a list at some later time:

    \quotefile snippets/qlistwidget-using/mainwindow.cpp
    \skipto QListWidgetItem *newItem
    \printuntil newItem->setText(
    \skipto listWidget->insertItem
    \printuntil listWidget->insertItem

    Each item in a list can display a text label and an icon. The colors
    and font used to render the text can be changed to provide a customized
    appearance for items. Tooltips, status tips, and "What's
    This?" help are all easily configured to ensure that the list is properly
    integrated into the application.

    \skipto newItem->setToolTip(
    \printuntil newItem->setWhatsThis(

    By default, items in a list are presented in the order of their creation.
    Lists of items can be sorted according to the criteria given in
    \l{Qt::SortOrder} to produce a list of items that is sorted in forward or
    reverse alphabetical order:

    \quotefile snippets/qlistwidget-using/mainwindow.cpp
    \skipto listWidget->sortItems(Qt::Ascend
    \printuntil listWidget->sortItems(Qt::Ascend
    \skipto listWidget->sortItems(Qt::Descend
    \printuntil listWidget->sortItems(Qt::Descend


    \section1 Tree Widgets

    Trees or hierarchical lists of items are provided by the \c QTreeWidget
    and \c QTreeWidgetItem classes. Each item in the tree widget can have
    child items of its own, and can display a number of columns of
    information. Tree widgets are created just like any other widget:

    \quotefile snippets/qtreewidget-using/mainwindow.h
    \skipto QTreeWidget *
    \printuntil QTreeWidget *
    \quotefile snippets/qtreewidget-using/mainwindow.cpp
    \skipto treeWidget = new
    \printuntil treeWidget = new

    Before items can be added to the tree widget, the number of columns must
    be set. For example, we could define two columns, and create a header
    to provide labels at the top of each column:

    \skipto treeWidget->setColumnCount
    \printuntil treeWidget->setColumnCount
    \printuntil treeWidget->setHeaderLabels

    The easiest way to set up the labels for each section is to supply a string
    list. For more sophisticated headers, you can construct a tree item,
    decorate it as you wish, and use that as the tree widget's header.

    Top-level items in the tree widget are constructed with the tree widget as
    their parent widget. They can be inserted in an arbitrary order, or you
    can ensure that they are listed in a particular order by specifying the
    previous item when constructing each item:

    \skipto QTreeWidgetItem *cities
    \printuntil osloItem->setText(1
    \skipto QTreeWidgetItem *planets
    \printuntil QTreeWidgetItem *planets

    Tree widgets deal with top-level items slightly differently to other
    items from deeper within the tree. Items can be removed from the top
    level of the tree by calling the tree widget's
    \l{QTreeWidget::takeTopLevelItem()}{takeTopLevelItem()} function, but
    items from lower levels are removed by calling their parent item's
    \l{QTreeWidgetItem::takeChild()}{takeChild()} function.
    Items are inserted in the top level of the tree with the
    \l{QTreeWidget::insertTopLevelItem()}{insertTopLevelItem()} function.
    At lower levels in the tree, the parent item's 
    \l{QTreeWidgetItem::insertChild()}{insertChild()} function is used.

    It is easy to move items around between the top level and lower levels
    in the tree. We just need to check whether the items are top-level items
    or not, and this information is supplied by each item's \c parent()
    function. For example, we can remove the current item in the tree widget
    regardless of its location:

    \quotefile snippets/qtreewidget-using/mainwindow.cpp
    \skipto void MainWindow::removeItem()
    \skipto QTreeWidgetItem *parent
    \printuntil treeWidget->takeTopLevelItem(
    \printuntil }

    Inserting the item somewhere else in the tree widget follows the same
    pattern:

    \quotefile snippets/qtreewidget-using/mainwindow.cpp
    \skipto void MainWindow::insertItem()
    \skipto QTreeWidgetItem *parent
    \printuntil else
    \printuntil newItem = new


    \section1 Table Widgets

    Tables of items similar to those found in spreadsheet applications
    are constructed with the \c QTableWidget and \c QTableWidgetItem. These
    provide a scrolling table widget with headers and items to use within it.

    Tables can be created with a set number of rows and columns, or these
    can be added to an unsized table as they are needed.

    \quotefile snippets/qtablewidget-using/mainwindow.h
    \skipto QTableWidget *
    \printuntil QTableWidget *
    \quotefile snippets/qtablewidget-using/mainwindow.cpp
    \skipto tableWidget = new
    \printuntil tableWidget = new

    Items are constructed outside the table before being added to the table
    at the required location:

    \skipto QTableWidgetItem *newItem
    \printuntil tableWidget->setItem(

    Horizontal and vertical headers can be added to the table by constructing
    items outside the table and using them as headers:

    \quotefile snippets/qtablewidget-using/mainwindow.cpp
    \skipto QTableWidgetItem *valuesHeaderItem
    \printuntil tableWidget->setHorizontalHeaderItem(0

    Note that the rows and columns in the table begin at zero.

    \section1 Common Features

    There are a number of item-based features common to each of the
    convenience classes that are available through the same interfaces
    in each class. We present these in the following sections with some
    examples for different widgets.
    Look at the \l{model-view.html}{class documentation} for each of the
    widgets for more details about the use of each function used.

    \section2 Hidden Items

    It is sometimes useful to be able to hide items in an item view widget
    rather than remove them. Items for all of the above widgets can be
    hidden and later shown again. You can determine whether an item is hidden
    by calling the isItemHidden() function, and items can be hidden with
    \c setItemHidden(). 

    Since this operation is item-based, the same function is available for
    all three convenience classes.

    \section2 Selections

    The way items are selected is controlled by the widget's selection mode
    (\l{QAbstractItemView::SelectionMode}).
    This property controls whether the user can select one or many items and,
    in many-item selections, whether the selection must be a continuous range
    of items. The selection mode works in the same way for all of the
    above widgets.

    \table
    \row
    \i \img selection-single.png
    \i \bold{Single item selections:}
    Where the user needs to choose a single item from a widget, the
    default \c SingleSelection mode is most suitable. In this mode, the
    current item and the selected item are the same.

    \row
    \i \img selection-multi.png
    \i \bold{Multi-item selections:}
    In this mode, the user can toggle the selection state of any item in the
    widget without changing the existing selection, much like the way
    non-exclusive checkboxes can be toggled independently.

    \row
    \i \img selection-extended.png
    \i \bold{Extended selections:}
    Widgets that often require many adjacent items to be selected, such
    as those found in spreadsheets, require the \c ExtendedSelection mode.
    In this mode, continuous ranges of items in the widget can be selected
    with both the mouse and the keyboard.
    Complex selections, involving many items that are not adjacent to other
    selected items in the widget, can also be created if modifier keys are
    used.

    If the user selects an item without using a modifier key, the existing
    selection is cleared.
    \endtable

    The selected items in a widget are read using the \c selectedItems()
    function, providing a list of relevant items that can be iterated over.
    For example, we can find the sum of all the numeric values within a
    list of selected items with the following code:

    \skipto void MainWindow::sumItems()
    \skipto QList<QTableWidgetItem *>
    \printto if (number > 0)

    Note that for the single selection mode, the current item will be in
    the selection. In the multi-selection and extended selection modes, the
    current item may not lie within the selection, depending on the way the
    user formed the selection.

    \section2 Searching

    It is often useful to be able to find items within an item view widget,
    either as a developer or as a service to present to users. All three
    item view convenience classes provide a common \c findItems() function
    to make this as consistent and simple as possible.

    Items are searched for by the text that they contain according to
    criteria specified by a selection of values from
    \l{QAbstractItemModel::MatchFlags}. We can obtain a list of matching
    items with the \c findItems() function:

    \quotefile snippets/qtreewidget-using/mainwindow.cpp
    \skipto void MainWindow::findItems()
    \skipto QTreeWidgetItem *
    \printuntil QTreeWidgetItem *
    \skipto QList<QTreeWidgetItem *> found
    \printuntil }

    The above code causes items in a tree widget to be selected if they
    contain the text given in the search string. This pattern can also be
    used in the list and table widgets.

*/
