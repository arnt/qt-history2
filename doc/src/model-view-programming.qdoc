/*!
\page model-view-programming.html
\nextpage Using Models and Views
\startpage index.html Qt Reference Documentation

\title Model/View Programming

\tableofcontents

\section1 Introduction

Qt 4 introduces a new set of item view classes that use a model/view
architecture to manage the relationship between data and the way it
is presented to the user. The separation of functionality introduced by
this architecture gives developers greater flexibility and access to
more features than was previously possible.
In this document, we give a brief introduction to the model/view paradigm,
outline the concepts involved, and describe the architecture of the item
view system. Each of the components in the architecture is explained,
and examples are given that show how to use the classes provided.

\section1 The Model/View Architecture

Model-View-Controller (MVC) is a design pattern originating from
Smalltalk that is often used when building user interfaces.
In \l{Design Patterns}, Gamma et al. write:

\quote
MVC consists of three kinds of objects. The Model is the application
object, the View is its screen presentation, and the Controller defines
the way the user interface reacts to user input. Before MVC, user
interface designs tended to lump these objects together. MVC decouples
them to increase flexibility and reuse.
\endquote

If the view and the controller objects are combined, the result is
the model/view architecture. This still separates the way that data
is stored from the way that it is presented to the user, but provides
a simpler framework based on the same principles. This separation
makes it possible to display the same data in several different views,
and to implement new types of views, without changing the underlying
data structures.
To allow flexible handling of user input, we introduce the concept of
the \e delegate. The advantage of having a delegate in this framework
is that it allows the way items of data are rendered and edited to be
customized.

\table
\row \i \inlineimage modelview-overview.png
\i \bold{The model/view architecture}

The model communicates with a source of data, providing an \e interface
for the other components in the architecture. The nature of the
communication depends on the type of data source, and the way the model
is implemented.

The view obtains \e{model indexes} from the model; these are references
to items of data. By supplying model indexes to the model, the view can
retrieve items of data from the data source.

In standard views, a \e delegate renders the items of data. When an item
is edited, the delegate communicates with the model directly using
model indexes.
\endtable

Generally, the model/view classes can be separated into the three groups
described above: models, views, and delegates. Each of these components
are defined by \e abstract classes that provide common interfaces and,
in some cases, default implementations of features.
Abstract classes are meant to be subclassed in order to provide the full
set of functionality expected by other components; this also allows
specialized components to be written.

Models, views, and delegates communicate with each other using \e{signals
and slots}:

\list
\o Signals from the model inform the view about changes to the data
   held by the data source.
\o Signals from the view provide information about the user's interaction
   with the items being displayed.
\o Signals from the delegate are used during editing to tell the other
   model and view about the state of the editor.
\endlist

\section2 Models

All item models are based on the QAbstractItemModel class. This class
defines an interface that is used by views and delegates to access data.
The data itself does not have to be stored in the model; it can be held
in a data structure or repository provided by a seperate class, a file,
a database, or some other application component. QAbstractItemModel
provides an interface to data that is flexible enough to handle views
that represent data in the form of tables, lists, and trees. However,
when implementing new models for list and table-like data structures,
the QAbstractListModel and QAbstractTableModel classes are better
starting points because they provide appropriate default implementations
of common functions. Each of these classes can be subclassed to provide
models that support specialized kinds of lists and tables.

The QStandardItemModel class provides a ready-made model that can be
used to handle arbitrary pieces of data which it stores internally.

\section2 Views

Complete implementations are provided for different kinds of
views: QListView displays a list of items, QTableView displays data
from a model in a table, and QTreeView shows model items of data in a
hierarchical list. Each of these classes is based on the
QAbstractItemView abstract base class. Although these classes are
ready-to-use implementations, they can also be subclassed to provide
customized views.

\section2 Delegates

QAbstractItemDelegate is the abstract base class for delegates in the
model/view framework. A default delegate implementation is provided by
the QItemDelegate class, and this is used as the default delegate by
Qt's standard views.

\section2 Convenience Classes

A number of \e convenience classes are derived from the standard view
classes for the benefit of applications that rely on Qt's item-based
item view and table classes. They are not intended to be subclassed,
but simply exist to provide a familiar interface to the equivalent classes
in Qt 3.
Examples of such classes include \l QListWidget, \l QTreeWidget, and
\l QTableWidget; these provide similar behavior to the \c QListBox,
\c QListView, and \c QTable classes in Qt 3.

These classes are less flexible than the view classes, and cannot be
used with arbitrary models. We recommend that you use a model/view
approach to handling data in item views unless you strongly need a
item-based set of classes.

\section1 The Model/View Components

The following sections describe the way in which the model/view pattern
is used in Qt. Each section provides an example of use, and is followed
by a section showing how you can create new components.

\list
\i \l{Using Models and Views}
  \tableofcontents{1 Using Models and Views}
\i \l{Model Classes}
  \tableofcontents{1 Model Classes}
\i \l{Creating New Models}
  \tableofcontents{1 Creating New Models}
\i \l{View Classes}
  \tableofcontents{1 View Classes}
\i \l{Handling Selections in Item Views}
  \tableofcontents{1 Handling Selections in Item Views}
\i \l{Delegate Classes}
  \tableofcontents{1 Delegate Classes}
\i \l{Item View Convenience Classes}
  \tableofcontents{1 Item View Convenience Classes}
\endlist

See also the list of \l{Model/View Classes}.

\section1 Related Examples

\list
\o \l{itemviews/dirview}{Dir View}
\o \l{itemviews/spinboxdelegate}{Spin Box Delegate}
\o \l{itemviews/pixelator}{Pixelator}
\o \l{itemviews/simpletreemodel}{Simple Tree Model}
\o \l{itemviews/chart}{Chart}
\endlist

*/

/*!
\page model-view-using.html
\contentspage model-view-programming.html Contents
\previouspage Model/View Programming
\nextpage Model Classes

\title Using Models and Views

\tableofcontents

\section1 Introduction

Two of the standard models provided by Qt are QStandardItemModel and
QDirModel. QStandardItemModel is a multi-purpose model that can be used
to represent various different data structures needed by list, table,
and tree views. This model also holds the items of data.
QDirModel is a model that maintains information about the contents of a
directory. As a result, it does not hold any items of data itself, but
simply represents files and directories on the local filing system.

QDirModel provides a ready-to-use model to experiment with, and can be
easily configured to use existing data. Using this model, we can show how
to set up a model for use with ready-made views, and explore how to
manipulate data using model indexes.

\section1 Using Views with an Existing Model

The QListView and QTreeView classes are the most suitable views
to use with QDirModel. The example presented below displays the
contents of a directory in a tree view next to the same information in
a list view. The views share the user's selection so that the selected
items are highlighted in both views.

\img shareddirmodel.png

We set up a QDirModel so that it is ready for use, and create some
views to display the contents of a directory. This shows the simplest
way to use a model. The construction and use of the model is
performed from within a single \c main() function:

\quotefile shareddirmodel/main.cpp
\skipto int main
\printuntil QDirModel

The model is set up to use data from a default directory. We create two
views so that we can examine the items held in the model in two
different ways:

\printto QItemSelectionModel

The views are constructed in the same way as other widgets. Setting up
a view to display the items in the model is simply a matter of calling its
\l{QAbstractItemView::setModel()}{setModel()} function with the directory
model as the argument. The calls to
\l{QAbstractItemView::setRootIndex()}{setRootIndex()} tell the views which
directory to display by supplying a \e{model index} that we obtain from
the directory model.

The \c index() function used in this case is unique to QDirModel; we supply
it with a directory and it returns a model index. Model indexes are
discussed in the \l{Model Classes} chapter.

The rest of the function just displays the views within a splitter
widget, and runs the application's event loop:

\skipto splitter
\printuntil }

In the above example, we neglected to mention how to handle selections
of items. This subject is covered in more detail in the chapter on
\l{Handling Selections in Item Views}. Before examining how selections
are handled, you may find it useful to read the
\l{Model Classes}{next chapter} and the concepts used in the model/view
framework.
*/

/*!
\page model-view-model.html
\contentspage model-view-programming.html Contents
\previouspage Using Models and Views
\nextpage Creating New Models

\title Model Classes

\tableofcontents

\section1 Basic Concepts

In the model/view architecture, the model provides a standard interface
that views and delegates use to access data. In Qt, the standard
interface is defined by the QAbstractItemModel class. No matter how
the data is stored in any underlying data structure, all subclasses of
QAbstractItemModel represent the data as a hierarchical structure
containing tables of items.
Views use this \e convention to access items of data in the model, but
they are not restricted in the way that they present this information
to the user.

\image modelview-models.png

Models also notify any attached views about changes to data through the
signals and slots mechanism.

This chapter describes some basic concepts that are central to the way
data is accessed by other components via a model class. More advanced
concepts are discussed in later chapters.

\section2 Model Indexes

To ensure that the representation of the data is kept separate from the
way it is accessed, the concept of a \e{model index} is introduced.
Each piece of information that can be obtained via a model is
represented by a model index. Views and delegates use these indexes to
request items of data to display.

As a result, only the model needs to know how to obtain data, and the
type of data managed by the model can be defined fairly generally.
Model indexes contain a pointer to the model that created them, and
this prevents confusion when working with more than one model.

\code
QAbstractItemModel *model = index.model();
\endcode

Model indexes provide \e temporary references to pieces of information,
and can be used to retrieve or modify data via the model. Since models
may reorganize their internal structures from time to time, model
indexes may become invalid, and \e{should not be stored}. If a
long-term reference to a piece of information is required, a
\e{persistent model index} must be created. This provides a reference
to the information that the model keeps up-to-date.
Temporary model indexes are provided by the QModelIndex class, and
persistent model indexes are provided by the QPersistentModelIndex
class.

To obtain a model index that corresponds to an item of data, three
properties must be specified to the model: a row number, a column number,
and the model index of a parent item. The following sections describe
and explain these properties in detail.

\section2 Rows and Columns

In its most basic form, a model can be accessed as a simple table
in which items are located by their row and column numbers. \e{This does
not mean that the underlying data is stored in an array structure};
the use of row and column numbers is only a convention to allow components
to communicate with each other.
We can retrieve information about any given item by specifying its row
and column numbers to the model, and we receive an index that
represents the item:

\code
QModelIndex index = model->index(row, column, ...);
\endcode

Models that provide interfaces to simple, single level data structures
like lists and tables do not need any other information to be provided
but, as the above code indicates, we need to supply more information
when obtaining a model index.

\table
\row \i \inlineimage modelview-tablemodel.png
\i \bold{Rows and columns}

The diagram shows a representation of a basic table model in which each
item is located by a pair of row and column numbers.
By passing the relevant row and column numbers to the model we
obtain a model index that refers to an item of data.

\code
QModelIndex indexA = model->index(0, 0, QModelIndex());
QModelIndex indexB = model->index(1, 1, QModelIndex());
QModelIndex indexC = model->index(2, 1, QModelIndex());
\endcode

Top level items in a model are always referenced by specifying
\c QModelIndex() as their parent item. This is discussed in the next
section.
\endtable

\section2 Parents of Items

The table-like interface to item data provided by models is ideal when
using data in a table or list view; the row and column number system
maps exactly to the way the views display items.
However, structures such as tree views require the model to expose a more
flexible interface to the items within. As a result, each item can also be
the parent of another table of items, in much the same way that a top-level
item in a tree view can contain another list of items.

When requesting an index for a model item, we must provide some
information about the item's parent. Outside the model, the only way to
refer to an item is through a model index, so a parent model index must
also be given:

\code
QModelIndex index = model->index(row, column, parent);
\endcode

\table
\row \i \inlineimage modelview-treemodel.png
\i \bold{Parents, rows, and columns}

The diagram shows a representation of a tree model in which each item
is referred to by a parent, a row number, and a column number.

Items "A" and "C" are represented as top-level siblings in the model:
\code
QModelIndex indexA = model->index(0, 0, QModelIndex());
QModelIndex indexC = model->index(2, 1, QModelIndex());
\endcode

Item "A" has a number of children. A model index for item "B" is
obtained with the following code:
\code
QModelIndex indexB = model->index(1, 0, indexA);
\endcode
\endtable

\section2 Item Roles

Items in a model can perform various \e roles for other components,
allowing different kinds of data to be supplied for different situations.
For example, the \l{Qt::ItemDataRole}{DisplayRole} role is used
to access a string that can be displayed as text in a view.
Typically, items contain data for a number of different roles.

We can ask the model for the item's data by passing it the model index
corresponding to the item, and by specifying a role to obtain the type
of data we want:

\code
QVariant value = model->data(index, role);
\endcode

\table
\row \i \inlineimage modelview-roles.png
\i \bold{Item roles}

The role indicates to the model which type of data is being referred to.
Views can display the roles in different ways, so it is important to
supply appropriate information for each role.

We will examine roles in more detail when we
\l{Creating New Models}{create an example model}.
\endtable

Many of the most common uses for items of data are represented by
standard roles. However, it is also possible to define additional
roles for your own purposes.

\section2 Summary of Concepts

\list
\o Model indexes give views and delegates information about the location
   of items provided by models in a way that is independent of any
   underlying data structures.
\o Items are referred to by their row and column numbers, and by the model
   index of their parent items.
\o Model indexes are constructed by models at the request of other 
   components, such as views and delegates.
\o If a valid model index is specified when an index is requested (using
   \l{QAbstractItemModel::index()}{index()}, the model understands that
   it refers to a parent item, and that it must return an index that refers
   to a child of that item.
\o If an invalid model index is specified when an index is requested (using
   \l{QAbstractItemModel::index()}{index()}, the model understands that
   it must return a model index that refers to a top-level item in the model.
\o The \l{Qt::ItemDataRole}{role} distinguishes between the
   different kinds of data associated with an item.
\endlist

\section2 Using Model Indexes

To demonstrate how data can be retrieved from a model, using model
indexes, we set up a QDirModel without a view and display the
names of files and directories in a widget.
Although this does not show a normal way of using a model, it demonstrates
the conventions used by models when dealing with model indexes.

We construct a directory model in the following way:

\quotefile simplemodel-use/main.cpp
\skipto QDirModel *model
\printuntil int numRows

In this case, we set up a default QDirModel, obtain a parent index using
a specific implementation of \l{QDirModel::index()}{index()} provided by
that model, and we count the number of rows in the model using the
\l{QDirModel::rowCount()}{rowCount()} function.

For simplicity, we are only interested in the items in the first column
of the model. We examine each row in turn, obtaining a model index for
the first item in each row, and read the data stored for that item
in the model.

\skipto for (
\printuntil QModelIndex index

To obtain a model index, we specify the row number, column number (zero
for the first column), and the appropriate model index for the parent
of all the items that we want.
The text stored in each item is retrieved using the model's
\l{QDirModel::data()}{data()} function. We specify the model index and
the \l{Qt::ItemDataRole}{DisplayRole} to obtain data for the
item in the form of a string.

\skipto QString text
\printuntil // Display
\skipto }
\printuntil }

The above example demonstrates the basic principles used to retrieve
data from a model:

\list
\i The dimensions of a model can be found using
   \l{QAbstractItemModel::rowCount()}{rowCount()} and
   \l{QAbstractItemModel::columnCount()}{columnCount()}.
   These functions generally require a parent model index to be
   specified.
\i Model indexes are used to access items in the model. The row, column,
   and parent model index are needed to specify the item.
\i To access top-level items in a model, specify a null model index
   as the parent index with \c QModelIndex().
\i Items contain data for different roles. To obtain the data for a
   particular role, both the model index and the role must be supplied
   to the model.
\endlist


\section1 Further Reading

New models can be created by implementing the standard interface provided
by QAbstractItemModel. In the \l{Creating New Models}{next chapter}, we
will demonstrate this by creating a convenient ready-to-use model for
holding lists of strings.
*/

/*!
\page model-view-view.html
\contentspage model-view-programming.html Contents
\previouspage Creating New Models
\nextpage Handling Selections in Item Views

\title View Classes

\tableofcontents

\section1 Concepts

In the model/view architecture, the view obtains items of data from the
model and presents them to the user. The way that the data is
presented need not resemble the representation of the data provided by
the model, and may be \e{completely different} from the underlying data
structure used to store items of data.

The separation of content and presentation is achieved by the use of a
standard model interface provided by QAbstractItemModel, a standard view
interface provided by QAbstractItemView, and the use of model indexes
that represent items of data in a general way.
Views typically manage the overall layout of the data obtained from
models. They may render individual items of data themselves, or use
\l{Delegate Classes}{delegates} to handle both rendering and editing
features.

As well as presenting data, views handle navigation between items,
and some aspects of item selection. The views also implement basic
user interface features, such as context menus and drag and drop.
A view can provide default editing facilities for items, or it may
work with a \l{Delegate Classes}{delegate} to provide a custom
editor.

A view can be constructed without a model, but a model must be
provided before it can display useful information. Views keep track of
the items that the user has selected through the use of
\l{Handling Selections in Item Views}{selections} which can be maintained
separately for each view, or shared between multiple views.

Some views, such as QTableView and QTreeView, display headers as well
as items. These are also implemented by a view class, QHeaderView.
Headers usually access the same model as the view that contains them.
They retrieve data from the model using the
\l{QAbstractItemModel::headerData()} function, and usually display
header information in the form of a label. New headers can be
subclassed from the QHeaderView class to provide more specialized
labels for views.

\section1 Using an Existing View

Qt provides three ready-to-use view classes that present data from
models in ways that are familiar to most users.
QListView can display items from a model as a simple list, or in the
form of a classic icon view. QTreeView displays items from a
model as a hierarchy of lists, allowing deeply nested structures to be
represented in a compact way. QTableView presents items from a model
in the form of a table, much like the layout of a spreadsheet
application.

\img standard-views.png

The default behavior of the standard views shown above should be
sufficient for most applications. They provide basic editing
facilities, and can be customized to suit the needs of more specialized
user interfaces.

\section2 Using a Model 

We take the string list model that \l{Creating New Models}{we created as
an example model}, set it up with some data, and construct a view to
display the contents of the model. This can all be performed within a
single function:

\quotefile stringlistmodel/main.cpp
\skipto int main
\printuntil QAbstractItemModel

Note that the \c StringListModel is declared as a \l QAbstractItemModel.
This allows us to use the abstract interface to the model, and
ensures that the code will still work even if we replace the string list
model with a different model in the future.

The list view provided by \l QListView is sufficient for presenting
the items in the string list model. We construct the view, and set up
the model using the following lines of code:

\skipto QListView
\printuntil QListView
\skipto view->setModel
\printuntil view->setModel

The view is shown in the normal way:

\skipto view->show
\printuntil }

The view renders the contents of a model, accessing data via the model's
interface. When the user tries to edit an item, the view uses a default
delegate to provide an editor widget.

\img stringlistmodel.png

The above image shows how a QListView represents the data in the string
list model. Since the model is editable, the view automatically allows
each item in the list to be edited using the default delegate.

\section2 Using Multiple Views onto the Same Model

Providing multiple views onto the same model is simply a matter of
setting the same model for each view. In the following code we create
two table views, each using the same simple table model which we have
created for this example:

\quotefile sharedtablemodel/main.cpp
\skipto QTableView *first
\printuntil QTableView *second
\skipto firstTableView->
\printuntil secondTableView->

The use of signals and slots in the model/view architecture means that
changes to the model can be propagated to all the attached views,
ensuring that we can always access the same data regardless of the
view being used.

\img sharedmodel-tableviews.png

The above image shows two different views onto the same model, each
containing a number of selected items. Although the data from the model
is shown consistently across view, each view maintains its own internal
selection model. This can be useful in certain situations but, for
many applications, a shared selection model is desirable.

\section1 Handling Selections of Items

The mechanism for handling selections of items within views is provided
by the \l QItemSelectionModel class. All of the standard views construct
their own selection models by default, and interact with them in the
normal way. The selection model being used by a view can be obtained
through the \l{QAbstractItemView::selectionModel()}{selectionModel()}
function, and a replacement selection model can be specified with
\l{QAbstractItemView::setSelectionModel()}{setSelectionModel()}.
The ability to control the selection model used by a view is useful
when we want to provide multiple consistent views onto the same model
data.

Generally, unless you are subclassing a model or view, you will not
need to manipulate the contents of selections directly. However, the
interface to the selection model can be accessed, if required, and
this is explored in the chapter on
\l{Handling Selections in Item Views}.

\section2 Sharing Selections Between Views

Although it is convenient that the view classes provide their own
selection models by default, when we use more than one view onto the
same model it is often desirable that both the model's data and the
user's selection are shown consistently in all views.
Since the view classes allow their internal selection models to be
replaced, we can achieve a unified selection between views with the
following line:

\quotefile sharedtablemodel/main.cpp
\skipto secondTableView->setSelectionModel
\printuntil secondTableView->setSelectionModel

The second view is given the selection model for the first view.
Both views now operate on the same selection model, keeping both
the data and the selected items synchronized.

\img sharedselection-tableviews.png

In the example shown above, two views of the same type were used to
display the same model's data. However, if two different types of view
were used, the selected items may be represented very differently in
each view; for example, a contiguous selection in a table view can be
represented as a fragmented set of highlighted items in a tree view.

*/

/*!
\page model-view-delegate.html
\contentspage model-view-programming.html Contents
\previouspage Handling Selections in Item Views
\nextpage Item View Convenience Classes

\title Delegate Classes

\tableofcontents

\section1 Concepts

Unlike the Model-View-Controller pattern, the model/view design does not
include a completely separate component for managing interaction with
the user. Generally, the view is responsible for the presentation of
model data to the user, and for processing user input. To allow some
flexibility in the way this input is obtained, the interaction is
performed by delegates. These components provide input capabilities
and are also responsible for rendering individual items in some views.
The standard interface for controlling delegates is defined in the
\l QAbstractItemDelegate class.

Delegates are expected to be able to render their contents themselves
by implementing the \l{QAbstractItemDelegate::paint()}{paint()}
and \l{QAbstractItemDelegate::sizeHint()}{sizeHint()} functions.
However, simple widget-based delegates can subclass \l QItemDelegate
instead of \l QAbstractItemDelegate, and take advantage of the default
implementations of those functions.
Editors for delegates can be implemented in two ways, either by using
widgets to manage the editing process, or by handling events directly.
The first approach is covered later in this section.


\section1 Using an Existing Delegate

The standard views provided with Qt use instances of \l QItemDelegate
to provide editing facilities. This default implementation of the
delegate interface renders items in the usual style for each of the
standard views: \l QListView, \l QTableView, and \l QTreeView.
The delegate being used for a view is returned by the
\l{QAbstractItemView::itemDelegate()}{itemDelegate()} function.
The \l{QAbstractItemView::setItemDelegate()}{setItemDelegate()} function
allows you to install a custom delegate for a standard view, and it is
necessary to use this function when setting the delegate for a custom
view.


\section1 A Simple Delegate

The delegate implemented here uses a \l QSpinBox to provide editing
facilities, and is mainly intended for use with models that display
integers. Although we set up a custom integer-based table model for
this purpose, we could easily have used \l QStandardItemModel instead
since the custom delegate will control data entry. We construct a
table view to display the contents of the model, and this will use
the custom delegate for editing.

\img spinboxdelegate-example.png

We subclass the delegate from \l QItemDelegate because we do not want
to write custom display functions. However, we must still provide
functions to manage the editor widget:

\quotefromfile itemviews/spinboxdelegate/delegate.h
\skipto class SpinBoxDelegate
\printuntil };

Note that no editor widgets are set up when the delegate is
constructed. We only construct an editor widget when it is needed.

\section2 Providing an Editor

In this example, when the table view needs to provide an editor, it
asks the delegate to provide an editor widget that is appropriate
for the item being modified. The
\l{QAbstractItemDelegate::createEditor()}{createEditor()} function is
supplied with everything that the delegate needs to be able to set up
a suitable widget:

\quotefromfile itemviews/spinboxdelegate/delegate.cpp
\skipto QWidget *SpinBoxDelegate::createEditor
\printuntil }

Note that we do not need to keep a pointer to the editor widget because
the view takes responsibility for destroying it when it is no longer
needed.

We install the delegate's default event filter on the editor to ensure
that it provides the standard editing shortcuts that users expect.
Additional shortcuts can be added to the editor to allow more
sophisticated behavior; these are discussed in the section on
\l{#EditingHints}{Editing Hints}.

The view ensures that the editor's data and geometry are set
correctly by calling functions that we define later for these purposes.
We can create different editors depending on the model index supplied
by the view. For example, if we have a column of integers and a column
of strings we could return either a \c QSpinBox or a \c QLineEdit,
depending on which column is being edited.

The delegate must provide a function to copy model data into the
editor. In this example, we read the data stored in the
\l{Qt::ItemDataRole}{display role}, and set the value in the
spin box accordingly.

\skipto void SpinBoxDelegate::setEditorData
\printuntil }

In this example, we know that the editor widget is a spin box, but we
could have provided different editors for different types of data in
the model, in which case we would need to cast the widget to the
appropriate type before accessing its member functions.

\section2 Submitting Data to the Model

When the user has finished editing the value in the spin box, the view
asks the delegate to store the edited value in the model by calling the
\l{QAbstractItemDelegate::setModelData()}{setModelData()} function.

\quotefromfile itemviews/spinboxdelegate/delegate.cpp
\skipto void SpinBoxDelegate::setModelData
\printuntil /^\}/

Since the view manages the editor widgets for the delegate, we only
need to update the model with the contents of the editor supplied.
In this case, we ensure that the spin box is up-to-date, and update
the model with the value it contains using the index specified.

The standard \l QItemDelegate class informs the view when it has
finished editing by emitting the 
\l{QAbstractItemDelegate::closeEditor()}{closeEditor()} signal.
The view ensures that the editor widget is closed and destroyed. In
this example, we only provide simple editing facilities, so we need
never emit this signal.

All the operations on data are performed through the interface
provided by \l QAbstractItemModel. This makes the delegate mostly
independent from the type of data it manipulates, but some
assumptions must be made in order to use certain types of
editor widgets. In this example, we have assumed that the model
always contains integer values, but we can still use this
delegate with different kinds of models because \l{QVariant}
provides sensible default values for unexpected data.

\section2 Updating the Editor's Geometry

It is the responsibility of the delegate to manage the editor's
geometry. The geometry must be set when the editor is created, and
when the item's size or position in the view is changed. Fortunately,
the view provides all the necessary geometry information inside a
\l{QStyleOptionViewItem}{view option} object.

\skipto void SpinBoxDelegate::updateEditorGeometry
\printuntil }

In this case, we just use the geometry information provided by the
view option in the item rectangle. A delegate that renders items with
several elements would not use the item rectangle directly. It would
position the editor in relation to the other elements in the item.

\target EditingHints
\section2 Editing Hints

After editing, delegates should provide hints to the other components
about the result of the editing process, and provide hints that will
assist any subsequent editing operations. This is achieved by
emitting the \l{QAbstractItemDelegate::closeEditor()}{closeEditor()}
signal with a suitable hint. This is taken care of by the default
QItemDelegate event filter which we installed on the spin box when
it was constructed.

The behavior of the spin box could be adjusted to make it more user
friendly. In the default event filter supplied by QItemDelegate, if
the user hits \key Return to confirm their choice in the spin box,
the delegate commits the value to the model and closes the spin box.
We can change this behavior by installing our own event filter on the
spin box, and provide editing hints that suit our needs; for example,
we might emit \l{QAbstractItemDelegate::closeEditor()}{closeEditor()}
with the \l{QAbstractItemDelegate::EndEditHint}{EditNextItem} hint to
automatically start editing the next item in the view.

Another approach that does not require the use of an event
filter is to provide our own editor widget, perhaps subclassing
QSpinBox for convenience. This alternative approach would give us
more control over how the editor widget behaves at the cost of
writing additional code. It is usually easier to install an event
filter in the delegate if you need to customize the behavior of
a standard Qt editor widget.

Delegates do not have to emit these hints, but those that do not will
be less integrated into applications, and will be less usable than
those that emit hints to support common editing actions.

*/

/*!
\page model-view-selection.html
\contentspage model-view-programming.html Contents
\previouspage View Classes
\nextpage Delegate Classes

\title Handling Selections in Item Views

\tableofcontents

\section1 Concepts

The selection model used in the new item view classes offers many
improvements over the selection model used in Qt 3. It provides a
more general description of selections based on the facilities of
the model/view architecture. Although the standard classes for
manipulating selections are sufficient for the item views provided,
the selection model allows you to create specialized selection models
to suit the requirements for your own item models and views.

Information about the items selected in a view is stored in an instance
of the \l QItemSelectionModel class. This maintains model indexes for
items in a single model, and is independent of any views. Since there
can be many views onto a model, it is possible to share selections
between views, allowing applications to show multiple views in a
consistent way.

Selections are made up of \e{selection ranges}. These efficiently
maintain information about large selections of items by recording
only the starting and ending model indexes for each range of selected
items. Non-contiguous selections of items are constructed by using
more than one selection range to describe the selection.

Selections are applied to a collection of model indexes held by
a selection model. The most recent selection of items applied is
known as the \e{current selection}. The effects of this selection can
be modified even after its application through the use of certain
types of selection commands. These are discussed later in this
section.

When manipulating selections, it is often helpful to think of
\l QItemSelectionModel as a record of the selection state of all the
items in an item model. Once a selection model is set up, collections
of items can be selected, deselected, or their selection states can
be toggled without the need to know which items are already selected.
The indexes of all selected items can be retrieved at any time, and
other components can be informed of changes to the selection model
via the signals and slots mechanism.


\section1 Using a Selection Model

The standard view classes provide default selection models that can
be used in most applications. A selection model belonging to one view
can be obtained using the view's
\l{QAbstractItemView::selectionModel()}{selectionModel()} function,
and shared between many views with
\l{QAbstractItemView::setSelectionModel()}{setSelectionModel()},
so the construction of new selection models is generally not required.

A selection is created by specifying a model, and a pair of model
indexes to a \l QItemSelection. This uses the indexes to refer to items
in the given model, and interprets them as the top-left and bottom-right
items in a block of selected items.
To apply the selection to items in a model requires the selection to be
submitted to a selection model; this can be achieved in a number of ways,
each having a different effect on the selections already present in the
selection model.


\section2 Selecting Items

To demonstrate some of the principal features of selections, we construct
an instance of a custom table model with 32 items in total, and open a
table view onto its data:

\quotefile itemselection/main.cpp
\skipto TableModel
\printuntil QItemSelectionModel

The table view's default selection model is retrieved for later use.
We do not modify any items in the model, but instead select a few
items that the view will display at the top-left of the table. To do
this, we need to retrieve the model indexes corresponding to the
top-left and bottom-right items in the region to be selected:

\skipto QModelIndex topLeft
\printuntil bottomRight = model->index

To select these items in the model, and see the corresponding change
in the table view, we need to construct a selection object then apply
it to the selection model. We must also specify the model that the
indexes belong to because the model indexes do not contain this
information:

\skipto QItemSelection
\printuntil selectionModel->select

The selection is applied to the selection model using a command
defined by a combination of
\l{QItemSelectionModel::SelectionFlag}{selection flags}.
In this case, the flags used cause the items recorded in the
selection object to be included in the selection model, regardless
of their previous state. The resulting selection is shown by the view.

\img selected-items1.png

The selection of items can be modified using various operations that
are defined by the selection flags. The selection that results from
these operations may have a complex structure, but will be represented
efficiently by the selection model. The use of different selection
flags to manipulate the selected items is described when we examine
how to update a selection.

\section2 Reading the Selection State

The model indexes stored in the selection model can be read using
the \l{QItemSelectionModel::selectedIndexes()}{selectedIndexes()}
function. This returns an unsorted list of model indexes that we can
iterate over as long as we know which model they are for:

\quotefile reading-selections/window.cpp
\skipto QModelIndexList indexes
\printuntil }

The above code uses Qt's convenient \l{containers.html}{foreach
keyword} to iterate over, and modify, the items corresponding to the
indexes returned by the selection model.

The selection model emits signals to indicate changes in the
selection. These notify other components about changes to both the
selection as a whole and the currently focused item in the item
model. We can connect the
\l{QItemSelectionModel::selectionChanged()}{selectionChanged()}
signal to a slot, and examine the items in the model that are selected or
deselected when the selection changes. The slot is called with two
\l{QItemSelection} objects: one contains a list of indexes that
correspond to newly selected items; the other contains indexes that
correspond to newly deselected items.

In the following code, we provide a slot that receives the
\l{QItemSelectionModel::selectionChanged()}{selectionChanged()}
signal, fills in the selected items with
a string, and clears the contents of the deselected items.

\quotefile updating-selections/window.cpp
\skipto void MainWindow::updateSelection
\printuntil model->setData
\printuntil }
\printuntil }

We can keep track of the currently focused item by connecting the
\l{QItemSelectionModel::currentChanged()}{currentChanged()} signal
to a slot that is called with two model indexes. These correspond to
the previously focused item, and the currently focused item.

In the following code, we provide a slot that receives the
\l{QItemSelectionModel::currentChanged()}{currentChanged()} signal,
and uses the information provided to update the status bar of a
\l QMainWindow:

\skipto void MainWindow::changeCurrent
\printuntil }

Monitoring selections made by the user is straightforward with these
signals, but we can also update the selection model directly.

\section2 Updating a Selection

Selection commands are provided by a combination of selection flags,
defined by \l{QItemSelectionModel::SelectionFlag}.
Each selection flag tells the selection model how to update its
internal record of selected items when either of the
\l{QItemSelection::select()}{select()} functions are called.
The most commonly used flag is the
\l{QItemSelectionModel::SelectionFlag}{Select} flag
which instructs the selection model to record the specified items as
being selected. The
\l{QItemSelectionModel::SelectionFlag}{Toggle} flag causes the
selection model to invert the state of the specified items,
selecting any deselected items given, and deselecting any currently
selected items. The \l{QItemSelectionModel::SelectionFlag}{Deselect}
flag deselects all the specified items.

Individual items in the selection model are updated by creating a
selection of items, and applying them to the selection model. In the
following code, we apply a second selection of items to the table
model shown above, using the
\l{QItemSelectionModel::SelectionFlag}{Toggle} command to invert the
selection state of the items given.

\quotefile itemselection/main.cpp
\skipto QItemSelection toggle
\printuntil selectionModel->select

The results of this operation are displayed in the table view,
providing a convenient way of visualizing what we have achieved:

\img selected-items2.png

By default, the selection commands only operate on the individual
items specified by the model indexes. However, the flag used to
describe the selection command can be combined with additional flags
to change entire rows and columns. For example if you call
\l{QItemSelectionModel::select()}{select()} with only one index, but
with a command that is a combination of
\l{QItemSelectionModel::SelectionFlag}{Select} and
\l{QItemSelectionModel::SelectionFlag}{Rows}, the
entire row containing the item referred to will be selected.
The following code demonstrates the use of the
\l{QItemSelectionModel::SelectionFlag}{Rows} and 
\l{QItemSelectionModel::SelectionFlag}{Columns} flags:

\skipto QItemSelection columnSelection
\printuntil QItemSelectionModel::Select | QItemSelectionModel::Rows

Although only four indexes are supplied to the selection model, the
use of the 
\l{QItemSelectionModel::SelectionFlag}{Columns} and
\l{QItemSelectionModel::SelectionFlag}{Rows} selection flags means
that two columns and two rows are selected. The following image shows
the result of these two selections:

\img selected-items3.png

The commands performed on the example model have all involved
accumulating a selection of items in the model. It is also possible
to clear the selection, or to replace the current selection with
a new one.

To replace the current selection with a new selection, combine
the other selection flags with the
\l{QItemSelectionModel::SelectionFlag}{Current} flag. A command using
this flag instructs the selection model to replace its current collection
of model indexes with those specified in a call to
\l{QItemSelectionModel::select()}{select()}.
To clear all selections before you start adding new ones,
combine the other selection flags with the
\l{QItemSelectionModel::SelectionFlag}{Clear} flag. This
has the effect of resetting the selection model's collection of model
indexes.

\section2 Selecting All Items in a Model

To select all items in a model, it is necessary to create a
selection for each level of the model that covers all items in that
level. We do this by retrieving the indexes corresponding to the
top-left and bottom-right items with a given parent index:

\quotefile reading-selections/window.cpp
\skipto void MainWindow::selectAll()
\skipto QModelIndex topLeft
\printuntil model->columnCount

A selection is constructed with these indexes and the model. The
corresponding items are then selected in the selection model:

\skipto QItemSelection selection
\printuntil selectionModel->select

This needs to be performed for all levels in the model.
For top-level items, we would define the parent index in the usual way:

\quotefile reading-selections/window.cpp
\skipto void MainWindow::selectAll()
\skipto QModelIndex parent
\printuntil QModelIndex parent

For hierarchical models, the
\l{QAbstractItemModel::hasChildren()}{hasChildren()} function is used to
determine whether any given item is the parent of another level of
items.

*/

/*!
    \page model-view-creating-models.html
    \contentspage model-view-programming.html Contents
    \previouspage Model Classes
    \nextpage View Classes

    \title Creating New Models

    \tableofcontents

    \section1 Introduction

    The separation of functionality between the model/view components allows
    models to be created that can take advantage of existing views. This
    approach lets us present data from a variety of sources using standard
    graphical user interface components, such as QListView, QTableView, and
    QTreeView.

    The QAbstractItemModel class provides an interface that is flexible
    enough to support data sources that arrange information in hierarchical
    structures, allowing for the possibility that data will be inserted,
    removed, modified, or sorted in some way. It also provides support for
    drag and drop operations.

    The QAbstractListModel and QAbstractTableModel classes provide support
    for interfaces to simpler non-hierarchical data structures, and are
    easier to use as a starting point for simple list and table models.

    In this chapter, we create a simple read-only model to explore
    the basic principles of the model/view architecture. Later in this
    chapter, we will adapt this simple model so that items can be modified
    by the user.

    For an example of a more complex model, see the
    \l{itemviews/simpletreemodel}{Simple Tree Model} example.

    \section1 A Read-Only Example Model

    The model implemented here is a simple, non-hierarchical, read-only data
    model. It has a \l QStringList as its internal data source, and
    implements only what is needed to make a functioning model. To make the
    implementation easier, we subclass \l QAbstractListModel because it
    defines sensible default behavior for list models, and it exposes a
    simpler interface than the \l QAbstractItemModel class.

    When implementing a model it is important to remember that
    \l QAbstractItemModel does not store any data itself, it merely
    presents an interface that the views use to access the data.
    For a minimal read-only model it is only necessary to implement a few
    functions as there are default implementations for most of the
    interface. The class declaration is as follows:

    \quotefile stringlistmodel/model.h

    \skipto class
    \printuntil headerData
    \printline
    \skipto /^\};/
    \printuntil /^\};/

    Apart from the model's constructor, we only need to implement two
    functions: \l{QAbstractItemModel::rowCount()}{rowCount()} returns the
    number of rows in the model and \l{QAbstractItemModel::data()}{data()}
    returns an item of data corresponding to a specified model index.

    Well behaved models also implement
    \l{QAbstractItemModel::headerData()}{headerData()} to give tree and
    table views something to display in their headers.

    Note that this is a non-hierarchical model, so we don't have to worry
    about the parent-child relationships. If our model was hierarchical, we
    would also have to implement the
    \l{QAbstractItemModel::index()}{index()} and
    \l{QAbstractItemModel::parent()}{parent()} functions.

    \section2 Dimensions of The Model

    We want the number of rows in the model to be the same as the number of
    strings in the string list. We implement the
    \l{QAbstractItemModel::rowCount()}{rowCount()} function with this in
    mind:

    \quotefile stringlistmodel/model.cpp
    \skipto int StringListModel
    \printuntil }

    Since the model is non-hierarchical, we can safely ignore the model index
    corresponding to the parent item. By default, models derived from
    QAbstractListModel only contain one column, so we do not need to
    reimplement the \l{QAbstractItemModel::columnCount()}{columnCount()}
    function.

    \section2 Model Headers and Data

    For items in the view, we want to return the strings in the string list.
    The \l{QAbstractItemModel::data()}{data()} function is responsible for
    returning the item of data that corresponds to the index argument:

    \skipto QVariant StringListModel::data
    \printuntil }

    We only return a valid QVariant if the model index supplied is valid,
    the row number is within the range of items in the string list, and the
    requested role is one that we support.

    If our model is displayed in a view with headers, we want the headers
    to show the row and column numbers. We can provide information about
    the headers by subclassing the
    \l{QAbstractItemModel::headerData()}{headerData()} function:

    \skipto QVariant StringListModel::headerData
    \printuntil }

    Again, we return a valid QVariant only if the model index is valid and
    the role is one that we support. The orientation of the header is also
    taken into account when deciding the exact data to return.

    An item can have several roles, giving out different data depending on the
    role specified. The items in our model only have one role,
    \l{Qt::ItemDataRole}{DisplayRole}, so we return the data
    for items irrespective of the role specified.
    However, we could reuse the data we provide for the
    \l{Qt::ItemDataRole}{DisplayRole} in
    other roles, such as the
    \l{Qt::ItemDataRole}{ToolTipRole} that views can use to
    display information about items in a tooltip.

    \section1 An Editable Model

    The read-only model shows how simple choices could be presented to the
    user but, for many applications, an editable list model is much more
    useful. We can modify the read-only model to make the items editable
    by implementing two extra functions:
    \l{QAbstractItemModel::flags()}{flags()} and
    \l{QAbstractItemModel::setData()}{setData()}.
    The following function declarations are added to the class definition:

    \quotefile stringlistmodel/model.h
    \skipto ItemFlags flags
    \printuntil setData

    \section2 Making the Model Editable

    A delegate checks whether an item is editable before creating an
    editor. The model must let the delegate know that its items are
    editable. We do this by returning the correct flags for each item in
    the model; in this case, we enable all items and make them both
    selectable and editable:

    \quotefile stringlistmodel/model.cpp
    \skipto ItemFlags StringListModel::flags
    \printuntil }

    Note that we do not have to know how the delegate performs the actual
    editing process. We only have to provide a way for the delegate to set the
    data in the model. This is achieved through the
    \l{QAbstractItemModel::setData()}{setData()} function:

    \quotefile stringlistmodel/model.cpp
    \skipto bool StringListModel::setData
    \printuntil }
    \printuntil }

    In this model, the item in the string list that corresponds to the model
    index is replaced by the value provided. However, before we can modify
    the string list, we must make sure that the index is valid, the item is
    of the correct type, and that the role is supported. By convention, we
    insist that the role is the \l{Qt::ItemDataRole}{EditRole} since
    this is the role used by the standard item delegate. The underlying data
    in this model is the same for all roles, so this detail just makes it
    easier to integrate the model with standard components.

    When the data has been set, the model must let the views know that some
    data has changed. This is done by emitting the
    \l{QAbstractItemModel::dataChanged()}{dataChanged()} signal. Since only
    one item of data has changed, the range of items specified in the signal
    is limited to just one model index.

    \section2 Inserting and Removing Rows

    It is possible to change the number of rows and columns in a model. In the
    string list model it only makes sense to change the number of rows, so we
    only reimplement the functions for inserting and removing rows. These are
    declared in the class definition:

    \quotefile stringlistmodel/model.h
    \skipto bool insertRows
    \printuntil bool removeRows

    We implement a function to allow rows to be inserted into the model:

    \quotefile stringlistmodel/model.cpp
    \skipto bool StringListModel::insertRows
    \printuntil return true
    \printuntil }

    Since rows in this model correspond to strings in a list, this function
    inserts a number of empty strings into the list before the specified
    position. The number of strings inserted is equivalent to the number of
    rows specified.

    The parent index is normally used to determine where in the model the
    rows should be added. In this case, we only have a single top-level list
    of strings, so we just insert empty strings into that list.

    The model emits the \l{QAbstractItemModel::rowsInserted()}{rowsInserted()}
    signal to inform other components that the number of rows has changed,
    and returns true to indicate success. The signal specifies the row numbers
    of the first and last rows that were inserted, and the model index for
    their parent item.
    Note that the signal is always emitted after the rows are inserted,
    allowing other components to immediately access the new rows.

    The function to remove rows from the model is also simple to write:

    \quotefile stringlistmodel/model.cpp
    \skipto bool StringListModel::removeRows
    \printuntil return true
    \printuntil }

    The rows to be removed from the model are specified by the position and
    the number of rows given. 
    We ignore the parent index to simplify our implementation, and just
    remove the corresponding items from the string list.
    The \l{QAbstractItemModel::rowsAboutToBeRemoved()}{rowsAboutToBeRemoved()}
    signal is always emitted before the rows are removed, and specifies the
    first and last rows to be removed. This allows other components to access
    the data before it is removed.

    \section1 Next Steps

    We can display the data provided by this model using the \l QListView
    class to present the model's items in the form of a vertical list. For
    the string list model, this view also provides a default editor so that
    the items can be manipulated. We examine the possibilities made
    available by the standard view classes in the chapter on
    \l{View Classes}.
*/

/*!
    \page model-view-convenience.html
    \contentspage model-view-programming.html Contents
    \previouspage Delegate Classes

    \title Item View Convenience Classes

    \tableofcontents

    \section1 Overview

    Alongside the model/view classes, Qt 4 also includes standard widgets to
    provide classic item-based container widgets. These behave in a similar
    way to the item view classes in Qt 3, but have been rewritten to use the
    underlying model/view framework for performance and maintainability. The
    old item view classes are still available in the compatibility library
    (see the \l{porting4.html}{Porting Guide} for more information).

    The item-based widgets have been given names which reflect their uses:
    \c QListWidget provides a list of items, \c QTreeWidget displays a
    multi-level tree structure, and \c QTableWidget provides a table of cell
    items. Each class inherits the behavior of the \c QAbstractItemView
    class which implements common behavior for item selection and header
    management.

    \section1 List Widgets

    Single level lists of items are typically displayed using a \c QListWidget
    and a number of \c{QListWidgetItem}s. A list widget is constructed in the
    same way as any other widget:

    \quotefile snippets/qlistwidget-using/mainwindow.h
    \skipto QListWidget *
    \printuntil QListWidget *
    \quotefile snippets/qlistwidget-using/mainwindow.cpp
    \skipto listWidget = new
    \printuntil listWidget = new

    List items can be added directly to the list widget when they are
    constructed:

    \quotefile snippets/qlistwidget-using/mainwindow.cpp
    \skipto new QListWidgetItem(tr("Sycamore"
    \printuntil new QListWidgetItem(tr("Mahogany"

    They can also be constructed without a parent list widget and added to
    a list at some later time:

    \quotefile snippets/qlistwidget-using/mainwindow.cpp
    \skipto QListWidgetItem *newItem
    \printuntil newItem->setText(
    \skipto listWidget->insertItem
    \printuntil listWidget->insertItem

    Each item in a list can display a text label and an icon. The colors
    and font used to render the text can be changed to provide a customized
    appearance for items. Tooltips, status tips, and "What's
    This?" help are all easily configured to ensure that the list is properly
    integrated into the application.

    \skipto newItem->setToolTip(
    \printuntil newItem->setWhatsThis(

    By default, items in a list are presented in the order of their creation.
    Lists of items can be sorted according to the criteria given in
    \l{Qt::SortOrder} to produce a list of items that is sorted in forward or
    reverse alphabetical order:

    \quotefile snippets/qlistwidget-using/mainwindow.cpp
    \skipto listWidget->sortItems(Qt::Ascend
    \printuntil listWidget->sortItems(Qt::Ascend
    \skipto listWidget->sortItems(Qt::Descend
    \printuntil listWidget->sortItems(Qt::Descend


    \section1 Tree Widgets

    Trees or hierarchical lists of items are provided by the \c QTreeWidget
    and \c QTreeWidgetItem classes. Each item in the tree widget can have
    child items of its own, and can display a number of columns of
    information. Tree widgets are created just like any other widget:

    \quotefile snippets/qtreewidget-using/mainwindow.h
    \skipto QTreeWidget *
    \printuntil QTreeWidget *
    \quotefile snippets/qtreewidget-using/mainwindow.cpp
    \skipto treeWidget = new
    \printuntil treeWidget = new

    Before items can be added to the tree widget, the number of columns must
    be set. For example, we could define two columns, and create a header
    to provide labels at the top of each column:

    \skipto treeWidget->setColumnCount
    \printuntil treeWidget->setColumnCount
    \printuntil treeWidget->setHeaderLabels

    The easiest way to set up the labels for each section is to supply a string
    list. For more sophisticated headers, you can construct a tree item,
    decorate it as you wish, and use that as the tree widget's header.

    Top-level items in the tree widget are constructed with the tree widget as
    their parent widget. They can be inserted in an arbitrary order, or you
    can ensure that they are listed in a particular order by specifying the
    previous item when constructing each item:

    \skipto QTreeWidgetItem *cities
    \printuntil osloItem->setText(1
    \skipto QTreeWidgetItem *planets
    \printuntil QTreeWidgetItem *planets

    Tree widgets deal with top-level items slightly differently to other
    items from deeper within the tree. Items can be removed from the top
    level of the tree by calling the tree widget's
    \l{QTreeWidget::takeTopLevelItem()}{takeTopLevelItem()} function, but
    items from lower levels are removed by calling their parent item's
    \l{QTreeWidgetItem::takeChild()}{takeChild()} function.
    Items are inserted in the top level of the tree with the
    \l{QTreeWidget::insertTopLevelItem()}{insertTopLevelItem()} function.
    At lower levels in the tree, the parent item's 
    \l{QTreeWidgetItem::insertChild()}{insertChild()} function is used.

    It is easy to move items around between the top level and lower levels
    in the tree. We just need to check whether the items are top-level items
    or not, and this information is supplied by each item's \c parent()
    function. For example, we can remove the current item in the tree widget
    regardless of its location:

    \quotefile snippets/qtreewidget-using/mainwindow.cpp
    \skipto void MainWindow::removeItem()
    \skipto QTreeWidgetItem *parent
    \printuntil treeWidget->takeTopLevelItem(
    \printuntil }

    Inserting the item somewhere else in the tree widget follows the same
    pattern:

    \quotefile snippets/qtreewidget-using/mainwindow.cpp
    \skipto void MainWindow::insertItem()
    \skipto QTreeWidgetItem *parent
    \printuntil else
    \printuntil newItem = new


    \section1 Table Widgets

    Tables of items similar to those found in spreadsheet applications
    are constructed with the \c QTableWidget and \c QTableWidgetItem. These
    provide a scrolling table widget with headers and items to use within it.

    Tables can be created with a set number of rows and columns, or these
    can be added to an unsized table as they are needed.

    \quotefile snippets/qtablewidget-using/mainwindow.h
    \skipto QTableWidget *
    \printuntil QTableWidget *
    \quotefile snippets/qtablewidget-using/mainwindow.cpp
    \skipto tableWidget = new
    \printuntil tableWidget = new

    Items are constructed outside the table before being added to the table
    at the required location:

    \skipto QTableWidgetItem *newItem
    \printuntil tableWidget->setItem(

    Horizontal and vertical headers can be added to the table by constructing
    items outside the table and using them as headers:

    \quotefile snippets/qtablewidget-using/mainwindow.cpp
    \skipto QTableWidgetItem *valuesHeaderItem
    \printuntil tableWidget->setHorizontalHeaderItem(0

    Note that the rows and columns in the table begin at zero.

    \section1 Common Features

    There are a number of item-based features common to each of the
    convenience classes that are available through the same interfaces
    in each class. We present these in the following sections with some
    examples for different widgets.
    Look at the list of \l{Model/View Classes} for each of the widgets
    for more details about the use of each function used.

    \section2 Hidden Items

    It is sometimes useful to be able to hide items in an item view widget
    rather than remove them. Items for all of the above widgets can be
    hidden and later shown again. You can determine whether an item is hidden
    by calling the isItemHidden() function, and items can be hidden with
    \c setItemHidden(). 

    Since this operation is item-based, the same function is available for
    all three convenience classes.

    \section2 Selections

    The way items are selected is controlled by the widget's selection mode
    (\l{QAbstractItemView::SelectionMode}).
    This property controls whether the user can select one or many items and,
    in many-item selections, whether the selection must be a continuous range
    of items. The selection mode works in the same way for all of the
    above widgets.

    \table
    \row
    \i \img selection-single.png
    \i \bold{Single item selections:}
    Where the user needs to choose a single item from a widget, the
    default \c SingleSelection mode is most suitable. In this mode, the
    current item and the selected item are the same.

    \row
    \i \img selection-multi.png
    \i \bold{Multi-item selections:}
    In this mode, the user can toggle the selection state of any item in the
    widget without changing the existing selection, much like the way
    non-exclusive checkboxes can be toggled independently.

    \row
    \i \img selection-extended.png
    \i \bold{Extended selections:}
    Widgets that often require many adjacent items to be selected, such
    as those found in spreadsheets, require the \c ExtendedSelection mode.
    In this mode, continuous ranges of items in the widget can be selected
    with both the mouse and the keyboard.
    Complex selections, involving many items that are not adjacent to other
    selected items in the widget, can also be created if modifier keys are
    used.

    If the user selects an item without using a modifier key, the existing
    selection is cleared.
    \endtable

    The selected items in a widget are read using the \c selectedItems()
    function, providing a list of relevant items that can be iterated over.
    For example, we can find the sum of all the numeric values within a
    list of selected items with the following code:

    \skipto void MainWindow::sumItems()
    \skipto QList<QTableWidgetItem *>
    \printto if (number > 0)

    Note that for the single selection mode, the current item will be in
    the selection. In the multi-selection and extended selection modes, the
    current item may not lie within the selection, depending on the way the
    user formed the selection.

    \section2 Searching

    It is often useful to be able to find items within an item view widget,
    either as a developer or as a service to present to users. All three
    item view convenience classes provide a common \c findItems() function
    to make this as consistent and simple as possible.

    Items are searched for by the text that they contain according to
    criteria specified by a selection of values from
    \l{QAbstractItemModel::MatchFlags}. We can obtain a list of matching
    items with the \c findItems() function:

    \quotefile snippets/qtreewidget-using/mainwindow.cpp
    \skipto void MainWindow::findItems()
    \skipto QTreeWidgetItem *
    \printuntil QTreeWidgetItem *
    \skipto QList<QTreeWidgetItem *> found
    \printuntil }

    The above code causes items in a tree widget to be selected if they
    contain the text given in the search string. This pattern can also be
    used in the list and table widgets.

*/
