/*!
    \page qt4-interview.html
    \title The Qt 4 Interview Classes

    The Interview classes provide a model/view framework for Qt
    applications based on the well known Model-View-Controller design
    pattern. In this document, we will describe Qt's model/view
    architecture, provide some examples, and show the improvements
    offered over Qt 3's item view classes.

    \tableofcontents

    \section1 Overview of The Model/View Architecture

    Model-View-Controller (MVC) is a design pattern originating from
    Smalltalk that is often used when building user interfaces.
    In \l{http://www.amazon.com/exec/obidos/ASIN/0201633612/103-8144203-3273444}
    {Design Patterns}, Gamma et al. write:

    \quote
    MVC consists of three kinds of objects. The Model is the
    application object, the View is its screen presentation, and the
    Controller defines the way the user interface reacts to user
    input. Before MVC, user interface designs tended to lump these
    objects together. MVC decouples them to increase flexibility and
    reuse.
    \endquote

    If the view and the controller objects are combined, the result is
    the model/view architecture. This still separates the data in the
    model from its presentation to the user, but simplifies both the
    design and implementation of a framework based on these
    principles. In Interview, we also introduce the concept of the \e
    delegate to provide further user input functionality. The
    advantage of using a delegate is that it allows custom input
    widgets to be used instead of the default ones provided by views.

    Interview defines the interfaces and common functionality for the
    models, views, and delegates at the \bold{abstract level}. All
    implementations subclass the relevant abstract class:
    QAbstractItemModel, QAbstractItemView, or
    QAbstractItemDelegate. This approach ensures a common set of
    interfaces for interoperability between each of the components.

    Interview provides ready-to-use implementations of views for the
    common table, tree, and list widgets: QTableView, QTreeView, and
    QListView. These reimplement and extend the interfaces provided
    by the abstract views to provide features for particular use
    cases. 

    Two specialized abstract models are provided for use with the
    view classes: QAbstractTableModel is a useful starting point for
    providing a model to use with QTableView; QAbstractListModel
    can be subclassed to produce a list-based model to use with
    QListView. In addition, two standard model classes are supplied
    for use with the view classes: the QStandardItemModel class is a
    minimal convenience model that developers can use to manage items
    of data; QDirModel provides directory information for use with
    QListView and QTreeView.

    At the \bold{convenience level}, we find classes that are provided
    to help those who are familiar with the conventional list, tree,
    and table widgets: QListWidget, QTreeWidget, and
    QTableWidget. These present a simplified interface to the
    developer that does not explicitly require a knowledge of the
    underlying model/view architecture.

    The view widgets interact with selection objects to ensure that
    items are selected in a consistent way, and that selections can be
    shared between different views of the same model.

    For details about how to use the model/view classes, see the
    \l{model-view-programming.html}{Model/View Programming} document.

    See also the \l{qt4-sql.html}{Database GUI Layer} document for
    information about Qt 4's database models.

    \section1 Example Code

    To illustrate how the Interview classes are used, we present two
    examples that show different aspects of the model/view
    architecture.

    \section2 Sharing a Model Between Two Views

    In this example, we display the contents of a model using two
    different views, and share the user's selection between
    them. We will use the QDirModel supplied with Qt because it
    requires very little configuration, and provides existing data to
    the views.

    The main() function for this example demonstrates all the
    principles involved in setting up the model, the views, and the
    selection:

    \quotefromfile snippets/shareddirmodel/main.cpp
    \skipto int main(
    \printuntil }

    In the above function, we constructed a directory model to display
    the contents of a default directory. The two views are constructed
    and given the same model to work with. By default, each view will
    maintain and display its own selection of items from the model,
    but we explicitly share a new selection with both the tree view
    and the list view. As a result, changes to the selection in either
    of these views will automatically cause the selection in the other
    to change.

    The model/view architecture allows us to replace the QDirModel in
    this example with a completely different model, one that will perhaps
    obtain data from a remote server, or from a database.

    \section2 Creating a Custom Model

    In this example, we display the contents of a simple read-only
    model using a ready-made view class.

    Creating a custom model for the existing views requires us
    to subclass QAbstractListModel and reimplement a standard set
    of functions. Our model will take a list of strings when
    constructed, and supply these to a view. Since we only require a
    simple read-only model, the number of functions we need to provide
    are very few.

    The complete declaration of our model is as follows:

    \quotefromfile snippets/stringlistmodel/model.h
    \skipto class StringListModel
    \printuntil };

    Since the underlying data structure contains one row for each
    string, and one column of strings, only the rowCount() function
    needs to be implemented; by default, the columnCount() function
    provided by QAbstractListModel will return a value of 1. The
    data() function returns the data that corresponds to each model
    index specified. In this way, the model controls access to the
    underlying data. We do not need to provide a function to \e set the
    data in the model because the string list is supplied to the
    constructor, and this model is read-only.

    These functions are implemented quite simply:

    \quotefromfile snippets/stringlistmodel/model.cpp
    \skipto int StringListModel::rowCount(
    \printuntil }

    \skipto QVariant StringListModel::data(
    \printuntil }

    The data() function returns a QVariant containing the
    information referred to by the model index. If the view requests
    an item from the string list, this is returned to the view, but
    only after a number of checks are performed on the model index. If
    the view specified an invalid model index, the model indicates
    this by returning an invalid QVariant.

    Vertical and horizontal headers are supplied by the headerData()
    function. In this model, the value returned for these items is the row
    or column number, depending on the header:

    \skipto QVariant StringListModel::headerData(
    \printuntil }

    We only include an excerpt from the main() function for this
    example:

    \quotefromfile snippets/stringlistmodel/main.cpp
    \skipto QStringList numbers;
    \printuntil view->setModel(model);

    We created a string list to use with the model, and this is
    supplied to the model when it is constructed. The information in
    the string list is then made available to the view via the model.

    If we require an editable model, we only need to define the following
    functions in the class declaration:

    \quotefromfile snippets/stringlistmodel/model.h
    \skipto ItemFlags flags(
    \printuntil bool setData(

    These are implemented in the following way:

    \quotefromfile snippets/stringlistmodel/model.cpp
    \skipto QAbstractItemModel::ItemFlags StringListModel::flags(
    \printuntil }

    \skipto bool StringListModel::setData(
    \printuntil return false;
    \printuntil }

    In the flags() function, we ensure that every item in the model is
    editable by returning the same combination of values for all indexes.
    The setData() function updates the data in the string list, but
    only if the specified index refers to an item that is valid, is enabled,
    and is editable. The dataChanged() signal ensures that the view is
    kept up-to-date.

    This example shows that it can be easy to populate views with data
    from a simple model. The standard models and views planned for
    Qt 4 will make the process even easier, and the convenience widgets
    supplied provide support for the classic item-based approach.

    \section1 What's Changed Since Qt 3?

    The table and item view classes in Qt 3 implemented widgets that
    served both as models and as views onto their contents. These
    classes were designed to be easy-to-use and consistent. The
    equivalent classes in Qt 4 are designed to be extensible while
    remaining easy-to-use; the introduction of the model/view
    architecture ensures that they will be more consistent than their
    predecessors. The view classes provided can be summarized
    in the following way:

    \list
    \i The QListView class provides a view widget that is
    similar to Qt 3's QListBox widget, but displays data from a
    model. It can also be used to display icons in a similar way
    to Qt 3's QIconView.
    \i The QTableView class is a view widget that displays
    data from a model of tabular data, similar to Qt 3's QTable
    widget.
    \i The QTreeView class provides a view widget that
    behaves like Qt 3's QListView widget, except that the data
    items are provided by a model.
    \endlist

    Since the model takes responsibility for managing items,
    and the view takes care of their presentation to the user,
    we do not require item classes to represent individual items.
    The delegate now handles the painting and editing of items
    from the model, and selections of items are stored in selection
    ranges.

    For developers who wish to continue to use old-style item views,
    there are a number of convenience classes that will provide
    familiar interfaces without requiring the use of compatibility
    classes. The QListWidget class provides a widget to display a
    list of items, as found in Qt 3's QListBox class, and the
    QTreeWidget class implements the equivalent of Qt 3's QListView
    class. User's of Qt 3's QTable class will find that
    QTableWidget provides comparable functionality with a familiar
    interface. Each of the convenience classes have a corresponding
    item class: QListWidgetItem, QTreeWidgetItem, and
    QTableWidgetItem are the Qt 4 equivalents of Qt 3's QListBoxItem,
    QListViewItem, and QTableItem respectively.

    The move towards a model/view architecture presents both
    challenges and opportunities for developers. Although the approach
    may appear to be rather powerful for simple applications, it
    encourages greater reuse of components, both within the library
    and within applications. For example, QFileDialog now displays
    the contents of a QDirModel using the QListView and
    QTreeView widgets.


    \link qt4-intro.html [Back to the Beta page] \endlink

*/
