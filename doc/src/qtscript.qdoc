/*!
  \module QtScript
  \since 4.3
  \title QtScript Module
  \contentspage Qt's Modules
  \previouspage QtSvg
  \nextpage QtXml
  \ingroup modules

  \brief The QtScript module provides classes for making Qt applications scriptable.

  \tableofcontents

  \section1 Configuring the Build Process

  Applications that use Qt's Script classes need to
  be configured to be built against the QtScript module.
  To include the definitions of the module's classes, use the
  following directive:

  \code
      #include <QtScript>
  \endcode

  To link against the module, add this line to your \l qmake \c
  .pro file:

  \code
      QT += script
  \endcode

  The QtScript module is part of the \l{Qt Desktop Edition} and the
  \l{Qt Open Source Edition}.

  \section1 Language Overview

  Qt Script is based on the ECMAScript scripting language, as defined
  in standard \l{ECMA-262}. Microsoft's JScript, and Netscape's
  JavaScript are also based on the ECMAScript standard. For an
  overview of ECMAScript, see the \l{ECMAScript Reference}{ECMAScript reference}.
  If you are not familiar with the ECMAScript language, there are
  several existing tutorials and books that cover this subject, such
  as \l{JavaScript: The Definitive Guide}.
  
  \section1 Basic Usage

  To evaluate script code, you create a QScriptEngine and call its
  evaluate() function, passing the script code (text) to evaluate
  as argument. The return value will be the result of the evaluation
  (represented as a QScriptValue).

  \code
  QScriptEngine engine;
  qDebug() << "the magic number is:" << engine.evaluate("1 + 2").toNumber();
  \endcode

  Registering your custom properties in the script environment (thus
  making them available to script code) is most easily done by setting
  properties of the script engine's \bold{Global Object}:

  \code
  QScriptValue val(&engine, 123);
  engine.globalObject().setProperty("foo", val);
  qDebug() << "foo times two is:" << engine.evaluate("foo * 2").toNumber();
  \endcode

  \section1 Making a QObject Available to the Script Engine

  By passing a QObject to the QScriptEngine::newQObject()) function,
  you create a QtScript wrapper object that can be used to make the
  QObject's signals, slots, properties, and child objects available
  to scripts. Because Qt Script uses Qt's meta object system, there
  is no need to implement any additional wrappers or bindings.

  Here's an example of making a QObject available to script code
  under the name \c{"myQObject"}:

  \code
  QScriptEngine engine;
  QObject *someQObject = ...;
  QScriptValue qobjectValue = engine.newQObject(someQObject);
  engine.globalObject().setProperty("myQObject", qobjectValue);
  \endcode

  newQObject() can take two additional arguments, one being
  the ownership mode, and the other being options that allow you
  to control certain aspects of how the QScriptValue that wraps
  the QObject should behave. We will come back to the usage of
  these arguments later.

  \section2 Using Signals and Slots

  To connect to a signal, you invoke the \c{connect()} function of
  the signal from script code. There are three overloads of \c{connect()}:

  \list
  \i \c{connect(function)}: The argument is the function to connect to the signal.

  \code
  function myInterestingScriptFunction() { ... }

  ...

  myQObject.somethingChanged.connect(myInterestingScriptFunction);
  \endcode

  The argument can be a Qt Script function, as in the above
  example, or it can be a QObject slot, as in
  the following example:

  \code
  myQObject.somethingChanged.connect(myOtherQObject.doSomething);
  \endcode

  To disconnect from a signal, you invoke the signal's
  \c{disconnect()} function, passing the function to disconnect
  as argument:

  \code
  myQObject.somethingChanged.disconnect(myInterestingFunction);
  myQObject.somethingChanged.disconnect(myOtherQObject.doSomething);
  \endcode

  When a script function is invoked in response to a signal, the
  `this' object will be the object that emitted the signal.

  \i \c{connect(thisObject, function)}: The first argument is the
  object to use as the `this' object when invoking the function to
  connect to the signal (the second argument).

  If you have a pushbutton in a form, you typically want to do
  something involving the form in response to the button's
  \c{clicked} signal; passing the form as the `this' object
  makes sense in such a case.

  \code
  var obj = { x: 123 };
  var fun = function() { print(this.x); };
  myQObject.somethingChanged.connect(obj, fun);
  \endcode

  To disconnect from the signal, pass the same arguments to \c{disconnect()}:

  \code
  myQObject.somethingChanged.disconnect(obj, fun);
  \endcode

  \i \c{connect(thisObject, functionName)}: The first argument is
  the object to use as the `this' object when invoking the function
  in response to the signal. The second argument is the name of the
  property of \c{thisObject} that holds the function to connect to.
  Note that the function is resolved at connect time, not at
  signal handling time.

  \code
  var obj = { x: 123, fun: function() { print(this.x); } };
  myQObject.somethingChanged.connect(obj, "fun");
  \endcode

  To disconnect from the signal, pass the same arguments to \c{disconnect()}:

  \code
  myQObject.somethingChanged.disconnect(obj, "fun");
  \endcode

  \endlist

  To emit a signal from script code, you simply invoke the signal
  function, passing the relevant arguments:

  \code
  myQObject.somethingChanged("hello");
  \endcode

  \section2 Accessing Properties

  The properties of the QObject are available as properties
  of the corresponding Qt Script object. When you manipulate
  a property in script code, the C++ get/set method for that
  property will automatically be invoked. For example, if your
  C++ class has a property declared as follows:

  \code
  Q_PROPERTY(bool enabled READ enabled WRITE setEnabled)
  \endcode

  then script code can do things like the following:

  \code
  myQObject.enabled = true;

  ...

  myQObject.enabled = !myQObject.enabled;
  \endcode

  \section2 Accessing Child QObjects

  Every named child of the QObject is by default available as
  a property of the corresponding Qt Script object. For example,
  if you have a QDialog whose \c{objectName()} is \c{"okButton"},
  you can access this object in script code through the expression

  \code
  myDialog.okButton
  \endcode

  Since \c{objectName} is itself a Q_PROPERTY, you can manipulate
  the name in script code:

  \code
  myDialog.okButton.objectName = "cancelButton";
  // from now on, myDialog.cancelButton references the button
  \endcode

  You can also use the functions \c{findChild()} and \c{findChildren()}
  to find children. These two functions behave identically to
  QObject::findChild() and QObject::findChildren(), respectively.
  Example:

  \code
  var okButton = myDialog.findChild("okButton");
  if (okButton != null) {
     // do something with the OK button
  }

  var buttons = myDialog.findChildren(RegExp("button[0-9]+"));
  for (var i = 0; i < buttons.length; ++i) {
     // do something with buttons[i]
  }
  \endcode

  You typically want to use \c{findChild()} when manipulating a form
  that uses nested layouts; that way the script is isolated from the
  details about which particular layout a widget is located in.

  \section2 Controlling QObject Ownership

  By default, the script engine does not take ownership of the
  QObject that is passed to QScriptEngine::newQObject(). You can
  change that by specifying a different ownership mode as the
  second argument (QScriptEngine::QtOwnership is the default).
  Specifying QScriptEngine::ScriptOwnership will cause the script
  engine to take full ownership of the QObject and delete it when
  it deems that it is safe to do so. If the QObject does not
  have a parent object, and/or the QObject is created in context
  of the script engine and is not intended to outlive the script
  engine, this ownership mode is appropriate.
  For example, a constructor function that constructs QObjects
  only to be used in the script environment is a good candidate:

  \code
  QScriptValue myQObjectConstructor(QScriptContext *context, QScriptEngine *engine)
  {
    // let the engine manage the new object's lifetime.
    return engine->newQObject(new MyQObject(), QScriptEngine::ScriptOwnership);
  }
  \endcode

  Another ownership mode is QScriptEngine::AutoOwnership, where
  the ownership is based on whether the QObject has a parent or not.
  If the QtScript garbage collector finds that the QObject is no
  longer referenced within the script environment, the QObject will
  be deleted \bold{only} if it does not have a parent.

  \section2 Customizing Access to the QObject

  QScriptEngine::newQObject() can take a third argument which allows
  you to control various aspects of the access to the QObject through
  the QtScript wrapper object (the value returned by newQObject()).
  QScriptEngine::ExcludeChildObjects specifies that child objects of
  the QObject should not appear as properties of the wrapper object.
  QScriptEngine::ExcludeSuperClassProperties and
  QScriptEngine::ExcludeSuperClassMethods can be used to avoid
  exposing members that are inherited from the QObject's superclass;
  this is useful e.g. when you want to define a "pure" interface where
  inherited members don't make sense from a scripting perspective
  (e.g. you don't want script authors to be able to change the
  \c{objectName} property of the object, or invoke the \c{deleteLater()} slot).
  QScriptEngine::AutoCreateDynamicProperties specifies that properties
  that don't already exist in the QObject should be created as dynamic
  properties of the QObject, rather than as properties of the QtScript
  wrapper object. If you want new properties to truly become persistent
  properties of the QObject, rather than properties that die when the
  wrapper object dies (and that aren't shared if the QObject is wrapped
  multiple times with newQObject()), you should use this option.

  \section1 How to Design and Implement Application Objects

  This section explains how to implement application objects and
  provides the necessary technical background material.

  \section2 Making a C++ object available to Scripts Written in Qt Script

  Making C++ classes and objects available to a scripting language is
  not trivial since scripting languages are more dynamic than C++ and
  it must be possible to introspect objects (query information such as
  functions names, function signatures, properties, etc., at
  runtime). Standard C++ doesn't provide for this.

  We can achieve the functionality we want by extending C++, using
  C++'s own facilities so our code is still standard C++. The Qt meta
  object system provides the necessary additional functionality. It
  allows us to write using an extended C++ syntax, but converts this
  into standard C++ using a small utility program called \l{moc} (Meta
  Object Compiler). Classes that wish to take advantage of the meta
  object facilities are either subclasses of QObject, or use the
  \c{Q_OBJECT} macro. Qt has used this approach for many years and it has
  proven to be solid and reliable. Qt Script uses this meta object
  technology to provide scripters with dynamic access to C++ classes
  and objects.

  To completely understand how to make C++ objects available to Qt
  Script, some basic knowledge of the Qt meta object system is very
  helpful. We recommend that you read the \l{Qt Object Model}. The
  information in this document and the documents it links to are very
  useful for understanding how to implement application objects,
  however this knowledge is not essential. To make an object available
  in Qt Script, it must derive from QObject. All classes which derive
  from QObject are introspective and can provide the information
  needed by the scripting engine, e.g. classname, functions,
  signatures, etc., at runtime. Because we obtain the information we
  need about classes dynamically at run time, there is no need to
  write wrappers for QObject derived classes.

  \section2 Making C++ Class Member Functions Available in Qt Script

  The meta object system makes information about slots dynamically
  available at runtime. This means that for QObject derived classes,
  only the slots are automatically made available to scripts. This is
  very convenient, because in practice we normally only want to make
  specially chosen functions available to scripters.  When you create
  a QObject subclass, make sure that the functions you want to be
  available to scripters are public slots:

    \code
    class MyObject : public QObject
    {
        Q_OBJECT

    public:
        MyObject( ... );

        void aNonScriptableFunction();

    public slots: // these functions (slots) will be available in Qt Script
        void calculate( ... );
        void setEnabled( bool enabled );
        bool isEnabled() const;

    private:
       ....

    };
    \endcode

  In the example above, aNonScriptableFunction() is not declared as a
  slot, so it will not be available in Qt Script. The other three
  functions will automatically be made available in Qt Script.

  \section2 Making C++ Class Properties Available in Qt Script

  In the previous example, if we wanted to get or set a property using
  Qt Script we would have to write code like the following:

    \code
    var obj = new MyObject;
    obj.setEnabled( true );
    print( "obj is enabled: " + obj.isEnabled() );
    \endcode

  Scripting languages often provide a property syntax to modify and
  retrieve properties (in our case the enabled state) of an
  object. Many script programmers would want to write the above code
  like this:

    \code
    var obj = new MyObject;
    obj.enabled = true;
    print( "obj is enabled: " + obj.enabled );
    \endcode

  To make this possible, you must define properties in the C++ QObject
  subclass. The class declaration of MyObject must look like the
  following to declare a property enabled of the type bool, which
  should use the function \c{setEnabled(bool)} as its setter function and
  the function \c{isEnabled()} as its getter function:

    \code
    class MyObject : public QObject
    {
        Q_OBJECT
        // define the enabled property
        Q_PROPERTY( bool enabled WRITE setEnabled READ isEnabled )

    public:
        MyObject( ... );

        void aNonScriptableFunction();

    public slots: // these functions (slots) will be available in Qt Script
        void calculate( ... );
        void setEnabled( bool enabled );
        bool isEnabled() const;

    private:
       ....

    };
    \endcode

  The only difference from the original code is the use of the macro
  \c{Q_PROPERTY}, which takes the type and name of the property, and
  the names of the setter and getter functions as arguments.

  \section2 Reacting to C++ Objects Signals in Scripts

  In the Qt object model, signals are used as a notification mechanism
  between QObjects. This means one object can connect a signal to
  another object's slot and every time the signal is fired (emitted)
  the slot is called. This connection is established using the
  QObject::connect() function. This mechanism is also available to Qt
  Script programmers. The C++ code for declaring a signal is no
  different for a C++ class that is to be used by Qt Script than a C++
  class used with Qt.

    \code
    class MyObject : public QObject
    {
        Q_OBJECT
        // define the enabled property
        Q_PROPERTY( bool enabled WRITE setEnabled READ isEnabled )

    public:
        MyObject( ... );

        void aNonScriptableFunction();

    public slots: // these functions (slots) will be available in Qt Script
        void calculate( ... );
        void setEnabled( bool enabled );
        bool isEnabled() const;

    signals: // the signals
        void enabledChanged( bool newState );

    private:
       ....

    };
    \endcode

  The only change this time is to declare a signals section, and
  declare the relevant signal in it.  Now the script writer can write
  a function and connect to the object like this:

    \code
    function enabledChangedHandler( b )
    {
        print( "state changed to: " + b );
    }

    function init()
    {
        var obj = new MyObject();
        // connect a script function to the signal
        obj["enabledChanged(bool)"].connect(enabledChangedHandler);
        obj.enabled = true;
        print( "obj is enabled: " + obj.enabled );
    }
    \endcode

  \section2 Design of Application Objects

  The previous section described how to implement C++ objects which
  can be used in Qt Script. Application objects are the same kind of
  objects, and they make your application's functionality available to
  Qt Script scripters.  Since the C++ application is already written
  in Qt, many objects are already QObjects. The easiest approach would
  be to simply add all these QObjects as application objects to the
  scripting engine. For small applications this might be sufficient,
  but for larger applications this is probably not the right
  approach. The problem is that this method reveals too much of the
  internal API and gives script programmers access to application
  internals which should not be exposed.  Generally, the best way of
  making application functionality available to scripters is to code
  some QObjects which define the applications public API using
  signals, slots, and properties. This gives you complete control of
  the functionality you make available. The implementation of these
  objects simply calls the functions in the application which do the
  real work. So instead of making all your QObjects available to the
  scripting engine, just add the wrapper QObjects.

  \section1 ECMAScript Compatibility

  QtScript implements all the built-in classes and functions defined
  in ECMA-262.

  The Date parsing and string conversion functions are implemented using
  QDateTime::fromString() and QDateTime::toString(), respectively.

  The RegExp class is a wrapper around QRegExp. The QRegExp semantics
  do not precisely match the semantics for regular expressions defined
  in ECMA-262.

  \section1 QtScript Extensions to ECMAScript

  \list
  \i \c{__proto__}: The prototype of an object (QScriptValue::prototype())
    can be accessed through its \c{__proto__} property in script code.
    This property has flags QScriptValue::Undeletable.
    Example:

  \code
    var o = new Object();
    (o.__proto__ === Object.prototype); // this evaluates to true
  \endcode

  \i \c{Object.prototype.__defineGetter__}: This function installs a
    getter function for a property of an object. The first argument is
    the property name, and the second is the function to call to get
    the value of that property. When the function is invoked, the
    `this' object will be the object whose property is being accessed.
    Example:

  \code
    var o = new Object();
    o.__defineGetter__("x", function() { return 123; });
    var y = o.x; // 123
  \endcode

  \i \c{Object.prototype.__defineSetter__}: This function installs a
    setter function for a property of an object. The first argument is
    the property name, and the second is the function to call to set
    the value of that property.  When the function is invoked, the
    `this' object will be the object whose property is being accessed.
    Example:

  \code
    var o = new Object();
    o.__defineSetter__("x", function(v) { print("and the value is:", v); });
    o.x = 123; // will print "and the value is: 123"
  \endcode

  \i \c{Function.prototype.connect}: This function connects
    a signal to a slot. Usage of this function is described in
    the section \l{Using Signals and Slots}.

  \i \c{Function.prototype.disconnect}: This function disconnects
    a signal from a slot. Usage of this function is described in
    the section \l{Using Signals and Slots}.

  \i \c{QObject.prototype.findChild}: This function is semantically
    equivalent to QObject::findChild().

  \i \c{QObject.prototype.findChildren}: This function is semantically
    equivalent to QObject::findChildren().

  \i \c{QObject.prototype.toString}: This function returns a default string
    representation of a QObject.

  \i \c{gc}: This function invokes the garbage collector.
  \endlist

 */
