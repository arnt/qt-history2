/*!
    \page qtopiacore-performance.html
    \contentspage Qtopia Core

    \title Performance Tuning
    \ingroup qtopiacore

    When building embedded applications on low-powered devices, a
    number of options are available that reduce the memory and/or CPU
    requirements by making various trade-offs. These options range
    from variations in programming style, to linking and memory
    allocation.

    But note that the most direct way of saving resources, is to avoid
    compiling in features that are not required. See \l {Fine-Tuning
    Features} for details.

    \tableofcontents

    \section1 Programming Style

    Rather than creating dialogs and widgets every time they are
    needed, and delete them when they are no longer required, create
    them once and use the QWidget::hide() and QWidget::show()
    functions whenever appropiate.  To avoid a a slow startup of the
    application, delay the creation of dialogs and widgets until they
    are requested.

    This will improve CPU performance: The approach requires a little
    more memory, but will be much faster.

    \section1 Static vs. Dynamic Linking

    A lot of CPU and memory is used by the ELF (Executable and Linking
    Format) linking process. Significant savings can be achieved by
    using a static build of the application suite.

    This means that rather than having dynamic Qt libraries and a
    collection of executables which link dynamically to these
    libraries, all the applications is built into into a single
    executable which is statically linked to static Qt libraries.

    This improves the start-up time and reduces memory usage, at the
    expense of flexibility (to add a new application, you must
    recompile the single executable) and robustness (if one
    application has a bug, it might harm other applications).

    \table 100%
    \row
    \o \bold {Creating a Static Build}

    To compile Qt as a static library, use the \c -static option when
    running configure:

    \code
        ./configure -static
    \endcode

    To build the application suite as an all-in-one application,
    design each application as a stand-alone widget (or set of
    widgets) with only minimal code in the \c main() function. Then,
    write an application that provides a means of switching between
    the applications.

    Note that the application still should link dynamically against
    the standard C library and any other libraries which might be used
    by other applications on the target device.

    \endtable

    The \l Qtopia platform is an example using this apporach: It can
    be built either as a set of dynamically linked executables, or as
    a single static application.

    When installing end-user applications, this approach may not be an
    option, but when building a single application suite for a device
    with limited CPU power and memory, this option could be very
    beneficial.

    \section1 Alternative Memory Allocation

    The libraries shipped with some C++ compilers on some platforms
    have poor performance in the built-in "new" and "delete"
    operators. Improved memory allocation and performance may be
    gained by re-implementing these functions:

    \code
        void *operator new[](size_t size)
        {
            return malloc(size);
        }

        void *operator new(size_t size)
        {
            return malloc(size);
        }

        void operator delete[](void *ptr)
        {
            free(ptr);
        }

        void operator delete[](void *ptr, size_t)
        {
            free(ptr);
        }

        void operator delete(void *ptr)
        {
            free(ptr);
        }

        void operator delete(void *ptr, size_t)
        {
            free(ptr);
        }
    \endcode

    The example above shows the necessary code to switch to the plain
    C memory allocators.

    \section1 Bypassing the Backing Store

    The backing store is a paint buffer that is used to reduce flicker,
    and to support graphics operations such as blending. On some devices,
    the memory requirements of the backing store are 

    \omit
    Memory = number of visible top-level windows * size of each widget * bit depth
    \endomit

    To bypass the backing store for any given application, it must be executed
    with the following value set in the running environment:

    \code
    QT_ONSCREEN_PAINT = 1
    \endcode

    This option only has an effect on opaque top-level windows. Enabling this
    option also has the side effect that software-based mouse cursors will be
    invisible when positioned any of the application's opaque windows since the
    cursor image cannot be superimposed on them.
*/
