/****************************************************************************
**
** Qt Coordinate System Documentation.
**
** Copyright (C) 1992-$THISYEAR$ Trolltech AS. All rights reserved.
**
** This file is part of the Qt GUI Toolkit.
** EDITIONS: FREE, PROFESSIONAL, ENTERPRISE
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
****************************************************************************/

/*!
    \page coordsys.html

    \title The Coordinate System

    A \link QPaintDevice paint device\endlink in Qt is a drawable 2D
    surface. \l QWidget, \l QPixmap, \l QPicture, and \l QPrinter are all
    paint devices. A \l QPainter is an object which can draw on such
    devices.

    The default coordinate system of a paint device has its origin at the
    top-left corner. The \e x values increase to the right and the \e y
    values increase downwards. The default unit is one pixel on
    pixel-based devices and one point (1/72 of an inch) on printers.

    \section1 An Example

    The illustration below shows a highly magnified portion of the top
    left corner of a paint device.

    \img coordsys.png

    The rectangle and the line were drawn by this code (with the grid
    added and colors touched up in the illustration):

    \quotefromfile snippets/coordsys/coordsys.cpp
    \skipto ::paintEvent
    \printuntil /^\}/

    Note that although we specify 4 x 3 to QPainter::drawRect() as
    the size, the actual rectangle ends up emcompassing 5 x 4 pixels.
    This is different from some toolkits (including earlier versions
    of Qt); starting with Qt 4, the size you specify is the size of
    the mathematical rectangle, without considering the pen width.
    This makes sense when you apply transformations (scaling,
    shearing, etc.). This applies to all the relevant functions in
    QPainter (e.g., \l{QPainter::drawRoundRect()}{drawRoundRect()},
    \l{QPainter::drawEllipse()}{drawEllipse()}).

    Similarly, the QPainter::drawLine() call draws both end points of
    the line, not just one.

    Here are the classes that relate most closely to the coordinate
    system. Some classes exist in two versions: an \c{int}-based
    version and a \c{float}-based version. For these, the \c float
    version's name is suffixed with an \c F.

    \table
    \header \o Class \o Description
    \row \o \l{QPoint}(\l{QPointF}{F})
         \o A single 2D point in the coordinate system. Most functions in
	    Qt that deal with points can accept either a QPoint, a QPointF,
            or two \c{int}s.
    \row \o \l{QSize}(\l{QSizeF}{F})
         \o A single 2D vector. Internally, QPoint and QSize are the same,
	    but a point is not the same as a size, so both classes exist.
	    Again, most functions accept either QSizeF, a QSize, or two 
            \c{int}s.
    \row \o \l{QRect}(\l{QRectF}{F})
         \o A 2D rectangle. Most functions accept either a QRectF, a
            QRect, or four \c{int}s.
    \row \o \l{QLine}(\l{QLineF}{F})
         \o A 2D finite-length line, characterized by a start point
            and an end point.
    \row \o QPolygon
         \o A 2D polygon. A polygon is a vector of \c{QPointF}s. If
            the first and last points are the same, the polygon is
            closed.
    \row \o QPainter
         \o The class that paints. It can paint on any device with the
	    same code. There are differences between devices, 
            QPrinter::newPage() is a good example, but QPainter works the
	    same way on all devices.
    \row \o QMatrix
         \o A 3 x 3 transformation matrix. Use QMatrix to rotate, shear,
            scale, or translate the coordinate system.
    \row \o QPainterPath
         \o A vectorial specification of a 2D shape. Painter paths
            are the ultimate painting primitive, in the sense that
            any shape (rectange, ellipse, spline) or combination of
            shapes can be expressed as a path. A path specifies both
            an outline and an area.
    \row \o QPaintDevice
         \o A device on which QPainter can paint. There are two internal
	    devices, both pixel-based, and two external devices,
            QPrinter and QPicture (which records QPainter commands to a
	    file or other QIODevice, and plays them back). Other
	    devices can be defined.
    \row \o QPaintEngine
         \o The base class for painter backends. Qt includes several
            backends. You normally don't need to use this class
            directly.
    \row \o QRegion
         \o An area in a paint device, expressed as a list of
            \l{QRect}s. In general, we recommend using the vectorial
            QPainterPath class instead of QRegion for specifying
            areas, because QPainterPath handles painter
            transformations much better.
    \endtable

    \section1 Transformations

    Qt's default coordinate system works as described above, with (0,
    0) at the top-left. QPainter also supports arbitrary
    transformations, through its transformation matrix. Use this
    matrix to orient and position your objects in your model. Qt
    provides methods such as QPainter::rotate(), QPainter::scale(),
    QPainter::translate() and so on to operate on this matrix.

    QPainter::save() and QPainter::restore() save and restore this
    matrix. You can also use QMatrix objects, QPainter::matrix() and
    QPainter::setMatrix() if you need the same transformations over
    and over.

    One frequent need for the transformation matrix is when reusing
    the same drawing code on a variety of paint devices. Without
    transformations, the results are tightly bound to the resolution
    of the paint device. Printers have typically 600 dots per inch,
    whereas screens often have between 75 and 100 dots per inch.

    Here is a short example that uses the matrix to draw the clock
    face in the \l widgets/analogclock example. We recommend
    compiling and running the example before you read any further. In
    particular, try resizing the window to different sizes.

    \quotefromfile widgets/analogclock/analogclock.cpp
    \skipto ::paintEvent
    \printuntil scale

    First, we set up the painter. We translate the coordinate system
    so that point (0, 0) is in the widget's center, instead of being
    at the top-left corner. We also scale the system by \c side /
    100, where \c side is either the widget's width or the height,
    whichever is shortest. We want the clock to be square, even if
    the device isn't.

    This will give us a 100 x 100 square area with point (0, 0) in
    the middle that we can draw on. What we draw will show up in the
    largest possible square that will fit in the widget.

    \printline painter.save()
    \printline rotate
    \printline hourHand
    \printline restore

    We draw the clock's hour hand by rotating the coordinate system
    and calling QPainter::drawConvexPolygon(). Thank's to the
    rotation, it's drawn pointed in the right direction.

    The polygon is specified as an array of alternating \e x, \e y
    values, stored in the \c hourHand static variable (defined at the
    beginning of the function), which corresponds to the four points
    (2, 0), (0, 2), (-2, 0), and (0, -25).

    The calls to QPainter::save() and QPainter::restore() surrounding
    the code guarantees that the code that follows won't be disturbed
    by the transformations we've used.

    \printline painter.save()
    \printline rotate
    \printline minuteHand
    \printline restore

    We do the same for the clock's minute hand, which is defined by
    the four points (1, 0), (0, 1), (-1, 0), and (0, -40). These
    coordinates specify a hand that is thinner and longer than the
    minute hand.

    \printline for (int
    \printuntil }

    Finally, we draw the clock face, which consists of twelve short
    lines at 30-degree intervals. At the end of that, the painter is
    rotated in a way which isn't very useful, but we're done with
    painting so that doesn't matter.
*/
