/*!
    \page arthur-overview.html

    \title The Qt 4.0 Paint Subsystem

    This document describes Qt 4's approach to painting, and contrasts
    it with the Qt 3 approach.

    \tableofcontents

    \section1 Architecture

    The Qt 4 Paint Subsystem is primarly based on the classes \l
    QPainter, \l QPaintDevice and \l QPaintEngine. \l QPainter is the
    class used to perform drawing operations, for example, \c
    drawLine() and \l drawRect(). \l QPaintDevice is an object that
    can be painted on using a \l QPainter. Both \l QWidget and \l
    QPixmap are QPaintDevices. \l QPaintEngine is the painter's means
    of drawing to a specific device type.

    \section2 A look back at Qt 3.x

    In Qt 3.x QPainter could be used to draw on widgets and pixmaps. (It
    could also be used to draw to printers on Windows and Mac OS
    X). When other paint devices needed to be supported, such as
    QPrinter on X11, this was done by deriving from QPaintDevice and
    reimplementing the virtual function QPaintDevice::cmd(). A
    reimplemented paint device was treated as an external device.

    QPainter was capable of recognizing external devices and could
    serialize each paint operation to the reimplemented cmd()
    function. This allowed reimplementation of arbitrary devices, but
    the approach has some disadvantages which we have addressed in
    Qt 4. One of these is that an external device could not reuse any
    functionality implemented in QPainter since QPainter is tied to
    widget/pixmap painting on the current platform. Supporting
    multiple device backends, such as OpenGL, was therefore
    inconvenient and not very efficient.

    This has led us to devise a more convenient and intuitive API for
    Qt 4.

    \section2 How painting is done in Qt 4

    In Qt 4 we have introduced the abstract class \l QPaintEngine.
    Implementations of this class provide the concrete functionallity
    needed to draw to a specific device type. The class QPaintEngine
    is only used internally by QPainter and QPaintDevice and is hidden
    from application programmers, unless they reimplement their own
    device type in their own QPaintEngine subclass. Qt currently
    provides paint engines for the following platforms and API's:

    \list
    \i GDI and GDI+ on Windows
    \i OpenGL on all platforms
    \i PostScript on Linux, Unix, and Mac OS X
    \i QuickDraw and CoreGraphics on Mac OS X
    \i X11 and the X Render Extension on Linux and Unix systems
    \endlist

    To implement support for a new backend, you must derive from
    QPaintEngine and reimplement its virtual functions. You also need
    to derive from QPaintDevice and reimplement the virtual function
    \l QPaintDevice::paintEngine() to tell QPainter which paint engine
    should be used to draw on this particular device.

    The main benefit of this approach is that all painting follows the
    same painting pipeline which means that adding support for new features
    and providing default implementations for unsupported ones has
    become much simpler.

    \section2 Enabling use of GDI+ on Windows

    GDI+ is installed by default on Windows XP, and is available as a
    downloadable redistributable binary for 98/ME/NT/2000. In order for
    Qt to take advantage of the features in GDI+ the gdiplus.dll
    library must be in the PATH.

    \section1 New features in the Qt 4 paint subsystem

    \section2 Linear gradient brushes

    With Qt 4 it is possible to fill shapes using a linear gradient
    brush. A gradient in this case is used to describe the transition
    from one color at one point to another color at another point. We
    use the term linear gradient since the transition area follows a
    line.

    Setting a linear gradient brush is done using the \l QBrush constructor
    that takes two points and two colors, as sketched below:

    \code
    QBrush diagonalGradient(QPoint(0, 0), Qt::red, QPoint(width(), height()), Qt::blue);
    painter.setBrush(diagonalGradient);
    painter.drawRect(0, 0, width(), height());
    \endcode

    The code shown above produces a pattern as show in the following pixmap:

    \img diagonalGradient.png

    \sa QBrush


    \section2 Alpha-blended drawing

    With Qt 4 we support alpha-blended outlining and filling. The alpha
    channel of a color is specified through \l QColor.

    \code
    // Specfiy semi-transparent red
    painter.setBrush(QColor(255, 0, 0, 127));
    painter.drawRect(0, 0, width()/2, height());

    // Specify semi-transparend blue
    painter.setBrush(QColor(0, 0, 255, 127));
    painter.drawRect(0, 0, width(), height()/2);
    \endcode

    The code shown above produces the following output.

    \img alphafill.png

    Alpha-blended drawing is supported on Windows, Mac OS X, and on
    X11 systems that have the X Render extension installed.


    \section2 QPainter and QGLWidget

    It is now possible to open a QPainter on a QGLWidget as if it
    were a normal QWidget. One huge benefit from this is that we
    utilize the high performance of OpenGL for most drawing
    operations, such as transformations and pixmap drawing.


    \section2 Anti-aliased edges

    On platforms where this is supported by the drawing API's, we
    provide the option of turning on anti-aliased edges when drawing
    primitives.

    \code
    // One line without anti-aliasing
    painter.drawLine(0, 0, width()/2, height());

    // One line with anti-aliasing
    painter.setRenderHints(QPainter::LineAntialiasing);
    painter.drawLine(width()/2, 0, width()/2, height());
    \endcode

    This produces the following output.

    \img antialiased.png

    Supported platforms are currently Mac OS X,  Windows if GDI+ is
    installed, and OpenGL.


    \section2 Extensive use of native graphics operations

    In the Qt 4 Paint Subsystem we make more use of native graphics
    operations. The benefit we gain from this is that these operations
    can potentially be performed in hardware which gives significant
    speed improvements.

    Among these are native transformations (Windows 2000/XP, Mac OS X,
    and, OpenGL) making painting with a world matrix much faster. Some
    pixmap operations have also been moved closer to hardware.


    \section2 QPainterPath

    A painter path is an object composed of a number of graphical
    building blocks, such as rectangles, ellipses, lines and curves. A
    painter path can be used for filling, outlining, and for clipping.
    The main advantage of painter paths over normal drawing operations
    is that it is possible to build up non-linear shapes which can be
    drawn later one go.

    Building blocks can be joined in closed subpaths, such as a
    rectangle or an ellipse, or they can exist independently as unclosed
    subpaths, although an unclosed path will not be filled.

    Below is a code example on how a path can be used. The
    painter in this case has a pen width of 3 and a light blue brush. We
    first add a rectangle, which becomes a closed subpath.  We then add
    two bezier curves, and finally draw the entire path.

    \code
    QPainterPath path;
    path.addRect(20, 20, 60, 60);
    path.addBezier(0, 0,  99, 0,  50, 50,  99, 99);
    path.addBezier(99, 99,  0, 99,  50, 50,  0, 0);
    painter.drawPath(path);
    \endcode

    The code above produces the following output:

    \img pathexample.png


    \section2 Widget double-buffering

    In Qt 4, all widgets are double-buffered by default.

    In previous versions of Qt double-buffereing was acheived by
    painting to an off-screen pixmap then copying the pixmap to the
    screen. e.g.

    \code
    QPixmap buffer(size());
    QPainter painter(&buffer);

    // Paint code here

    painter.end();
    bitBlt(this, 0, 0, &buffer);
    \endcode

    Since the double-buffering is handled by QWidget internally this now becomes:

    \code
    QPainter painter(this);

    // Paint code here

    painter.end();
    \endcode

    Double-buffering is turned on by default, but can be turned off by
    setting the widget attribute Qt::WA_PaintOnScreen.

    \code
    unbufferedWidget->setAttribute(Qt::WA_PaintOnScreen);
    \endcode

    \section1 More to come

    The Qt 4 Paint Subsystem is mostly completed, but there is still
    work being done.

    Part of the work in progress is the finalization of the rendering
    pipeline for all platforms, so that all features are supported and
    look the same on all platforms. Among the currently unfinished
    features are these:

    \list
    \i Gradients cannot have alpha color on X11.
    \i Anti-aliasing of lines on X11.
    \i Clipping regions on OpenGL.
    \i Transformation of pen widths.
    \i Transformation of fill patterns.
    \i Support for querying for supported features (such as if
       antialiasing is available)
    \i Not all primitive types are supported with gradient filling or
       alpha filling at the moment. These will be made more consistent
       in the time to come.
    \i Use painter paths for clipping.
    \endlist

    \link tech-preview.html [Back to the Technology Preview page] \endlink

*/
