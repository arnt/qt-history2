/****************************************************************************
**
** Copyright (C) 1992-$THISYEAR$ Trolltech AS. All rights reserved.
**
** This file is part of the Qt GUI Toolkit.
** EDITIONS: FREE, PROFESSIONAL, ENTERPRISE
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
****************************************************************************/

/*!
\page scribe-overview.html
\title The Scribe Classes

Scribe introduces a set of text layout classes to Qt 4. These classes
replace the old rich text engine found in Qt 3, and provide new features
for processing and laying out both plain text and rich text.

\tableofcontents

\section1 Overview of Scribe

Support for text rendering and layout in Qt 4 has been redesigned
around a system that allows textual content to be represented in a more
flexible way than was possible with Qt 3. Qt 4 also provides a more
convenient programming interface for editing documents. These
improvements are made available through a reimplementation of the
existing text rendering engine, and the introduction of several new
classes.

The following sections provide a brief overview of the main concepts
behind Scribe.


\section2 The document interface

Text documents are represented by the \c QTextDocument class, rather
than by \c QString objects. Each \c QTextDocument object contains
information about the document's internal representation, its
structure, and keeps track of modifications to provide undo/redo facilities.
This approach allows features such as the layout management to be
delegated to specialized classes, but also provides a focus for the
framework.

Documents are either converted from external sources or created from
scratch using Qt. The creation process can done by an editor widget,
such as \c QTextEdit, or by explicit calls to the Scribe API.

There are two complementary ways to visualize the contents of a
document: as a linear buffer that is used by editors to modify the
contents, and as an object hierarchy containing structural information
that is useful to layout engines. In the hierarchical model, the
objects generally correspond to visual elements such as frames, tables,
and lists. At a lower level, these elements describe properties such as
the style of text used and its alignment. The linear representation of
the document is used for editing and manipulation of the document's
contents.

\section2 Document structure

Each document contains a root frame into which all other structural
elements are placed. This frame contains other structural elements,
including tables, text blocks, and other frames; these can be nested to
an arbitrary depth.

Frames provide logical separation between parts of the document, but
also have properties that determine how they will appear when rendered.
A table is a specialized type of frame that consists of a number of
cells, arranged into rows and columns, each of which can contain
further structure and text. Tables provide management and layout
features that allow flexible configurations of cells to be created.

Text blocks contain text fragments, each of which specifies text and
character format information. Textual properties are defined both at
the character level and at the block level. At the character level,
properties such as font family, text color, and font weight can be
specified. The block level properties control the higher level
appearance and behavior of the text, such as the direction of text
flow, alignment, and background color.

The document structure is not manipulated directly. Editing is
performed through the cursor-based interface.

\section2 Editing and content creation

Documents can be edited via the interface provided by the \c QTextCursor
class; cursors are either created using a constructor or obtained from
an editor widget. The cursor is used to perform editing operations that
correspond exactly to those the user is able to make themselves in an
editor. As a result, information about the document structure is also
available through the cursor, and this allows the structure to be
modified. The use of a cursor-oriented interface for editing makes the
process of writing a custom editor simpler for developers, since the
editing operations can be easily visualized.

The \c QTextCursor class also maintains information about any text it
has selected in the document, again following a model that is
conceptually similar to the actions made by the user to select text
in an editor.

\section2 Document layout

The layout of a document is only relevant when it is to be displayed on
a device, or when some information is requested that requires a visual
representation of the document. Until this occurs, the document does
not need to be formatted and prepared for a device.

Each document's layout is managed by a subclass of the \c
QAbstractTextDocumentLayout class. This class provides a common
interface for layout and rendering engines. The default rendering
behavior is currently implemented in a private class.


\section1 The state of Scribe

The new Scribe classes are functioning, but some parts are still
incomplete. Plain text layout through the \c QTextLayout class should
be working fine, but we are interested in receiving feedback on the
public API, usability, and bugs. Rich text support is currently
incomplete.

The following features are mostly complete:

\list
\i The document structure: \c QTextDocument, \c QTextBlock,
   \c QTextFragment, \c QTextObject, and derived classes.
\i Undo/redo.
\i Lists: \c QTextList.
\i \c QTextFormat and related structure is complete and working. We are
   mainly interested in feedback on the public API of the \c QText*
   group of classes.
\i Most editing operations using \c QTextCursor.
\endlist

The rich text module still has a few missing features:

\list
\i Layout of documents is still somewhat limited, especially with
   regards to tables.
\i Table support in the document is still limited. Cells that span
   multiple rows and columns are not yet supported.
\i A class to replace \c QTextBrowser in Qt 3 is missing.
\i Laying out text using design metrics (WYSIWYG) is currently disabled.
\i Memory consumption is still rather high (though lower than in Qt
   3). The reasons are known to us and will be fixed before the release
   of Qt 4.
\i The API of \c QAbstractTextDocumentLayout is subject to change.
   The class is not guaranteed to be present in Qt 4.
\i HTML export.
\endlist


\section1 Example code

Here we present two different ways in which the Scribe classes can be
used: for creating and manipulating rich text, and for laying out
plain text.


\section2 Manipulating rich text

Rich text is stored in text documents that can either be created by
importing HTML from an external source, or generated using a
\c QTextCursor. The easiest way to use a rich text document is through
the \c QTextEdit class, providing an editable view onto a document. The code
below imports HTML into a document, and displays the document using a
text edit widget.

\code
    QTextEdit *edit = new QTextEdit(parent);
    edit->setHtml(aStringContainingHTMLtext);
    edit->show();
\endcode

You can retrieve the document from the text edit using the \c
document() function. The document can then be edited programmatically
using the \c QTextCursor class. This class is modeled after a screen
cursor, and editing operations follow the same semantics. The following
code changes the first line of the document to a bold font, leaving all
other font properties untouched. The editor will be automatically
updated to reflect the changes made to the underlying document data.

\code
    QTextDocument *document = edit->document(); 
    QTextCursor cursor(document);

    cursor.movePosition(QTextCursor::Start); 
    cursor.movePosition(QTextCursor::EndOfLine, QTextCursor::KeepAnchor);

    QTextCharFormat format;
    format.setFontWeight(QFont::Bold);

    cursor.mergeCharFormat(format);
\endcode

Note that the cursor was moved from the start of the first line to the
end, but that it retained an anchor at the start of the line. This
demonstrates the cursor-based selection facilities of the \c
QTextCursor class.

Rich text can be generated very quickly using the cursor-based
approach. The following example shows a simple calendar in a \c
QTextEdit widget with bold headers for the days of the week:

\code
    QTextEdit *edit = new QTextEdit();
    edit->show();

    QTextCursor cursor(edit->textCursor());
    cursor.movePosition(QTextCursor::Start); 

    QTextCharFormat format(cursor.charFormat());
    format.setFontFamily("Courier");
    format.setFontWeight(QFont::Bold);

    cursor.insertBlock();
    cursor.insertText(" ", format);

    QDate date = QDate::currentDate();
    int year = date.year();
    int month = date.month();

    for (int weekDay = 1; weekDay <= 7; ++weekDay) {
        cursor.insertText(QString("%1 ").arg(QDate::shortDayName(weekDay), 3),
                          format);
    }

    cursor.insertBlock();
    format.setFontWeight(QFont::Normal);
    cursor.insertText(" ", format);

    for (int column = 1; column < QDate(year, month, 1).dayOfWeek(); ++column) {
        cursor.insertText("    ", format);
    }

    for (int day = 1; day <= date.daysInMonth(); ++day) {
        int weekDay = QDate(year, month, day).dayOfWeek();

        cursor.insertText(QString("%1 ").arg(day, 3), format);

        if (weekDay == 7) {
            cursor.insertBlock();
            cursor.insertText(" ", format);
        }
    }
\endcode

The above example demonstrates how simple it is to quickly generate new
rich text documents using a minimum amount of code. Although we have
generated crude fixed-pitch calendars to avoid quoting too much code,
Scribe provides much more sophisticated layout and formatting features.
These can be seen in the demonstrations and examples that accompany this
release.

\section2 Plain text layout

Sometimes it is important to be able to format plain text within an
irregularly-shaped region, perhaps when rendering a custom widget, for
example. Scribe provides generic features to help developers perform
word-wrapping and layout tasks without the need to create a document
first.

\img plaintext-layout.png

Formatting and drawing a paragraph of plain text is straightforward.
The example below will lay out a paragraph of text, using a single
font, around the right hand edge of a circle.

\code
    QTextLayout textLayout(text, font);
    int radius = 150;
    int margin = 10;
    QFontMetrics fm(font);

    int leading = fm.leading();
    int lineHeight = fm.height();
    int y = 0;

    textLayout.clearLines();
    while (1) {
        int x1 = int(pow(pow(radius,2) - pow(radius-y,2), 0.5));
        int x2 = int(pow(pow(radius,2) - pow(radius-(y+lineHeight),2), 0.5));
        int x = qMax(x1, x2);
        int lineWidth = 2*radius - x;

        QTextLine line = textLayout.createLine();
        if (!line.isValid())
            break;

        line.layout(lineWidth);
        line.setPosition(QPoint(margin+x, margin+y));
        y += line.ascent() + line.descent() + leading;
    }
\endcode

We create a text layout, specifying the text string we want to display
and the font to use. We ensure that the text we supplied is formatted
correctly by obtaining text lines from the text format, and wrapping
the remaining text using the available space. The lines are positioned
as we move down the page.

The formatted text can then be drawn using a standard paint device:
\code
    QPainter painter(paintDevice);
    textLayout.draw(&painter, QPoint(0, 0));
\endcode

The cursor-based editing features, combined with the structural document
model, provide a powerful set of tools for manipulating and displaying
rich text documents.


\section1 Comparison with Qt 3

The new Scribe API offers a complete set of APIs to lay out and
manipulate both plain text and rich text documents. These provide
features that were unavailable in Qt 3's public API. The engine used is
a complete rewrite and does not use the rich text engine supplied with
Qt 3.

The \c QTextEdit class in Qt 4 has also been completely rewritten with an
API that is quite different from its Qt 3 counterpart. Some compatibility
methods have been added to allow the widget to be used, for basic cases,
in a way that is familiar to users of Qt 3. This class is provided as a
working example of an editor widget that uses the new API, showing that
it is possible to completely implement a document editor based on the \c
QTextCursor editing interface.

The \c QTextBrowser class is not included in this release.


\section1 Future work

The rich text support continues to evolve. Some ideas on what's planned
towards Qt 4 can be found below. Some of them might be implemented while
others might not. Feedback is welcome and encouraged.

\list
\i Lay out using design metrics (WYSIWYG)
\i Complete table support (including editing)
\i Multiple views onto documents
\i Improved layout of rich text documents
\endlist

\link tech-preview.html [Back to the Technology Preview page] \endlink

*/
