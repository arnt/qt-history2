/*!
\page designer-manual.html
\startpage index.html Qt Reference Documentation
\nextpage Getting Started with Qt Designer

\title Qt Designer Manual

\keyword Qt Designer

\QD is Trolltech's tool for designing and building graphical user
interfaces (GUIs) from Qt components. It allows you to design and build
widgets and dialogs using on-screen forms using the same widgets that
will be used in your application.
Components created with \QD can also take advantage of Qt's
signals and slots, and they can be previewed so that you can ensure
that they will look and feel exactly as you intended.

\section1 Using Qt Designer

\list
\i \l{Getting Started with Qt Designer}
  \tableofcontents{1 Getting Started with Qt Designer}
\i \l{Designing a Component with Qt Designer}
 \tableofcontents{1 Designing a Component with Qt Designer}
\i \l{Qt Designer's Form Editing Mode}
 \tableofcontents{1 Qt Designer's Form Editing Mode}
\i \l{Using Containers in Qt Designer}
 \tableofcontents{1 Using Containers in Qt Designer}
\i \l{Editing Signals and Slots}
 \tableofcontents{1 Editing Signals and Slots}
\i \l{Qt Designer's Buddy Editing Mode}
 \tableofcontents{1 Qt Designer's Buddy Editing Mode}
\i \l{Qt Designer's Tab Order Mode}
 \tableofcontents{1 Qt Designer's Tab Order Mode}
\i \l{Editing Resources with Qt Designer}
 \tableofcontents{1 Editing Resources with Qt Designer}
\i \l{Using Custom Widgets with Qt Designer}
 \tableofcontents{1 Using Custom Widgets with Qt Designer}
\endlist

\section1 Using Forms and Components

\list
\i \l{Using a Component in Your Application}
 \tableofcontents{1 Using a Component in Your Application}
\i \l{Creating Custom Widgets for Qt Designer}
 \tableofcontents{1 Creating Custom Widgets for Qt Designer}
\endlist

\section1 Figures and Hints

\list
\i \l{Getting Started with Qt Designer#MainWindow}{\e{Qt Designer}'s main window}
\i \l{Getting Started with Qt Designer#WidgetBox}{\e{Qt Designer}'s widget box}
\i \l{Designing a Component with Qt Designer#ChoosingAForm}{Choosing a form}
\i \l{Designing a Component with Qt Designer#EditingModes}{Editing modes}
\i \l{Designing a Component with Qt Designer#AddingWidgetsToAForm}{Adding widgets to a form}
\i \l{Designing a Component with Qt Designer#ThePropertyEditor}{The Property Editor}
\i \l{Designing a Component with Qt Designer#PlacingWidgetsInLayouts}{Placing widgets in layouts}
\i \l{Designing a Component with Qt Designer#ConnectingWidgets}{Connecting widgets}
\i \l{Designing a Component with Qt Designer#PreviewingAForm}{Previewing a form}
\i \l{Qt Designer's Form Editing Mode#SelectingObjects}{Selecting objects}
\i \l{Qt Designer's Form Editing Mode#ShortcutsForEditing}{Shortcuts for editing}
\i \l{Qt Designer's Form Editing Mode#DragAndDrop}{Drag and drop}
\i \l{Qt Designer's Form Editing Mode#EditingProperties}{Editing properties}
\i \l{Qt Designer's Form Editing Mode#InsertingObjectsIntoALayout}{Inserting objects into a layout}
\i \l{Editing Signals and Slots#HighlightedObjects}{Highlighted objects}
\i \l{Editing Signals and Slots#MakingAConnection}{Making a connection}
\i \l{Editing Signals and Slots#ChoosingSignalsAndSlots}{Choosing signals and slots}
\i \l{Editing Signals and Slots#DeletingConnections}{Deleting connections}
\endlist

*/

/*!
\page designer-getting-started.html
\contentspage designer-manual.html Contents
\previouspage Qt Designer Manual
\nextpage Designing a Component with Qt Designer

\title Getting Started with Qt Designer

This manual covers the fundamental steps that most users will take when
creating graphical user interfaces with \QD. We will introduce the
main features of the tool by creating a simple dialog that we can use
in an example program.

\image designer-getting-started.png A simple dialog produced with \QD.

\target LaunchingDesigner
\section1 Launching Designer

The way that you launch \QD depends on your platform:

\list
\i On Windows, click the Start button, open the \e Programs submenu, open
the \e{Qt 4} submenu, and click \e Designer.
\i On Unix or Linux, you may find a \QD icon on the desktop background or
in the desktop start menu under the \e Programming or \e Development
submenus. You can launch \QD from this icon. Alternatively, you can
enter \c{designer} in a terminal window.
\i On Mac OS X, double click on \QD in the Finder.
\endlist

\target TheUserInterface
\section1 The User Interface

When used as a standalone application, \QD's user interface can be
configured to provide either a multi-window user interface (the default
mode), or it can be used in workbench mode. When used from within an
integrated development environment (IDE) only the multi-window user
interface is available.

In multi-window mode, you can arrange each of the tool panels to suit
your working style. The main window consists of a menu bar, a tool bar,
and a toolbox (the \l{WidgetBox}{widget box}) that contains the widgets you can use
to create your user interface.

\target MainWindow
\table
\row
\i \inlineimage designer-main-window.png
\i \bold{\QD's main window}

The menu bar provides all the standard actions for managing forms,
using the clipboard, and accessing application-specific help.
The current editing mode, the tool panels, and the forms in use can
also be accessed via the menu bar.

The tool bar displays common actions that are used when editing a form.
These are also available via the main menu.

The toolbox provides common widgets and layouts that are used to design
components. These are grouped into categories that reflect their uses or
features.
\endtable

Most features of \QD are accessible via the menu bar, the tool bar, or the
toolbox. Some features are also available through context menus that can
opened over the form windows. On most platforms, the right mouse button is
used to open context menus.

\target WidgetBox
\table
\row
\i \inlineimage designer-widget-box.png
\i \bold{\QD's widget box}

The widget box provides a selection of standard Qt widgets, layouts, and other
objects that can be used to create user interfaces on forms. Each of the
categories in the toolbox contains widgets that have similar uses, or that
provide related features.

You can display all of the available objects in a category by clicking on
the "+" handle next to the category label. When in
\l{designer-editing-mode.html}{Form Editing Mode}, you can add objects to a
form by dragging the appropriate items from the widget box onto the form, and
dropping them in the required locations.
\endtable

*/

/*!
\page designer-designing-a-component.html
\contentspage designer-manual.html Contents
\previouspage Getting Started with Qt Designer
\nextpage Qt Designer's Form Editing Mode

\title Designing a Component with Qt Designer

\tableofcontents

In this chapter we will look at the main steps that users will take
when creating new graphical user interfaces with \QD. Usually,
creating a new component for an application will involve various
activities:

\list
\i Deciding which kind of component to use.
\i Composing the user interface by adding widgets from the tool panel to
   the form.
\i Laying out the contents of the form.
\omit \i Setting the tab order of the widgets. \endomit
\i Connecting widgets together with signals and slots by using the connection
   editor.
\i Previewing the form.
\endlist

Users may find that they they prefer to perform these activities in a
different order, and we expect that for complex widgets the design process
may involve many iterations of these steps. However, we present each of the
activities in the above order, and leave it up to the user to find the
approach that suits them best.

To demonstrate the processes used to create a new component, we will take
a look at the steps needed to create a simple dialog with \QD. We use the
dialog to illustrate certain features of the tool. General concepts are
explained in the gray boxes in each section, and you can follow links
from some of these to read more about the features being discussed.

\target CreatingADialog
\section1 Creating a Dialog

\QD can be used to create user interfaces for different purposes,
and provides different kinds of forms for each of these. The first choice
that you face when creating a new user interface is to decide which kind of
form you will be using; for example, you may require a dialog rather than
a generic custom widget. New forms can be created by opening the \key File
menu and selecting the \key{New Form...} option, or by pressing \key{Ctrl+N}.

\target ChoosingAForm
\table
\row \i
\inlineimage designer-choosing-form.png
\i \bold{Choosing a form}

\QD provides a number of template forms that are
suitable for different kinds of components. You can either choose one of
these templates or open an form that was saved earlier.
\endtable

If your requirements later change so that you need to supply a different
type of component, you can easily reuse the contents of your existing form.
For our example, we select the \bold{Dialog} template, and an empty form
is created ready for use.

\omit
\image designer-empty-form.png
\endomit

\target ComposingTheDialog
\section1 Composing the Dialog

The empty form is displayed as an empty dialog with a grid pattern overlayed
on the widget area in a style similar to many drawing packages. 
\QD provides two different editing modes: In form editing mode, widgets
and other objects can be arranged, resized, and configured on the form;
in connection editing mode, signals and slots connections can be made between
the widgets.

We ensure that \QD is in form editing mode by opening the \key Form menu
and selecting \key{Edit Widgets}. This makes it possible for widgets to be
dragged from the main toolbox onto the form.

\target EditingModes
\table
\header \i \i \bold{Editing modes}
\row \i \inlineimage designer-widget-tool.png
\i In \l{Qt Designer's Form Editing Mode}{form editing mode},
we can change the appearance of the form, add layouts, and edit the
properties of each widget.
\row \i \inlineimage designer-connection-tool.png
\i In \l{Editing Signals and Slots}{connection editing mode},
we can connect widgets together using Qt's signals and slots mechanism.
\row \i \inlineimage designer-buddy-tool.png
\i In \l{Qt Designer's Buddy Editing Mode}, buddy widgets can be
assigned to label widgets to help them handle keyboard focus correctly.
\row \i \inlineimage designer-tab-order-tool.png
\i In \l{Qt Designer's Tab Order Mode}{tab order mode}, we can set the
order in which widgets receive the keyboard focus.
\row \i \inlineimage designer-resource-tool.png
\i In \l{Editing Resources with Qt Designer}{resource editing mode},
resources can be associated with a particular form, making it easier
to use images and other external data with widgets.
\endtable

For our example, we will develop a dialog that lets the user create an
image with a given size and color depth - these properties can be
represented by spinboxes and a combobox. We will also provide a line edit
so that the user can specify a name for the image if they want.

Before we begin adding widgets to the form, it is useful to resize it to
give us the required amount of space to work with. We can make the form
larger than necessary because it can be resized later.

We start composing the dialog by placing some text labels onto the form.
This is achieved by dragging each \e Label from the \e Display section
of the toolbox onto the form. We add some spinboxes and a combobox from
the \e Input section of the toolbox, one vertical spacer and one horizontal
spacer from the \e Spacers section (represented on the form as blue
springs), and two push buttons from the \e Buttons section.

Widgets and spacers can be moved around on the form by dragging them to
their new locations. A widget can be resized by dragging the resize handles
that appear when it is selected - click the left mouse button over the
widget to select it. It can be helpful to resize label widgets
so that all of their text is displayed, but this is not necessary as they
will be displayed fully when we add them to a layout.
It is useful to place the widgets where they are needed on the form
because it helps visualize how it will appear when it is finished, but
we do not need to fine tune the positions of widgets - this task
is the responsibility of the form's layout objects which we will add
later.

\target AddingWidgetsToAForm
\table
\row \i
\inlineimage designer-dialog-initial.png
\i \bold{Adding widgets to a form}

The dialog initially contains standard widgets and spacers. All the
objects on the form can be freely positioned. The spacers have no effect
since they have not yet been included in any layouts.
\endtable

The label text and initial values are changed in the Property Editor.
This can be accessed by opening the \e Tools menu in \QD's main
window and selecting \e{Property Editor}, or by pressing \key{Ctrl+I}.
The Property Editor always shows the properties of the currently selected
object, so we just need to select each of the widgets in turn to access
their properties.

For the labels and push buttons, we only need to change the \c text
property of each widget; for the spinboxes, we must change the \c value,
\c minimum, and \c maximum properties.
The dialog's window title can also be changed using the Property Editor -
click on the form itself to access the dialog's properties.

It is usually a good idea to give meaningful names to widgets in case
you want to connect their signals to slots in other components, or
refer to the widgets by name in your application.

\target ThePropertyEditor
\table
\row \i
\inlineimage designer-property-editor-link.png
\i \bold{The Property Editor}

All designable widget properties can be
edited in the \l{designer-editing-mode.html}{Property Editor}
window.

The properties can be edited by using the controls provided; the type of
control supplied for each property depends on the type of data it contains.
Any changes made to the widget's properties cause it to be updated
immediately.
\endtable

Once all the widgets are in position, they need to be placed into one or
more layouts. These will ensure that the widgets are the correct size, and
are correctly positioned on the form.

\target CreatingALayout
\section1 Creating a Layout

In Qt, widget positions and sizes are organized by layout managers. Before a
form can be used, it is necessary to put each of the widgets into layouts,
and set the form's overall layout. \QD provides all the standard types of
layout, making it simple to experiment with different ways of arranging
components.

At any point during editing, we can experiment with the layout of widgets
on the form by selecting a group of objects and applying a layout to them.
Any of the standard Qt layouts (horizontal, vertical, and grid) can be used.
To apply a layout to a selection of objects, click the appropriate icon
in \QD's tool bar, or select the layout from the form's context menu.

We begin laying out our dialog by putting all the labels and their
associated input widgets into a grid layout. To do this, we need to ensure
that all the widgets are lined up in a grid arrangement. We put the push
buttons into a horizontal layout with the horizontal spacer.

\target PlacingWidgetsInLayouts
\table
\row \i
\inlineimage designer-dialog-layout.png
\i \bold{Placing widgets in layouts}

The widgets and spacers are placed in a grid layout that takes up as
little space as possible. The horizontal spacer in the lower layout
reserves some space to the left of the push buttons, and makes the
layout larger than normal. This will ensure that the buttons are
positioned on the right hand side of the dialog.

We will examine the use of layouts in more detail in
\l{designer-editing-mode.html}{Form Editing Mode}.
\endtable

The Property Editor can be used to change the appearance of layouts on
the form. To access the properties of a layout, we click inside the layout,
taking care not to click any of the widgets. The \c margin property
controls the thickness of the margin around the edges of the
layout, and \c spacing determines the space between widgets. By default,
\QD gives inner layouts a 1 pixel wide \c margin so that it can show a
border around each object on the form. If you wish, you can set this to 0.

We can create more complex layouts by selecting the layouts and placing
them into other layouts, but we really only need a form-level vertical
layout to ensure that the dialog will appear correctly. To do this,
we click the form to ensure that no objects are selected then apply the
vertical layout. The form may now be larger than necessary, but we can
resize it to make it smaller.

\image designer-dialog-final.png

Once all the objects on the form have been placed in layouts, we can
concentrate on connecting them together using Qt's signals and slots
mechanism.

\target SignalAndSlotConnections
\section1 Signal and Slot Connections

Objects on the form can be connected together using their signals and
slots, making it unnecessary to write code in your application to
connect many standard widgets together. In addition, \QD's connection
editor provides a visual representation of the signal and slot
connections in the form that can help other developers understand how
the final component will behave.

We can show how the connection editor is used by connecting the
\l{QLineEdit::returnPressed()}{returnPressed()} signal of the line edit
in our dialog to the \key OK button's
\l{QAbstractButton::animateClick()}{animateClick()} slot.
We change into connection editing mode by opening the \key{Edit} menu
and selecting \key{Edit Signals/Slots}. The objects in the form will now
become highlighted as the cursor passes over them. 

\target ConnectingWidgets
\table
\row \i
\inlineimage designer-making-connection.png
\i \bold{Connecting widgets}

To connect the line edit to the \key OK button, we click on the widget
and drag the cursor toward the push button; a line extends from the
line edit to the cursor.
\endtable

When the cursor is over the \key OK button, we release the mouse button
to complete the connection, and a dialog opens to allow us to choose
compatible signals and slots. Since the returnPressed() signal
and the animateClick() slot have compatible signatures, we can use them
together to "click" the \key OK button whenever the return key is
pressed in the line edit. To try this out, we can open a preview of
the dialog by pressing \key{Ctrl+R} or by opening the \key Form menu
and selecting \key Preview.

\target PreviewingAForm
\table
\row \i
\inlineimage designer-dialog-preview.png
\i \bold{Previewing a form}

When you preview a form, it appears just as it would in your application.
You can resize it to see how the layouts used to manage the child widgets
respond to different window sizes, and use this information to fine tune
the form's design.
\endtable

*/

/*!
\page designer-editing-mode.html
\previouspage Designing a Component with Qt Designer
\contentspage designer-manual.html Contents
\nextpage Using Containers in Qt Designer

\title Qt Designer's Form Editing Mode

\image designer-editing-mode.png

In \QD's form editing mode, objects can be dragged from the main window's
toolbox to a form, edited, resized, dragged around on the form, and even
dragged between forms. Their properties can be modified interactively, so
that changes can be seen immediately.
The editing interface is intuitive for simple operations, yet still
supports Qt's powerful layout facilities.

\tableofcontents

\target ManagingForms
\section1 Managing Forms

\QD allows you to create and edit new forms (open the \key File menu and
select \key{New Form...} or press \key{Ctrl N}). Existing forms can also
be edited (open the \key File menu and select \key{Open Form...} or press
\key{Ctrl O}).

At any point, it is possible to save a form by selecting the
\key {Save Form As...} option from the \key {File} menu. The .ui files saved
by \QD contain information about the objects used, and record the details
of any signal and slot connections between them.

\target EditingAForm
\section1 Editing a Form

By default, new forms are opened in editing mode. If \QD is in another mode,
you can enter editing mode by opening the \key Edit menu and selecting
\key{Edit Widgets}, or by pressing the \key F3 key.

Objects are added to the form by dragging them from the main toolbox
and dropping them in the desired location on the form. Once there, they
can be moved around simply by dragging them. Objects can be selected by
clicking on them using the left mouse button.

The toolbox contains objects in a number of different categories, all of
which can be simply placed on the form as required. The only objects that
require a little more preparation are the \e Container widgets.
These are described in more detail in the chapter on
\l{designer-using-containers.html}{Using Containers}.

\target SelectingObjects
\table
\row \i
\inlineimage designer-selecting-widget.png
\i \bold{Selecting objects}

Objects on the form are selected by clicking on them with the left mouse
button. When an object is selected, resize handles are shown at each corner
and at the midpoint of each side, indicating that it can be resized.

If more than one object is selected, the current object will be displayed
with resize handles that are colored differently to the others.
\endtable

When selected, the normal clipboard operations can be performed on a widget
to cut, copy, and paste it. All of these operations are recorded in an undo
buffer to enable changes to be undone and redone as necessary. The
shortcuts used to perform all of these actions are described in the table
below.

\target ShortcutsForEditing
\table
\header \i Action       \i Shortcut     \i Description
\row    \i Cut          \i \key{Ctrl+X} \i Cuts the selected objects to the clipboard.
\row    \i Copy         \i \key{Ctrl+C} \i Copies the selected objects to the clipboard.
\row    \i Paste        \i \key{Ctrl+V} \i Pastes the objects in the clipboard onto the form.
\row    \i Delete       \i \key Delete  \i Deletes the selected objects.
\row    \i Clone object \i \key{Ctrl+drag} (left mouse button)
        \i Makes a copy of the selected object or group of objects.
\row    \i Preview      \i \key{Ctrl+R} \i Shows a preview of the form.
\endtable

All the above actions (apart from cloning) can be accessed via both the
\key Edit and the form's context menu. These menus also provide a
\key{Select All} function to select all the objects on the form. They also
provide functions for laying out objects.

Widgets are not unique objects; you can make as many copies of them as you
need. To quickly duplicate a widget, you can clone it by holding down the
\key Ctrl key and dragging it. This allows widgets to be copied and placed
on the form much more quickly than with clipboard operations.

\target DragAndDrop
\table
\row \i
\inlineimage designer-dragging-onto-form.png
\i \bold{Drag and drop}

\QD makes extensive use of the drag and drop
facilities provided by Qt. Widgets can be dragged from the toolbox and dropped
onto the form.

Widgets can also be "cloned" on the form: Holding down \key Ctrl and dragging
the widget creates a copy of the widget that can be dragged to a new position.
\endtable

\QD allows selections of objects to be copied, pasted, and dragged between
forms. You can use this feature to create more than one copy of the same
form, and experiment with different layouts in each of them.

\target ThePropertyEditor
\section1 The Property Editor

The Property Editor always displays the properties of
the currently selected object on the form. The properties available depend
on the object being edited, but all of the widgets provided have common
properties such as \c objectName (the object's internal name) and
\c enabled (whether it can be interacted with).

\target EditingProperties
\table
\row \i 
\inlineimage designer-property-editor.png
\i \bold{Editing properties}

The Property Editor uses standard Qt input widgets to manage the properties
of objects on the form. Textual properties are shown in line edits,
integer properties are displayed in spinboxes, and compound properties such
as colors and sizes are presented in drop-down lists of input widgets.
\endtable

\section1 The Object Inspector

The Object Inspector shows an up-to-date hierarchical list of the objects
(widgets, layouts, spacers, and other objects) on the form that is currently
being edited.

\target TheObjectInspector
\table
\row \i 
\inlineimage designer-object-inspector.png
\i \bold{Editing properties}

The Object Inspector displays a hierarchical list of all the objects on the
form that is currently being edited. To show the child objects of a container
widget or a layout, click the "+" handle next to the object label.

Each object on a form can be selected by double clicking on the corresponding
item in the Object Inspector. This feature can be useful if you have many
overlapping objects.
\endtable

\target Layouts
\section1 Layouts

Before the form can be used the objects on the form need to be placed into
layouts, this ensures that they will be displayed properly when the form is
previewed or deployed in an application. Placing objects in a layout also
ensures that they will be resized correctly when the form is resized.

\section2 Applying and Breaking Layouts

The simplest way to manage objects is to apply a layout to a group of
existing objects. This is achieved by selecting the objects that you
need to manage and applying one of the standard layouts from the main
toolbar, the \key Edit menu, or the form's context menu.

Once widgets have been inserted into a layout, it is not possible to
move and resize them individually because the layout itself controls
the geometry of each widget within it, taking account of the hints
provided by spacers. Instead, you must either break the layout
(\key{Ctrl+B} or \key{Break Layout}) and adjust each object's geometry
manually, or you can influence the widget's geometry by resizing the
layout. You can also add and remove spacers from the layout to influence
the geometries of the widgets.

\target InsertingObjectsIntoALayout
\table
\row
\i \inlineimage designer-layout-inserting.png
\i \bold{Inserting objects into a layout}

Objects can be inserted into an existing layout by dragging them from
their current positions and dropping them at the required location.
A blue cursor is displayed in the layout as an object is dragged over it
to indicate where the object will be added.
\endtable

The form's top level layout can be set by clearing the selection (click
the left mouse button on the form itself) and applying a layout.

\target HoizontalAndVerticalLayouts
\section2 Horizontal and Vertical Layouts

The simplest way to arrange objects on a form is to place them in a
horizontal or vertical layout. For example, the dialog shown at the
beginning of this chapter contains two push buttons and a spacer that
can be placed in a horizontal layout; this makes sure that the buttons
remain next to each other when more layouts are added to the dialog.
In the same way, vertical layouts ensure that each of the widgets
within are aligned horizontally.

Horizontal and vertical layouts can be combined, and nested to any depth.
However, if you need more control over the placement of objects, you
should consider using the grid layout.

\target TheGridLayout
\section2 The Grid Layout

Complex form layouts can be created by placed objects in a grid layout.
This kind of layout gives the form designer much more freedom to arrange
widgets on the form, but can result in a much less flexible layout.
However, for some kinds of form layout, a grid arrangement is much more
suitable than a nested arrangement of horizontal and vertical layouts.

\target PreviewingForms
\section1 Previewing Forms

Although \QD's forms are accurate representations of the components
being edited, it is useful to preview the final appearance while editing.
This feature can be activated by opening the \key Form menu and selecting
\key Preview, or by pressing \key{Ctrl+R} when in the form.

\image designer-dialog-preview.png

The preview shows exactly what the final component will look like when
used in an application.

*/

/*!
\page designer-connection-mode.html
\contentspage designer-manual.html Contents
\previouspage Using Containers in Qt Designer
\nextpage Qt Designer's Buddy Editing Mode

\title Editing Signals and Slots

\image designer-connection-mode.png

\QD's connection editing mode allows objects in a form to be connected
together using Qt's signals and slots mechanism. Both widgets and layout
objects can be connected via an intuitive connection interface, and \QD
will present a menu of compatible signals and slots to use for each
connection made. When the form is saved, the connections are preserved
so that they will be ready for use when your project is built.

\tableofcontents

\target ConnectingObjects
\section1 Connecting Objects

To begin connecting objects, enter connection mode by opening the
\key Edit menu and selecting \key{Edit Signals/Slots}, or by pressing
the \key F4 key.
All widgets and layout objects on the form can be connected together.
Spacers just provide spacing hints to layouts, so they cannot be connected
to other objects.

\target HighlightedObjects
\table
\row
\i \inlineimage designer-connection-highlight.png
\i \bold{Highlighted objects}

When the cursor is over an object that can be used in a
connection, the object will be highlighted, and can be connected to
other objects on the form.
\endtable

To make a connection, hold down the left mouse button over a highlighted
object, and drag the cursor towards the object you want to connect it to.
As you do this, a line will extend from the source object to the cursor.
If the cursor is over another object on the form, the line will end with
an arrow head that points to the destination object, indicating that a
connection will be made between the two objects when you release the
mouse button.

You can abandon the connection at any point while you are dragging the
connection path by pressing \key{Escape}.

\target MakingAConnection
\table
\row
\i \inlineimage designer-connection-making.png
\i \bold{Making a connection}

The connection path changes shape as the cursor moves around the form.
As it passes over objects, they are highlighted, indicating that they
can be used in a signals and slots connection.
\endtable

When you are satisfied that the correct objects will be connected, release
the mouse button to make the connection. A dialog displays the signals
from the source object and the slots from the destination object that
can be used to connect the two objects.

To complete the connection, select a signal from the source object and a
slot from the destination object, then click the \key OK button. Click
\key Cancel if you wish to abandon the connection.

\target ChoosingSignalsAndSlots
\table
\row
\i \inlineimage designer-connection-dialog.png
\i \bold{Choosing signals and slots}

The \bold{Configure Connection} dialog presents the signals that can be
emitted by the source object alongside a list of compatible slots in the
destination object. When you select a signal, the dialog automatically
updates the list of compatible slots to ensure that a valid connection
is made.

If the \bold{Show all signals and slots} checkbox is selected, all
available signals from the source object are shown. The list of available
slots in the destination object is updated to show all the slots that
are compatible with the currently selected signal.
\endtable

You can make as many connections as you like between objects on the form,
and it is possible to connect signals from objects to slots in the form
itself. As a result, the signal and slot connections in many dialogs can
be completely configured from within \QD.

\target ConnectingToTheForm
\table
\row
\i \inlineimage designer-connection-to-form.png
\i \bold{Connecting to a form}

Connections can be made between objects on the form and the form itself.
Instead of dragging a connection path to another object, position the
cursor over the form and release the mouse button.

To make it clear that the connection will be made with the form itself,
the end point of the connection changes to an electrical "ground" symbol.
\endtable

\target EditingConnections
\section1 Editing and Deleting Connections

By default, connection paths are created with two labels that show
the signal and slot involved in the connection. These labels are usually
oriented along the line of the connection, and they can be moved around
inside their host widgets by dragging the red square at each end of the
connection path.

The signal and slot used in a connection can be changed after it has
been set up. To do this, simply double click on the connection path
or one of its labels, and select the signal and slot to be used in
the connection dialog.

\target DeletingConnections
\table
\row
\i \inlineimage designer-connection-editing.png
\i \bold{Deleting connections}

The whole connection can be selected by clicking on any of the path
segments. Once selected, connections can be deleted with the \key Delete
key, and they will not be set up in the .ui file.
\endtable

*/

/*!
\page designer-using-containers.html
\contentspage designer-manual.html Contents
\previouspage Qt Designer's Form Editing Mode
\nextpage Editing Signals and Slots

\title Using Containers in Qt Designer

Container widgets provide high level control over groups of objects on a form.
They can be used to perform a variety of functions, such as managing input
widgets, providing paged and tabbed layouts, or just acting as decorative
containers for other objects.

Since many containers offer specialized functionality, they require a little
more explanation than ordinary widgets in order to make the most of them.

\tableofcontents

\section1 General Features

Since containers are designed to hold other objects, \QD provides visual
feedback to help you place objects inside them. When dragging an object
from the toolbox or from elsewhere on the form, each container will become
highlighted as the cursor is positioned over it. This indicates that you
can drop the object inside, and that it will become a child object of the
container. This feedback is important because it is easy to place objects
close to containers without actually placing them inside. Both widgets
and spacers can be used inside containers.

Stacked widgets, tab widgets, and toolboxes are handled specially in
\QD. Normally, when adding pages (tabs, pages, compartments) to these
containers in your own code, you need to supply existing widgets, either
as placeholders or containing child widgets. In \QD, these are
automatically created for you, so you can add child objects to each page
straight away. New pages are added to each of these containers in the
same way: Select the container on the form, open the context menu, and
select \key{Add Page}. To delete the current page, select the container
widget then select the \key{Delete Page} from the context menu.

Each container typically allows its child objects to be arranged in
one or more layouts. The type of layout management provided depends on
each container, although setting the layout is usually just a matter of
selecting the container by clicking it, and applying a layout.

\section1 Frames

\image designer-containers-frame.png

Frames are used to enclose and group widgets, and to provide decoration.
They are used as the foundation for more complex containers, but they
can also be used as placeholders in forms.

The most important properties of frames are \c frameShape,
\c frameShadow, \c lineWidth, and \c midLineWidth. These are described
in more detail in the QFrame class description.

Each frame can contain its own layout. Select the frame and apply the
layout as usual.

\section1 Group Boxes

\image designer-containers-groupbox.png

Group boxes are usually used to group together collections of checkboxes
and radio buttons with similar purposes.

The most important properties of groupboxes are \c title, \c flat,
\c checkable, and \c checked. These are demonstrated in the
\l{widgets/groupbox}{Group Box} example, and described in the
QGroupBox class documentation.

Each group box can contain its own layout, and this is needed if it
contains other widgets. To add a layout to the group box, click inside
it and apply the layout as usual.

\section1 Stacked Widgets

\image designer-containers-stackedwidget.png

Stacked widgets are collections of widgets in which only the topmost
layer is visible. Control over the visible layer is usually managed by
another widget, such as a combobox, using signals and slots.

\QD shows arrows in the top-right corner of the stack to allow you to
see all the widgets in the stack; these do not appear in either the
preview or in the final component. To navigate between pages in the
stack, select the stacked widget and use the \key{Next Page} and
\key{Previous Page} entries from the context menu. The \key{Add Page}
and \key{Delete Page} context menu options allow you add and remove
pages.

Each page in the stack can be given its own layout, and this is
necessary if the page contains other objects. To add a layout to
a page, click inside the widget and apply the layout as usual.

\section1 Tab Widgets

\image designer-containers-tabwidget.png

Tab widgets allow the developer to split up the contents of a widget
into different labelled sections, only one of which is displayed at
any given time. By default, the tab widget contains two tabs, and
these can be deleted or renamed as required. You can also add additional
tabs.

To delete a tab, make it the current tab by clicking on its label,
select the tab widget, open the context menu over the tab, and select
\key{Delete Page}. To add a new tab \e{to the left} of the current tab,
select the tab widget, open the context menu, and select \key{Add Page}.
\QD will create a new widget for that tab, and insert it into the
tab widget. The title of the current tab can be set by selecting the
tab widget, and changing the \c currentTabText property in the
Property Editor.

Each tab can be given its own layout, and one must be defined for each
tab that contains other objects. To add a layout to a tab, click inside
it and apply the layout as usual.

\section1 Toolbox Widgets

\image designer-containers-toolbox.png

Toolbox widgets provide a series of pages or compartments in a toolbox,
much like the toolbox used in Qt 3's \QD. Toolboxes are handled in
much the same way as stacked widgets.

To rename a page in a toolbox, make it the current page, open the
Property Editor, and change the \c currentItemText property.
To add a new page \e above the current page in the toolbox, select the
toolbox widget, open the context menu, and select \key{Add Page}.
To delete the current page, select the toolbox widget, open the context
menu, and select \key{Delete Page}.

Each page in the toolbox can be given its own layout, and this is
necessary if it contains other objects. To add a layout to a page,
click inside it and apply the layout as usual.

*/

/*!
\page designer-buddy-mode.html
\contentspage designer-manual.html Contents
\previouspage Editing Signals and Slots
\nextpage Qt Designer's Tab Order Mode

\title Qt Designer's Buddy Editing Mode

\image designer-buddy-mode.png

One of the most useful basic features of Qt is the support for buddy widgets.
At the simplest level, a buddy widget accepts the input focus on behalf on
a QLabel when the user types the label's shortcut key combination. The buddy
concept is also used in Qt's \l{Model/View Programming}{model/view} framework.

\tableofcontents

\section1 Linking Labels to Buddy Widgets

To enter buddy mode, open the \key Edit menu and select \key{Edit Buddies}.
This mode presents the widgets on the form in a similar way to the
\l{Editing Signals and Slots}{signals and slots} except that, in this mode,
connections must start at label widgets. Ideally, you should connect each
label widget that provides a shortcut with a suitable input widget, such as
a QLineEdit.

\target MakingBuddies
\table
\row
\i \inlineimage designer-buddy-making.png
\i \bold{Making Buddies}

To define a buddy widget for a label, click on the label, drag the
connection to another widget on the form, and release the mouse button.
The connection shown indicates how the input focus is passed to the
buddy widget.

You can use the \l{Designing a Component with Qt Designer#PreviewingAForm}{form
preview} to test the connections between each label and its buddy.
\endtable

\section1 Removing Buddy Connections

Only one buddy widget can be defined for each label. To change the buddy
used, it is therefore necessary to delete any existing budy connection and
create a new one.

Connections between labels and their buddy widgets can be deleted in the
same way as signal-slot connections in connection mode. Select the buddy
connection by clicking on it, and press the \key Delete key. This
operation does not modify either the label or its buddy in any way.
*/

/*!
\page designer-tab-order.html
\contentspage designer-manual.html Contents
\previouspage Qt Designer's Buddy Editing Mode
\nextpage Editing Resources with Qt Designer

\title Qt Designer's Tab Order Mode

\image designer-tab-order-mode.png

Many users expect to be able to navigate between widgets and controls using only
the keyboard. Qt lets the user navigate between input widgets with the \key Tab
and \key{Shift-Tab} keyboard shortcuts. The default \e{tab order} is based on
the order in which widgets are constructed and, although this order may be
sufficient for many users, it is often better to explictly specify the tab order
to make your application easier to use.

\section1 Setting the Tab Order

To enter tab order mode, open the \key Edit menu and select \key{Edit Tab Order}.
In this mode, each input widget in the form is shown with a number indicating
its position in the tab order. So, if the user gives the first input widget the
input focus then presses the tab key, the focus will move to the second input
widget, and so on.

The tab order is defined by clicking on each of the numbers in the correct order.
You can set the first widget in the tab order by double-clicking on it. After
this has been done, click on another widget to make it the second in the tab
order, set the third with the next click, and so on until you are satisfied.
If you make a mistake, simply double click to set the first widget, and start
again.
*/

/*!
\page designer-resources.html
\contentspage designer-manual.html Contents
\previouspage Qt Designer's Tab Order Mode
\nextpage Using Custom Widgets with Qt Designer

\title Editing Resources with Qt Designer

\image designer-resources-editing.png

\QD fully supports \l{The Qt Resource System}, allowing resources to be
specified alongside forms as they are designed. To help designers and
developers manage the resources that are needed by applications, \QD's
resource editing mode allows resources to be defined on a per-form basis.

\tableofcontents

\section1 The Resource Editor

Each form has an associated resource editor which can be activated by
opening the \key Edit menu and selecting \key{Edit Resources}.
*/

/*!
    \page designer-using-custom-widgets.html
    \contentspage designer-manual.html Contents
    \previouspage Editing Resources with Qt Designer
    \nextpage Using a Component in Your Application

    \title Using Custom Widgets with Qt Designer

    \QD can display custom widgets through its extensible plugin mechanism,
    allowing the range of designable widgets to be extended by the user and
    third parties. This feature also allows \QD to optionally support
    \l{The Qt 3 Support Classes}{Qt 3 compatibility widgets}.
    Alternatively, it is possible to use existing widgets as placeholders for
    widget classes that provide similar APIs.

    \tableofcontents

    Widgets from the \l{The Qt 3 Support Classes}{Qt3Support} library are made
    available via in \QD's support for custom widgets.

    \section1 Handling Custom Widgets

    Although \QD supports all of the standard Qt widgets, and can be configured
    to handle widgets supplied in the \l{The Qt 3 Support Classes}{Qt3Support
    library}, some specialized widgets may not be available as standard for
    a number of reasons:

    \list
     \i Custom widgets may not be available at the time the user interface is being
        designed.
     \i Custom widgets may be platform-specific, and designers may be developing
        the user interface on a different platform to end users.
     \i The source code for a custom widget is not available, or the user interface
        designers are unable to use the widget for non-technical reasons.
    \endlist

    In the above situations, it is still possible to design forms with the aim
    of using custom widgets in the application. To achieve this, we can use
    the widget promotion feature of \QD.

    In all other cases, where the source code to the custom widgets is available,
    we can adapt the custom widget for use with \QD.

    \section2 Promoting Widgets

    \image designer-promoting-widgets.png

    In the case where forms must be designed, but where certain custom widgets
    are unavailable to the designer, we can substitute similar widgets to
    represent the missing widgets. For example, we might represent instances
    of a custom push button class, \c MyPushButton, with instances of QPushButton
    and promote these to \c MyPushButton so that \l{uic.html}{uic} generates
    suitable code for this missing class.

    When choosing a widget to use as a placeholder, it is useful to compare the
    API of the missing widget with those of standard Qt widgets. For specialized
    widgets that subclass standard classes, the obvious choice of placeholder
    is the base class of the custom widget; for example, QSlider might be
    used for specialized QSlider subclasses.

    For specialized widgets that do not share a common API with standard Qt
    widgets, it is worth considering adapting a custom widget for use in \QD.
    If this is not possible then QWidget is the obvious choice for a placeholder
    widget since it is the lowest common denominator for all widgets.

    \section2 User Defined Custom Widgets

    \image customwidgetplugin-example.png

    Custom widgets can be adapted for use with \QD, giving designers the
    opportunity to configure the user interface using the actual widgets
    that will be used in an application rather than placeholder widgets.

    The process of creating a custom widget plugin is described in the
    \l{designer/customwidgetplugin}{Custom Widget Plugin} example. To use a
    plugin, it is necessary to ensure that it is located on a path that \QD
    searches for plugins. Generally, plugins stored in
    \c{$QTDIR/plugins/designer} will be loaded when \QD starts.
*/

/*!
\page designer-using-a-component.html
\previouspage Using Custom Widgets with Qt Designer
\contentspage designer-manual.html Contents
\nextpage Creating Custom Widgets for Qt Designer

\title Using a Component in Your Application

\tableofcontents

With Qt's integrated build tools, \l{qmake-manual.html}{qmake} and
\l{uic.html}{uic}, the code for user interface components created
with \QD is automatically generated when the rest of of your
application is built. Forms can be included and used directly from
your application or, and you can use them to extend subclasses of
standard widgets.

There are three approaches to using a form in your application: the
direct approach, single inheritance subclassing, and multiple
inheritance subclassing.
In the direct approach, you simply construct a widget to use as a
placeholder for the component, and set up the user interface inside it.
In the single inheritance approach, you subclass the form's base class
(QWidget or QDialog, for example), and include a private instance of
the form's user interface object.
In the multiple inheritance approach, you subclass from both the
form's base class and the form's user interface object. This allows the
widgets defined in the form to be used directly from within the scope of
the subclass.

\target TheDirectApproach
\section1 The Direct Approach

To demonstrate how user interface components can be used straight from
\QD, we take the dialog that we created in the chapter on
\l{designer-designing-a-component.html}{Designing a Component}, and we
create a simple application to display it.

The source of the application consists of two files: \c main.cpp and
\c imagedialog.ui. We will use \c qmake to build the executable, so we
need to write a \c .pro file:

\quotefromfile snippets/designer/imagedialog/imagedialog.pro
\skipto TEMPLATE
\printuntil SOURCES

The special feature of this file is the \c FORMS declaration that tells
\c qmake which files it needs to process with \c uic. In this case,
the \c imagedialog.ui file is used to create a \c ui_imagedialog.h file
that can be used by any files listed in the \c SOURCES declaration.
To ensure that \c qmake generates the \c ui_imagedialog.h file, we need
to include it in a file listed in \c SOURCES. Since we only have
\c main.cpp, we include it there:

\quotefromfile snippets/designer/imagedialog/main.cpp
\skipto #include "ui_imagedialog.h"
\printuntil #include <QApplication>

This additional check ensures that we do not generate code for \e .ui
files that are not used.

The \c main function creates the image dialog by constructing a standard
QDialog that we use to host the user interface described by the
\c imagedialog.ui file.

\skipto main
\printuntil /^\}/

In this case, the \c{Ui::ImageDialog} is an interface description object
from the \c ui_imagedialog.h file that sets up all the dialog's widgets
and the connections between its signals and slots.

This approach provides a quick and easy way to use simple, self-contained
components in your applications, but many components created with \QD
will need to be integrated more closely with the rest of the application
code. To achieve this, we need to subclass a standard Qt widget.

\target TheSingleInheritanceApproach
\section1 The Single Inheritance Approach

In this approach, we use the \c{Ui::ImageDialog} object as we did in
the simple case, but instead of setting up the dialog from the
application's main function, we subclass QDialog and set up the
user interface from within the constructor.
Components used in this way expose the widgets and layouts used in the
form to the QDialog subclass, and provide a standard system for
making signal and slot connections between the user interface and other
objects in your application.

To ensure that we can use the user interface, we need to include the
header file that \c uic generates before referring to \c{Ui::ImageDialog}:

\quotefromfile snippets/designer/singleinheritance/imagedialog.h
\skipto #include "ui_imagedialog.h"
\printuntil #include "ui_imagedialog.h"

The subclass is defined in the following way:

\skipto class ImageDialog
\printuntil /^\};/

The important features of the class are the private \c ui object
which provides the code for setting up and managing the user
interface, and two private slots for handling mouse clicks on the
push buttons in the dialog.

The constructor for the subclass constructs and configures all the
widgets and layouts for the dialog just by calling the \c ui object's
setupUi() function. Once this has been done, it is possible to modify
the user interface and create items for the combobox:

\quotefromfile snippets/designer/singleinheritance/imagedialog.cpp
\skipto ImageDialog::ImageDialog
\printuntil /^\}/

We can connect signals from the user interface widgets to slots in the
dialog in the usual way, taking care to prefix the \c ui object to
each widget used.

The main advantages of this approach are its simple use of inheritance
to provide a QDialog-based interface, and its encapsulation of the
user interface widget variables within the \c ui data member.
We can use this method to define a number of user interfaces within the
same widget, each of which is contained within its own namespace,
and overlay (or "compose") them. This approach can be used to create
individual tabs from existing forms, for example.

\target TheMultipleInheritanceApproach
\section1 The Multiple Inheritance Approach

Forms created with \QD can be subclassed along with a standard
QWidget-based class. This approach makes all the user interface
components defined in the form directly accessible within the scope of
the subclass, and enables signal and slot connections to be made in
the usual way with the \l{QObject::connect()}{connect()} function.

As before, we need to include the header file that \c uic generates
from the \c imagedialog.ui file:

\quotefromfile snippets/designer/multipleinheritance/imagedialog.h
\skipto #include "ui_imagedialog.h"
\printuntil #include "ui_imagedialog.h"

The class is defined in a similar way to the one used in the private
interface approach, except that this time we inherit from both QDialog
and \c{Ui::ImageDialog}:

\skipto class ImageDialog
\printuntil /^\};/

We inherit \c{Ui::ImageDialog} privately to ensure that the user
interface objects are private in our subclass. We can also inherit
it with the \c public or \c protected keywords in the same way that
we could have made \c ui public or protected in the previous case.

The constructor for the subclass performs many of the same tasks as
the constructor used in the private interface example:

\quotefromfile snippets/designer/multipleinheritance/imagedialog.cpp
\skipto ImageDialog::ImageDialog
\printuntil /^\}/

In this case, the interface can be set up using a member function,
and the combobox is accessed in the same way as a widget created
in code by hand. The push buttons are also referred to directly in
the connect() function calls.

Subclassing using multiple inheritance gives us more direct access
to the contents of the form, is slightly cleaner than the single
inheritance approach, but does not conveniently support composition of
multiple user interfaces.

\target AutomaticConnections
\section1 Automatic Connections

In the previous sections, we connected the \key OK and \key Cancel
buttons in the form directly to the dialog's accept() and reject()
slots because we did not need to perform any processing on the
contents of the dialog. If we want to process the information entered
by the user before accepting it, we need to connect the clicked()
signal from the \key OK button to a custom slot in our dialog.
We will first show an example of the dialog in which the slot is
connected by hand then compare it with a dialog that uses automatic
connection.

\target ADialogWithoutAutoConnect
\section2 A Dialog Without Auto-Connect

We define the dialog in the same way as before, but now include a
slot in addition to the constructor:

\quotefromfile snippets/designer/noautoconnection/imagedialog.h
\skipto class
\printuntil /^\};/

The checkValues() slot will be used to validate the values provided
by the user.

In the dialog's constructor we set up the widgets as before, and connect
the \key Cancel button's clicked() signal to the dialog's reject() slot.
We also disable the \l{QPushButton::autoDefault}{autoDefault}
property in both buttons to ensure that the dialog does not interfere
with the way that the line edit handles return key events:

\quotefromfile snippets/designer/noautoconnection/imagedialog.cpp
\skipto ImageDialog::ImageDialog
\printuntil cancelButton
\dots
\skipto connect(okButton
\printuntil /^\}/

We connect the \key OK button's clicked() signal to the dialog's
checkValues() slot which we implement as follows:

\skipto ImageDialog::checkValues()
\printuntil /^\}/

This custom slot does the minimum necessary to ensure that the data
entered by the user is valid - it only accepts the input if a name
was given for the image.

\target ADialogWithAutoConnect
\section2 A Dialog With Auto-Connect

Although it is easy to implement a custom slot in the dialog and
connect it in the constructor, we could instead use \c{uic}'s
auto-connection facilities to connect the \key OK button's clicked()
signal to a slot in our subclass. To do this, we only need to
declare and implement a slot with a name that follows a standard
convention:

\code
    void on_<widget name>_<signal name>(<signal parameters>);
\endcode

Using this convention, we can define and implement a slot that responds
to mouse clicks on the \key OK button:

\quotefromfile snippets/designer/autoconnection/imagedialog.h
\skipto class
\printuntil /^\};/

Automatic connection of signals and slots provides both a standard
naming convention and an explicit interface for widget designers to
work to. By providing source code that implements a given interface,
user interface designers can check that their designs actually work
without having to write code themselves.

*/

/*!
    \page designer-creating-custom-widgets.html
    \previouspage Using a Component in Your Application
    \contentspage designer-manual.html Contents

    \title Creating Custom Widgets for Qt Designer

    \QD's plugin-based architecture allows user-defined and third party custom
    widgets to be edited in the same way as standard Qt widgets. All the features
    of the custom widgets are made available to the designer, including widget
    properties, signals, and slots. Since \QD uses real widgets during the form
    design process, custom widgets will appear the same as they do when previewed.

    \image worldtimeclockplugin-example.png

    The documentation for this chapter is currently being revised. Please see
    the \l{designer/customwidgetplugin}{Custom Widget Plugin} example for more
    information about using custom widgets in \QD.
*/
