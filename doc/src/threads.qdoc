/****************************************************************************
**
** Copyright (C) 1992-$THISYEAR$ Trolltech AS. All rights reserved.
**
** This file is part of the Qt GUI Toolkit.
** EDITIONS: FREE, PROFESSIONAL, ENTERPRISE
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
****************************************************************************/

/*! \page threads.html

    \title Thread Support in Qt

    Qt provides thread support in the form of platform-independent
    threading classes, a thread-safe way of posting events, and ###.
    It also uses threads internally to perform certain operations,
    such as DNS lookups (QDns).

    This document is intended for an audience that has knowledge of,
    and experience with, multithreaded applications. If you are new
    to threading see our \l{#reading}{Recommended Reading} list.

    Topics:

    \tableofcontents

    \section1 The Thread Classes

    Qt includes the following thread classes:

    \list
    \o QThread provides the means to start a new thread.
    \o QThreadStorage provides per-thread data storage.
    \o QMutex provides a mutual exclusion lock, or mutex.
    \o QMutexLocker is a convenience class that automatically locks
       and unlocks a QMutex.
    \o QReadWriteLock provides a lock that allows simultaneous read access.
    \o QReadWriteLockLocker is a convenience class that automatically
       locks and unlocks a QReadWriteLock.
    \o QSemaphore provides an integer semaphore (a generalization of a mutex).
    \o QWaitCondition provides a way for threads to go to sleep until
       woken up by another thread.
    \endlist

    \section1 Creating a Thread

    To create a thread, you must subclass QThread and reimplement its
    \l{QThread::run()}{run()} function. For example:

    \quotefromfile snippets/threads/threads.h
    \skipto class MyThread : public
    \printuntil };

    \quotefromfile snippets/threads/threads.cpp
    \skipto MyThread::run
    \printline ::run
    \printline {
    \dots
    \printline }

    Creating threads is explained in more detail in the QThread
    documentation.

    Note that QCoreApplication::exec() must always be called from the
    initial thread. This thread is sometimes referred to as the
    \e{main thread}. In GUI applications, it's also called the \e{GUI
    thread} because it's the only thread that is allowed to perform
    GUI-related operations.

    \section1 Reentrancy and Thread-Safety

    Throughout the Qt documentation, the terms \e reentrant and \e
    thread-safe are used to specify how a function can be used in
    multithreaded applications:

    \list
    \o A \e reentrant function can be called simultaneously by
       multiple threads as long as each invocation of the function
       references unique data.
    \o A \e thread-safe function can be called simultaneously by
       multiple threads when each invocation references shared data.
       All access to the shared data is serialized.
    \endlist

    By extension, a class is said to be reentrant if any of its
    functions can be called simultaneously by multiple threads on
    different instances of the class, and thread-safe if it even
    works if the different threads operate on the same instance.

    Note that the terminology in this domain isn't entirely
    standardized. For example, POSIX defines thread-safety as a
    lesser requirement than reentrant, whereas in Qt it's the
    opposite. When dealing with an object-oriented C++ class library
    such as Qt instead of a C-based API, the definitions had to be
    adapted.

    Most C++ classes are inherently reentrant, since they typically
    only reference class member data. Any thread can call such a
    member function on an instance of the class, as long as no other
    thread is calling a member function on the same instance. For
    example, the \c Counter class below is reentrant:

    \quotefromfile snippets/threads/threads.cpp
    \skipto ReentrantCounter
    \skipline ReentrantCounter
    \printline class Counter
    \printuntil };

    The class isn't thread-safe, because if multiple threads try to
    modify the data member \c n, the result is undefined. This is
    because the C++ \c ++ and \c -- usually aren't atomic. Indeed, they
    usually of three operations:

    \list 1
    \o Load the variable's value in a register.
    \o Increment the register's value.
    \o Store the register's value back into main memory.
    \endlist

    If thread A and B load the variable's old value simultaneously,
    increment their register, and store it back, they end up
    overwriting each other, and the variable is incremented only
    once!

    Clearly, the access must be serialized. Thread A must perform
    steps 1, 2, 3 without interruption (i.e. \e{atomically}) before
    thread B performs the same steps. One way to make the class
    thread-safe is to protect all access to the data members with a
    mutex:

    \skipto ThreadSafeCounter
    \skipline ThreadSafeCounter
    \printline class Counter
    \printuntil };

    The QMutexLocker class automatically locks the mutex in its
    constructor and unlocks it when the destructor is invoked, at the
    end of the function. Locking the mutex ensures that access from
    different threads will be serialized.

    Since locking and unlocking a QMutex is a rather expensive
    operation, most Qt classes are reentrant (like the first \c
    Counter example) but not thread-safe (like the second example).
    For example, QString is reentrant, meaning that you can use it in
    different threads, but you can't access the same QString object
    from different threads simultaneously. A few classes and
    functions are thread-safe; these are mainly thread-related
    classes, such as QMutex, or fundamental functions, such as
    QCoreApplication::postEvent().

    \section1 Threads and QObjects

    QThread inherits QObject. It emits signals to indicate that the
    thread started or finished executing, and provides a few slots as
    well.

    More interesting is that \l{QObject}s can be used in multiple
    threads, emit signals that invoke slots in other threads, and
    post events to objects that live in other threads. This is
    possible because each thread is allowed to have its own event
    loop.

    \section2 QObject Reentrancy

    QObject is reentrant. Most of its non-GUI subclasses, such as
    QTimer, QTcpSocket, QUdpSocket, QHttp, QFtp, and QProcess, are
    also reentrant, making it possible to use these classes from
    multiple threads simultaneously. This is documented on a
    per-class basis.

    On the other hand, the GUI classes, notably QWidget and all its
    subclasses, are not reentrant. They can only be used from the
    initial thread (which is for that reason often called the GUI
    thread). As noted earlier, QApplication::exec() must also be
    called from that thread.

    In practice, the impossibility of using GUI classes in other
    threads than the GUI thread can easily be worked around by
    putting time-consuming operations in a separate worker thread and
    displaying the results on screen in the main thread when the
    worker thread is finished.

    \section2 Per-Thread Event Loop

    Each thread can have its own event loop. The initial thread
    starts its event loops using QApplication::exec(); other threads
    can start an event loop using QThread::exec().

    An event loop in a thread makes it possible for the thread to use
    certain non-GUI Qt classes that require the presence of an event
    loop (such as QTimer, QTcpSocket, and QSocket). It also makes it
    possible to connect signals from any threads to slots of a
    specific thread. This is explained in more detail in the
    \l{Signals and Slots Across Threads} section below.

    A QObject instance is said to \e live in the thread in which it
    is created. Events to that object are dispatched by that thread's
    event loop. All other access to the QObject must be made from
    that thread, since \l{QObject}s aren't thread-safe. (The
    \l{Thread-Safe QObject Subclasses} section below presents a
    partial solution to this problem.) The thread in which a QObject
    lives is available using QObject::thread().

    If no event loop is running, events won't be delivered to the
    object. For example, if you create a QTimer object in a thread
    but never call QThread::exec(), the QTimer will never emit its
    \l{QTimer::timeout()}{timeout()} signal.

    You can manually post events to any object in any thread at any
    time using the thread-safe function QApplication::postEvent().
    The events will automatically be dispatched by the event loop of
    the thread where the object was created.

    Event filters, on the other
            * event filters, event delivery, etc., not thread-safe
            * caveat: make sure you delete all objects in a thread before you delete the QThread
            * use deleteLater()



    Once the event loop is started, 
        * QThread::exec(), QThread::exit(), QThread::quit()

        * thread-safe event posting

    \section2 Signals and Slots Across Threads

            * direct connections
            * queued connections (needs exec())
            * auto-connection

    \section2 Thread-Safe QObject Subclasses

            * possible...
    "QObject and all of its subclasses are not thread-safe. This
     includes the entire event delivery system. It is important to
     remember that the GUI thread may be delivering events to your QObject
     subclass while you are accessing the object from another thread. If
     you are using QObject in a thread that is not the GUI thread, and you
     are handling events sent to this object, you must protect all access
     to your data with a mutex; otherwise you may experience crashes or
     other undesired behavior."

    \section1 Threads and Implicit Sharing

    Qt uses an optimization called \l{shclass.html}{implicit sharing}
    for many of its value class, notably QImage and QString. In many
    people's minds, implicit sharing and multithreading are
    incompatible concepts, because of the way the reference counting
    is typically done. One solution is to protect the internal
    reference counter with a mutex, but this is prohibitively slow.
    Earlier versions of Qt didn't provide a satisfactory solution to
    this problem.

    Since Qt 4, implicit shared classes can safely be copied across
    threads, like any other value classes. They are fully
    \l{#reentrant}{reentrant}. The implicit sharing is really
    implicit. This is implemented using atomic reference counting
    operations, which are implemented in assembly language for the
    different platforms supported by Qt. Atomic reference counting is
    very fast, much faster than using a mutex.

    This having been said, if you access the same \e object in
    multiple threads simultaneously (as opposed to copies of the same
    object), you still need a mutex to serialize the accesses, just
    like with any reentrant class. As mentioned \l{Reentrance and
    Thread-Safety}{above}, reentrance and thread-safety aren't the
    same thing.

    To sum it up, implicitly shared classes in Qt 4 are really \e
    implicitly shared. Even in multithreaded applications, you can
    safely use them as if they were plain, non-shared, reentrant
    classes.
*/
