/*!
    \page qt4-arthur.html

    \title The Arthur Paint System

    This document describes Qt 4's approach to painting, and contrasts
    it with the Qt 3 approach.

    \tableofcontents

    \section1 Architecture

    The Qt 4 Paint System is primarily based on the classes
    QPainter, QPaintDevice and QPaintEngine. QPainter is the
    class used to perform drawing operations, for example,
    drawLine() and drawRect(). QPaintDevice is an object that
    can be painted on using a QPainter. Both QWidget and
    QPixmap are QPaintDevices. QPaintEngine is the painter's means
    of drawing to a specific device type.

    \section2 A Look Back at Qt 3

    In Qt 3, QPainter could be used to draw on widgets and pixmaps.
    (It could also be used to draw to printers on Windows and Mac OS
    X). When other paint devices needed to be supported, such as
    QPrinter on X11, this was done by deriving from QPaintDevice and
    reimplementing the virtual function QPaintDevice::cmd(). A
    reimplemented paint device was treated as an external device.

    QPainter was capable of recognizing external devices and could
    serialize each paint operation to the reimplemented cmd()
    function. This allowed reimplementation of arbitrary devices, but
    the approach has some disadvantages which we have addressed in
    Qt 4. One of these is that an external device could not reuse any
    functionality implemented in QPainter since QPainter is tied to
    widget/pixmap painting on the current platform. Supporting
    multiple device backends, such as OpenGL, was therefore
    inconvenient and not very efficient.

    This has led us to devise a more convenient and intuitive API for
    Qt 4.

    \section2 How Painting is Done in Qt 4

    In Qt 4 we have introduced the abstract class QPaintEngine.
    Implementations of this class provide the concrete functionality
    needed to draw to a specific device type. The class QPaintEngine
    is only used internally by QPainter and QPaintDevice and is hidden
    from application programmers, unless they reimplement their own
    device type in their own QPaintEngine subclass. Qt currently
    provides paint engines for the following platforms and API's:

    \list
    \o Pixel based engine used on Windows(tm) and for QImage on all platforms.
    \o OpenGL on all platforms
    \o PostScript on Linux, Unix, and Mac OS X
    \o QuickDraw and CoreGraphics on Mac OS X
    \o X11 and the X Render Extension on Linux and Unix systems
    \o QVFb, VNC and LinuxFb on Qt/Embedded
    \endlist

    To implement support for a new backend, you must derive from
    QPaintEngine and reimplement its virtual functions. You also need
    to derive from QPaintDevice and reimplement the virtual function
    QPaintDevice::paintEngine() to tell QPainter which paint engine
    should be used to draw on this particular device.

    The main benefit of this approach is that all painting follows the
    same painting pipeline which means that adding support for new features
    and providing default implementations for unsupported ones has
    become much simpler.

    \section2 What's Changed Since Qt 4 Technology Preview 2?

    As a result of user feedback and internal discussion, we have
    made some improvements to the Qt 4 Paint System:

    \list

    \o We now support alpha channels in gradient fills on all platforms.

    \o We now provide a floating-point API in addition to the
       integer-based API in QPainter.

    \o It is possible to fill a pixmap with transparent pixels using QPixmap::fill().
       (In Qt 3, you had to first create a QImage, fill it with alpha
       pixels, and convert it to a QPixmap, which was both slow and
       counter-intuitive.)

    \o In Qt 4, rectangles are drawn as polygons instead of being handled specially.
       This makes transformations work correctly on rectangles for the first time
       in Qt history, but has the inconvenient that it introduces off-by-one issues
       in existing Qt applications. The Q3Painter class provides the old semantics
       as a help to porting to Qt 4. (The Q3Painter documentation fully explains
       why we made this change.)

    \endlist

    \section1 New Features in the Qt 4 Paint System

    \section2 Gradient Brushes

    With Qt 4 it is possible to fill shapes using gradient
    brushes. A gradient in this case is used to describe the transition
    from one color at one point to another color at another point. A
    gradient can span from one color to another or over a
    number of colors by specifying multiple colors at positions in the
    gradient area.. Qt 4 supports three types of gradients; Linear,
    Radial and Conical.

    Linear gradients are specified using two control points.
    Setting a linear gradient brush is done by creating a QLinearGradient
    object and setting it as a brush.

    \code
    QLinearGradient gradient(0, 0, 100, 100);
    gradient.appendStop(0, Qt::red);
    gradient.appendStop(0.5, Qt::green);
    gradient.appendStop(1, Qt::blue);
    painter.setBrush(gradient);
    painter.drawRect(0, 0, 100, 100);
    \endcode

    The code shown above produces a pattern as show in the following
    pixmap:

    \img diagonalGradient.png

    Radial gradients are specified using a center, a radius and a
    focal point. Setting a radial brush is done by creating a QRadialGradient
    object and setting it as a brush.

    \code
    QRadialGradient gradient(50, 50, 50, 30, 30);
    gradient.appendStop(0.2, Qt::white);
    gradient.appendStop(0.8, Qt::green);
    gradient.appendStop(1, Qt::black);
    painter.setBrush(gradient);
    painter.drawEllipse(0, 0, 100, 100);
    \endcode

    The code shown above produces a pattern as shown in the following
    pixmap:

    \img radialGradient.png

    Concal gradients are specified using a center and a start
    angle. Setting a conical brush is done by creating a
    QConicalGradient object and setting it as a brush.

    \code
    QConicalGradient gradient(60, 40, 0);
    gradient.appendStop(0, Qt::black);
    gradient.appendStop(0.4, Qt::green);
    gradient.appendStop(0.6, Qt::white);
    gradient.appendStop(1, Qt::black);
    painter.setBrush(gradient);
    painter.drawEllipse(0, 0, 100, 100);
    \endcode

    The code shown above produces a pattern as shown in the following
    pixmap:

    \img conicalGradient.png

    \section2 Alpha-Blended Drawing

    With Qt 4 we support alpha-blended outlining and filling. The alpha
    channel of a color is specified through QColor.

    \code
    // Specfiy semi-transparent red
    painter.setBrush(QColor(255, 0, 0, 127));
    painter.drawRect(0, 0, width()/2, height());

    // Specify semi-transparend blue
    painter.setBrush(QColor(0, 0, 255, 127));
    painter.drawRect(0, 0, width(), height()/2);
    \endcode

    The code shown above produces the following output.

    \img alphafill.png

    Alpha-blended drawing is supported on Windows, Mac OS X, and on
    X11 systems that have the X Render extension installed.


    \section2 QPainter and QGLWidget

    It is now possible to open a QPainter on a QGLWidget as if it
    were a normal QWidget. One huge benefit from this is that we
    utilize the high performance of OpenGL for most drawing
    operations, such as transformations and pixmap drawing.


    \section2 Anti-Aliased Edges

    On platforms where this is supported by the drawing API's, we
    provide the option of turning on anti-aliased edges when drawing
    primitives.

    \code
    // One line without anti-aliasing
    painter.drawLine(0, 0, width()/2, height());

    // One line with anti-aliasing
    painter.setRenderHints(QPainter::Antialiasing);
    painter.drawLine(width()/2, 0, width()/2, height());
    \endcode

    This produces the following output.

    \img antialiased.png

    Antialiasing is supported when drawing to a QImage and on all
    systems except X when XRender is not present.


    \section2 Extensive Use of Native Graphics Operations

    In the Qt 4 Paint System we make more use of native graphics
    operations. The benefit we gain from this is that these operations
    can potentially be performed in hardware which gives significant
    speed improvements.

    Among these are native transformations (Mac OS X and OpenGL)
    making painting with a world matrix much faster. Some pixmap
    operations have also been moved closer to hardware.


    \section2 Painter Paths

    A painter path is an object composed of a number of graphical
    building blocks, such as rectangles, ellipses, lines and curves. A
    painter path can be used for filling, outlining, and for clipping.
    The main advantage of painter paths over normal drawing operations
    is that it is possible to build up non-linear shapes which can be
    drawn later one go.

    Building blocks can be joined in closed subpaths, such as a
    rectangle or an ellipse, or they can exist independently as unclosed
    subpaths, although an unclosed path will not be filled.

    Below is a code example on how a path can be used. The
    painter in this case has a pen width of 3 and a light blue brush. We
    first add a rectangle, which becomes a closed subpath.  We then add
    two bezier curves, and finally draw the entire path.

    \code
    QPainterPath path;
    path.addRect(20, 20, 60, 60);
    path.addBezier(0, 0,  99, 0,  50, 50,  99, 99);
    path.addBezier(99, 99,  0, 99,  50, 50,  0, 0);
    painter.drawPath(path);
    \endcode

    The code above produces the following output:

    \img pathexample.png


    \section2 Widget Double-Buffering

    In Qt 4, all widgets are double-buffered by default.

    In previous versions of Qt double-buffering was achieved by
    painting to an off-screen pixmap then copying the pixmap to the
    screen. e.g.

    \code
    QPixmap buffer(size());
    QPainter painter(&buffer);

    // Paint code here

    painter.end();
    bitBlt(this, 0, 0, &buffer);
    \endcode

    Since the double-buffering is handled by QWidget internally this
    now becomes:

    \code
    QPainter painter(this);

    // Paint code here

    painter.end();
    \endcode

    Double-buffering is turned on by default, but can be turned off by
    setting the widget attribute Qt::WA_PaintOnScreen.

    \code
    unbufferedWidget->setAttribute(Qt::WA_PaintOnScreen);
    \endcode

    \section2 Pen and Brush Transformation

    In Qt 3, pens and brushes weren't affected by the painter's
    transformation matrix. For example, if you drew a rectangle with a
    pen width of 1 using a scaled painter, the resulting line width
    would still be 1. This made it difficult to implement features
    such as zooming and high-resolution printing.

    In Qt 4, pens and brushes honor the painter's transformation
    matrix.

    Note that this feature is still in development and not yet
    supported on all platforms.

    \section2 Custom filled Pens

    In Qt 4, it is possible to specify how an outline should be
    filled.  It can be a solid color or a QBrush, which makes it
    possible to specify both texture and gradient fills for both
    text and outlines.

    \code
    QLinearGradient gradient(0, 0, 100, 100);
    gradient.appendStop(0, Qt::blue);
    gradient.appendStop(1, Qt::red);
    painter.setPen(QPen(gradient, 0));
    for (int y=fontSize; y<100; y+=fontSize)
        drawText(0, y, text);
    \endcode

    The code above produces the following output:

    \img gradientText.png

    \section2 QImage as a paint device

    A great improvement of Qt 4 over previous versions it that we now
    provide a pixel based raster paint engine which allows users to
    open a painter on a QImage. The QImage paint engine supports the
    full featureset of QPainter (paths, antialiasing, alphablending,
    etc) and can be used on all platforms.

    One advantage of this is that it is possible to guarantee the
    pixel exactness of any drawing operation independent of platform.

    Painting on an image is as simple as drawing on any other paint device.

    \code
    QImage image(100, 100, 32);
    QPainter painter(&image);

    // painter commands.

    painter.end();
    \endcode

    \link qt4-intro.html [Back to the Beta page] \endlink
*/
