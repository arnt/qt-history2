/*! \page qaxcontainer.html

    \title The QAxContainer Module

    This module is part of the \link activeqt.html ActiveQt
    framework\endlink. (To make an application into an ActiveX server
    see the \link qaxserver.html QAxServer module\endlink.)

    \tableofcontents

    \section1 Introduction

    The QAxContainer module provides a library implementing a QWidget
    subclass, QAxWidget, that acts as a container for ActiveX
    controls, and a QObject subclass, QAxObject, that can be used to
    easily access non-visual COM objects. Scripting COM objects embedded
    using these classes is possible through the QAxScript, QAxScriptManager
    and QAxScriptEngine classes, and a set of \link activeqt-tools.html 
    tools \endlink make it easy to use embedded COM objects programmatically.

    The module consists of six classes
    \list 1
    \i \l QAxBase is an abstract class that provides an API to initialize 
       and access a COM object or ActiveX control.
    \i \l QAxObject provides a QObject that wraps a COM object.
    \i \l QAxWidget is a \l QWidget that wraps an ActiveX control.
    \i \l QAxScriptManager, QAxScript and QAxScriptEngine provide an 
          interface to the Windows Script Host.
    \endlist

    Some \link qaxcontainer-examples.html example applications \endlink
    that use standard ActiveX controls to provide high level user
    interface functionality are provided.

    \section1 Building the library

    In the \c activeqt directory (usually \c QTDIR/extensions/activeqt)
    enter the \c container subdirectory and run \c qmake to generate the
    makefile, and use your make tool to build the library. 
    The library \c qaxcontainer.lib will be linked into \c QTDIR/lib.

    If you are using a shared configuration of Qt enter the \c plugin subdirectory
    and run \c qmake and your make tool to build a plugin that integrates the
    QAxWidget class into \l{Qt Designer}.

    \section1 Using the library

    To build Qt applications that can host COM objects and ActiveX controls
    link the application against the QAxContainer module by adding

    \code
    CONFIG += qaxcontainer
    \endcode

    to the application's \c .pro file.

    \section2 Distributing QAxContainer applications

    The QAxContainer library is static, so there is no need to redistribute
    any additional files when using this module. Note however that the
    ActiveX server binaries you are using might not be installed on the
    target system, so you have to ship them with your package and register
    them during the installation process of your application.

    \section1 Instantiating COM objects

    To instantiate a COM object use the QAxBase::setControl() API, or pass
    the name of the object directly into the constructor of the QAxBase 
    subclass you are using.

    The control can be specified in a variety of formats, but the fastest
    and most powerful format is to use the class ID (CLSID) of the object
    directly. The class ID can be prepended with information about a remote
    machine that the object should run on, and can include a license key
    for licensed controls.

    \section1 Accessing the object API

    ActiveQt provides a Qt API to the COM object, and replaces COM
    datatypes with Qt equivalents. Use the \c dumpdoc tool to get the 
    documentation of the Qt API for any COM object and it's subobjects.

    See the QAxWidget and QAxObject API documentation about how to 
    use this class to use ActiveX controls and COM objects in Qt 
    applications via QAxBase::dynamicCall() and QAxBase::querySubObject() 
    as well as the QObject::setProperty() and QObject::property() APIs. 
    To access the COM object with scripting languages use the QAxScript class.

    To generate a C++ namespace for the type library you want to access,
    use the \link activeqt-tools-dumpcpp.html dumpcpp \endlink tool. Run 
    this tool manually on the type library you want to use, or integrate it
    into the build system by adding the following to your application .pro file:

    \code
    CONFIG += dumpcpp
    TYPELIBS = file.tlb
    \endcode

    Include the resulting header file in your code to access the object APIs
    through the generated C++ classes. See the \link qaxcontainer-example-qutlook.html
    Qutlook \endlink example for more information.

    To call functions of the COM object that can not be accessed via
    ActiveQt it is possible to request the COM interface directly using
    \c QAxBase::queryInterface(). To get a C++ definition of the respective
    interface classes use the \c #import directive with the type library
    provided with the control; see your compiler manual for details.

    \section2 Typical error messages

    ActiveQt prints error messages to the debug output when it
    encounters error situations at runtime. Usually you must run 
    your program in the debugger to see these messages (e.g. in Visual
    Studio's Debug output).

    \section3 Requested control could not be instantiated

    The control requested in QAxBase::setControl() is not installed
    on this system, or is not accessible for the current user.

    The control might require administrator rights, or a license key.
    If the control is licensed, reimplement initialize() and use the
    COM APIs to call the IClassFactory2 interface functions.

    \section3 QAxBase::internalInvoke: No such method

    A \c dynamicCall() failed - the function prototype did not
    match any function available in the object's API.

    \section3 Error calling IDispatch member: Non-optional parameter 
    missing

    A \c dynamicCall() failed - the function prototype was correct,
    but too few parameters were provided.

    \section3 Error calling IDispatch member: Type mismatch in 
    parameter n

    A \c dynamicCall() failed - the function prototype was correct,
    but the paramter at index \c n was of the wrong type and could 
    not be coerced to the correct type.

    \section3 QAxScriptManager::call(): No script provides this function

    You try to call a function that is provided through an engine
    that doesn't provide introspection (ie. ActivePython or 
    ActivePerl). You need to call the function directly on the
    respective QAxScript object.
*/
