/*! \page qaxserver.html

    \title The QAxServer Module

    This module is part of the \link activeqt.html ActiveQt
    framework\endlink. (To incorporate ActiveX controls in a Qt
    application see the \link qaxcontainer.html QAxContainer
    module\endlink.) 

    \tableofcontents

    \section1 Introduction

    The QAxServer module provides a static library implementing the
    functionality required to turn a standard Qt binary into a COM server. 

    The module consists of three classes
    \list
    \i QAxFactory defines a factory for the creation of COM objects.
    \i QAxBindable provides an interface between the Qt widget and the 
       COM object.
    \i QAxAggregated can be subclassed to implement additional COM interfaces.
    \endlist

    Some \link qaxserver-examples.html example implementations \endlink 
    of ActiveX controls and COM objects are provided.

    \section1 Building the library

    In the \c activeqt directory (usually \c QTDIR/extensions/activeqt)
    enter the \c control subdirectory and run \c qmake to generate the
    makefile, and use the make tool (\c nmake for VC++, \c make for Borland)
    to build the library. The library \c qaxserver.lib will be linked into 
    \c QTDIR/lib.

    \section1 Using the library

    To turn a standard Qt application into an COM server using the
    QAxServer library you must add \c qaxserver as a CONFIG setting
    in your \c .pro file.

    An out-of-process executable server is generated from a \c .pro
    file like this:
    \code
    TEMPLATE = app
    CONFIG  += qaxserver

    RC_FILE  = qaxserver.rc
    ...
    \endcode

    To build an in-process server, use a \c .pro file like this:
    \code
    TEMPLATE = lib
    CONFIG  += qaxserver dll

    DEF_FILE = qaxserver.def
    RC_FILE  = qaxserver.rc
    ...
    \endcode

    The files \c qaxserver.rc and \c qaxserver.def are part of the
    framework and can be used from their usual location (specify a
    path in the \c .pro file), or copied into the project directory.
    You can modify these files as long as it includes any file as the
    type library entry, ie. you can add version information or specify
    a different toolbox icon.

    The \c qaxserver configuration will cause the \c qmake tool to add the 
    required build steps to the build system:
    \list
    \i link the binary against \c qaxserver.lib
    \i generate an interface definition and link the type library into
       the binary (see \link activeqt-tools-idc.html idc \endlink)
    \i register the server
    \endlist

    To skip the post-processing step, also set the \c qaxserver_no_postlink
    configuration.

    Additionally you can specify a version number using the \c VERSION
    variable, e.g.
    \code
    TEMPLATE = lib
    VERSION = 2.5
    ...
    \endcode
    The version number specified will be used as the version of the type
    library and of the server when registering.

    \section2 Out-of-process vs. In-process

    Whether your COM server should run as a stand-alone executable
    or as a shared library in the client process depends mainly on the
    type of controls you want to provide in the server. 

    An executable server has the advantage of being able to run as a
    stand-alone application, but adds considerable overhead to the
    communication between the COM client and the COM object. If the
    control has a programming error only the server process running
    the control will crash, and the client application will probably
    continue to run. Not all COM clients support executable servers.

    An in-process server is usually smaller and has faster startup
    time. The communication between client and server is done directly
    through virtual function calls and does not introduce the overhead
    required for remote procedure calls. However, if the server crashes the
    client application is likely to crash as well, and not every 
    functionality is available for in-process servers (i.e. register in
    the COM's running-object-table).

    Both server types can use Qt either as a shared library, or statically
    linked into the server binary.

    \section1 The QAxServer build system

    To be able to build COM objects and ActiveX controls with Qt, the 
    build system must be extended to include some additional build steps 
    that are used when the \c .pro file includes \c qaxserver in the 
    \c CONFIG settings. The resulting makefile will:

    \list
    \i Link the executable against \c qaxserver.lib instead of \c qtmain.lib
    \i Call the \link activeqt-tools-idc.html idc \endlink tool to generate an 
    IDL description for the COM server.
    \i Compile the IDL into a type library using the MIDL tool (part of your 
    compiler installation)
    \i Attach the resulting type library as a binary resource to the server
       executable
    \endlist

    Attaching resources to an executable is not supported by
    Windows&nbsp;95/98/ME, but a server built on
    Windows&nbsp;NT/2000/XP will work on those versions.

    \section2 Typical build problems

    The compiler/linker errors listed are based on those issued by the 
    Microsoft Visual C++ 6.0 compiler.

    \section3 Compilation errors

    \section4 "No overloaded function takes 2 parameters"

    When the error occurs in code that uses the \c QAXFACTORY_DEFAULT
    macro, the widget class had no constructor that can be used by the
    default factory. Either add a standard widget constructor or
    implement a custom factory that doesn't require one.

    When the error occurs in code that uses the \c QAXFACTORY_EXPORT
    macro, the QAxFactory subclass had no appropriate constructor.
    Provide a public class constructor like
    \code
    MyFactory( const QUuid &, const QUuid & );
    \endcode
    for your factory class.

    \section4 "syntax error: bad suffix on number"

    The unique identifiers have not been passed as strings into the 
    \c QAXFACTORY_EXPORT or \c QAXFACTORY_DEFAULT macro.

    \section3 Linker errors

    \section4 "unresolved external symbol _ucm_instantiate"

    The server does not export an implementation of a QAxFactory. Use
    the \c QAXFACTORY_EXPORT macro in one of the project's
    implementation files to instantiate and export a factory, or use
    the \c QAXFACTORY_DEFAULT macro to use the default factory.

    \section4 "_ucm_initialize already defined in ..."

    The server exports more than one implementation of a QAxFactory,
    or exports the same implementation twice. If you use the default
    factory, the \c QAXFACTORY_DEFAULT macro must only be used once in
    the project. Use a custom QAxFactory implementation and the \c
    QAXFACTORY_EXPORT macro if the server provides multiple ActiveX
    controls.

    \section4 "cannot open file ... "

    The ActiveX server could not shut down properly when the last
    client stopped using it. It usually takes about two seconds for
    the application to terminate, but you might have to use the task
    manager to kill the process (e.g. when a client doesn't release
    the controls properly).

    \section3 Postprocessing and runtime errors

    The ActiveQt build system performs four commands after the linking
    of the binary to make it into an ActiveX server.

    \list
    \i Call the server to dump the IDL for the controls
    \i Compile the IDL into a type library
    \i Attach the type library as a binary resource to the server
    \i Register the server
    \endlist

    For this to work the server has to meet some requirements:

    \list
    \i All controls exposed can be created with nothing but a QApplication
    instance being present
    \i The initial linking of the server includes a temporary type 
    library resource
    \i All dependencies required to run the server are in the system path 
    (or in the path used by the calling environment; note that Visual 
    Studio has it's own set of environment variables listed in the
    Tools|Options|Directories dialog).
    \endlist

    If those requirements are not met one ore more of the following 
    errors are likely to occur:

    \omit ### which errors? \endomit

    \section4 The server executable crashes

    To generate the IDL the widgets exposed as ActiveX controls need to
    be instantiated (the constructor is called). At this point, nothing 
    else but a QApplication object exists. Your widget constructor must 
    not rely on any other objects to be created, e.g. it should check for
    null-pointers.

    To debug your server run it with -dumpidl outputfile and check where
    it crashes.

    Note that no functions of the control are called.


    \section4 The server executable is not a valid Win32 application

    Attaching the type library corrupted the server binary. This is a
    bug in Windows and happens only with release builds.

    The first linking step has to link a dummy type library into the
    executable that can later be replaced by idc. Add a resource file
    with a type library to your project as demonstrated in the examples.

    \section4 "Unable to Locate DLL"

    The build system needs to run the server executable to generate
    the interface definition, and to register the server. If a dynamic
    link library the server links against is not in the path this
    might fail (e.g. Visual Studio calls the server using the
    enivronment settings specified in the "Directories" option). Make
    sure that all DLLs required by your server are located in a
    directory that is listed in the path as printed in the error
    message box.

    \section4 The Server does not respond

    If the system is unable to start the server (check with the task
    manager whether the server runs a process), make sure that no DLL
    the server depends on is missing from the system path (e.g. the Qt 
    DLL!). Use a dependency walker to view all dependencies of the server 
    binary.

    If the server runs (e.g. the task manager lists a process), see
    the following section for information on debugging your server.

    \section4 The Object cannot be created

    If the server could be built and registered correctly during the build
    process, but the object cannot be initiliazed e.g. by the OLE/COM Object 
    Viewer application, make sure that no DLL the server depends on is
    missing from the system path (e.g. the Qt DLL). Use a dependency walker
    to view all dependencies of the server binary.

    If the server runs, see the following section for information on
    debugging your server.

    \section2 Debugging runtime errors

    To debug an in-process server in Visual Studio, set the server project 
    as the active project, and specify a client "executable for debug
    session" in the project settings (e.g. use the ActiveX Test Container). 
    You can set breakpoints in your code, and also step into ActiveQt and 
    Qt code if you installed the debug version.

    To debug an executable server, run the application in a debugger
    and start with the command line parameter "-activex". Then start
    your client and create an instance of your ActiveX control. COM 
    will use the existing process for the next client trying to create 
    an ActiveX control.

    \section1 Implementing Controls

    To implement a COM object with Qt, create a subclass of QObject
    or any existing QObject subclass. If the class is a subclass of QWidget,
    the COM object will be an ActiveX control.

    \code
    #include <qwidget.h>

    class MyActiveX : public QWidget
    {
        Q_OBJECT
    \endcode

    The \c Q_OBJECT macro is required to provide the meta object information
    about the widget to the ActiveQt framework.

    \code
       Q_CLASSINFO("ClassID", "{1D9928BD-4453-4bdd-903D-E525ED17FDE5}")
       Q_CLASSINFO("InterfaceID", "{99F6860E-2C5A-42ec-87F2-43396F4BE389}")
       Q_CLASSINFO("EventsID", "{0A3E9F27-E4F1-45bb-9E47-63099BCCD0E3}")
    \endcode

    Use the \c Q_CLASSINFO macro to specify the COM identifiers for the COM
    object. \c ClassID and \c InterfaceID are required, while \c EventsID is
    only necessary when your object has signals. To generate these identifiers,
    use system tools like \c uuidgen or \c guidgen.

    You can specify additional attributes for each of your classes; see 
    \link qaxserver.html#sec.8.2 Class Information and Tuning \endlink for 
    details.

    \code
        Q_PROPERTY( int value READ value WRITE setValue )
    \endcode

    Use the \c Q_PROPERTY macro to declare properties for the ActiveX control.

    Declare a standard constructor taking a parent object, and functions, 
    signals and slots like for any QObject subclass.
    \footnote
    If a standard constructor is not present the compiler will issue
    an error "no overloaded function takes 2 parameters" when using
    the default factory through the QAXFACTORY_DEFAULT macro. If you
    cannot provide a standard constructor you must implement a \l
    QAxFactory custom factory and call the constructor you have in
    your implementation of QAxFactory::create.
    \endfootnote

    \code
    public:
        MyActiveX(QWidget *parent = 0)
        ...

        int value() const;

    public slots:
        void setValue(int v);
        ...

    signals:
        void valueChange(int v);
        ...

    };
    \endcode

    The ActiveQt framework will expose properties and public slots as ActiveX 
    properties and methods, and signals as ActiveX events, and convert between
    the Qt data types and the equivalent COM data types.

    \section2 Data Types

    The Qt data types that are supported for properties are:

    \table
    \header
    \i Qt data type
    \i COM property
    \row
    \i bool
    \i VARIANT_BOOL
    \row
    \i QString
    \i BSTR
    \row
    \i QCString
    \i BSTR
    \row
    \i int
    \i int
    \row
    \i uint
    \i unsigned int
    \row
    \i double
    \i double
    \row
    \i Q_LLONG
    \i CY
    \row
    \i Q_ULLONG
    \i CY
    \row
    \i QColor
    \i OLE_COLOR
    \row
    \i QDate
    \i DATE
    \row
    \i QDateTime
    \i DATE
    \row
    \i QTime
    \i DATE
    \row
    \i QFont
    \i IFontDisp*
    \row
    \i QPixmap
    \i IPictureDisp*
    \footnote
    COM cannot marshal IPictureDisp accross process boundaries,
    so QPixmap properties cannot be called for out-of-process servers. You
    can however marshal the image data via e.g. temporary files. See the
    Microsoft 
    \link http://support.microsoft.com/default.aspx?scid=kb;[LN];Q150034 KB article 
    Q150034 \endlink for more information.
    \endfootnote
    \row
    \i QVariant
    \i VARIANT
    \row
    \i QValueList\<QVariant\>
    \i SAFEARRAY(VARIANT)
    \row
    \i QStringList
    \i SAFEARRAY(BSTR)
    \row
    \i QByteArray
    \i SAFEARRAY(BYTE)
    \row
    \i QRect
    \i User defined type
    \row
    \i QSize
    \i User defined type
    \row
    \i QPoint
    \i User defined type
    \endtable

    The Qt data types that are supported for parameters in signals and
    slots are:
    \table
    \header
    \i Qt data type
    \i COM parameter
    \row
    \i bool
    \i [in] VARIANT_BOOL
    \row
    \i bool&
    \i [in, out] VARIANT_BOOL*
    \row
    \i QString, const QString&
    \i [in] BSTR
    \row
    \i QString&
    \i [in, out] BSTR*
    \row
    \i QCString, const QCString&
    \i [in] BSTR
    \row
    \i QString&
    \i [in, out] BSTR*
    \row
    \i int
    \i [in] int
    \row
    \i int&
    \i [in,out] int
    \row
    \i uint
    \i [in] unsigned int
    \row
    \i uint&
    \i [in, out] unsigned int*
    \row
    \i double
    \i [in] double
    \row
    \i double&
    \i [in, out] double*
    \row
    \i QColor, const QColor&
    \i [in] OLE_COLOR
    \row
    \i QColor&
    \i [in, out] OLE_COLOR*
    \row
    \i QDate, const QDate&
    \i [in] DATE
    \row
    \i QDate&
    \i [in, out] DATE*
    \row
    \i QDateTime, const QDateTime&
    \i [in] DATE
    \row
    \i QDateTime&
    \i [in, out] DATE*
    \row
    \i QFont, const QFont&
    \i [in] IFontDisp*
    \row
    \i QFont&
    \i [in, out] IFontDisp**
    \row
    \i QPixmap, const QPixmap&
    \i [in] IPictureDisp*
    \row
    \i QPixmap&
    \i [in, out] IPictureDisp**
    \row
    \i QValueList\<QVariant\>, const QValueList\<QVariant\>&
    \i [in] SAFEARRAY(VARIANT)
    \row
    \i QValueList\<QVariant\>&
    \i [in, out] SAFEARRAY(VARIANT)*
    \row
    \i QStringList, const QStringList&
    \i [in] SAFEARRAY(BSTR)
    \row
    \i QStringList&
    \i [in, out] SAFEARRAY(BSTR)*
    \row
    \i QByteArray, const QByteArray&
    \i [in] SAFEARRAY(BYTE)
    \row
    \i QByteArray&
    \i [in, out] SAFEARRAY(BYTE)*
    \row
    \i QObject*
    \i [in] IDispatch*
    \row
    \i QRect&
    \footnote
    OLE needs to marshal user defined types by reference (ByRef), and cannot 
    marshal them by value (ByVal). This is why const-references and object
    parameters are not supported for QRect, QSize and QPoint. Also note that
    servers with this datatype require Windows 98 or DCOM 1.2 to be installed.
    \endfootnote
    \i [in, out] struct QRect (user defined)
    \row
    \i QSize&
    \i [in, out] struct QSize (user defined)
    \row
    \i QPoint&
    \i [in, out] struct QPoint (user defined)
    \endtable

    Also supported are exported enums and sets (see Q_ENUMS and Q_SETS).
    The in-parameter types are also supported as return values.

    Properties and signals/slots that have parameters using any other
    data types are ignored by the QActiveX framework.

    \section2 Sub-Objects

    COM objects can have multiple sub-objects that can represent a sub element
    of the COM object. A COM object representing a multi-document spread sheet 
    application can for example provide one sub-object for each spread sheet.

    Any QObject subclass can be used as the type for a sub object in ActiveX, as
    long as it is known to the QAxFactory. Then the type can be used in properties,
    or as the return type or paramter of a slot.

    \section2 Property Notification

    To make the properties bindable for the ActiveX client, use multiple
    inheritance from the QAxBindable class:

    \code
    #include <qwidget.h>
    #include <qaxbindable.h>

    class MyActiveX : public QWidget, public QAxBindable
    {
        Q_OBJECT
    \endcode

    When implementing the property write functions, use the
    QAxBindable class's requestPropertyChange() and propertyChanged()
    functions to allow ActiveX clients to bind to the control
    properties. 
    \footnote 
    This is not required, but gives the client more control over 
    the ActiveX control.
    \endfootnote

    \section1 Serving Controls

    To make a COM server available to the COM system it must be registered 
    in the system registry using five unique identifiers. 
    These identifiers are provided by tools like \c guidgen or \c uuidgen. 
    The registration information allows COM to localize the binary providing 
    a requested ActiveX control, marshall remote procedure calls to the 
    control and read type information about the methods and properties exposed 
    by the control.

    To create the COM object when the client asks for it the server must export 
    an implementation of a QAxFactory. The easist way to do this is to use a set
    of macros:

    \code
    QAXFACTORY_BEGIN("{ad90301a-849e-4e8b-9a91-0a6dc5f6461f}",
                     "{a8f21901-7ff7-4f6a-b939-789620c03d83}")
        QAXCLASS(MyWidget)
        QAXCLASS(MyWidget2)
        QAXTYPE(MySubType)
    QAXFACTORY_END()
    \endcode

    This will export \c MyWidget and \c MyWidget2 as COM objects that can be
    created by COM clients, and will register \c MySubType as a type that can
    be used in properties and parameters of \c MyWidget and \c MyWidget2.

    The \link QAxFactory QAxFactory class documentation \endlink explains 
    how to use this macro, and how to implement and use custom factories.

    For out-of-process executable servers you can implement a main()
    function to instantiate a QApplication object and enter the event
    loop just like any normal Qt application. By default the
    application will start as a standard Qt application, but if you
    pass \c -activex on the command line it will start as an ActiveX
    server. Use QAxFactory::isServer() to create and run a standard
    application interface, or to prevent a stand-alone execution:

    \code
    #include <qapplication.h>
    #include <qaxfactory.h>

    int main( int argc, char **argv )
    {
        QApplication app( argc, argv );
        if ( !QAxFactory::isServer() ) {
            // create and show main window...
        }
        return app.exec();
    }
    \endcode

    This is however not necessary as ActiveQt provides a default implementation
    of a main function. The default implemenation calls QAxFactory::startServer(),
    creates a QApplication instance and calls exec().

    To build the ActiveX server executable run \c qmake
    to generate the makefile, and use your compiler's
    make tool as for any other Qt application. The make process will
    also register the controls in the system registry by calling the
    resulting executable with the \c -regserver command line option.

    If the ActiveX server is an executable, the following command line
    options are supported:
    \table
    \header \i Option \i Result
    \row \i \c -regserver \i Registers the server in the system registry
    \row \i \c -unregserver \i Unregisters the server from the system registry
    \row \i \c -activex \i Starts the application as an ActiveX server
    \row \i \c{-dumpidl <file> -version x.y} \i Writes the server's IDL to the
    specified file. The type library will have version x.y
    \endtable

    In-process servers can be registered using the \c regsvr32 tool available
    on all Windows systems.

    \section2 Distributing QAxServer binaries

    ActiveX servers written with Qt can use Qt either as a shared
    library, or have Qt linked statically into the binary. Both ways
    will produce rather large packages (either the server binary
    itself becomes large, or you have to ship the Qt DLL).

    \section3 Installing stand-alone Servers

    When your ActiveX server can also run as a stand-alone application,
    run the server executable with the \c -regserver command line
    parameter after installing the executable on the target system.
    After that the controls provided by the server will be available to
    ActiveX clients.

    \section3 Installing In-process Servers

    When your ActiveX server is part of an installation package, use the
    \c regsvr32 tool provided by Microsoft to register the controls on
    the target system. If this tool is not present, load the DLL into
    your installer process, resolve the \c DllRegisterServer symbol and
    call the function:

    \code
    HMODULE dll = LoadLibrary( "myserver.dll" );
    typedef HRESULT(__stdcall *DllRegisterServerProc)();
    DllRegisterServerProc DllRegisterServer = 
        (DllRegisterServerProc)GetProcAddress( dll, "DllRegisterServer" );

    HRESULT res = E_FAIL;
    if ( DllRegisterServer )
	res = DllRegisterServer();
    if ( res != S_OK )
        // error handling
    \endcode

    \section3 Distributing Servers over the Internet

    If you want to use controls in your server in web-pages you need to
    make the server available to the browser used to view your page, and
    you need to specify the location of the server package in your page.

    To specify the location of a server, use the CODEBASE attribute in
    the OBJECT tag of your web-site. The value can point to the server
    file itself, to an \c INF file listing other files the server requires
    (e.g. the Qt DLL), or a compressed \c CAB archive.

    INF and CAB files are documented in almost every book available about
    ActiveX and COM programming as well as in the MSDN library and various
    other Online resources. The examples include INF files that can be used
    to build CAB archives:

    \quotefile simple/simple.inf
    \printuntil RegisterServer

    The CABARC tool from Microsoft can easily generate CAB archives:
    \code cabarc N simpleax.cab simpleax.exe simple.inf \endcode

    The INF files assume a static build of Qt, so no dependencies to other DLLs
    are listed in the INF files. To distribute an ActiveX server depending on
    DLLs you must add the dependencies, and provide the library files
    with the archive.

    \section1 Using the Controls

    To use the ActiveX controls, e.g. to embed them in a web page, use
    the \c <object> HTML tag. 

    \code
    <object ID="MyActiveX1" CLASSID="CLSID:ad90301a-849e-4e8b-9a91-0a6dc5f6461f">
       ...
    <\object>
    \endcode

    To initialize the control's properties, use
    \code
    <object ID=...>
        <param name="name" value="value">
    <\object>
    \endcode

    If the web browser supports scripting use JavaScript, VBScript and
    forms to script the control. The \link qaxserver-examples.html
    examples \endlink include demonstration HTML pages for the
    example controls.

    \section2 Supported and Unsupported ActiveX clients

    The following is largly based on our own experiements with ActiveX
    controls and client applications, and is by no means complete.

    \section3 Supported Clients

    These standard applications work with ActiveX controls developed with 
    ActiveQt. Note that some clients support only in-process controls.

    \list
    \i Internet Explorer
    \i Microsoft ActiveX Control Test Container
    \i Microsoft Visual Studio 6.0
    \i Microsoft Visual Studio.NET/2003
    \i Microsoft Visual Basic 6.0
    \i MFC- and ATL-based containers
    \i Sybase PowerBuilder
    \i ActiveQt based containers
    \endlist

    Microsoft Office applications are supported, but you need to register
    the controls as "Insertable" objects. Reimplement \c QAxFactory::registerClass
    to add this attribute to the COM class, or set the "Insertable" class info
    for your class to "yes" using the Q_CLASSINFO macro.

    \section3 Unsupported Clients

    We have not managed to make ActiveQt based COM objects work with the
    following client applications.

    \list
    \i Borland C++ Builder (Versions 5 and 6)
    \i Borland Delphi
    \endlist

    \section1 Class Information and Tuning

    To provide attributes for each COM class, use the Q_CLASSINFO macro, which is part of
    Qt's meta object system.

    \table
    \header
    \i Key
    \i Meaning of value
    \row
    \i Version
    \i The version of the class (1.0 is default)
    \row
    \i Description
    \i A string describing the class.
    \row
    \i ClassID
    \i The class ID.
       You must reimplement QAxFactory::classID if not specified.
    \row
    \i InterfaceID
    \i The interface ID. 
       You must reimplement QAxFactory::interfaceID if not specified.
    \row
    \i EventsID
    \i The event interface ID.
       No signals are exposed as COM events if not specified.
    \row
    \i DefaultProperty
    \i The property specified represents the default property of this class.
       Ie. the default property of a push button would be "text".
    \row
    \i DefaultSignal
    \i The signal specified respresents the default signal of this class.
       Ie. the default signal of a push button would be "clicked".
    \row
    \i LicenseKey
    \i Object creation requires the specified license key. The key can be
       empty to require a licensed machine. By default classes are not
       licensed. Also see the following section.
    \row
    \i StockEvents
    \i Objects expose stock events if value is "yes".
       See \l QAxFactory::hasStockEvents()
    \row
    \i ToSuperClass
    \i Objects expose functionality of all super-classes up to and
       including the class name in value.
       See \l QAxFactory::exposeToSuperClass()
    \row
    \i Insertable
    \i If the value is "yes" the class is registered to be "Insertable" 
       and will be listed in OLE 2 containers (ie. Microsoft Office). This 
       attribute is not be set by default.
    \row
    \i Aggregatable
    \i If the value is "no" the class does not support aggregation. By 
       default aggregation is supported.
    \row
    \i Creatable
    \i If the value is "no" the class cannot be created by the client,
       and is only available through the API of another class (ie. the
       class is a sub-type).
    \row
    \i RegisterObject
    \i If the value is "yes" objects of this class are registered with
       OLE and accessible from the running object table (ie. clients
       can connect to an already running instance of this class). This
       attribute is only supported in out-of-process servers.
    \endtable

    Note that both keys and values are case sensitive.

    The following declares version 2.0 of a class that exposes only its
    own API, and is available in the "Insert Objects" dialog of Microsoft
    Office applications.

    \code
    class MyActiveX : public QWidget
    {
        Q_OBJECT
        Q_CLASSINFO("Version", "2.0")
        Q_CLASSINFO("ClassID", "{7a4cffd8-cbcd-4ae9-ae7e-343e1e5710df}")
        Q_CLASSINFO("InterfaceID", "{6fb035bf-8019-48d8-be51-ef05427d8994}")
        Q_CLASSINFO("EventsID", "{c42fffdf-6557-47c9-817a-2da2228bc29c}")
        Q_CLASSINFO("Insertable", "yes")
        Q_CLASSINFO("ToSuperClass", "MyActiveX")

        Q_PROPERTY( ...
    public:
        MyActiveX(QWidget *parent = 0);

        ...
    };
    \endcode

    \section2 Developing licensed components

    If you develop components you might want to control who is able to instantiate
    those components. Since the server binary can be shipped to and registered on 
    any client machine it is possible for anybody to use those components in his 
    own software.

    Licensing components can be done using a variety of techniques, e.g. the code
    creating the control can provide a license key, or the machine on which the
    control is supposed to run needs to be licensed.

    To mark a Qt class as licensed specify a "LicenseKey" using the \c Q_CLASSINFO
    macro.
    \code
    class MyLicensedControl : public QWidget
    {
        Q_OBJECT
        Q_CLASSINFO("LicenseKey", "&lt;key string&gt;")
    ...
    };
    \endcode

    The key is required to be able to create an instance of \c MyLicensedControl
    on a machine that is not licensed itself. The licensed developer can now 
    redistributes the server binary with his application, which creates the control 
    using the value of "LicenseKey", while users of the application cannot create
    the control without the license key.

    If a single license key for the control is not sufficient (ie. you want 
    differnet developers to receive different license keys) you can specify an 
    empty key to indicate that the control requires a license, and reimplement 
    \l QAxFactory::validateLicenseKey() to verify that a license exists on the 
    system (ie. through a license file).

    \section2 More Interfaces

    ActiveX controls provided by ActiveQt servers support a minimal set of COM 
    interfaces to implement the OLE specifications. When the ActiveX class inherits 
    from the QAxBindable class it can also implement additional COM interfaces.

    Create a new subclass of QAxAggregated and use multiple inheritance
    to subclass additional COM interface classes. 

    \code
    class AxImpl : public QAxAggregated, public ISomeCOMInterface
    {
    public:
        AxImpl() {}

        long queryInterface( const QUuid &iid, void **iface );

        // IUnknown
	QAXAGG_IUNKNOWN

        // ISomeCOMInterface
        ...
    }
    \endcode

    Reimplement the \c queryInterface() function to support the additional 
    COM interfaces.

    \code
    long AxImpl::queryInterface( const QUuid &iid, void **iface )
    {
        *iface = 0;
	if ( iid == IID_ISomeCOMInterface )
	    *iface = (ISomeCOMInterface*)this;
	else
	    return E_NOINTERFACE;

	AddRef();
	return S_OK;
    }
    \endcode

    Since \c ISomeCOMInterface is a subclass of \c IUnknown you will have
    to implement the \c QueryInterface, \c AddRef and \c Release functions. 
    Use the \c QAXAGG_IUNKNOWN macro in your class definition to do that. If 
    you implement the IUnknown functions manually, delegate the calls to the
    interface pointer returned by the controllingUnknown() function, e.g.
    \code
    HRESULT AxImpl::QueryInterface( REFIID iid, void **iface )
    {
        return controllingUnknown()->QueryInterface( iid, iface );
    }
    \endcode
    Do not support the \c IUnknown interface itself in your \c queryInterface() 
    implementation.

    Implement the methods of the COM interfaces, and use QAxAggregated::Object()
    if you need to make calls to the QObject subclass implementing the control.

    In your QAxBindable subclass, implement \c createAggregate() to return
    a new object of the QAxAggregated subclass.

    \code
    class MyActiveX : public QWidget, public QAxBindable
    {
    	Q_OBJECT
    public:
        MyActiveX(QWidget *parent);

        QAxAggregated *createAggregate()
        {
            return new AxImpl();
        }
    };
    \endcode
*/
