/*!
    \example qtopiacore/mousecalibration
    \title Mouse Calibration Example

    The Mouse Calibration example demonstrates how to write a simple
    program using the mechanisms provided by the QWSMouseHandler class
    to calibrate the mouse handler.

    \image mousecalibration-example.png

    Calibration is ...

    The example consists of two classes in addition to the main program:

    \list
        \o \c Calibration is a dialog widget that ...
        \o \c ScribbleWidget is ...
    \endlist

    First we will review the main program, then we will take a look at
    the \c Calibration and \c ScribbleWidget classes.

    \section1 The Main Program

    \quotefromfile qtopiacore/mousecalibration/main.cpp
    \skipto main
    \printto Calibration

    The program starts by using the QMessageBox class to inform the
    user of what is going to happen. QMessageBox provides a modal
    dialog with a short message, an icon, and some buttons. It provides
    a range of different messages, arranged roughly along two axes:
    severity and complexity.

    At this stage in the program, the mouse could be completely
    uncalibrated, making the user unable to press the OK button. For
    that reeason we use the QTimer class to make the message box
    disappears after 10 seconds. QTimer provides repetitive and
    single-shot timers.

    \skipto Calibration
    \printuntil /^\}/

    Next, we create an instance of the Calibration class which
    ....

    Since the mouse still could be completely uncalibrated, we
    continue to use QMessageBox and QTimer to inform the user about
    the program's process.

    Finally, we let the user test the new mouse settings by drawing
    into a widget. An improved calibration tool would let the user
    choose between accepting the new calibration, revert to the old
    one, and restarting the calibration.

    \section1 Calibration Class Definition

    The \c Calibration class inherits from QDialog, and is ...

    \quotefromfile qtopiacore/mousecalibration/calibration.h
    \skipto class Calibration
    \printuntil /^\};/

    We reimplement QDialog's \l {QDialog::exec()}{exec()} and \l
    {QWidget::accept()}{accept()} slots, and QWidget's \l
    {QWidget::paintEvent()}{paintEvent()} and \l
    {QWidget::mouseReleaseEvent()}{mouseReleaseEvent()} functions.

    In addition we declare a couple of private variables, \c data and
    \c pressCount, holding the \c Calibration object's number of mouse
    press events and current calibration data. The \c pressCount
    variable is used when..., while the calibration data, i.e. the
    device and screen coordinates, is stored in a
    QWSPointerCalibrationData object that is passed to the mouse
    handlerr. The QWSPointerCalibrationData class is simply a
    container for calibration data.

    \section1 Calibration Class Implementation

    In the constructor we first ensure that the Calibration dialog
    fills up the entire screen, has focus and will receive mouse
    events (by making the dialog modal):

    \quotefromfile qtopiacore/mousecalibration/calibration.cpp
    \skipto Calibration()
    \printuntil setModal(true)

    Then we initialize the QWSPointerCalibrationData::screenPoints
    array:

    \skipto width
    \printuntil Center

    This array must contain the actual screen coordinates of the
    logical positions "TopLeft", "BottomRight", etc. The \c qt_screen
    pointer is ...

    Since non-linearity is expected to increase on the edge of the
    screen, all points are kept 10 percent within the screen.

    \skipto pressCount
    \printuntil /^\}/

    Finally, we initialize the variable which keeps track of the number of
    mouse press events we have received.

    \skipto ~Calibration
    \printuntil /^\}/

    The destructor is trivial.

    \skipto exec()
    \printuntil /^\}/

    The reimplementation of the QDialog::exec() slot is called from
    the main program.

    First we clear the current calibration making the following mouse
    event delivered in raw device coordinates. Then we call the
    QWidget::grabMouse() function to make sure no mouse events are
    lost, and the QWidget::activateWindow() function making the
    top-level widget containing this dialog, the active window. After
    calling the QDialog::exec() base function, we call the
    QWidget::releaseMouse() function to release the mouse grab before
    the function returns.

    \skipto paintEvent
    \printuntil /^\}/

    In our reimplementation of the QWidget::paintEvent() function we simply
    draw a cross at the next point the user should press.

    \skipto mouseReleaseEvent
    \printuntil }

    We then reimplement the QWidget::mouseReleaseEvent() function,
    using the QMouseEvent object passed as parameter to find the
    coordinates the user pressed and update the
    QWSPointerCalibrationData::devPoints array. We continue by drawing
    the next cross, or close the dialog by calling the accept() slot
    if we have collected all the necessary samples.

    \skipto accept
    \printuntil }

    Our reimplementation of the QDialog::accept() slot simply activate
    the new calibration data, using Q_ASSERT to ensure that the number
    of required samples are present.

    \section1 ScribbleWidget Class Definition

    \quotefromfile qtopiacore/mousecalibration/scribblewidget.h
    \skipto class ScribbleWidget
    \printuntil /^\}/

    \section1 ScribbleWidget Class Implementation

    \quotefromfile qtopiacore/mousecalibration/scribblewidget.cpp
    \skipto ScribbleWidget
    \printuntil /^\}/
    \printuntil /^\}/
    \printuntil /^\}/
    \printuntil /^\}/
    \printuntil /^\}/
    \printuntil /^\}/
*/
