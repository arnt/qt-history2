/*!
    \example designer/containerextension
    \title Container Extension Example

    The Container Extension example shows how to create a custom
    multi-page plugin for Qt Designer using the
    QDesignerContainerExtension class.

    \image containerextension-example.png

    To provide a custom widget that can be used with \QD, we need to
    supply a self-contained implementation. In this example we use a
    custom multi-page widget designed to show the container extension
    feature.

    An extension is an object which modifies the behavior of \QD. The
    QDesignerContainerExtension enables \QD to manage and manipulate a
    custom multi-page widget, i.e. adding and deleting pages to the
    widget.

    There are four available types of extensions in \QD:

    \list
        \o QDesignerMemberSheetExtension  provides an extension that allows
           you to manipulate a widget's member functions which is displayed
           when configuring connections using Qt Designer's mode for editing
           signals and slots.
        \o QDesignerPropertySheetExtension provides an extension that
           allows you to manipulate a widget's properties which is displayed
           in Qt Designer's property editor.
        \o QDesignerTaskMenuExtension provides an extension that allows
           you to add custom menu entries to \QD's task menu.
        \o QDesignerContainerExtension provides an extension that allows
           you to add (and delete) pages to a multi-page container plugin
           in \QD.
    \endlist

    You can use all the extensions following the same pattern as in
    this example, only replacing the respective extension base
    class. For more information, see the \l {QtDesigner Module}.

    The Container Extension example consists of four classes:

    \list
    \o \c MultiPageWidget is a custom container widget that lets the user
       manipulate and populate its pages, and navigate among these
       using a combobox.
    \o \c MultiPageWidgetPlugin exposes the \c MultiPageWidget class
       to \QD.
    \o \c MultiPageWidgetExtensionFactory creates a
       \c MultiPageWidgetContainerExtension object.
    \o \c MultiPageWidgetContainerExtension provides the container
       extension.
    \endlist

    The project file for custom widget plugins needs some additional
    information to ensure that they will work within \QD. For example,
    custom widget plugins rely on components supplied with \QD, and
    this must be specified in the project file that we use. We will
    first take a look at the plugin's project file.

    Then we will continue by reviewing the \c MultiPageWidgetPlugin
    class, and take a look at the \c MultiPageWidgetExtensionFactory
    and \c MultiPageWidgetContainerExtension classes. Finally, we will
    take a quick look at the \c MultiPageWidget class definition.

    \section1 The Project File: containerextension.pro

    \quotefromfile designer/containerextension/containerextension.pro
    \printline TEMPLATE
    \printline CONFIG
    \printline DESTDIR

    The \c TEMPLATE variable's value makes \c qmake create the custom
    widget as a library. Later, we will ensure that the widget will be
    recognized as a plugin by Qt by using the Q_EXPORT_PLUGIN2() macro
    to export the relevant widget information.

    The \c CONFIG variable contains two values, \c designer and \c
    plugin:

    \list
        \o \c designer: Since custom widgets plugins rely on components
           supplied with \QD, this value ensures that our plugin link against
           \QD's library (\c libQtDesigner.so).

        \o \c plugin: We also need to ensure that \c qmake considers the
           custom widget a \e plugin library.
    \endlist

    When Qt is configured to build in both debug and release modes,
    \QD will be built in release mode.  When this occurs, it is
    necessary to ensure that plugins are also built in release
    mode. For that reason you might have to add a \c release value to
    your \c CONFIG variable. Otherwise, if a plugin is built in a mode
    that is incompatible with \QD, it won't be loaded and
    installed. For more information about plugins, see the \l {How to
    Create Qt Plugins} documentation.

    The \c DESTDIR variable's value makes \c qmake install the plugin
    alongside the other \QD widget plugins which is useful for testing
    purposes.

    \skipto HEADERS
    \printuntil multipagewidgetextensionfactory.cpp

    The header and source files for the widget are declared in the
    usual way, and in addition we provide an implementation of the
    plugin interface so that \QD can use the custom widget. In this
    particular example we also provide implementations of the
    container extension interface and the extension factory.

    \section1 MultiPageWidgetPlugin Class Definition

    The \c MultiPageWidgetPlugin class expose \c the MultiPageWidget class to
    \QD. Its definition is equivalent to the \l
    {designer/customwidgetplugin}{Custom Widget Plugin} example's
    plugin class which is explained in detail. The only part of the
    class definition that is specific to this particular custom widget
    is the class name:

    \quotefromfile designer/containerextension/multipagewidgetplugin.h
    \skipto #ifndef
    \printuntil #endif


    The plugin class provides \QD with basic information about our
    plugin, such as its class name and its include file. Furthermore
    it knows how to create instances of the \c MultiPageWidget widget.
    \c MultiPageWidgetPlugin also defines the \l
    {QDesignerCustomWidgetInterface::initialize()}{initialize()}
    function which is called after the plugin is loaded into \QD. The
    function's QDesignerFormEditorInterface parameter provides the
    plugin with a gateway to all of \QD's API's.

    The \c MultiPageWidgetPlugin class inherits from both QObject and
    QDesignerCustomWidgetInterface. It is important to remember, when
    using multiple inheritance, to ensure that all the interfaces
    (i.e. the classes that doesn't inherit Q_OBJECT) are made known to
    the meta object system using the Q_INTERFACES() macro. This
    enables \QD to use \l qobject_cast() to query for supported
    interfaces using nothing but a QObject pointer.

    \section1 MultiPageWidgetPlugin Class Implementation

    The MultiPageWidgetPlugin class implementation is in most parts
    equivalent to the \l {designer/customwidgetplugin}{Custom Widget
    Plugin} example's plugin class:

    \quotefromfile designer/containerextension/multipagewidgetplugin.cpp
    \skipto MultiPageWidgetPlugin
    \printto isContainer(

    \skipto createWidget(
    \printto initialize(

    \quotefromfile designer/containerextension/multipagewidgetplugin.cpp
    \skipto isContainer(
    \printto createWidget(

    One of the functions that differ is the isContainer() function
    which returns true in this example since our custom widget is
    intended to be used as a container. Note also the initialize()
    function:

    \skipto initialize(
    \printuntil return;

    The \c initialize() function takes a QDesignerFormEditorInterface
    object as argument.  The QDesignerFormEditorInterface class
    provides access to Qt Designer's components.

    In \QD you can create two kinds of plugins: custom widget plugins
    and tool plugins. QDesignerFormEditorInterface provides access to
    all the \QD components that you normally need to create a tool
    plugin: the extension manager, the object inspector, the property
    editor and the widget box. Custom widget plugins have access to
    the same components.

    \skipto manager
    \printuntil manager

    When creating extensions associated with custom widget plugins, we
    need to access \QD's current extension manager which we retrieve
    from the QDesignerFormEditorInterface parameter.

    \QD's QDesignerFormEditorInterface holds information about all Qt
    Designer's components: The action editor, the object inspector,
    the property editor, the widget box, and the extension and form
    window managers.

    The QExtensionManager class provides extension management
    facilities for \QD. Using \QD's current extension manager you can
    retrieve the extension for a given object. You can also register
    and unregister an extension for a given object. Remember that an
    extension is an object which modifies the behavior of \QD.

    When registrering an extension, it is actually the associated
    extension factory that is registered. In \QD, extension factories
    are used to look up and create named extensions as they are
    required. So, in this example, the container extension itself is
    not created until \QD must know whether the associated widget is a
    container, or not.

    \skipto factory
    \printuntil }

    We create a \c MultiPageWidgetExtensionFactory object that we
    register using \QD's current \l {QExtensionManager}{extension
    manager} retrieved from the QDesignerFormEditorInterface
    parameter. The first argument is the newly created factory and the
    second argument is an extension identifier which is a string. The
    \c Q_TYPEID() macro simply convert the string into a
    QLatin1String.

    The \c MultiPageWidgetExtensionFactory class is a subclass of
    QExtensionFactory. When \QD must know whether a widget is a
    container, or not, \QD's extension manager will run through all
    its registered factories invoking the first one which is able to
    create a container extension for that widget. This factory will in
    turn create a \c MultiPageWidgetExtension object.

    \skipto domXml
    \printuntil /^\}/

    Note also the \c domXml() function which include default settings
    for the widget in the standard XML format used by \QD. In this
    case, we specify the container's first page; any inital pages of a
    multi-page widget must be specified within this function.

    We have omitted to reimplement the
    QDesignerCustomWidgetInterface::codeTemplate() function which
    normally provide a sample code template for the custom widget.

    \printline Q_EXPORT_PLUGIN2

    Finally, we use the Q_EXPORT_PLUGIN2() macro to export the
    MultiPageWidgetPlugin class for use with Qt's plugin handling classes:
    This macro ensures that \QD can access and construct the custom
    widget. Without this macro, there is no way for \QD to use the
    widget.

    \section1 MultiPageWidgetExtensionFactory Class Definition

    The \c MultiPageWidgetExtensionFactory class inherits QExtensionFactory
    which provides a standard extension factory for \QD.

    \quotefromfile designer/containerextension/multipagewidgetextensionfactory.h
    \skipto class MultiPageWidgetExtensionFactory
    \printuntil /^\};/

    The subclass's purpose is to reimplement the
    QExtensionFactory::createExtension() function, making it able to
    create a \c MultiPageWidget container extension.


    \section1 MultiPageWidgetExtensionFactory Class Implementation

    The class constructor simply calls the QExtensionFactory base
    class constructor:

    \quotefromfile designer/containerextension/multipagewidgetextensionfactory.cpp
    \skipto MultiPageWidgetExtensionFactory
    \printuntil {}

    As described above, the factory is invoked when \QD must know
    whether the associated widget is a container, or not.

    \skipto createExtension
    \printuntil /^\}/

    \QD's behavior is the same whether the requested extension is
    associated with a container, a member sheet, a property sheet or a
    task menu: Its extension manager runs through all its registered
    extension factories calling \c createExtension() for each until
    one responds by creating the requested extension.

    So the first thing we do in \c
    MultiPageWidgetExtensionFactory::createExtension() is to check if
    the QObject, for which the extension is requested, is in fact a \c
    MultiPageWidget object. Then we check if the requested extension
    is a container extension.

    If the object is a MultiPageWidget requesting a container
    extension, we create and return a \c MultiPageWidgetExtension
    object. Otherwise, we simply return a null pointer, allowing \QD's
    extension manager to continue its search through the registered
    factories.


    \section1 MultiPageWidgetContainerExtension Class Definition

    The \c MultiPageWidgetContainerExtension class inherits
    QDesignerContainerExtension which allows you to add (and delete)
    pages to a multi-page container plugin in \QD.

    \quotefromfile designer/containerextension/multipagewidgetcontainerextension.h
    \skipto class MultiPageWidgetContainerExtension
    \printuntil /^\}/

    It is important to recognize that the QDesignerContainerExtension
    class only is intended to provide \QD access to your custom
    multi-page widget's functionality; your custom multi-page widget
    must implement functionality corresponding to the extension's
    functions.

    Note also that we implement a constructor that takes \e two
    arguments: the parent widget, and the \c MultiPageWidget object
    for which the task menu is requested.

    QDesignerContainerExtension provides a couple of menu entries in
    \QD's task menu by default, enabling the user to add or delete
    pages to the associated custom multi-page widget in \QD's
    workspace.

    \section1 MultiPageWidgetContainerExtension Class Implementation

    In the constructor we save the reference to the \c MultiPageWidget
    object sent as parameter, i.e the widget associated with the
    extension. We will need this later to access the custom multi-page
    widget performing the requested actions.

    \quotefromfile designer/containerextension/multipagewidgetcontainerextension.cpp
    \skipto MultiPageWidgetContainerExtension
    \printuntil /^\}/

    To fully enable \QD to manage and manipulate your custom
    multi-page widget, you must reimplement all the functions of
    QDesignerContainerExtension:

    \skipto addWidget(QWidget *widget)
    \printuntil /^\}/

    \skipto count()
    \printuntil /^\}/

    \skipto currentIndex()
    \printuntil /^\}/

    You must reimplement \l
    {QDesignerContainerExtension::addWidget()}{addWidget()} adding a
    given page to the container, \l
    {QDesignerContainerExtension::count()}{count()} returning the
    number of pages in the container, and \l
    {QDesignerContainerExtension::currentIndex()}{currentIndex()}
    returning the index of the currently selected page.

    \skipto insertWidget(int index, QWidget *widget)
    \printuntil /^\}/

    \skipto remove(int index)
    \printuntil /^\}/

    \skipto setCurrentIndex(int index)
    \printuntil /^\}/

    \skipto widget(int index)
    \printuntil /^\}/

    You must reimplement \l
    {QDesignerContainerExtension::insertWidget()}{insertWidget()}
    adding a given page to the container at a given index, \l
    {QDesignerContainerExtension::remove()}{remove()} deleting the
    page at a given index, \l
    {QDesignerContainerExtension::setCurrentIndex()}{setCurrentIndex()}
    setting the index of the currently selected page, and finally \l
    {QDesignerContainerExtension::widget()}{widget()} returning the
    page at a given index.

    \section1 MultiPageWidget Class Definition

    The MultiPageWidget class is a custom container widget that lets
    the user manipulate and populate its pages, and navigate among
    these using a combobox.

    \quotefromfile designer/containerextension/multipagewidget.h
    \skipto class MultiPageWidget
    \printuntil /^\};/

    The main detail to observe is that your custom multi-page widget
    must implement functionality corresponding to the
    QDesignerContainerExtension's member functions since the
    QDesignerContainerExtension class only is intended to provide Qt
    Designer access to your custom multi-page widget's functionality.

    In addition, we declare the \c currentIndex and \c pageTitle
    properties, and their associated set and get functions. By
    declaring these attributes as properties, we allow \QD to manage
    them in the same way it manages the properties the MultiPageWidget
    widget inherits from QWidget and QObject, for example featuring
    the property editor.
*/
