/*!
    \example designer/containerextension
    \title Container Extension Example

    The Container Extension example shows how to create a custom
    multi-page plugin for Qt Designer using the
    QDesignerContainerExtension class.

    \image containerextension-example.png

    To provide a custom widget that can be used with \QD, we need to
    supply a self-contained implementation. In this example we use a
    custom multi-page widget designed to show the container extension
    feature.

    An extension is an object which modifies the behavior of \QD. The
    QDesignerContainerExtension enables \QD to manage and manipulate a
    custom multi-page widget, i.e. adding and deleting pages to the
    widget.

    There are four available types of extensions in \QD:

    \list
        \o QDesignerMemberSheetExtension  provides an extension that allows
           you to manipulate a widget's member functions which is displayed
           when configuring connections using Qt Designer's mode for editing
           signals and slots.
        \o QDesignerPropertySheetExtension provides an extension that
           allows you to manipulate a widget's properties which is displayed
           in Qt Designer's property editor.
        \o QDesignerTaskMenuExtension provides an extension that allows
           you to add custom menu entries to \QD's task menu.
        \o QDesignerContainerExtension provides an extension that allows
           you to add (and delete) pages to a multi-page container plugin
           in \QD.
    \endlist

    You can use all the extensions following the same pattern as in
    this example, only replacing the respective extension base
    class. For more information, see the \l {QtDesigner Module}.

    The Container Extension example consists of four classes:

    \list
    \o \c MultiPageWidget is a custom container widget that lets the user
       manipulate and populate its pages, and navigate among these
       using a combobox.
    \o \c MultiPageWidgetPlugin exposes the \c MultiPageWidget class
       to \QD.
    \o \c MultiPageWidgetExtensionFactory creates a
       \c MultiPageWidgetContainerExtension object.
    \o \c MultiPageWidgetContainerExtension provides the container
       extension.
    \endlist

    The project file for custom widget plugins needs some additional
    information to ensure that they will work within \QD. For example,
    custom widget plugins rely on components supplied with \QD, and
    this must be specified in the project file that we use. We will
    first take a look at the plugin's project file.

    Then we will continue by reviewing the \c MultiPageWidgetPlugin
    class, and take a look at the \c MultiPageWidgetExtensionFactory
    and \c MultiPageWidgetContainerExtension classes. Finally, we will
    take a quick look at the \c MultiPageWidget class definition.

    \section1 The Project File: containerextension.pro

    \quotefromfile designer/containerextension/containerextension.pro
    \printline TEMPLATE
    \printline CONFIG

    The \c TEMPLATE variable's value makes \c qmake create the custom
    widget as a library. Later, we will ensure that the widget will be
    recognized as a plugin by Qt by using the Q_EXPORT_PLUGIN2() macro
    to export the relevant widget information.

    The \c CONFIG variable contains two values, \c designer and \c
    plugin:

    \list
        \o \c designer: Since custom widgets plugins rely on components
           supplied with \QD, this value ensures that our plugin link against
           \QD's library (\c libQtDesigner.so).

        \o \c plugin: We also need to ensure that \c qmake considers the
           custom widget a \e plugin library.
    \endlist

    When Qt is configured to build in both debug and release modes,
    \QD will be built in release mode.  When this occurs, it is
    necessary to ensure that plugins are also built in release
    mode. For that reason we add a \c debug_and_release value to
    the \c CONFIG variable. Otherwise, if a plugin is built in a mode
    that is incompatible with \QD, it won't be loaded and
    installed. For more information about plugins, see the \l {How to
    Create Qt Plugins} documentation.

    \skipto HEADERS
    \printuntil multipagewidgetextensionfactory.cpp

    The header and source files for the widget are declared in the
    usual way, and in addition we provide an implementation of the
    plugin interface so that \QD can use the custom widget. In this
    particular example we also provide implementations of the
    container extension interface and the extension factory.

    It is important to ensure that the plugin is installed in a location that
    is searched by \QD. We do this by specifying a target path for the project
    and adding it to the list of items to install:

    \code
        target.path = $$[QT_INSTALL_PLUGINS]/designer
        INSTALLS += target
    \endcode

    The container extension is created as a library, and will be installed
    alongside the other \QD plugins when the project is installed (using
    \c{make install} or an equivalent installation procedure).

    Note that if you want the plugins to appear in a Visual Studio
    integration, the plugins must be built in release mode and their
    libraries must be copied into the plugin directory in the install
    path of the integration (for an example, see C:/program
    files/trolltech as/visual studio integration/plugins).

    \section1 MultiPageWidgetPlugin Class Definition

    The \c MultiPageWidgetPlugin class expose \c the MultiPageWidget class to
    \QD. Its definition is equivalent to the \l
    {designer/customwidgetplugin}{Custom Widget Plugin} example's
    plugin class which is explained in detail. The only part of the
    class definition that is specific to this particular custom widget
    is the class name:

    \quotefromfile designer/containerextension/multipagewidgetplugin.h
    \skipto #ifndef
    \printuntil #endif

    The plugin class provides \QD with basic information about our
    plugin, such as its class name and its include file. Furthermore
    it knows how to create instances of the \c MultiPageWidget widget.
    \c MultiPageWidgetPlugin also defines the \l
    {QDesignerCustomWidgetInterface::initialize()}{initialize()}
    function which is called after the plugin is loaded into \QD. The
    function's QDesignerFormEditorInterface parameter provides the
    plugin with a gateway to all of \QD's API's.

    In case of a multipage widget such as ours, we must also implement
    two private slots: currentIndexChanged() and
    pageTitleChanged(). These are required to update \QD's property
    editor whenever the user views another page or changes one of the
    page titles.

    The \c MultiPageWidgetPlugin class inherits from both QObject and
    QDesignerCustomWidgetInterface. It is important to remember, when
    using multiple inheritance, to ensure that all the interfaces
    (i.e. the classes that doesn't inherit Q_OBJECT) are made known to
    the meta object system using the Q_INTERFACES() macro. This
    enables \QD to use \l qobject_cast() to query for supported
    interfaces using nothing but a QObject pointer.

    \section1 MultiPageWidgetPlugin Class Implementation

    The MultiPageWidgetPlugin class implementation is in most parts
    equivalent to the \l {designer/customwidgetplugin}{Custom Widget
    Plugin} example's plugin class:

    \quotefromfile designer/containerextension/multipagewidgetplugin.cpp
    \skipto MultiPageWidgetPlugin
    \printto isContainer(

    \skipto isInitialized
    \printuntil /^\}/

    One of the functions that differ is the isContainer() function
    which returns true in this example since our custom widget is
    intended to be used as a container.

    \quotefromfile designer/containerextension/multipagewidgetplugin.cpp
    \skipto isContainer(
    \printto createWidget(

    Another function that differ is the function creating our custom widget:

    \skipto createWidget
    \printto isInitialized

    In addition to actually creating the widget, we connect the
    widget's currentIndexChanged() signal to the plugin's
    currentIndexChanged() slot to update \QD's property editor. We
    also connect the widget's pageTitleChanged() signal to the
    plugin's pageTitleChanged() slot.

    So the currentIndexChanged() slot is called whenever our custom
    widget's currentIndexChanged() \e signal is emitted, i.e. whenever
    the user views another page:

    \skipto currentIndexChanged
    \printuntil sender

    First, we retrieve the object emitting the signal using the
    QObject::sender() and qobject_cast() functions. If called in a
    slot activated by a signal, QObject::sender() returns a pointer to
    the object that sent the signal; otherwise it returns 0.

    \skipto if (widget)
    \printuntil /^\}/

    Then we need to update the property editor; we use the static
    QDesignerFormWindowInterface::findFormWindow() function to
    retrieve the QDesignerFormWindowInterface object containg the
    widget and emit its \l
    {QDesignerFormWindowInterface::emitSelectionChanged()}{emitSelectionChanged()}
    signal, forcing an update of the property editor.

    \skipto pageTitleChanged
    \printuntil sender

    The pageTitleChanged() slot is called whenever our custom widget's
    pageTitleChanged() \e signal is emitted. Again we first retrieve
    the object emitting the signal using the QObject::sender() and
    qobject_cast() functions. Then we need to update the property editor:

    \skipto if (widget)
    \printuntil findFormWindow

    We retrieve the new current page from the widget that emitted the
    signal, and again we use the static
    QDesignerFormWindowInterface::findFormWindow() function to
    retrieve the form containing the widget.

    \skipto editor
    \printuntil manager

    Then we use the QDesignerFormWindowInterface::core() function to
    get hold of the current QDesignerFormEditorInterface object. The
    QDesignerFormEditorInterface class allows you to access Qt
    Designer's various components; a reference to \QD's extension
    manager can be obtained using the
    QDesignerFormEditorInterface::extensionManager() function.

    \skipto sheet
    \printuntil /^\}/

    Once we have the extension manager we can retrieve the current
    QDesignerPropertySheetExtension object. \QD uses the
    QDesignerPropertySheetExtension class to feed its property
    editor. Whenever a widget is selected in its workspace, \QD will
    query for the widget's property sheet extension. By calling the
    the QDesignerPropertySheetExtension::setChanged() function, we
    implicitly force an update of the property editor.

    propertyIndex vs windowTitle

    \quotefromfile designer/containerextension/multipagewidgetplugin.cpp
    \skipto initialize(
    \printuntil return;

    Note also the initialize() function: The \c initialize() function
    takes a QDesignerFormEditorInterface object as argument. The
    QDesignerFormEditorInterface class provides access to Qt
    Designer's components.

    In \QD you can create two kinds of plugins: custom widget plugins
    and tool plugins. QDesignerFormEditorInterface provides access to
    all the \QD components that you normally need to create a tool
    plugin: the extension manager, the object inspector, the property
    editor and the widget box. Custom widget plugins have access to
    the same components.

    \skipto manager
    \printuntil manager

    When creating extensions associated with custom widget plugins, we
    need to access \QD's current extension manager which we retrieve
    from the QDesignerFormEditorInterface parameter.

    \QD's QDesignerFormEditorInterface holds information about all Qt
    Designer's components: The action editor, the object inspector,
    the property editor, the widget box, and the extension and form
    window managers.

    The QExtensionManager class provides extension management
    facilities for \QD. Using \QD's current extension manager you can
    retrieve the extension for a given object. You can also register
    and unregister an extension for a given object. Remember that an
    extension is an object which modifies the behavior of \QD.

    When registrering an extension, it is actually the associated
    extension factory that is registered. In \QD, extension factories
    are used to look up and create named extensions as they are
    required. So, in this example, the container extension itself is
    not created until \QD must know whether the associated widget is a
    container, or not.

    \skipto factory
    \printuntil }

    We create a \c MultiPageWidgetExtensionFactory object that we
    register using \QD's current \l {QExtensionManager}{extension
    manager} retrieved from the QDesignerFormEditorInterface
    parameter. The first argument is the newly created factory and the
    second argument is an extension identifier which is a string. The
    \c Q_TYPEID() macro simply convert the string into a
    QLatin1String.

    The \c MultiPageWidgetExtensionFactory class is a subclass of
    QExtensionFactory. When \QD must know whether a widget is a
    container, or not, \QD's extension manager will run through all
    its registered factories invoking the first one which is able to
    create a container extension for that widget. This factory will in
    turn create a \c MultiPageWidgetExtension object.

    \skipto domXml
    \printuntil /^\}/

    Finally, take a look at the \c domXml() function. This function
    includes default settings for the widget in the standard XML
    format used by \QD. In this case, we specify the container's first
    page; any inital pages of a multi-page widget must be specified
    within this function.

    \skipto Q_EXPORT_PLUGIN2
    \printline Q_EXPORT_PLUGIN2

    Remember also to use the Q_EXPORT_PLUGIN2() macro to export the
    MultiPageWidgetPlugin class for use with Qt's plugin handling
    classes: This macro ensures that \QD can access and construct the
    custom widget. Without this macro, there is no way for \QD to use
    the widget.

    \section1 MultiPageWidgetExtensionFactory Class Definition

    The \c MultiPageWidgetExtensionFactory class inherits QExtensionFactory
    which provides a standard extension factory for \QD.

    \quotefromfile designer/containerextension/multipagewidgetextensionfactory.h
    \skipto class MultiPageWidgetExtensionFactory
    \printuntil /^\};/

    The subclass's purpose is to reimplement the
    QExtensionFactory::createExtension() function, making it able to
    create a \c MultiPageWidget container extension.


    \section1 MultiPageWidgetExtensionFactory Class Implementation

    The class constructor simply calls the QExtensionFactory base
    class constructor:

    \quotefromfile designer/containerextension/multipagewidgetextensionfactory.cpp
    \skipto MultiPageWidgetExtensionFactory
    \printuntil {}

    As described above, the factory is invoked when \QD must know
    whether the associated widget is a container, or not.

    \skipto createExtension
    \printuntil /^\}/

    \QD's behavior is the same whether the requested extension is
    associated with a container, a member sheet, a property sheet or a
    task menu: Its extension manager runs through all its registered
    extension factories calling \c createExtension() for each until
    one responds by creating the requested extension.

    So the first thing we do in \c
    MultiPageWidgetExtensionFactory::createExtension() is to check if
    the QObject, for which the extension is requested, is in fact a \c
    MultiPageWidget object. Then we check if the requested extension
    is a container extension.

    If the object is a MultiPageWidget requesting a container
    extension, we create and return a \c MultiPageWidgetExtension
    object. Otherwise, we simply return a null pointer, allowing \QD's
    extension manager to continue its search through the registered
    factories.


    \section1 MultiPageWidgetContainerExtension Class Definition

    The \c MultiPageWidgetContainerExtension class inherits
    QDesignerContainerExtension which allows you to add (and delete)
    pages to a multi-page container plugin in \QD.

    \quotefromfile designer/containerextension/multipagewidgetcontainerextension.h
    \skipto class MultiPageWidgetContainerExtension
    \printuntil /^\}/

    It is important to recognize that the QDesignerContainerExtension
    class only is intended to provide \QD access to your custom
    multi-page widget's functionality; your custom multi-page widget
    must implement functionality corresponding to the extension's
    functions.

    Note also that we implement a constructor that takes \e two
    arguments: the parent widget, and the \c MultiPageWidget object
    for which the task menu is requested.

    QDesignerContainerExtension provides a couple of menu entries in
    \QD's task menu by default, enabling the user to add or delete
    pages to the associated custom multi-page widget in \QD's
    workspace.

    \section1 MultiPageWidgetContainerExtension Class Implementation

    In the constructor we save the reference to the \c MultiPageWidget
    object sent as parameter, i.e the widget associated with the
    extension. We will need this later to access the custom multi-page
    widget performing the requested actions.

    \quotefromfile designer/containerextension/multipagewidgetcontainerextension.cpp
    \skipto MultiPageWidgetContainerExtension
    \printuntil /^\}/

    To fully enable \QD to manage and manipulate your custom
    multi-page widget, you must reimplement all the functions of
    QDesignerContainerExtension:

    \skipto addWidget(QWidget *widget)
    \printuntil /^\}/

    \skipto count()
    \printuntil /^\}/

    \skipto currentIndex()
    \printuntil /^\}/

    You must reimplement \l
    {QDesignerContainerExtension::addWidget()}{addWidget()} adding a
    given page to the container, \l
    {QDesignerContainerExtension::count()}{count()} returning the
    number of pages in the container, and \l
    {QDesignerContainerExtension::currentIndex()}{currentIndex()}
    returning the index of the currently selected page.

    \skipto insertWidget(int index, QWidget *widget)
    \printuntil /^\}/

    \skipto remove(int index)
    \printuntil /^\}/

    \skipto setCurrentIndex(int index)
    \printuntil /^\}/

    \skipto widget(int index)
    \printuntil /^\}/

    You must reimplement \l
    {QDesignerContainerExtension::insertWidget()}{insertWidget()}
    adding a given page to the container at a given index, \l
    {QDesignerContainerExtension::remove()}{remove()} deleting the
    page at a given index, \l
    {QDesignerContainerExtension::setCurrentIndex()}{setCurrentIndex()}
    setting the index of the currently selected page, and finally \l
    {QDesignerContainerExtension::widget()}{widget()} returning the
    page at a given index.

    \section1 MultiPageWidget Class Definition

    The MultiPageWidget class is a custom container widget that lets
    the user manipulate and populate its pages, and navigate among
    these using a combobox.

    \quotefromfile designer/containerextension/multipagewidget.h
    \skipto class MultiPageWidget
    \printuntil /^\};/

    The main detail to observe is that your custom multi-page widget
    must implement functionality corresponding to the
    QDesignerContainerExtension's member functions since the
    QDesignerContainerExtension class only is intended to provide Qt
    Designer access to your custom multi-page widget's functionality.

    In addition, we declare the \c currentIndex and \c pageTitle
    properties, and their associated set and get functions. By
    declaring these attributes as properties, we allow \QD to manage
    them in the same way it manages the properties the MultiPageWidget
    widget inherits from QWidget and QObject, for example featuring
    the property editor.

    Note the \c STORED attribute in the declaration of the \a
    pageTitle property: This attribute indicates persistence, ie.e \c
    STORED declares whether the property's value must be remembered
    when storing an object's state, and only makes sense for writable
    properties.  Technically superfluous properties define this to be
    false; the default value is true.

    We must also implement and emit the currentIndexChanged() and
    pageTitleChanged() signals to ensure that \QD's property editor is
    updated whenever the user views another page or changes one of the
    page titles.
*/
