/*!
    \example qtopiacore/ahigl
    \title OpenGL for Embedded Systems Example

    The OpenGL for Embedded Systems (ES) screen driver example shows
    how to use the \l {Graphics Driver Framework} in \l {Qtopia Core}
    to write an OpenGL ES integration. The example assumes basic
    knowledge of the graphics driver framework as discussed in the \l
    {Accelerated Screen Driver Example}.

    In \l {Qtopia Core}, OpenGL ES can be used in different ways. It
    can be used to compose displays of overlapping top-level windows,
    where the top-most window is not opaque but allows features of the
    underlying windows to show through. Or it can be used to animate a
    transition from an existing window to a newly created one. A third
    use is to access hardware features of your device to accelerate
    widget painting, and a fourth use is simply to enable access to
    class QGLWidget. This example shows how to implement all of these.

    The example uses an OpenGL ES implementation from 
    \l {http://ati.amd.com}{ATI} for the 
    \l {http://ati.amd.com/products/imageon238x/}{Imageon 2380}. The
    OpenGL ES and EGL libraries are required for compiling and linking
    the example. If your target device is different, you must supply
    the corresponding libraries for that device, and you also might 
    have to modify the example source code to match any API signature 
    differences in your EGL library.

    After compiling the example source, install the resulting screen
    driver plugin with the command \c {make install}. To start an
    application using the example's screen driver, either set the
    environment variable \l QWS_DISPLAY and then start the program, or
    start the program using the \c -display switch:

    \code
        myApplication -qws -display ahigl
    \endcode

    To enable the window transition effect when showing new windows,
    run the application with \c {-display ahigl:effects}.

    \section1 QAhiGLScreen Class Definition

    The example screen driver class is called QAhiGLScreen. "Ahi"
    stands for ATI Handheld Interface. The class can be used as the
    screen driver for other ATI handheld devices. 

    \quotefromfile qtopiacore/ahigl/qscreenahigl_qws.h
    \skipto class QAhiGLScreen :
    \printuntil };

    The screen driver class is derived from class QGLScreen, which is
    itself derived from class QScreen. If you will only use OpenGL ES
    for composing displays of top-level windows, you can create a
    screen driver class by deriving from QScreen directly. Otherwise
    your screen driver class must be derived from QGLScreen.

    Note that class QGLScreen is not included in the Qt documentation.
    The design of QGLScreen is still preliminary, so it is not yet
    included in the published Qt API. Class QScreen, however, is in
    the published API and is included in the Qt documentation.

    QAhiGLScreen's reimplementation of \l {QScreen::}{exposeRegion()}
    is the function that does the composition and display of
    windows. The QAhiGLScreen private functions updateTexture(),
    redrawScreen(), and drawWindow() are helper functions for
    composing and displaying windows. The private functions
    drawQuad(), drawQuadInverseY(), and drawQuadWavyFlag() are used
    for creating the transition effect displaying a new window or
    reshowing a window that was mninimized.

    The only data member in class QAhiGLScreen is the standard pointer
    to a private implementation class QAhiGLScreenPrivate, where the 
    screen driver's internal state variables are held. These variables
    contain the data used for composing displays.

    \quotefromfile qtopiacore/ahigl/qscreenahigl_qws.cpp
    \skipto class QAhiGLScreenPrivate
    \printuntil /^\}/

    Class QAhiGLScreenPrivate is derived from QObject so it can use
    the Qt signal/slot mechanism to receive the window server's 
    \l {QWSServer::windowEvent()} {window event signal} at its
    \c QAhiGLScreenPrivate::windowEvent() slot. If the value of data 
    member \c doEffects is true, this slot performs the transition
    effect animation, whenever a new window is first shown, or when 
    it is reshown after having been minimized. Note that \c doEffects
    can be set to true at screen driver startup time by including the
    \c {-display ahigl:effects} option on the command line.

    To control animation of the window transition effect, an instance
    of class ShowAnimation is created by the 
    \c QAhiGLScreenPrivate::windowEvent() slot, when a 
    \l {QWSServer::WindowEvent} {Show window event} is emitted by the
    \l {QWSServer} {window server}. This happens when a window is 
    first created and when it is reshown after having been minimized.

    \skipto class ShowAnimation
    \printuntil /^\}/

    Class ShowAnimation is derived from the QTimeLine class for
    controlling animations. The \c ShowAnimation() constructor
    initializes the timeline, connecting its 
    \l {QTimeLine::valueChanged()} {valueChanged()} signal to the 
    screen driver's \c QAhiGLScreen::redrawScreen() slot, and 
    connecting its \l {QTimeLine::finished()} {finished()} signal
    to the QObject::deleteLater() slot. Finally, the constructor
    tells the timeline to \l {QTimeLine::start()} {start} the 
    animation. ShowAnimation reimplements the 
    \l {QTimeLine::}{valueForTime()} function, which returns a 
    value used for customizing the shape of the curve used for
    the transition effect.

    \skipto struct WindowInfo
    \printuntil windowMap;

    Top-level windows that are not drawn using OpenGL are rendered the
    normal way into a shared memory segment. The driver supports this
    by creating a GL texture of the memory segment and drawing it to
    the screen. The \c texture identifier and a pointer to the active
    \c animation are held in an instance of \c struct \c WindowInfo.
    The instances of WindowInfo are held in a global map, \c windowMap.

    \section1 QAhiGLScreen Class Implementation

    The \l {QScreen::}{connect()} function is the first function that
    is called after the constructor returns. This implementation just
    initializes the QScreen variables to some hardcoded values. A better
    implementation would query the hardware for it's current state.

    At the end of the function we check if the driver has been started with
    the \c effects argument which should trigger use of transition effects.

    \quotefromfile qtopiacore/ahigl/qscreenahigl_qws.cpp
    \skipto QAhiGLScreen::connect
    \printuntil /^\}/

    The \l {QScreen::}{initDevice()} function is called on the server process
    and is responsible for initializing the hardware. This implementation
    use the EGL library to achieve this. Note that some of the data structures
    used in this API are specific to the current EGL implementation, as for
    instance the DummyScreen structure.

    In this function we also connects to the QWSServer::windowEvent() signal
    if the transition effect is to be enabled.

    \skipto initDevice
    \printuntil /^\}/

    Before the application exists, the {QScreen::}{shutdownDevice()} is called
    in the server process to release the hardware resources. This 
    implementation again use the EGL library to achieve this.

    \skipto shutdownDevice
    \printuntil /^\}/

    Whenever an area on the screen needs to be updated the function 
    \l {QScreen::}{exposeRegion()} is called by the window system. This
    implementation doesn't actually redraw the screen, but starts a timer
    to redraw at a later time.

    \skipto exposeRegion
    \printuntil /^\}/

    We won't go through the \c updateTexture() function but only mention that
    it uses the EGL functions \c glTexImage2D() and \c glTexSubImage2D()
    to copy the memory image of the widget into a OpenGL texture if
    necessary.

    The actual window compositioning happens in the redrawScreen() function.
    It starts by using standard OpenGL to fill the screen with the background
    color.

    \quotefromfile qtopiacore/ahigl/qscreenahigl_qws.cpp
    \skipto void QAhiGLScreen::redrawScreen()
    \printuntil glClear(GL_COLOR_BUFFER_BIT);

    Next it iterates over all the windows and use the helper function
    \c drawWindow() to draw each of them as a OpenGL texture to the screen.
    The texture id is either taken from the \c WindowInfo struct or from the
    window surface if it is a surface that's being painted using OpenGL, i.e
    a \c QAhiGLWindowSurface. We'll discuss this class shortly.

    \c drawWindow() takes a \c progress parameter that is used to create an
    animation effect if it's less than 1.0. We won't discuss the 
    \c drawWindow() function any further in this text, but point to the source
    code for more details.

    \skipto QAhiGLScreen::createSurface
    \printuntil /^\}/
    \skipto QAhiGLScreen::createSurface
    \printuntil /^\}/

    The two \l {QScreen::}{createSurface()} functions decides when  
    instantiate a QAhiGLWindowSurface. We do this whenever we create a
    QGLWidget and also for top-level windows that are under a certain size.
    The size contraint is a necessary for this particular OpenGL ES 
    implementation. Additionly this driver only supports use of
    OpenGL in the server process.

    \section1 QAhiGLWindowSurface Class Definition

    To be able to support QGlWidget or use of OpenGL when using QPainter on
    a normal widget we need to create a subclass of QWSGLWindowSurface. In
    addition to reimplementing the standard functionality needed when 
    subclassing a QWSWindowSurface, the QAhiGLWindowSurface also contains
    the \c textureId() function used by QAhiGLScreen.

    \quotefromfile qtopiacore/ahigl/qwindowsurface_ahigl_p.h
    \skipto class QAhiGLWindowSurface
    \printuntil /^\}/

    \section1 QAhiGLWindowSurface Class Implementation

    The implementation of OpenGL ES tested with this example only supports
    one OpenGL context. This context is therefore shared between QAhiGLScreen
    and all instances QAhiGLWindowSurface and passed in the constructor.

    \quotefromfile qtopiacore/ahigl/qwindowsurface_ahigl.cpp
    \skipto QAhiGLWindowSurface::QAhiGLWindowSurface
    \printuntil /^\}/

    The constructor also creates an instance of \c QWSGLPaintDevice which is 
    returned in the \l {QWSWindowSurface::}{paintDevice()} function. This
    ensures that all \l {QPainter}s used on this surface will use an
    OpenGL enabled QPaintEngine.

    This example makes use of the OpenGL FrameBufferObject extension. All 
    painting is performed into a framebuffer object which is later
    compositioned onto the screen by QAhiGLScreen. Allocateding the framebuffer
    object is done in \l {QWindowSurface::}{setGeometry()}.

    \skipto QAhiGLWindowSurface::setGeometry
    \printuntil /^\}/

    Since there can be several instances of the QAhiGLWindowSurface, we need
    to make sure that the correct framebuffer object is active before painting.
    This is done by reimplementing \l QWindowSurface::beginPaint():

    \skipto QAhiGLWindowSurface::beginPaint
    \printuntil /^\}/

    Finally we need to make sure that whenever a widget grows beyond the size
    supported by this driver (256 x 256), the surface is deleted and a new
    standard surface is created instead. This is handled by reimplementing
    \l QWSWindowSurface::isValid():    

    \skipto QAhiGLWindowSurface::isValid
    \printuntil /^\}/
*/
