/*!
    \example qtopiacore/ahigl
    \title OpenGL for Embedded Systems Example

    This example demonstrates how you can use OpenGL for Embedded
    Systems (ES) to create your own graphics driver and \l {add your
    graphics driver to Qtopia Core}. In \l {Qtopia Core}, painting is
    a pure software implementation and is normally performed in two
    steps: The clients render each window onto a corresponding surface
    (stored in memory) using a paint engine, and then the server uses
    the graphics driver to compose the surface images and copy them to
    the screen. (See the \l {Qtopia Core Architecture} documentation
    for details.)

    This example is not for the novice. It assumes the reader is
    knowledgeable about both OpenGL ES and the graphics driver
    framework demonstrated in the \l {Accelerated Graphics Driver
    Example}.

    When designing an OpenGL graphics driver for Qtopia Core, the
    programmer can use OpenGL ES in three ways. First, the 
    \l {QWSServer} {Qtopia Core server} can use the graphics driver 
    to create a composition of multiple window images and copy that
    composition to the screen. Second, clients can use the graphics
    driver to accelerate OpenGL painting operations using the
    QOpenGLPaintEngine class. Finally, clients can use the graphics
    driver to do OpenGL operations in the QGLWidget class. This
    example implements all three cases.

    The example uses an implementation of OpenGL ES from 
    \l {http://ati.amd.com}{ATI} for the 
    \l {http://ati.amd.com/products/imageon238x/}{Imageon 2380}. The
    OpenGL ES and EGL libraries are required for compiling and linking
    the example. If your target device is different, you must supply
    the corresponding libraries for that device, and you also might 
    have to modify the example source code to account for differences
    in API signatures between your EGL library and the one used here.

    To run the example, after compiling the example source, install
    the compiled screen driver plugin with the command \c {make
    install}. Then, to start an application that you want to use the 
    plugin, either set the environment variable \l QWS_DISPLAY and 
    then start the application, or just start the application with 
    the \c -display switch:

    \code
        myApplication -qws -display ahigl
    \endcode

    The example graphics driver includes an animated transition effect
    for showing new windows. To enable this transition effect, run the 
    application with \c {-display ahigl:effects}.

    \section1 Graphics Driver Class Definition

    The example's graphics driver class is called QAhiGLScreen. "Ahi"
    stands for ATI Handheld Interface. The class can also be used as
    the graphics driver for other ATI handheld devices.

    \quotefromfile qtopiacore/ahigl/qscreenahigl_qws.h
    \skipto class QAhiGLScreen :
    \printuntil };

    The graphics driver class is derived from class QGLScreen, which
    in turn is derived from class QScreen. If your graphics driver
    will only be used to create compositions of window images in the
    Qtopia Core server and copy the compositions to the screen, then
    you can derive your graphics driver class directly from QScreen.
    But if your graphics driver will be used by clients to accelerate
    graphics rendering operations with the QOpenGLPaintEngine, or if
    clients will use it to access class QGLWidget, then your graphics
    driver class must be derived from QGLScreen.

    Note that class QScreen is documented in the published API, but
    class QGLScreen is not, because the design of class QGLScreen is
    still preliminary.

    All the public functions in our example graphics driver class
    QAhiGLScreen are reimplementations of virtual functions declared
    in either QScreen or QGLScreen. Function hasOpenGL() comes from
    QGLScreen. All the others come from QScreen.

    The reimplementation of \l {QScreen::}{exposeRegion()} is called
    by the Qtopia Core server, whenever a screen update is required.
    Its parameters are the region on the screen to be updated and the
    index of the client window to be updated. 

    Two reimplementations of \l {QScreen::}{createSurface()} are
    provided for creating new window surfaces. One is called on the
    client side to create the window surface for a new window, and the
    other is called on the server side to create the server's copy.
    These window surfaces will be separate objects, but they will
    communicate through shared memory. The overloading that has a
    QWidget parameter is the one called on the client side. The
    overloading that has the string key parameter is the one called 
    on the server side.

    The reimplementation of \l {QScreen::}{setMode()} would normally
    be used to reset the frame buffer's resolution, but it is only a
    stubb in this example. The parameters are the \e width, \e height,
    and the bit \e depth for the frame buffer's new resolution. If you
    provide a real implementation in your graphics driver class, it
    must notify other applications that the resolution has changed,
    because the other applications must redraw their frame buffers
    with the new resolution. The function is only a stub in this
    example because the base class declares the function as pure
    virtual, so it must have an implementation in this subclass. In
    your graphics driver class, you would normally want to implement
    this function to actually change the frame buffer resolution. 

    The graphics driver class uses the OpenGL library API in its
    private functions, which are helper functions for its public
    functions. invalidateTexture() is called by exposeRegion() to
    invalidate the existing OpenGL texture for the window to be
    updated, thus forcing the window image to be redrawn.
    redrawScreen() performs the actual redrawing using the other
    helper functions. redrawScreen() is not called directly but by
    starting an internal timer which is started by a call to
    exposeRegion(). This internal timer limits the frequency of screen
    updates. drawWindow() is used by redrawScreen(). The private
    functions drawQuad(), drawQuadInverseY(), and drawQuadWavyFlag()
    are used for creating the transition effect displaying a new
    window or reshowing a window that was mninimized.

    The only data member in class QAhiGLScreen is the standard pointer
    to a private implementation class QAhiGLScreenPrivate, where the 
    screen driver's internal state variables are held. These variables
    contain the data used for composing displays.

    \quotefromfile qtopiacore/ahigl/qscreenahigl_qws.cpp
    \skipto class QAhiGLScreenPrivate
    \printuntil /^\}/

    Class QAhiGLScreenPrivate is derived from QObject so it can use
    the Qt signal/slot mechanism to receive the window server's 
    \l {QWSServer::windowEvent()} {window event signal} at its
    \c QAhiGLScreenPrivate::windowEvent() slot. If the value of data 
    member \c doEffects is true, this slot performs the transition
    effect animation, whenever a new window is first shown, or when 
    it is reshown after having been minimized. Note that \c doEffects
    can be set to true at screen driver startup time by including the
    \c {-display ahigl:effects} option on the command line.

    To control animation of the window transition effect, an instance
    of class ShowAnimation is created by the 
    \c QAhiGLScreenPrivate::windowEvent() slot, when a 
    \l {QWSServer::WindowEvent} {Show window event} is emitted by the
    \l {QWSServer} {window server}. This happens when a window is 
    first created and when it is reshown after having been minimized.

    \skipto class ShowAnimation
    \printuntil /^\}/

    Class ShowAnimation is derived from the QTimeLine class for
    controlling animations. The \c ShowAnimation() constructor
    initializes the timeline, connecting its 
    \l {QTimeLine::valueChanged()} {valueChanged()} signal to the 
    screen driver's \c QAhiGLScreen::redrawScreen() slot, and 
    connecting its \l {QTimeLine::finished()} {finished()} signal
    to the QObject::deleteLater() slot. Finally, the constructor
    tells the timeline to \l {QTimeLine::start()} {start} the 
    animation. ShowAnimation reimplements the 
    \l {QTimeLine::}{valueForTime()} function, which returns a 
    value used for customizing the shape of the curve used for
    the transition effect.

    \skipto struct WindowInfo
    \printuntil windowMap;

    Top-level windows that are not drawn using OpenGL are rendered the
    normal way into a shared memory segment. The driver supports this
    by creating a GL texture of the memory segment and drawing it to
    the screen. The \c texture identifier and a pointer to the active
    \c animation are held in an instance of \c struct \c WindowInfo.
    The instances of WindowInfo are held in a global map, \c windowMap.

    \section1 QAhiGLScreen Class Implementation

    The \l {QScreen::}{connect()} function is the first function that
    is called after the constructor returns. This implementation just
    initializes the QScreen variables to some hardcoded values. A better
    implementation would query the hardware for it's current state.

    At the end of the function we check if the driver has been started with
    the \c effects argument which should trigger use of transition effects.

    \quotefromfile qtopiacore/ahigl/qscreenahigl_qws.cpp
    \skipto QAhiGLScreen::connect
    \printuntil /^\}/

    The \l {QScreen::}{initDevice()} function is called on the server process
    and is responsible for initializing the hardware. This implementation
    use the EGL library to achieve this. Note that some of the data structures
    used in this API are specific to the current EGL implementation, as for
    instance the DummyScreen structure.

    In this function we also connects to the QWSServer::windowEvent() signal
    if the transition effect is to be enabled.

    \skipto initDevice
    \printuntil /^\}/

    Before the application exists, the {QScreen::}{shutdownDevice()} is called
    in the server process to release the hardware resources. This 
    implementation again use the EGL library to achieve this.

    \skipto shutdownDevice
    \printuntil /^\}/

    Whenever an area on the screen needs to be updated the function 
    \l {QScreen::}{exposeRegion()} is called by the window system. This
    implementation doesn't actually redraw the screen, but starts a timer
    to redraw at a later time.

    \skipto exposeRegion
    \printuntil /^\}/

    We won't go through the \c updateTexture() function but only mention that
    it uses the EGL functions \c glTexImage2D() and \c glTexSubImage2D()
    to copy the memory image of the widget into a OpenGL texture if
    necessary.

    The actual window compositioning happens in the redrawScreen() function.
    It starts by using standard OpenGL to fill the screen with the background
    color.

    \quotefromfile qtopiacore/ahigl/qscreenahigl_qws.cpp
    \skipto void QAhiGLScreen::redrawScreen()
    \printuntil glClear(GL_COLOR_BUFFER_BIT);

    Next it iterates over all the windows and use the helper function
    \c drawWindow() to draw each of them as a OpenGL texture to the screen.
    The texture id is either taken from the \c WindowInfo struct or from the
    window surface if it is a surface that's being painted using OpenGL, i.e
    a \c QAhiGLWindowSurface. We'll discuss this class shortly.

    \c drawWindow() takes a \c progress parameter that is used to create an
    animation effect if it's less than 1.0. We won't discuss the 
    \c drawWindow() function any further in this text, but point to the source
    code for more details.

    \skipto QAhiGLScreen::createSurface
    \printuntil /^\}/
    \skipto QAhiGLScreen::createSurface
    \printuntil /^\}/

    The two \l {QScreen::}{createSurface()} functions decides when  
    instantiate a QAhiGLWindowSurface. We do this whenever we create a
    QGLWidget and also for top-level windows that are under a certain size.
    The size contraint is a necessary for this particular OpenGL ES 
    implementation. Additionly this driver only supports use of
    OpenGL in the server process.

    \section1 QAhiGLWindowSurface Class Definition

    To be able to support QGlWidget or use of OpenGL when using QPainter on
    a normal widget we need to create a subclass of QWSGLWindowSurface. In
    addition to reimplementing the standard functionality needed when 
    subclassing a QWSWindowSurface, the QAhiGLWindowSurface also contains
    the \c textureId() function used by QAhiGLScreen.

    \quotefromfile qtopiacore/ahigl/qwindowsurface_ahigl_p.h
    \skipto class QAhiGLWindowSurface
    \printuntil /^\}/

    \section1 QAhiGLWindowSurface Class Implementation

    The implementation of OpenGL ES tested with this example only supports
    one OpenGL context. This context is therefore shared between QAhiGLScreen
    and all instances QAhiGLWindowSurface and passed in the constructor.

    \quotefromfile qtopiacore/ahigl/qwindowsurface_ahigl.cpp
    \skipto QAhiGLWindowSurface::QAhiGLWindowSurface
    \printuntil /^\}/

    The constructor also creates an instance of \c QWSGLPaintDevice which is 
    returned in the \l {QWSWindowSurface::}{paintDevice()} function. This
    ensures that all \l {QPainter}s used on this surface will use an
    OpenGL enabled QPaintEngine.

    This example makes use of the OpenGL FrameBufferObject extension. All 
    painting is performed into a framebuffer object which is later
    compositioned onto the screen by QAhiGLScreen. Allocateding the framebuffer
    object is done in \l {QWindowSurface::}{setGeometry()}.

    \skipto QAhiGLWindowSurface::setGeometry
    \printuntil /^\}/

    Since there can be several instances of the QAhiGLWindowSurface, we need
    to make sure that the correct framebuffer object is active before painting.
    This is done by reimplementing \l QWindowSurface::beginPaint():

    \skipto QAhiGLWindowSurface::beginPaint
    \printuntil /^\}/

    Finally we need to make sure that whenever a widget grows beyond the size
    supported by this driver (256 x 256), the surface is deleted and a new
    standard surface is created instead. This is handled by reimplementing
    \l QWSWindowSurface::isValid():    

    \skipto QAhiGLWindowSurface::isValid
    \printuntil /^\}/
*/
