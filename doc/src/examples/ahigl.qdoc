/*!
    \example qtopiacore/ahigl
    \title OpenGL for Embedded Systems Example

    This example demonstrates how you can use OpenGL for Embedded
    Systems (ES) to create your own graphics driver and \l {add your
    graphics driver to Qtopia Core}. In \l {Qtopia Core}, painting is
    a pure software implementation and is normally performed in two
    steps: The clients render each window onto a corresponding surface
    (stored in memory) using a paint engine, and then the server uses
    the graphics driver to compose the surface images and copy them to
    the screen. (See the \l {Qtopia Core Architecture} documentation
    for details.)

    This example is not for the novice. It assumes the reader is
    knowledgeable about both OpenGL ES and the graphics driver
    framework demonstrated in the \l {Accelerated Graphics Driver
    Example}.

    When designing an OpenGL graphics driver for Qtopia Core, the
    programmer can use OpenGL ES in three ways. First, the 
    \l {QWSServer} {Qtopia Core server} can use the graphics driver 
    to create a composition of multiple window images and copy that
    composition to the screen. Second, clients can use the graphics
    driver to accelerate OpenGL painting operations using the
    QOpenGLPaintEngine class. Finally, clients can use the graphics
    driver to do OpenGL operations in the QGLWidget class. This
    example implements all three cases.

    The example uses an implementation of OpenGL ES from \l
    {http://ati.amd.com}{ATI} for the \l
    {http://ati.amd.com/products/imageon238x/}{Imageon 2380}. The
    OpenGL include files gl.h and egl.h must be installed to compile
    the example, and the OpenGL and EGL libraries must be installed
    for linking. If your target device is different, you must install
    the include files and libraries for that device, and you also
    might need to modify the example source code if any API signatures
    in your EGL library differ from the ones used here.

    After compiling and linking the example source, install the
    graphics driver plugin with the command \c {make install}. To
    start an application that uses the plugin, you can either set the
    environment variable \l QWS_DISPLAY and then start the
    application, or just start the application with the \c -display
    switch, as follows:

    \code
        myApplication -qws -display ahigl
    \endcode

    The example graphics driver includes an animated transition effect
    for showing new windows. To enable this transition effect, run the 
    application with \c {-display ahigl:effects}.

    \section1 Graphics Driver Class Definition

    The example's graphics driver class is called QAhiGLScreen. "Ahi"
    stands for ATI Handheld Interface. The class can also be used as
    the graphics driver for other ATI handheld devices.

    \quotefromfile qtopiacore/ahigl/qscreenahigl_qws.h
    \skipto class QAhiGLScreen :
    \printuntil };

    The graphics driver class is derived from class QGLScreen, which,
    in turn, is derived from class QScreen. If your graphics driver
    will only be used to create compositions of window images in the
    Qtopia Core server and copy the compositions to the screen, then
    you can derive your graphics driver class directly from QScreen.
    But if your graphics driver will be used by clients to accelerate
    graphics rendering operations with the QOpenGLPaintEngine, or if
    clients will use it to access class QGLWidget, then your graphics
    driver class must be derived from QGLScreen.

    Note that class QScreen is documented in the published API, but
    class QGLScreen is not, because the design of class QGLScreen is
    still preliminary.

    The public functions in our example graphics driver class
    QAhiGLScreen are implementations of virtual functions declared in
    either QScreen or QGLScreen. Function hasOpenGL() comes from
    QGLScreen.  All the others come from QScreen.

    The driver's implementation of \l {QScreen::}{exposeRegion()} is
    called by the Qtopia Core server, whenever a screen update is
    required.  Its parameters are the region on the screen to be
    updated and the index of the client window to be updated.

    The two implementations of \l {QScreen::}{createSurface()} are
    used for creating new window surfaces. The one that accepts a
    QWidget as input is called on the client side to create the window
    surface for the widget. The one that accepts a QString identifying
    the type of window surface to create is called on the server side
    to create the server's copy of a client side window surface. The
    client window surface object communicates its window image data to
    the server window surface object through shared memory.
    
    The implementation of \l {QScreen::}{setMode()}, which is a stub
    in the example driver, would normally reset the frame buffer's
    resolution. Its parameters are the \e width, \e height, and the
    bit \e depth for the frame buffer's new resolution. If you provide
    a real implementation of setMode() in your graphics driver class,
    remember that it must signal the other applications that it has
    changed the frame buffer resolution, so they can redraw their
    frame buffers with the new resolution. There is no significance to
    setMode() being implemented as a no-op in this example. It simplyu
    wasn't implemented. The stub is provided because QScreen declares
    setMode() as pure virtual.

    Complex graphics operations are implemented using the OpenGL API
    in the private functions declared in QAhiGLScreen. These private
    functions are then used by the public API to do the real work.
    For example, exposeRegion() first calls the private function
    invalidateTexture() to destroy the texture (image) for the window
    about to be updated. Then it calls redrawScreen() to build a new
    image and display it on the screen. But exposeRegion() doesn't
    call redrawScreen() directly. Instead it activates the driver's
    screen update timer, which has had its timeout() signal connected
    to the redrawScreen() slot. When the update timer times out,
    redrawScreen() is called once to compose a single image of all
    windows that had been passed to calls of exposeRegion() during the
    previous timer interval. redrawScreen() uses the private function
    drawWindow(), which in turn uses drawQuad() to paint each window
    into the composed image. Using the update timer to funnel multiple
    calls to exposeRegion() into a single call to redrawScreen() lets
    the driver limit the frequency of screen updates. 

    But there is a caveat. When the animated transition effect for new
    windows is enabled, an a window is shown for the first time, or
    reshown after being minimized, an instance of class ShowAnimation
    is created for the window to run the animation of the transition
    effect. The valueChanged() signal of this ShowAnimation object is
    also connected to the redrawScreen() slot, so in the example as it
    is currently written, if the window transition effect is enabled,
    when the plugin is started, with \c {-display ahigl:effects}, then
    redrawScreen() can be called more often than the update timer is
    meant to allow. This could be a bug in the example, so be aware of
    it if you use the example as the basis for your own OpenGL driver.

    Once redrawScreen() has composed all the window images, it uses
    the private function drawQuad() to add the cursor. Finally, the
    composed image is displayed on the screen. The private functions
    drawQuad(), drawQuadInverseY(), and drawQuadWavyFlag() are used
    for creating the animated transition effect when displaying a new
    window or reshowing a window that had bin minimized.

    The only data member in class QAhiGLScreen is the standard pointer
    to a private implementation class QAhiGLScreenPrivate, where the 
    screen driver's internal state variables are held. These variables
    contain the data used for composing displays.

    \quotefromfile qtopiacore/ahigl/qscreenahigl_qws.cpp
    \skipto class QAhiGLScreenPrivate
    \printuntil /^\}/

    Class QAhiGLScreenPrivate is derived from QObject so it can use
    the Qt signal/slot mechanism to receive the window server's 
    \l {QWSServer::windowEvent()} {window event signal} at its
    \c QAhiGLScreenPrivate::windowEvent() slot. If the value of data 
    member \c doEffects is true, this slot performs the transition
    effect animation, whenever a new window is first shown, or when 
    it is reshown after having been minimized. Note that \c doEffects
    can be set to true at screen driver startup time by including the
    \c {-display ahigl:effects} option on the command line.

    To control animation of the window transition effect, an instance
    of class ShowAnimation is created by the 
    \c QAhiGLScreenPrivate::windowEvent() slot, when a 
    \l {QWSServer::WindowEvent} {Show window event} is emitted by the
    \l {QWSServer} {window server}. This happens when a window is 
    first created and when it is reshown after having been minimized.

    \skipto class ShowAnimation
    \printuntil /^\}/

    Class ShowAnimation is derived from the QTimeLine class for
    controlling animations. The \c ShowAnimation() constructor
    initializes the timeline, connecting its 
    \l {QTimeLine::valueChanged()} {valueChanged()} signal to the 
    screen driver's \c QAhiGLScreen::redrawScreen() slot, and 
    connecting its \l {QTimeLine::finished()} {finished()} signal
    to the QObject::deleteLater() slot. Finally, the constructor
    tells the timeline to \l {QTimeLine::start()} {start} the 
    animation. ShowAnimation reimplements the 
    \l {QTimeLine::}{valueForTime()} function, which returns a 
    value used for customizing the shape of the curve used for
    the transition effect.

    \skipto struct WindowInfo
    \printuntil windowMap;

    Top-level windows that are not drawn using OpenGL are rendered the
    normal way into a shared memory segment. The driver supports this
    by creating a GL texture of the memory segment and drawing it to
    the screen. The \c texture identifier and a pointer to the active
    \c animation are held in an instance of \c struct \c WindowInfo.
    The instances of WindowInfo are held in a global map, \c windowMap.

    \section1 QAhiGLScreen Class Implementation

    The \l {QScreen::}{connect()} function is the first function that
    is called after the constructor returns. This implementation just
    initializes the QScreen variables to some hardcoded values. A better
    implementation would query the hardware for it's current state.

    At the end of the function we check if the driver has been started with
    the \c effects argument which should trigger use of transition effects.

    \quotefromfile qtopiacore/ahigl/qscreenahigl_qws.cpp
    \skipto QAhiGLScreen::connect
    \printuntil /^\}/

    The \l {QScreen::}{initDevice()} function is called on the server process
    and is responsible for initializing the hardware. This implementation
    use the EGL library to achieve this. Note that some of the data structures
    used in this API are specific to the current EGL implementation, as for
    instance the DummyScreen structure.

    In this function we also connects to the QWSServer::windowEvent() signal
    if the transition effect is to be enabled.

    \skipto initDevice
    \printuntil /^\}/

    Before the application exists, the {QScreen::}{shutdownDevice()} is called
    in the server process to release the hardware resources. This 
    implementation again use the EGL library to achieve this.

    \skipto shutdownDevice
    \printuntil /^\}/

    Whenever an area on the screen needs to be updated the function 
    \l {QScreen::}{exposeRegion()} is called by the window system. This
    implementation doesn't actually redraw the screen, but starts a timer
    to redraw at a later time.

    \skipto exposeRegion
    \printuntil /^\}/

    We won't go through the \c updateTexture() function but only mention that
    it uses the EGL functions \c glTexImage2D() and \c glTexSubImage2D()
    to copy the memory image of the widget into a OpenGL texture if
    necessary.

    The actual window compositioning happens in the redrawScreen() function.
    It starts by using standard OpenGL to fill the screen with the background
    color.

    \quotefromfile qtopiacore/ahigl/qscreenahigl_qws.cpp
    \skipto void QAhiGLScreen::redrawScreen()
    \printuntil glClear(GL_COLOR_BUFFER_BIT);

    Next it iterates over all the windows and use the helper function
    \c drawWindow() to draw each of them as a OpenGL texture to the screen.
    The texture id is either taken from the \c WindowInfo struct or from the
    window surface if it is a surface that's being painted using OpenGL, i.e
    a \c QAhiGLWindowSurface. We'll discuss this class shortly.

    \c drawWindow() takes a \c progress parameter that is used to create an
    animation effect if it's less than 1.0. We won't discuss the 
    \c drawWindow() function any further in this text, but point to the source
    code for more details.

    \skipto QAhiGLScreen::createSurface
    \printuntil /^\}/
    \skipto QAhiGLScreen::createSurface
    \printuntil /^\}/

    The two \l {QScreen::}{createSurface()} functions decides when  
    instantiate a QAhiGLWindowSurface. We do this whenever we create a
    QGLWidget and also for top-level windows that are under a certain size.
    The size contraint is a necessary for this particular OpenGL ES 
    implementation. Additionly this driver only supports use of
    OpenGL in the server process.

    \section1 QAhiGLWindowSurface Class Definition

    To be able to support QGlWidget or use of OpenGL when using QPainter on
    a normal widget we need to create a subclass of QWSGLWindowSurface. In
    addition to reimplementing the standard functionality needed when 
    subclassing a QWSWindowSurface, the QAhiGLWindowSurface also contains
    the \c textureId() function used by QAhiGLScreen.

    \quotefromfile qtopiacore/ahigl/qwindowsurface_ahigl_p.h
    \skipto class QAhiGLWindowSurface
    \printuntil /^\}/

    \section1 QAhiGLWindowSurface Class Implementation

    The implementation of OpenGL ES tested with this example only supports
    one OpenGL context. This context is therefore shared between QAhiGLScreen
    and all instances QAhiGLWindowSurface and passed in the constructor.

    \quotefromfile qtopiacore/ahigl/qwindowsurface_ahigl.cpp
    \skipto QAhiGLWindowSurface::QAhiGLWindowSurface
    \printuntil /^\}/

    The constructor also creates an instance of \c QWSGLPaintDevice which is 
    returned in the \l {QWSWindowSurface::}{paintDevice()} function. This
    ensures that all \l {QPainter}s used on this surface will use an
    OpenGL enabled QPaintEngine.

    This example makes use of the OpenGL FrameBufferObject extension. All 
    painting is performed into a framebuffer object which is later
    compositioned onto the screen by QAhiGLScreen. Allocateding the framebuffer
    object is done in \l {QWindowSurface::}{setGeometry()}.

    \skipto QAhiGLWindowSurface::setGeometry
    \printuntil /^\}/

    Since there can be several instances of the QAhiGLWindowSurface, we need
    to make sure that the correct framebuffer object is active before painting.
    This is done by reimplementing \l QWindowSurface::beginPaint():

    \skipto QAhiGLWindowSurface::beginPaint
    \printuntil /^\}/

    Finally we need to make sure that whenever a widget grows beyond the size
    supported by this driver (256 x 256), the surface is deleted and a new
    standard surface is created instead. This is handled by reimplementing
    \l QWSWindowSurface::isValid():    

    \skipto QAhiGLWindowSurface::isValid
    \printuntil /^\}/
*/
