/*!
    \example qtopiacore/ahigl
    \title OpenGL for Embedded Systems Example

    The OpenGL for Embedded Systems (ES) screen driver example shows
    how the \l {Graphics Driver Framework} in \l {Qtopia Core} can be
    used to create an OpenGL ES screen driver. The example assumes a
    basic knowledge of the graphics driver framework as discussed in
    the \l {Accelerated Screen Driver Example}.

    In \l {Qtopia Core}, OpenGL ES can be used in three ways. First,
    it can be used to do window composition and creation of graphical
    effects including animation. A second use to access features of
    your device that allow you to accelerate widget painting. A third
    use is to simply provide access to class QGLWidget, the widget
    class for rendering OpenGL graphics. This example shows how to
    implement all of these.

    The example uses an implementation of OpenGL ES from 
    \l {http://ati.amd.com}{ATI} for the 
    \l {http://ati.amd.com/products/imageon238x/}{Imageon 2380}. The
    OpenGL ES and EGL libraries are required for compiling and linking
    the example. If your target device is different, you must supply
    the corresponding libraries for that device, and you also might 
    have to modify the example source code to account for differences
    in API signatures between your EGL library and the one used for
    this example.

    After compiling the example source, install the resulting screen
    driver plugin with the command \c {make install}. To start an
    application using the example's screen driver, either set the
    environment variable \l QWS_DISPLAY and then start the program, or
    start the program using the \c -display switch:

    \code
        myApplication -qws -display ahigl
    \endcode

    To enable the window transition effect when showing new windows,
    run the application with \c {-display ahigl:effects}.

    \section1 QAhiGLScreen Class Definition

    The example's screen driver class is called QAhiGLScreen. "Ahi"
    stands for ATI Handheld Interface. The class can be used as the
    screen driver for other ATI handheld devices. 

    \quotefromfile qtopiacore/ahigl/qscreenahigl_qws.h
    \skipto class QAhiGLScreen :
    \printuntil };

    The screen driver class is derived from class QGLScreen, which is
    itself derived from class QScreen. If you will only use OpenGL ES
    for composing displays of top-level windows, you can derive your
    OpenGL ES screen driver class directly from QScreen. Otherwise it
    must be derived from QGLScreen.

    Note that class QGLScreen is not part of the Qt documentation.
    The design of QGLScreen is still preliminary, so it is not yet
    included in the published Qt API. Class QScreen, however, is in
    the published API and is included in the Qt documentation.

    All the public functions in our example screen driver class
    QAhiGLScreen are reimplementations of virtual or pure virtual
    functions from its base classes. Except for function hasOpenGL(), 
    which is declared in QGLScreen, the public functions are from 
    QScreen.

    \l {QScreen::}{exposeRegion()} is called by the Qtopia Core server
    whenever a screen update is required. Its parameters are the
    region on the screen to be updated and the index of the client 
    window to be updated.

    One of the two \l {QScreen::}{createSurface()} functions are
    called by the server whenever it needs to create a new window,
    e.g., when copying the contents of an area of memory to the
    screen. You can either provide a widget, from which the correct
    type of window surface is created automatically, or you can
    provide a key string to specify which kind of window surface you
    want.

    The implementation of \l {QScreen::}{setMode()} is used to 
    reset the frame buffer's resolution. The parameters are the
    \e width, \e height, and the bit \e depth for the frame buffer's
    new resolution. The function must notify other applications, when 
    the resolution is changed, because the other applications must 
    redraw their frame buffers with the new resolution.

does the composition and display of windows. The
    QAhiGLScreen private functions updateTexture(), redrawScreen(),
    and drawWindow() are helper functions for composing and displaying
    windows. The private functions drawQuad(), drawQuadInverseY(), and
    drawQuadWavyFlag() are used for creating the transition effect
    displaying a new window or reshowing a window that was mninimized.

    The only data member in class QAhiGLScreen is the standard pointer
    to a private implementation class QAhiGLScreenPrivate, where the 
    screen driver's internal state variables are held. These variables
    contain the data used for composing displays.

    \quotefromfile qtopiacore/ahigl/qscreenahigl_qws.cpp
    \skipto class QAhiGLScreenPrivate
    \printuntil /^\}/

    Class QAhiGLScreenPrivate is derived from QObject so it can use
    the Qt signal/slot mechanism to receive the window server's 
    \l {QWSServer::windowEvent()} {window event signal} at its
    \c QAhiGLScreenPrivate::windowEvent() slot. If the value of data 
    member \c doEffects is true, this slot performs the transition
    effect animation, whenever a new window is first shown, or when 
    it is reshown after having been minimized. Note that \c doEffects
    can be set to true at screen driver startup time by including the
    \c {-display ahigl:effects} option on the command line.

    To control animation of the window transition effect, an instance
    of class ShowAnimation is created by the 
    \c QAhiGLScreenPrivate::windowEvent() slot, when a 
    \l {QWSServer::WindowEvent} {Show window event} is emitted by the
    \l {QWSServer} {window server}. This happens when a window is 
    first created and when it is reshown after having been minimized.

    \skipto class ShowAnimation
    \printuntil /^\}/

    Class ShowAnimation is derived from the QTimeLine class for
    controlling animations. The \c ShowAnimation() constructor
    initializes the timeline, connecting its 
    \l {QTimeLine::valueChanged()} {valueChanged()} signal to the 
    screen driver's \c QAhiGLScreen::redrawScreen() slot, and 
    connecting its \l {QTimeLine::finished()} {finished()} signal
    to the QObject::deleteLater() slot. Finally, the constructor
    tells the timeline to \l {QTimeLine::start()} {start} the 
    animation. ShowAnimation reimplements the 
    \l {QTimeLine::}{valueForTime()} function, which returns a 
    value used for customizing the shape of the curve used for
    the transition effect.

    \skipto struct WindowInfo
    \printuntil windowMap;

    Top-level windows that are not drawn using OpenGL are rendered the
    normal way into a shared memory segment. The driver supports this
    by creating a GL texture of the memory segment and drawing it to
    the screen. The \c texture identifier and a pointer to the active
    \c animation are held in an instance of \c struct \c WindowInfo.
    The instances of WindowInfo are held in a global map, \c windowMap.

    \section1 QAhiGLScreen Class Implementation

    The \l {QScreen::}{connect()} function is the first function that
    is called after the constructor returns. This implementation just
    initializes the QScreen variables to some hardcoded values. A better
    implementation would query the hardware for it's current state.

    At the end of the function we check if the driver has been started with
    the \c effects argument which should trigger use of transition effects.

    \quotefromfile qtopiacore/ahigl/qscreenahigl_qws.cpp
    \skipto QAhiGLScreen::connect
    \printuntil /^\}/

    The \l {QScreen::}{initDevice()} function is called on the server process
    and is responsible for initializing the hardware. This implementation
    use the EGL library to achieve this. Note that some of the data structures
    used in this API are specific to the current EGL implementation, as for
    instance the DummyScreen structure.

    In this function we also connects to the QWSServer::windowEvent() signal
    if the transition effect is to be enabled.

    \skipto initDevice
    \printuntil /^\}/

    Before the application exists, the {QScreen::}{shutdownDevice()} is called
    in the server process to release the hardware resources. This 
    implementation again use the EGL library to achieve this.

    \skipto shutdownDevice
    \printuntil /^\}/

    Whenever an area on the screen needs to be updated the function 
    \l {QScreen::}{exposeRegion()} is called by the window system. This
    implementation doesn't actually redraw the screen, but starts a timer
    to redraw at a later time.

    \skipto exposeRegion
    \printuntil /^\}/

    We won't go through the \c updateTexture() function but only mention that
    it uses the EGL functions \c glTexImage2D() and \c glTexSubImage2D()
    to copy the memory image of the widget into a OpenGL texture if
    necessary.

    The actual window compositioning happens in the redrawScreen() function.
    It starts by using standard OpenGL to fill the screen with the background
    color.

    \quotefromfile qtopiacore/ahigl/qscreenahigl_qws.cpp
    \skipto void QAhiGLScreen::redrawScreen()
    \printuntil glClear(GL_COLOR_BUFFER_BIT);

    Next it iterates over all the windows and use the helper function
    \c drawWindow() to draw each of them as a OpenGL texture to the screen.
    The texture id is either taken from the \c WindowInfo struct or from the
    window surface if it is a surface that's being painted using OpenGL, i.e
    a \c QAhiGLWindowSurface. We'll discuss this class shortly.

    \c drawWindow() takes a \c progress parameter that is used to create an
    animation effect if it's less than 1.0. We won't discuss the 
    \c drawWindow() function any further in this text, but point to the source
    code for more details.

    \skipto QAhiGLScreen::createSurface
    \printuntil /^\}/
    \skipto QAhiGLScreen::createSurface
    \printuntil /^\}/

    The two \l {QScreen::}{createSurface()} functions decides when  
    instantiate a QAhiGLWindowSurface. We do this whenever we create a
    QGLWidget and also for top-level windows that are under a certain size.
    The size contraint is a necessary for this particular OpenGL ES 
    implementation. Additionly this driver only supports use of
    OpenGL in the server process.

    \section1 QAhiGLWindowSurface Class Definition

    To be able to support QGlWidget or use of OpenGL when using QPainter on
    a normal widget we need to create a subclass of QWSGLWindowSurface. In
    addition to reimplementing the standard functionality needed when 
    subclassing a QWSWindowSurface, the QAhiGLWindowSurface also contains
    the \c textureId() function used by QAhiGLScreen.

    \quotefromfile qtopiacore/ahigl/qwindowsurface_ahigl_p.h
    \skipto class QAhiGLWindowSurface
    \printuntil /^\}/

    \section1 QAhiGLWindowSurface Class Implementation

    The implementation of OpenGL ES tested with this example only supports
    one OpenGL context. This context is therefore shared between QAhiGLScreen
    and all instances QAhiGLWindowSurface and passed in the constructor.

    \quotefromfile qtopiacore/ahigl/qwindowsurface_ahigl.cpp
    \skipto QAhiGLWindowSurface::QAhiGLWindowSurface
    \printuntil /^\}/

    The constructor also creates an instance of \c QWSGLPaintDevice which is 
    returned in the \l {QWSWindowSurface::}{paintDevice()} function. This
    ensures that all \l {QPainter}s used on this surface will use an
    OpenGL enabled QPaintEngine.

    This example makes use of the OpenGL FrameBufferObject extension. All 
    painting is performed into a framebuffer object which is later
    compositioned onto the screen by QAhiGLScreen. Allocateding the framebuffer
    object is done in \l {QWindowSurface::}{setGeometry()}.

    \skipto QAhiGLWindowSurface::setGeometry
    \printuntil /^\}/

    Since there can be several instances of the QAhiGLWindowSurface, we need
    to make sure that the correct framebuffer object is active before painting.
    This is done by reimplementing \l QWindowSurface::beginPaint():

    \skipto QAhiGLWindowSurface::beginPaint
    \printuntil /^\}/

    Finally we need to make sure that whenever a widget grows beyond the size
    supported by this driver (256 x 256), the surface is deleted and a new
    standard surface is created instead. This is handled by reimplementing
    \l QWSWindowSurface::isValid():    

    \skipto QAhiGLWindowSurface::isValid
    \printuntil /^\}/
*/
