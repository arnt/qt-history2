/*!
    \example qtopiacore/ahigl
    \title OpenGL for Embedded Systems Example

    \section1 Introduction

    This example demonstrates how you can use OpenGL for Embedded
    Systems (ES) to create your own graphics driver and \l {add your
    graphics driver to Qtopia Core}. In \l {Qtopia Core}, painting is
    a pure software implementation and is normally performed in two
    steps: The clients render each window onto a corresponding surface
    (stored in memory) using a paint engine, and then the server uses
    the graphics driver to compose the surface images and copy them to
    the screen. (See the \l {Qtopia Core Architecture} documentation
    for details.)

    This example is not for the novice. It assumes you are familiar
    with both OpenGL ES and the graphics driver framework demonstrated
    in the \l {Accelerated Graphics Driver Example}.

    An OpenGL graphics driver for Qtopia Core can use OpenGL ES in
    three ways. First, the \l {QWSServer} {Qtopia Core server} can use
    the driver to compose multiple window images and then show the
    composition on the screen. Second, clients can use the driver to
    accelerate OpenGL painting operations using the QOpenGLPaintEngine
    class. Finally, clients can use the driver to do OpenGL operations
    in the QGLWidget class. This example implements all three cases.

    The example uses an implementation of OpenGL ES from 
    \l {http://ati.amd.com}{ATI} for the 
    \l {http://ati.amd.com/products/imageon238x/}{Imageon 2380}. The
    OpenGL include files gl.h and egl.h must be installed to compile
    the example, and the OpenGL and EGL libraries must be installed
    for linking. If your target device is different, you must install
    the include files and libraries for that device, and you also
    might need to modify the example source code if any API signatures
    in your EGL library differ from the ones used here.

    After compiling and linking the example source, install the
    graphics driver plugin with the command \c {make install}. To
    start an application that uses the plugin, you can either set the
    environment variable \l QWS_DISPLAY and then start the
    application, or just start the application with the \c -display
    switch, as follows:

    \code
        myApplication -qws -display ahigl
    \endcode

    The example driver also implements an animated transition effect
    that can be used when showing new windows or reshowing windows
    that have been minimized. To enable this transition effect, run
    the application with \c {-display ahigl:effects}.

    \section1 The Class Definitions

    The example comprises three main classes plus some helper classes.
    The main classes are the graphics driver, QAhiGLScreen, which is
    defined in qscreenahigl_qws.h, the window surface,
    QAhiGLWindowSurface, which is defined in qwindowsurface_ahigl_p.h,
    and the plugin, QAhiGLScreenPlugin, which is defined in
    qscreenahiglplugin.cpp. The "Ahi" prefix in these class names
    stands for \e {ATI Handheld Interface}. The example was written
    for the ATI Imageon 2380, but it can also be used as a template
    for other ATI handheld devices.

    \section2 The Graphics Driver Class Definition

    The graphics driver class is called QAhiGLScreen. It is derived
    from class QGLScreen, which, in turn, is derived from class
    QScreen.

    \quotefromfile qtopiacore/ahigl/qscreenahigl_qws.h
    \skipto class QAhiGLScreen :
    \printuntil };

    If your graphics driver will only do window compositions and
    display them on the screen, then you can derive your graphics
    driver class directly from QScreen.  But if you want to accelerate
    graphics rendering operations with the QOpenGLPaintEngine, or if
    you want to use class QGLWidget, then your graphics driver class
    must be derived from QGLScreen.

    Note that class QScreen is documented in the published API, but
    because the design of class QGLScreen is still preliminary, it is
    not yet included in the documentation.

    The only data member in class QAhiGLScreen is a standard d_ptr,
    which points to an instance of the driver's private implementation
    class QAhiGLScreenPrivate. The driver's internal state is stored
    in the private class. Using the so-called d-pointer pattern allows
    making changes to the driver's internal design without breaking
    binary compatibility.

    \quotefromfile qtopiacore/ahigl/qscreenahigl_qws.cpp
    \skipto class QAhiGLScreenPrivate :
    \printuntil /^\}/

    Class QAhiGLScreenPrivate is derived from QObject so it can use
    the Qt signal/slot mechanism. All signals sent to the graphics
    driver are received by slots in the private implementation class,
    in this case, windowEvent() and redrawScreen().

    \section2 The Window Surface Class Definition

    To support the driver's use of the OpenGL paint engine,
    QOpenGLPaintEngine, and the OpenGL widget, QGLWidget, we must
    create a subclass of the OpenGL window surface class,
    QWSGLWindowSurface, which we can then tailor to the special
    requirements of our particular ATI handheld device. The subclass
    is called QAhiGLWindowSurface.

    \quotefromfile qtopiacore/ahigl/qwindowsurface_ahigl_p.h
    \skipto class QAhiGLWindowSurface :
    \printuntil /^\}/

    QAhiGLWindowSurface is derived from QWSGLWindowSurface, which, in
    turn, is derived from the abstract base class QWSWindowSurface.
    In addition to reimplementing the standard functionality required
    when creating any new subclass of QWSWindowSurface,
    QAhiGLWindowSurface also contains the \c textureId() function used
    by QAhiGLScreen.

    The same d-pointer pattern is used here and for the same reason.
    Thw window surface's private implementation class is
    QAhiGLWindowSurfacePrivate. It allows making changes to the
    internal design of the window surface without breaking binary
    compatibility.

    \quotefromfile qtopiacore/ahigl/qwindowsurface_ahigl.cpp
    \skipto class QAhiGLWindowSurfacePrivate
    \printuntil /^\}/

    In this case, the private implementation class has no member
    functions, except for its constructor. It contains only state
    information, which is accessible directly because the data members
    are declared in the public section of the class.

    \section2 The Plugin Class Definition

    The screen driver plugin is class QAhiGLScreenPlugin.

    \quotefromfile qtopiacore/ahigl/qscreenahiglplugin.cpp
    \skipto class QAhiGLScreenPlugin
    \printuntil /^\}/

    QAhiGLScreenPlugin is derived from class QScreenDriverPlugin,
    which in turn is derived from QObject.

    \section2 The Helper Classes

    The example graphics driver maintains a static \l {QMap} {map} of
    all the \l {QWSWindow} {windows} it is responsible for showing on
    the screen.  Each window is mapped to an instance of \c struct \c
    WindowInfo.

    \quotefromfile qtopiacore/ahigl/qscreenahigl_qws.cpp
    \skipto struct WindowInfo
    \printuntil windowMap;

    An instance of struct WindowInfo is allocated and inserted into \c
    windowMap as each new window is created. WindowInfo uses a GLuint
    to identify the GL \c texture it creates for the window. Note that
    the example driver, in addition to drawing windows using OpenGL,
    also supports drawing windows in the normal way without OpenGL.
    It uses a GL texture for the rendering operations in either case.
    Top-level windows that are drawn without OpenGL are rendered in
    the normal way into a shared memory segment, which is then
    converted to a GL texture before it is drawn to the screen.

    To perform the animation of the window transition effect,
    WindowInfo uses an instance of the class ShowAnimation. This \c
    animation is created by the \c QAhiGLScreenPrivate::windowEvent()
    slot, whenever a \l {QWSServer::WindowEvent} {Show window event}
    is emitted by the \l {QWSServer} {window server}. The server emits
    this signal when a window is created or when the window is reshown
    after having been minimized.  

    \quotefromfile qtopiacore/ahigl/qscreenahigl_qws.cpp
    \skipto class ShowAnimation
    \printuntil /^\}/

    Class ShowAnimation is derived from the QTimeLine class, which is
    used for controlling animations.

    \section1 The Class Implementations

    \section2 The Graphics Driver Class Implementation

    The public functions in class QAhiGLScreen are implementations of
    virtual functions declared in the base classes. hasOpenGL() is
    declared in base class QGLScreen. The others are declared in base
    class QScreen.

    The implementation of \l {QScreen::}{exposeRegion()} is called by
    the Qtopia Core server whenever a screen update is required.  Its
    parameters are the region on the screen to be updated and the
    index of the client window to be updated.

    The two implementations of \l {QScreen::}{createSurface()} are
    used for creating new window surfaces. The one that accepts a
    QWidget as input is called on the client side to create the window
    surface for the widget. The one that accepts a QString identifying
    the type of window surface to create is called on the server side
    to create the server's copy of a client side window surface. The
    client's window surface instance communicates its window image
    data to the server's window surface instance through shared
    memory.
    
    The implementation of \l {QScreen::}{setMode()}, which is a stub
    in this example, would normally reset the frame buffer's
    resolution. Its parameters are the \e width, \e height, and the
    bit \e depth for the frame buffer's new resolution. If you
    implement setMode() in your graphics driver, remember that it must
    emit a signal to warn other applications to redraw their frame
    buffers with the new resolution.  There is no significance to
    setMode() not being implemented in this example. It simply wasn't
    implemented. However, the stub had to be included because QScreen
    declares setMode() to be pure virtual.

    Complex graphics operations are implemented using the OpenGL API.
    Examples of this are shown in the private functions declared in
    QAhiGLScreen, which do the real work.  For example, exposeRegion()
    first calls the invalidateTexture() to destroy the existing
    texture (image) for the window about to be updated. This ensures
    that a new texture will be created. Then it calls redrawScreen()
    to build the new texture and display it on the screen. But
    exposeRegion() doesn't call redrawScreen() directly. Instead it
    activates the driver's screen update timer, which has its
    timeout() signal connected to the redrawScreen() slot. When a
    timeout occurs, redrawScreen() is called once to compose a single
    image of all the windows for which exposeRegion() was called
    during the previous timer interval.  redrawScreen() calls the
    private function drawWindow(), which in turn calls drawQuad(), to
    paint each window into the composition. Using the update timer to
    funnel multiple calls of exposeRegion() into a single call of
    redrawScreen() gives us a way to limit the frequency of screen
    updates.

    But there is a caveat. When the driver's animated transition
    effect for displaying new windows is enabled, and a new window is
    being shown or a window is being reshown after having been
    minimized, an instance of class ShowAnimation is created for the
    window to run the animated transition effect. The valueChanged()
    signal of this ShowAnimation object is also connected to the
    redrawScreen() slot of the driver, so in the driver as currently
    written, if the driver's window transition effect is enabled
    (i.e. if the plugin is started, with \c {-display ahigl:effects}),
    then redrawScreen() can be called more often than the update timer
    is meant to allow. This could be a bug in the example, so be aware
    of it if you use the example as the basis for your OpenGL driver.

    Once redrawScreen() has composed all the window images, it uses
    the private function drawQuad() to add the cursor. Finally, the
    composed image is displayed on the screen. The private functions
    drawQuad(), drawQuadInverseY(), and drawQuadWavyFlag() are used
    for creating the animated transition effect when displaying a new
    window or reshowing a window that has been minimized.

    The \l {QScreen::}{connect()} function is the first function that
    is called after the constructor returns. This implementation just
    initializes the QScreen variables to some hardcoded values. A better
    implementation would query the hardware for it's current state.

    At the end of the function we check if the driver has been started with
    the \c effects argument which should trigger use of transition effects.

    \quotefromfile qtopiacore/ahigl/qscreenahigl_qws.cpp
    \skipto QAhiGLScreen::connect
    \printuntil /^\}/

    The \l {QScreen::}{initDevice()} function is called on the server process
    and is responsible for initializing the hardware. This implementation
    use the EGL library to achieve this. Note that some of the data structures
    used in this API are specific to the current EGL implementation, as for
    instance the DummyScreen structure.

    In this function we also connects to the QWSServer::windowEvent() signal
    if the transition effect is to be enabled.

    \skipto initDevice
    \printuntil /^\}/

    Before the application exists, the {QScreen::}{shutdownDevice()} is called
    in the server process to release the hardware resources. This 
    implementation again use the EGL library to achieve this.

    \skipto shutdownDevice
    \printuntil /^\}/

    Whenever an area on the screen needs to be updated the function 
    \l {QScreen::}{exposeRegion()} is called by the window system. This
    implementation doesn't actually redraw the screen, but starts a timer
    to redraw at a later time.

    \skipto exposeRegion
    \printuntil /^\}/

    We won't go through the \c updateTexture() function but only mention that
    it uses the EGL functions \c glTexImage2D() and \c glTexSubImage2D()
    to copy the memory image of the widget into a OpenGL texture if
    necessary.

    The actual window compositioning happens in the redrawScreen() function.
    It starts by using standard OpenGL to fill the screen with the background
    color.

    \quotefromfile qtopiacore/ahigl/qscreenahigl_qws.cpp
    \skipto void QAhiGLScreen::redrawScreen()
    \printuntil glClear(GL_COLOR_BUFFER_BIT);

    Next it iterates over all the windows and use the helper function
    \c drawWindow() to draw each of them as a OpenGL texture to the screen.
    The texture id is either taken from the \c WindowInfo struct or from the
    window surface if it is a surface that's being painted using OpenGL, i.e
    a \c QAhiGLWindowSurface. We'll discuss this class shortly.

    \c drawWindow() takes a \c progress parameter that is used to create an
    animation effect if it's less than 1.0. We won't discuss the 
    \c drawWindow() function any further in this text, but point to the source
    code for more details.

    \skipto QAhiGLScreen::createSurface
    \printuntil /^\}/
    \skipto QAhiGLScreen::createSurface
    \printuntil /^\}/

    The two \l {QScreen::}{createSurface()} functions decides when  
    instantiate a QAhiGLWindowSurface. We do this whenever we create a
    QGLWidget and also for top-level windows that are under a certain size.
    The size contraint is a necessary for this particular OpenGL ES 
    implementation. Additionly this driver only supports use of
    OpenGL in the server process.

    The \c ShowAnimation() constructor initializes the timeline. Its
    \l {QTimeLine::valueChanged()} {valueChanged()} signal is
    connected to the screen driver's \c redrawScreen() slot, and its
    \l {QTimeLine::finished()} {finished()} signal is connectd to the
    QObject::deleteLater() slot. Finally, the constructor tells the
    timeline to \l {QTimeLine::start()} {start} the
    animation. ShowAnimation reimplements the \l
    {QTimeLine::}{valueForTime()} function, which returns the value
    used for customizing the shape of the curve used for the
    transition effect.

    For example, the window server's 
    \l {QWSServer::windowEvent()} {window event signal} is connected
    to the \c QAhiGLScreenPrivate::windowEvent() slot. If data member 
    \c doEffects is set, this slot performs the animation of the
    transition effect, whenever a new window is shown, or when an
    existing window is reshown after having been minimized. Note that
    \c doEffects will be set true at startup time if the 
    \c {-display ahigl:effects} option is included on the command line.



    \section2 The window Surface Class Implementation    

    The implementation of OpenGL ES tested with this example only supports
    one OpenGL context. This context is therefore shared between QAhiGLScreen
    and all instances QAhiGLWindowSurface and passed in the constructor.

    \quotefromfile qtopiacore/ahigl/qwindowsurface_ahigl.cpp
    \skipto QAhiGLWindowSurface::QAhiGLWindowSurface
    \printuntil /^\}/

    The constructor also creates an instance of \c QWSGLPaintDevice which is 
    returned in the \l {QWSWindowSurface::}{paintDevice()} function. This
    ensures that all \l {QPainter}s used on this surface will use an
    OpenGL enabled QPaintEngine.

    This example makes use of the OpenGL FrameBufferObject extension. All 
    painting is performed into a framebuffer object which is later
    compositioned onto the screen by QAhiGLScreen. Allocateding the framebuffer
    object is done in \l {QWindowSurface::}{setGeometry()}.

    \skipto QAhiGLWindowSurface::setGeometry
    \printuntil /^\}/

    Since there can be several instances of the QAhiGLWindowSurface, we need
    to make sure that the correct framebuffer object is active before painting.
    This is done by reimplementing \l QWindowSurface::beginPaint():

    \skipto QAhiGLWindowSurface::beginPaint
    \printuntil /^\}/

    Finally we need to make sure that whenever a widget grows beyond the size
    supported by this driver (256 x 256), the surface is deleted and a new
    standard surface is created instead. This is handled by reimplementing
    \l QWSWindowSurface::isValid():    

    \skipto QAhiGLWindowSurface::isValid
    \printuntil /^\}/
*/
