/*! 
    \example dialogs/simplewizard
    \title Simple Wizard Example

    The Simple Wizard example shows how to implement simple wizards
    in Qt.

    A wizard is a special type of input dialog that consists of a
    sequence of dialog pages. A wizard's purpose is to walk the user
    through a process step by step. Wizards are useful for complex or
    infrequently occurring tasks that users may find difficult to
    learn or do.

    \image simplewizard.png Screenshot of the Simple Wizard example

    Most wizards have a linear structure, with step 1 followed by
    step 2 and so on until the last step. Some wizards are more
    complex in that they allow different traversal paths based on the
    information provided by the user. The
    \l{dialogs/complexwizard}{Complex Wizard} example shows how to
    create such wizards.

    The Simple Wizard example consists of the following classes:

    \list
    \o \c SimpleWizard is an abstract base class that provides the
       basic framework for sequential wizards. You can use it in your
       own projects for implementing custom wizards.
    \o \c ClassWizard inherits \c SimpleWizard and provides a
       three-step wizard that generates the skeleton of a C++ class
       based on the user's input.
    \o \c FirstPage, \c SecondPage, and \c ThirdPage are QWidget
       subclasses that implement the wizard pages.
    \endlist

    \section1 SimpleWizard Class Definition

    \c SimpleWizard offers a \gui Cancel, a \gui Back, a \gui Next,
    and a \gui Finish button. It takes care of enabling and disabling
    the buttons as the user advances through the pages. For example,
    if the user is viewing the first page, \gui Back and \gui Finish
    are disabled.

    Here's the class definition:

    \quotefromfile dialogs/simplewizard/simplewizard.h
    \skipto class SimpleWizard :
    \printuntil /^\}/

    The \c SimpleWizard class inherits QDialog. Subclasses must
    reimplement the \c createPage() pure virtual function and call
    \c setNumPages() in their constructor. In addition, you can call
    \c setButtonEnabled() at any time to enable or disable the \gui Next
    button (or the \gui Finish button if the current page is the last
    page). This is useful to prevent the user from advancing to the
    next page before the current page is completed.

    The \c history member variable stores the list of wizard pages
    that the user has seen so far. When the user presses \gui Back,
    the previous page in the history list is retrieved so that the
    user can adjust their input when required.

    \section1 SimpleWizard Class Implementation

    First the constructor:

    \quotefromfile dialogs/simplewizard/simplewizard.cpp
    \skipto ::SimpleWizard
    \printuntil /^\}/

    We start by creating the \gui Cancel, \gui Back, \gui Next, and
    \gui Finish buttons and connecting their
    \l{QPushButton::clicked()}{clicked()} signals to \c SimpleWizard
    slots. The \l{QDialog::accept()}{accept()} and
    \l{QDialog::reject()}{reject()} slots are inherited from QDialog;
    they close the dialog and set the dialog's
    \l{QDialog::result()}{return code} to QDialog::Accepted or
    QDialog::Rejected. The \c backButtonClicked() and
    \c nextButtonClicked() are defined in \c SimpleWizard.

    After establishing the signal-slot connections, we put the
    buttons in a horizontal layout. We put a stretch item on the left
    (using QBoxLayout::addStretch()) to ensure that the buttons are
    pushed to the right side of the dialog.

    At the end, we nest the button's layout into a vertical layout
    called \c mainLayout. At this point, \c mainLayout isn't very
    useful, because it contains only one item, but we'll add one more
    item to it later on.

    \printline ::setButtonEnabled
    \printuntil /^\}/

    The \c setButtonEnabled() function is called by subclasses to enable
    or disable the \gui Next button. If the current page is the last
    page, we enable or disable the \gui Finish button instead.

    To determine whether the current page is the last page, we check
    the number of pages the user has visited so far (\c
    history.size()). If that number is the same as the wizard's total
    number of pages (\c numPages), we know it's the last page.

    \printline ::setNumPages
    \printuntil /^\}/

    The \c setNumPages() function must be called exactly once from the
    subclass's constructor. It initializes \c numPages and creates
    the first page using \c createPage(), which we will review in a
    moment.

    \printline ::backButtonClicked
    \printuntil /^\}/

    When the user clicks the \gui Back button, we update the enabled
    state of the other buttons, remove the last page from the history
    (the current page) and call \c switchPage() to change the page that
    is rendered.

    Strangely enough, the argument to \c switchPage() is the page that
    was the current page \e before the use clicked \gui Back (\c
    oldPage), not the page that will become the current page. The
    reason for this behavior will become clear when we implement
    \c switchPage().

    \printline ::nextButtonClicked
    \printuntil /^\}/

    When the user clicks the \gui Next button, we create a new page
    using \c createPage(). The argument to \c createPage() is the number
    of the page. The rest of the code is similar to the previous
    function.

    \printline ::switchPage
    \printuntil /^\}/

    In \c switchPage(), we hide the page that was current and remove it
    from the layout, assuming that there was a current page. (The
    first time \c switchPage() is called, from \c setNumPages(), the
    argument is a null pointer.)

    The new current page is always the last page in the history. We
    insert it into the vertical layout at position 0. This ensures
    that the page is displayed above the wizard buttons, which are
    grouped in a nested layout and occpy position 1 of the outer
    layout.

    We show the new current page and give it the focus. Then we
    update the state of the \gui Next and \gui Finish buttons based
    on whether the current page is the last page or not, and we
    update the window title.

    \section1 ClassWizard Class Definition

    We will now see how to subclass \c SimpleWizard to implement our
    own wizard. The concrete wizard class is called \c ClassWizard.
    It has three page:

    \table
    \row \i \inlineimage simplewizard-page1.png
            \inlineimage simplewizard-page2.png
            \inlineimage simplewizard-page3.png
    \endtable

    The first page asks for a class name and a base class, and allows
    the user to specify whether the class should have a \c Q_OBJECT
    macro and what constructors it should provide. The second page
    allows the user to set some options related to the code style,
    such as the macro used to protect the header file from multiple
    inclusion (e.g., \c MYDIALOG_H). Finally, the third page allows
    the user to specify the names of the output files.

    Although the program is just an example, if you press \gui
    Finish, C++ source files will actually be generated.

    Here's the class definition:

    \quotefromfile dialogs/simplewizard/classwizard.h
    \skipto class ClassWizard :
    \printuntil /^\}/

    The class reimplements the \c createPage() virtual function that we
    declared in \c SimpleWizard. It also reimplements QDialog's
    \l{QDialog::accept()}{accept()} slot.

    The private section of the class declares three data members: \c
    firstPage, \c secondPage, and \c thirdPage. In addition, the \c
    FirstPage, \c SecondPage, and \c ThirdPage widgets are declared
    friends of \c ClassWizard. This will make it possible for them to
    access the \c{ClassWizard}'s private members. In this case, we
    want every page to be able to access members in any other page,
    because the values set on one page may influence those on
    subsequent pages.

    An alternative design would have been to declare the \c
    firstPage, \c secondPage, and \c thirdPage members public, but
    that would have exposed them to the outside world.

    \section1 ClassWizard Class Implementation

    Here's the constructor:

    \quotefromfile dialogs/simplewizard/classwizard.cpp
    \skipto ::ClassWizard
    \printuntil /^\}/

    We call \c setNumPages() to tell \c SimpleWizard that our wizard
    has three pages.

    \printline ::createPage
    \printuntil /^\}/

    In \c createPage(), we create the page requested by \c
    SimpleWizard. We also store the return value in a member
    variable, so we can access it later.

    We don't need to worry about deleting the page later. Whenever
    the user presses \gui Back, the \c SimpleWizard deletes the page.
    The next time it needs the page, it will call \c createPage()
    again. This ensures that the page will be a fresh new page with
    correctly initialized values.

    \printline ::accept
    \printuntil QString implementation
    \dots
    \skipto QDialog::accept
    \printline QDialog::accept
    \printline }

    If the user clicks \gui Finish, we extract the information from
    the various pages and generate the files. The code is long and
    tedious (and unrelated to the noble art of designing wizards), so
    most of it is skipped here. See the actual example in the Qt
    distribution for the details if you're curious.

    \section1 The FirstPage, SecondPage, and ThirdPage Classes

    The pages are defined in \c classwizard.h and implemented in \c
    classwizard.cpp, together with \c ClassWizard.

    \quotefromfile dialogs/simplewizard/classwizard.h
    \skipto class FirstPage :
    \printuntil /^\}/

    The \c FirstPage class has a constructor that takes a \c
    ClassWizard, and a private slot called \c classNameChanged().

    The other classes in the quadrumvirate (\c ClassWizard, \c
    SecondPage, and \c ThirdPage) are declared as friends so that
    they can access the page's child widgets.

    \quotefromfile dialogs/simplewizard/classwizard.cpp
    \skipto ::FirstPage
    \printuntil baseClassLabel->setBuddy
    \dots
    \skipto connect(
    \printuntil ;
    \dots
    \skipto /^\}/
    \printline }

    The constructor sets up the dialog. The QObject::connect() call
    ensures that the \c classNameChanged() slot is called whenever
    the user modifies the name of the current class. That slot is
    responsible for enabling or desabling the wizard's \gui Next
    button.

    \skipto ::classNameChanged
    \printuntil /^\}/

    We set the \gui Next button enabled if and only if the \gui{Class
    name} editor has some contents.

    The \c SecondPage and \c ThirdPage classes are very similar to \c
    FirstPage, so we won't spend as much time reviewing them. One
    thing that's different with them is that they use values entered
    in the first page to initialize some of their fields.

    Let's have a look at \c SecondPage. In the constructor, we have
    the following code:

    \skipto QString className =
    \printuntil macroNameLineEdit->setText

    The value of the second page's \gui{Macro name} field on the
    first page's \gui{Class name} field. For example, if the class
    name is \c SuperDuperWidget, the default macro name is \c
    SUPERDUPERWIDGET_H. This is possible because of all the friends.
*/
