/*!
    \example motif/walkthrough
    \title Qt Motif Extension - A Migration Walkthrough

    \startpage motif-walkthrough-1.html Getting Started
    \nextpage motif-walkthrough-1.html Getting Started

    This walkthrough covers a complete migration of a Motif based program
    to the Qt toolkit using the Qt Motif extension.

    It is rarely practical for a large project with hundreds of thousands
    or even millions of lines of code to be migrated all at once; such an
    endeavor would require too many development resources and would incur
    significant risks. Every line of code would have to be rewritten,
    every user interface redesigned, and quality assurance tests and
    procedures all rewritten. The Qt Motif extension provides a
    complete and working solution for incremental migration that can be
    paced to suit each individual project and the available resources. The
    user interface and related code can be migrated in steps while the
    rest of the project need not be changed at all.

    This walkthrough is intended for programmers who will be
    migrating an existing Motif based project to the Qt toolkit. We
    assume that they have experience with C/C++ and Xt/Motif. Some
    experience with the Qt toolkit is also necessary. For developers
    completely new to Qt we recommend following the learning plan
    outlined in \l{How to Learn Qt}; or to go on a Qt training
    course. (See \l{http://www.trolltech.com/} for details of
    training courses.)

    \section1 Goals for the Walkthrough

    The goal of this walkthrough is to provide the reader with enough
    knowledge to migrate Motif applications to the Qt toolkit. We will do
    this by example: We will convert a real-world Motif based program
    step-by-step. This walkthrough will discuss both techniques and their
    rationales throughout the process. This walkthrough is broken down
    into individual chapters which cover a specific topic:

    \list 1
    \o \l{motif-walkthrough-1.html}{Getting Started}
    \o \l{motif-walkthrough-2.html}{Preparing to Migrate the User Interface}
    \o \l{motif-walkthrough-3.html}{Using Qt Standard Dialogs}
    \o \l{motif-walkthrough-4.html}{Using Custom QDialogs}
    \o \l{motif-walkthrough-5.html}{Using Existing Dialogs with QMotifDialog}
    \o \l{motif-walkthrough-6.html}{Using Qt Main Window Classes}
    \o \l{motif-walkthrough-7.html}{Refactoring Existing Code}
    \o \l{motif-walkthrough-8.html}{Replacing the View Widget}
    \o \l{motif-walkthrough-9.html}{Replacing the Print Dialog}
    \o \l{motif-walkthrough-10.html}{Continuing Development}
    \endlist

    We will use the \e todo demo program included with the Motif 2.x
    distribution as our migration project. This walkthrough contains
    references to the source code, which is included in the \c
    extensions/motif/examples/walkthrough subdirectory.

    \section1 Prerequisites

    Before we can start using the Qt Motif extension, we must satisfy
    these requirements:

    \list 1
    \o We are using the X11R6.x and Motif 2.x libraries.
    \o The project is compilable by a C++ compiler.
    \o We have built and installed the Qt Motif extension.
    \o We have built and linked the project with the Qt toolkit and the
    Qt Motif extension.
    \endlist

    \section2 X11R6.x and Motif 2.x Libraries

    The mechanisms used by the Qt Motif extension require development
    headers and libraries from the X11R6 release and the Motif 2.0
    release. Newer versions of these can also be used.

    \section2 C++ Compiler

    Since Qt is a C++ toolkit, all new code will be written in C++. In
    order for existing code to coexist with new code, a C++ compiler must
    be able to compile the existing code.

    It is possible to keep existing code and new code separate, and only
    convert or rewrite existing code as needed. This is a normal part
    of the migration process, and does not need to be done before the
    migration process begins. This is the most common scenario, and we
    will demonstrate it by migrating existing C code to C++ as needed in
    this walkthrough.

    \section2 Build and Install the Qt Motif Extension

    The Qt Motif extension is not built and installed along with the
    Qt toolkit. The extension resides in the \c extensions/motif
    subdirectory. Run \e make in this directory to build the extension
    and the examples. Once the extension has been built, run \e {make
    install}.

    \code
        $ cd extensions/motif
        $ make
        $ make install
    \endcode

    The Qt Motif extension is now installed and ready to use.

    \section2 Build and Link the Project with the Qt Toolkit and the Qt Motif Extension

    For simplicity, we use \e qmake to create the \c Makefile. The \c
    -project option causes \e qmake to automatically generate a project
    file. After \e {qmake -project} has generated our project file, we
    run \e qmake again to generate a \c Makefile. Now, we can just run \e
    make to build our project.

    \code
        $ qmake -project
        $ qmake
        $ make
    \endcode

    Everything builds correctly, but fails to link because we don't link
    with the Motif library. We tell \e qmake to do this by adding the \c
    -lXm to the \c LIBS variable in our project file. Since we are
    planning to use the Qt Motif extension in this project as well,
    we should also add \c -lqmotif to the list of libraries.

    \code
        LIBS += -lXm -lqmotif
    \endcode

    Now we regenerate our \c Makefile by running \c qmake again, and
    rebuild using \c make. This time, our project successfully links, and
    the application runs as expected.

    We are now ready to start using the Qt Motif extension.
*/

/*!
    \page motif-walkthrough-1.html
    \title Getting Started

    \contentspage motif/walkthrough Home
    \previouspage motif/walkthrough Home
    \nextpage motif-walkthrough-2.html Chapter 2

    \section1 Starting with QMotif and QApplication

    To be able to use Qt, we need to create a QApplication object. The
    QApplication class controls all the event delivery and display
    management for all other Qt objects and widgets. We need to use the
    QMotif class from the Qt Motif extension to allow QApplication
    and the \c XtAppContext to coexist.

    The QApplication object must be created in the \c main() function.
    We will need to modify \c {todo.c} to compile with a C++ compiler, so we
    rename \c {todo.c} to \c {todo.cpp}.

    Next, we add the appropriate includes for the QMotif and QApplication
    classes.

    \quotefromfile motif/walkthrough/start/todo.cpp
    \skipto // Qt includes
    \printuntil #include <qmotif.h>

    Next, we create the QMotif and QApplication objects. We create QMotif
    with a foreign \c XtAppContext, and we create QApplication with a
    foreign \c Display.

    \skipto XtVaAppInitialize
    \printuntil QApplication

    The next change is not yet necessary, but it is included to show that
    the Qt Motif extension provides a complete integration.
    Normally, a Motif based program would use the \c XtAppMainLoop()
    function to run the application's event loop. This is still possible,
    but since we are migrating to the Qt toolkit, we prefer to use the
    QApplication::exec() function for running the event loop.

    \skipuntil Eventloop integration
    \printuntil }

    Since we renamed \c {todo.c} to \c {todo.cpp}, we must change the
    project file and rerun \e qmake to regenerate our \c Makefile. When we
    build our project, there are compile and link errors: we will fix
    these in the following section.

    \section1 Migrating to C++

    We need to convert the code in this file to proper C++ code.
    Fortunately, the changes are not too large. Most files included from
    existing C projects are not C++ compatible, so we make them compatible
    by wrapping them in an \c {extern "C"} block.

    \quotefromfile motif/walkthrough/start/todo.cpp

    \skipuntil Wrap non-standard includes
    \printuntil } // extern "C"

    Global C functions that are forward declared must also be wrapped into
    an \c {extern "C"} block.

    \skipuntil Wrap extern/callback functions and global variables with extern "C"
    \printuntil } // extern "C"

    The \c manageCB() function needs to be converted to proper C++.

    \skipuntil Use proper C++ function declarations
    \printuntil }

    And we need to fix two invalid casts. One is in the \c Save() function.

    \skipuntil Temporarily fix invalid casts
    \printuntil SaveDB

    The other invalid cast is in the \c Open() function.

    \skipuntil Temporarily fix invalid casts
    \printuntil ReadDB

    After these changes, the project compiles and links, and the
    application runs and operates correctly.
*/

/*!
    \page motif-walkthrough-2.html
    \title Preparing to Migrate the User Interface

    \contentspage motif/walkthrough Home
    \previouspage motif-walkthrough-1.html Getting Started
    \nextpage motif-walkthrough-3.html Using Qt Standard Dialogs

    We are ready to start migrating the user interface for our project.
    As mentioned in the introduction, we do this in steps, ensuring that
    our application is still usable at every step of the migration process.

    The user interface can be viewed as a hierarchy; each top-level window
    and dialog depends upon a parent (which is another top-level window or
    dialog). When using Motif \c XmMainWindow widgets, these should be
    viewed as two separate entities: the \e {Main Window} widget with the
    popup-menu hierarchy and the \e View widget contained in the \e {Main
    Window} widget. The \e View widget depends on the \e {Main Window}
    widget.

    We begin migrating the pieces that have no dependencies, and work our
    way up the dependency tree until all the pieces have been migrated.

    The hierarchy for this project looks something like this:

    \img motif-todo.png Motif Todo Hierarchy

    We will begin by migrating and replacing all of the dialogs, then the
    \e {Main Window} widget with popup-menu hierarchy, and finally the \e
    View widget.

    However, we are not ready to begin just yet. The migration process can
    be long, but it does not have to be difficult. The \e Open, \e {Save
    As}, \e {Page Delete} and \e {IO Error} dialogs use Motif \c
    XmFileSelectionBox and \c XmMessageBox dialogs. Qt provides similar
    functionality with QFileDialog and QMessageBox, which we can begin
    using immediately.

    The \e Print dialog is special, however. The \e Print dialog cannot be
    replaced until after we have replaced the \e View widget. Qt provides
    a complete printing mechanism with QPrinter, but we cannot start using
    it until we have replaced the \e View widget.

    \section1 Removing the \e Help Dialog

    The \e Help dialog is also special. Instead of replacing the \e Help
    dialog with a custom QDialog, we will use the Qt \l{Help System}
    classes to provide a more advanced online help.
    However, we cannot start using classes like QToolTip and QWhatsThis
    until we replace the \e {Main Window} and \e View widgets.

    The help text included with the original project is very small
    and only contains information about the \c XmNoteBook widget. The
    use of tooltips and whats-this text will suffice for this
    example. If your migration project has a large online help
    system, we recommend using \l{Qt Assistant}.

    Removing the existing \e Help dialog is relatively simple. We remove
    the \c Xmd/Help.h, \c Xmd/HelpP.h and \c Xmd/Help.c files from our
    project file and regenerate our \c Makefile.

    The code to create the \e Help menu and \e Help dialog is in \c
    todo.cpp. We remove the \c Xmd/Help.h include, the \c *help_manager
    resource string, the \c help_cb() function forward declaration and the
    \c help_widget global variable. We also need to remove the code that
    creates the \e Help dialog. We will also remove the code to create
    the \e Help menu, since this menu is now empty. Finally, we remove
    the \c help_cb() function implementation.

    The \e Help dialog is now removed from our project. We cannot add
    QToolTip and QWhatsThis help at the moment, since we are still using
    \c XmMainWindow for the \e {Main Window} widget. Once we have
    migrated the \e {Main Window} and the popup-menu hierarchy, we can
    begin using QToolTip and QWhatsThis for online help.
*/

/*!
    \page motif-walkthrough-3.html
    \title Using Qt Standard Dialogs

    \contentspage motif/walkthrough Home
    \previouspage motif-walkthrough-2.html Preparing to Migrate the User Interface
    \nextpage motif-walkthrough-4.html Using Custom QDialogs

    We start by using two of Qt's \l{Standard Dialog Classes}{standard
    dialogs}: QFileDialog and QMessageBox. Both of these classes provide
    useful static convenience functions.

    \table
    \row \o QFileDialog::getOpenFileName() \o replacement for the \e Open dialog
    \row \o QFileDialog::getSaveFileName() \o replacement for the \e {Save As} dialog
    \row \o QMessageBox::information() \o replacement for \e {Page Delete} dialog
    \row \o QMessageBox::warning() \o replacement for \e {IO Error} dialog.
    \endtable

    Each of these functions takes a \e {QWidget *parent} argument. If we
    pass zero as the \e parent argument, then we will have dialogs that
    are centered on the screen, instead of being centered over our main
    window. We can have QMotifWidget create our \c XmMainWindow, and we
    can then use this class as the parent for both Motif dialogs and Qt
    dialogs.

    We need to include the appropriate headers for QMotifWidget and
    QFileDialog in \c todo.cpp.

    \quotefromfile motif/walkthrough/dialogs/todo.cpp
    \skipto Qt includes
    \printuntil qmotifwidget.h

    Next, we make a few modifications to how the application is
    initialized. We could initialize Xt/Motif and create the \c
    XtAppContext ourselves, but QMotif can do this for us.
    We also let QApplication open the connection to the X server. Next,
    we create a QMotifWidget, passing \c xmMainWindowWidgetClass as the \e
    widgetclass argument. We can now use the QMotifWidget::motifWidget()
    function to access the Motif widget. The shell widget is created
    automatically by QMotifWidget. We use \c XtParent() to access it.
    The top-level window is now a QMotifWidget, which means we can use it
    as the parent for the Qt Standard Dialogs.

    \skipto QMotif integrator
    \printuntil XtManageChild

    \section1 Replacing the \e {Open} and \e {Save As} Dialogs

    First, we completely remove all use of the existing Motif file
    selection dialog. We remove the \c Xm/FileSB.h include, the global \c
    file_dialog variable, and the code to create the dialog. We also
    remove the \c PresentFDialog() callback function. None of this code
    is needed to use QFileDialog.

    After removing the \c PresentFDialog() callback function, we need to
    make \e Open and \e {Save As} popup-menu callbacks call the \c Open()
    and \c Save() functions.

    First we must change the declaration of these two functions.

    \quotefromfile motif/walkthrough/dialogs/todo.cpp

    \skipto Wrap extern/callback functions and global variables with extern "C"
    \skipto void Open
    \printto void Print

    We also change the arguments to the callbacks. We pass the top-level
    QMotifWidget as the \c client_data to these functions, since we will
    be using it as the parent for the QFileDialog.

    \skipto // XtAddCallback(file_menu[FILE_OPEN], XmNactivateCallback,
    \printuntil (XtCallbackProc) Open, (XtPointer) &toplevel);
    \dots
    \skipto // XtAddCallback(file_menu[FILE_SAVE_AS], XmNactivateCallback,
    \printuntil (XtCallbackProc) Save, (XtPointer) &toplevel);

    Next, we modify the \c Save() function to use
    QFileDialog::getSaveFileName().

    \skipuntil Save using QFileDialog
    \printuntil SaveDB

    ... and the \c Open() function to use QFileDialog::getOpenFileName().

    \skipuntil Open using QFileDialog
    \printuntil ReadDB

    After we build the project, the application runs and operates as
    expected. The difference is that the \e Open and \e {Save As} dialogs
    now use QFileDialog.

    \section1 Replacing the \e {Page Delete} and \e {IO Error} Dialogs

    The \e {Page Delete} dialog is created and used in \c {actions.c}. We
    need to migrate this file to C++. We rename it to \c {actions.cpp},
    modify the project file and regenerate the \c Makefile.

    The changes required to make \c {actions.cpp} compile are minimal. We
    need to wrap more C header files and global variables in an \c {extern
    "C"} block.

    \quotefromfile motif/walkthrough/dialogs/actions.cpp

    \skipuntil Wrap non-standard includes and global variables with extern "C"
    \printuntil extern int maxpages

    We need to forward declare the \c NewPage(), \c DeletePage(), \c
    EditPage() and \c SaveIt() functions so that the compiler generates
    the correct symbols for these functions.

    \printuntil } // extern "C"

    We need to fix a single invalid pointer cast.

    \skipto // XtFree((XtPointer) pages[currentPage]);
    \printline
    \printline

    And we need to change the variable named \e new to \e newstr in the \c
    Trim() function.

    We can now change the \c DeletePage() function to use
    QMessageBox::information().

    First, we need to make sure we include the proper header for
    QMessageBox.

    \quotefromfile motif/walkthrough/dialogs/actions.cpp
    \skipto Qt includes
    \printuntil #include <qmessagebox.h>

    The code for \c DeletePage() looks like this:

    \skipuntil DeletePage using QMessageBox
    \printuntil return

    At this point in the code, the page should be deleted. The code to do
    this is in the \c DoDeletePage() function. We move the contents of \c
    DoDeletePage() to this point and remove the \c DoDeletePage() function
    completely.

    Next, we change \c {todo.cpp} to pass the top-level QMotifWidget as the
    \c client_data tot he \c DeletePage() function.

    \quotefromfile motif/walkthrough/dialogs/todo.cpp

    \skipto // XtAddCallback(selected_menu[SELECTED_DELETE], XmNactivateCallback,
    \printuntil (XtCallbackProc) DeletePage, (XtPointer) &toplevel

    The \e {IO Error} dialog is created and used in \c {io.c}. We need to
    migrate this file to C++. We rename it to \c {io.cpp}, modify the
    project file and regenerate the \c Makefile.

    The changes required to make \c {io.cpp} compile are minimal. We need
    to wrap more C header files and global variables in an \c {extern "C"}
    block.

    \quotefromfile motif/walkthrough/dialogs/io.cpp

    \skipuntil Wrap non-standard includes and global variables with extern "C"
    \printuntil Page AllocPage()

    We need to forward declare the \c ReadDB() and \c SaveDB() functions
    so that the compiler generates the correct symbols for these
    functions.

    \printuntil } // extern "C"

    The \c ParseNewLines() function needs to be converted to proper C++.

    \skipuntil Convert ParseNewLines to proper C++
    \printuntil look for "\n"

    The \c PrintWithNewLines() function also needs to be converted to proper
    C++.

    \skipuntil Convert PrintWithNewLines to proper C++
    \printuntil look for '\n'

    We can now change the \c ReadDB() and \c SaveDB() functions to use
    QMessageBox::warning().

    First, we need to make sure we include the proper header for QMessageBox.

    \quotefromfile motif/walkthrough/dialogs/io.cpp
    \skipto Qt includes
    \printline
    \printline

    The code for \c ReadDB() looks like this:

    \skipto input = fopen(filename, "r")
    \printuntil Destroy current pages on reread
    \dots

    The code for \c SaveDB() looks like this:

    \skipto (access(filename, F_OK) == 0
    \printuntil Append a ~ to make the old filename
    \dots

    After we build the project, the application runs and operates as
    expected. The difference is that the \e {Page Delete} and \e {IO
    Error} dialogs now use QMessageBox.
*/

/*!
    \page motif-walkthrough-4.html
    \title Using Custom QDialogs

    \contentspage motif/walkthrough Home
    \previouspage motif-walkthrough-3.html Using Qt Standard Dialogs
    \nextpage motif-walkthrough-5.html Using Existing Dialogs with QMotifDialog

    After we have replaced the standard dialogs, we move onto the custom
    dialogs. This project has a single custom dialog: the \e {Page Edit}
    dialog.

    Instead of writing the code ourselves, we use Qt Designer
    to create our dialog.  Designing a custom dialog is beyond the scope of
    this document: see the \l{Qt Designer Manual} if you're unfamiliar
    with Qt's visual design tool.

    \section1 Replacing the \e {Page Edit} Dialog

    The custom QDialog description for the \e {Page Edit} dialog is saved
    as \c pageeditdialog.ui. We add this file to the project file by
    adding the line
    \code
    FORMS += pageeditdialog.ui
    \endcode
    to the \c{.pro} file, and regenerate the \c Makefile. The \e uic
    utility generates the code for our custom QDialog, which is then
    compiled and linked into our application. (\e uic is invoked
    automatically from makefiles generated from \c{.pro} files.)

    We need to pass the top-level QMotifWidget as the \e client_data
    argument to the \c EditPage function, which we will use as the parent
    for our new \c PageEditDialog. We do this the same way as we have
    done for the \e Open and \e {Save As} dialogs in \c todo.cpp.

    \quotefromfile motif/walkthrough/dialogs/todo.cpp

    \skipto // XtAddCallback(selected_menu[SELECTED_PROPERTIES], XmNactivateCallback,
    \printuntil (XtCallbackProc) EditPage, (XtPointer) &toplevel );

    The \c EditPage() function is implemented in \c actions.cpp. We start
    by adding the includes needed for the \c PageEditDialog and QLineEdit.

    \quotefromfile motif/walkthrough/dialogs/actions.cpp

    \skipto // PageEditDialog includes
    \printline
    \printline
    \printline

    In the \c EditPage() function, We create the \c PageEditDialog, set
    the initial values of the three QLineEdit widgets with values from the
    current page and execute the dialog.

    \skipuntil // EditPage using custom QDialog
    \printuntil if ( result != QDialog::Accepted )
    \printuntil return
    \dots

    At this point in the code, the page properties should be modified. The
    code to do this is in the \c DoEditPage() function. We move the
    contents of \c DoEditPage() to this point and remove the \c
    DoEditPage() function completely.

    The \c Page struct defined in \c page.h stores strings in \c {char*}
    arrays. Since the PageEditDialog and the data it contains will be
    destroyed when we return from this function, we need to convert the
    unicode QString data into a QCString in the local encoding and
    duplicate it with \c qstrdup().

    \skipto // pages[currentPage] -> label = XmTextFieldGetString(labelEditW);
    \printuntil pages[currentPage]->label = qstrdup( qstr.local8Bit().data() );

    The same process must be done for the minorTab text:

    \skipto // temp = XmTextGetString(minorTabW);
    \printuntil temp = qstrdup( qstr.local8Bit().data() );

    ... and for the majorTab text:

    \skipto // temp = XmTextGetString(majorTabW);
    \printuntil temp = qstrdup( qstr.local8Bit().data() );
*/

/*!
    \page motif-walkthrough-5.html
    \title Using Existing Dialogs with QMotifDialog

    \contentspage motif/walkthrough Home
    \previouspage motif-walkthrough-4.html Using Custom QDialogs
    \nextpage motif-walkthrough-6.html Using Qt Main Window Classes

    As mentioned earlier, the \e Print dialog cannot be replaced until we
    have converted the \e View widget. The \e Print dialog will be
    removed once we have finished our migration, since we will use
    QPrinter instead. Based on this information, we decide that it is not
    worth replacing the \e Print dialog with a custom QDialog replacement.
    Instead, we will keep the Motif based dialog and use QMotifDialog to
    integrate the dialog with the application.

    \section1 Modality Requirements

    Modality with QDialog is different from Motif. The QDialog::exec()
    function does not return until the dialog is finished. In Motif,
    modality is simply a property of the shell, and the application
    programmer must write QDialog::exec() style functionality if they
    want that behavior.

    Since we will be using QMotifDialog (which is a QDialog subclass), we
    will need to have an \e accept and a \e reject callback for each
    dialog we integrate with QMotifDialog. The predefined Motif dialogs
    have these already: the \c XmNokCallback and \c XmNcancelCallback
    callbacks. However, the \e Print dialog only has an \e accept callback
    (the \c XmdNprintCallback), but it does not have a \e reject callback.
    We need to add this.

    This is easily done. We add an \c XtCallbackList for the \c
    XmNcancelCallback callback in \c Xmd/PrintP.h:

    \quotefromfile motif/walkthrough/Xmd/PrintP.h
    \skipto print_callback
    \printline
    \printline

    We add the \c XmNcancelCallback callback to the list of resources for
    the \c XmdPrint widget class in \c Xmd/Print.c:

    \quotefromfile motif/walkthrough/Xmd/Print.c
    \skipto XmdNprintCallback
    \printuntil XmRPointer, (XtPointer) NULL }
    \printuntil XmRPointer, (XtPointer) NULL }

    We need to activate this callback whenever we unmanage the widget and
    do not activate the \e print callback, which is in the \c do_help_cb()
    function:

    \skipto do_help_cb(Widget button, Widget pw, XtPointer ignore)
    \printuntil XtUnmanageChild
    \printline

    ... and in the unmanage_cb() function:

    \skipto unmanage_cb(Widget button, Widget pw, XtPointer ignore)
    \printuntil XtUnmanageChild
    \printline

    \section1 Integrating the \e Print Dialog

    Now that the \e Print dialog has the appropriate \e accept and \e
    reject callbacks, we can use QMotifDialog. First we need to include
    the QMotifDialog header in \c todo.cpp.

    \quotefromfile motif/walkthrough/dialogs/todo.cpp

    \skipto qmotifdialog.h
    \printline

    We add a \c ShowPrintDialog() function which will create and execute the
    print dialog.

    \skipto void ShowPrintDialog(Widget, XtPointer, XmPushButtonCallbackStruct *);
    \printline

    We change the \e Print menu item callback to call the new \c
    ShowPrintDialog() function. We pass the top-level QMotifWidget, which
    we will use as the parent for the dialog.

    \skipto XtAddCallback(file_menu[FILE_PRINT], XmNactivateCallback,
    \printuntil (XtCallbackProc) ShowPrintDialog, (XtPointer) &toplevel);

    The \c ShowPrintDialog() function creates the \e Print dialog and
    executes it. We use the \c XmdNprintCallback callback to accept the
    dialog and the \c XmNcancelCallback callback to reject the dialog. We
    can do this easily by using the QMotifDialog::acceptCallback() and
    QMotifDialog::rejectCallback() functions, respectively. We also
    ensure that the \e print callback continues to call the \c
    Print() function as before.

    \skipto ShowPrintDialog(Widget, XtPointer client_data,
    \printuntil dialog.exec();
    \printline

    After we build the project, the application runs and operates as
    expected. There is no visual or behavioral difference, even though
    the \e Print dialog is using QMotifDialog.
*/

/*!
    \page motif-walkthrough-6.html
    \title Using Qt Main Window Classes

    \contentspage motif/walkthrough Home
    \previouspage motif-walkthrough-5.html Using Existing Dialogs with QMotifDialog
    \nextpage motif-walkthrough-7.html Refactoring Existing Code

    After we have replaced all the dialogs, we are ready to begin replacing
    the \e {Main Window}. \l{motif-walkthrough-4.html}{As mentioned
    above}, we will replace the existing \c XmMainWindow and
    popup-menu hierarchy with QMainWindow and friends.

    We will use Qt Designer to design our new main window. 

    \section1 Implementing the \e {Main Window}

    The description for the \e {Main Window} is saved as \c mainwindow.ui.
    We add this file to the project file and regenerate the \c Makefile.
    The \e uic utility generates the code for our \e {Main Window}, which
    is then compiled and linked into our application.

    \e {Qt Designer} also created the \c mainwindow.ui.h file. We need to
    add the implementation for our \e {Main Window} to this skeleton
    implementation.

    We begin by adding the necessary includes for QApplication
    and QMotifWidget.

    \quotefromfile motif/walkthrough/mainwindow/mainwindow.ui.h

    \skipuntil Qt includes
    \printuntil qmotifwidget.h

    We need includes for the Motif callback structs and the \c XmdPrint
    widget.

    \skipuntil Motif includes
    \printline
    \skipuntil Demo includes
    \printline

    We are now ready to add implementations for the slots in our \e {Main
    Window}. We have one slot per menu item. Each slot will call the
    existing callback functions found in \c todo.cpp and \c actions.cpp.

    \table
    \header \i31 File menu
    \row \o New \o \c MainWindow::fileNew() \o calls the \c New() callback
    \row \o Open \o \c MainWindow::fileOpen() \o calls the \c Open() callback
    \row \o Save \o \c MainWindow::fileSave() \o calls the \c SaveIt() callback
    \row \o Save As \o \c MainWindow::fileSaveAs() \o calls the \c Save() callback
    \row \o Print \o \c MainWindow::filePrint() \o calls the \c ShowPrintDialog() callback
    \row \o Exit \o \c MainWindow::fileExit() \o calls QApplication::quit()
    \header \i31 Selected menu
    \row \o Properties \o \c MainWindow::selProperties() \o calls the \c EditPage() callback
    \row \o New \o \c MainWindow::selNewPage() \o calls the \c NewPage() callback
    \row \o Delete to Trash \o \c MainWindow::selDeletePage() \o calls the \c DeletePage() callback
    \endtable

    We need to add forward declarations for these callbacks before we can
    use them.

    \skipuntil Existing functions/variables found in todo.cpp and action.cpp
    \printuntil // extern "C"

    Each of the existing callback functions takes three arguments. We pass
    \e NULL to all of the arguments in this example (with a few exceptions,
    see below). The existing code does not rely on any of the arguments.
    Each slot implementation is a single line calling the related callback
    function. The code is not very interesting and would just take up
    space, so we've omitted it.

    There are four exceptions to the above. The \c Open(), \c Save(), \c
    EditPage() and \c DeletePage() callbacks accept a pointer to the
    toplevel QWidget as argument 2 (the \e client_data argument). For
    these four functions, we pass \e this as the second argument, which is
    a toplevel \c MainWindow derived from QMainWindow.

    \section1 Replacing the \e {Main Window}

    The next step is to use the new \e {Main Window} in our application.
    The changes needed in \c todo.cpp are large due to the large amount of
    code being removed.

    First, we add the include for our new \e {Main Window}.

    \quotefromfile motif/walkthrough/mainwindow/todo.cpp

    \skipuntil Qt based Main Window
    \printuntil mainwindow.h

    We can cleanup the Motif includes, since many of them are no longer
    needed.

    \skipuntil Motif include files
    \printuntil Text.h
    \skipto Print.h
    \printline
    \skipto page.h
    \printline

    The \c QuitAppl() and \c manageCB() callbacks are not needed any more,
    so we remove them. We do not need the global \c shell variable
    either. We remove it and all references to it in the \c New(), \c
    Save() and \c Open() callbacks.

    In \c main(), we make the large changes. First, we use our new \c
    MainWindow instead of QMotifWidget with \c XmMainWindow.

    \quotefromfile motif/walkthrough/mainwindow/todo.cpp

    \skipto QMotif integrator
    \printuntil app.setMainWidget( &mainwindow );

    We will now use QMotifWidget to create the \c XmNotebook widget.

    \skipto n = 0;
    \printuntil notebook = center->motifWidget();

    We remove all of the code used to create the Motif menus. The
    remaining code in \c main() is self-explanatory.

    \printuntil return app.exec();
    \printline

    Our application is now using QMainWindow instead of \c XmMainWindow.
    After we build the project, the application runs and operates as
    expected.
*/

/*!
    \page motif-walkthrough-7.html
    \title Refactoring Existing Code

    \contentspage motif/walkthrough Home
    \previouspage motif-walkthrough-6.html Using Qt Main Window Classes
    \nextpage motif-walkthrough-8.html Replacing the View Widget

    In the author's view, the existing code is slightly disorganized.
    Even though the code \e does work, some cleanups and reorganization
    can only help with readability and maintainability. The steps
    described below are not necessary during the migration process but are
    included for completeness.

    \section1 Migrating Data Structures to C++

    The \c Page data structure is an opaque data type. The real data
    structure is called \c PageRec; \c Page defined to be a pointer to a
    \c PageRec. In addition, we have the \c AllocPage() function that
    allocates and initializes memory for a \c PageRec struct.

    With C++, we can do this in the constructor. We can also write a
    destructor which automatically frees all resources in the \c PageRec,
    instead of having to do it in several different places.

    The \c PageRec struct declaration is removed from \c page.h. We
    declare a \c Page struct with the same data members as \c PageRec, a
    constructor and a destructor.

    \quotefromfile motif/walkthrough/refactor/page.h
    \skipto struct Page {
    \printuntil int lastcursorpos;
    \printline

    The existing \c pages, \c currentPage and \c maxpages global variables
    are removed from the source files. We replace them with \c extern
    declarations in \c page.h.

    \skipto extern Page *pages[];
    \printuntil extern int maxpages;

    The global variable instantiations are placed in \c todo.cpp.

    Each source file contains function declarations that deal with the
    global \c Page related variables. We remove these declarations from
    the source files and declare them once in the \c page.h header file.

    \skipto void SetPage(int);
    \printuntil void FixPages();

    Now that \c Page has a constructor, we remove the \c AllocPage()
    function. It is no longer needed. The calls to \c AllocPage() are
    replaced with \c {'new Page()'} in the \c NewPage(), \c DeletePage()
    and \c ReadDB() functions. We also replace the code to deallocate
    pages with \c {delete pages[X]}, where \e X is the appropriate index
    value. This is done in the \c ReadDB and \c DeletePage() functions.

    Code that accesses the global \c pages variable does not need to be
    modified since the data members of the \c Page struct did not change.
    The existing code will continue to work.

    The \c OptionsRec struct declared in \c page.h is also updated,
    following the same pattern as the \c Page struct above.

    \skipto struct Options {
    \printuntil extern Options options;

    The global variable instantiation is also placed in \c todo.cpp.

    Code that accesses the global \c options variable does not need to be
    modified since the data members of the \c Options struct did not
    change. The existing code will continue to work.

    \section1 Using \e new and \e delete

    The destructors of the \c Page and \c Options structs use \e delete
    instead of \c XtFree() to deallocate all \c char* members. This is a
    necessary change since we are migrating away from Xt/Motif. We need
    to fix existing code that modifies the \c Page struct members to use
    \e new and \e delete ( instead of \c XtMalloc(), \c XtNewString() and
    \c XtFree() ).

    The \c PageChange() function in \c todo.cpp simply saves the contents
    and cursor position of current page before calling \c SetPage(). We
    use \e new and \e delete when modifying members of the \c Page struct.

    \quotefromfile motif/walkthrough/refactor/todo.cpp
    \skipto PageChange(Widget, XtPointer, XmNotebookCallbackStruct *cs)
    \printuntil delete [] pages[currentPage] -> page;

    When storing the context of the \c XmText widget, we use \c qstrdup()
    to make a copy of the string returned by the \c XmTextGetString()
    function.

    \printuntil SetPage(cs -> page_number - 1);
    \printline

    The \c ReadDB() function in \c io.cpp needs similar changes. We
    replace all use of \c XtMalloc() and \c XtNewString() with \e new and
    \c qstrdup(), respectively.

    This needs to be done just after opening the file.

    \quotefromfile motif/walkthrough/refactor/io.cpp
    \skipto if (input != NULL) {
    \printuntil pages[0] = new Page();

    ... when starting a new page ...

    \dots
    \skipto pages[number] -> page = buffer;
    \printuntil pages[number] = new Page();

    ... and when reading in the label and tab texts/

    \dots
    \skipto pages[number] -> label = qstrdup( &line[2] );
    \printline
    \dots
    \skipto pages[number] -> majorTab = qstrdup( &line[2] );
    \printline
    \dots
    \skipto pages[number] -> minorTab = qstrdup( &line[2] );
    \printline

    The \c ReadDB() function uses \c XtRealloc() to expand the data
    storage buffer. Unfortunately, C++ does not provide a way to
    reallocate an existing block of data, so we have to do this ourselves.

    \skipto // C++ doesn't have 'renew'
    \printuntil max = newmax;

    There is also one occurrence in \c ReadDB() where we call \c XtMalloc()
    with an argument of 2. This was done when a file could not be read.
    Creating an empty string is not necessary, so we remove this code
    instead of using \e new.

    \skipto if (input == NULL) {
    \printuntil } else {
    \printuntil }

    The \c SaveDB() function in \c io.cpp also needs these changes. We
    change one occurrence of \c XtFree() to \e delete.

    \skipto SaveDB(char* filename)
    \skipto Make sure to grab current page
    \printuntil delete [] pages[currentPage] -> page;

    Finally, We need to replace two occurrences of \c XtNewString() in the \c
    main() function in \c todo.cpp.

    \quotefromfile motif/walkthrough/refactor/todo.cpp
    \skipto if (options.todoFile == NULL) {
    \printuntil options.todoFile = qstrdup( options.todoFile );
    \printline

    \section1 Moving Existing Code

    The rest of the refactoring process involves moving existing code into
    new places. Currently, each function in the \c mainwindow.ui.h file
    simply calls the old callback handlers present in the other files.
    Instead of calling the old callback functions, the implementations are
    moved accordingly.

    \table
    \header \o Function             \o Original File  \o Moved to Function 
    \row    \o \c New()             \o \c todo.cpp    \o \c MainWindow::fileNew()
    \row    \o \c Open()            \o \c todo.cpp    \o \c MainWindow::fileOpen()
    \row    \o \c SaveIt()          \o \c actions.cpp \o \c MainWindow::fileSave()
    \row    \o \c Save()            \o \c todo.cpp    \o \c MainWindow::fileSaveAs()
    \row    \o \c ShowPrintDialog() \o \c todo.cpp    \o \c MainWindow::filePrint()
    \row    \o \c EditPage()        \o \c actions.cpp \o \c MainWindow::selProperties()
    \row    \o \c NewPage()         \o \c actions.cpp \o \c MainWindow::selNewPage()
    \row    \o \c DeletePage()      \o \c actions.cpp \o \c MainWindow::selDeletePage()
    \endtable

    The \c Print() callback function is still used by the \e {Print}
    dialog, so we move it into \c mainwindow.ui.h and make it \c static.

    Previously, the \c Open(), \c Save(), \c EditPage() and \c DeletePage()
    functions created dialogs with \e client_data as the parent argument.
    Since we have moved the code directly into the \e {Main Window}
    implementation, we create these dialogs with \e this as the parent
    argument.

    The \c PageChange() callback function is moved from \c actions.cpp
    to \c todo.cpp and made \c static since it is not used anywhere else.

    Earlier modifications to \c actions.cpp caused the \c Trim() function
    to become redundant, so we remove it.

    The \c MIN() and \c MAX() macros in \c todo.cpp are redundant. Qt
    provides the \c qMin() and \c qMax() functions which we will use.

    Earlier modifications caused the \c fallback_resources array to become
    redundant, so we remove it. 

    In the near future, our program will not use Motif any more, and we
    will no longer need to use QMotif. To prepare for this, we remove the
    \c resources and \c optionDesc arrays and create the QMotif instance
    with just the \e APP_CLASS argument.

    The \c #include statements in the source files are mostly incorrect
    due to the refactoring changes. Many of the \c #include statements
    are no longer needed. The \c #include statements from each file are
    listed below, instead of describing which includes are removed and
    added to each file.  

    Includes for \c actions.cpp:

    \quotefromfile motif/walkthrough/refactor/actions.cpp
    \skipuntil // Motif includes
    \printuntil #include "page.h"

    Includes for \c io.cpp:

    \quotefromfile motif/walkthrough/refactor/io.cpp
    \skipuntil // Qt includes
    \printto // Motif includes
    \skipline
    \printto // Demo includes
    \skipline
    \printuntil }

    Includes for \c todo.cpp:

    \quotefromfile motif/walkthrough/refactor/todo.cpp
    \skipuntil // MainWindow includes
    \printline
    \skipuntil // Qt includes
    \printuntil stdlib
    \skipuntil // Motif includes
    \printuntil page.h

    Includes for \c mainwindow.ui.h:

    \quotefromfile motif/walkthrough/refactor/mainwindow.ui.h
    \skipuntil // PageEditDialog includes
    \printline
    \skipuntil // Qt includes
    \printuntil unistd
    \skipuntil // X includes
    \printuntil Xatom
    \skipuntil // Motif includes
    \printuntil Text.h
    \skipuntil // Demo includes
    \printuntil // extern
*/

/*!
    \page motif-walkthrough-8.html
    \title Replacing the View Widget

    \contentspage motif/walkthrough Home
    \previouspage motif-walkthrough-7.html Refactoring Existing Code
    \nextpage motif-walkthrough-9.html Replacing the Print Dialog

    We are ready to start replacing the \e {View} widget. However, our
    example program uses the \c XmNotebook widget class. Qt does not
    provide a direct equivalent of this class, so we are faced with three
    possibilities, each with several advantages and disadvantages.

    \list 1

    \o We can continue the conversion using existing Qt widgets.

    \list

    \o Advantages - The widgets provided by Qt are well designed and
    tested, allowing us to quickly redesign the user interface.

    \o Disadvantages - Most, if not all, of the existing data structures
    and code will need to be modified or rewritten. New code must be
    written in a way that maintains compatibility with previous versions
    of our application.

    \endlist

    \o We can write a new QWidget subclass that is identical to the \c
    XmNotebook widget class.

    \list

    \o Advantages - The existing data structures will not change, allowing
    compatibility with previous and future versions.

    \o Disadvantages - The new widget will need to be written and
    regression tested. Existing code in our application will need to be
    changed in order to deal with the new widget's API.

    \endlist

    \o We can leave the \c XmNotebook widget untouched.

    \list

    \o Advantages - The existing data structures and code remain
    unchanged, allowing us to continue development on other projects,
    new features, etc.

    \o Disadvantages - This is the simplest solution, but the application
    will still be dependent upon X11; we will not be able to deploy our
    application on all platforms supported by Qt.

    \endlist

    \endlist

    We will use the first approach to complete the migration of the
    example project used in this walkthrough, using QTextEdit, QLabel and
    QSpinBox to provide a similar look. The only difference is that we
    will not have tabs.

    We use Qt Designer to add the QTextEdit, QLabel and QSpinBox widgets to
    the \e {Main Window} widget.

    \section1 Data Structure Modifications

    The \c Page struct contains \c majorPB and \c minorPB members which
    need to be removed.  These members correspond to the tabs displayed in
    the existing version. The new version will not have any tabs, so we
    remove them.

    \quotefromfile motif/walkthrough/view/page.h
    \skipto struct Page {
    \printuntil int lastcursorpos;
    \printline

    \section1 Code Modifications

    Most of the existing functions in our application need to be modified
    to work with the new \e View widget. The \c MainWindow class has five
    new functions that correspond to existing functions.

    \table
    \header \o Existing Function            \o New Function 
    \row    \o \c {void SetPage( int ) }    \o \c {void MainWindow::setPage( int )}
    \row    \o \c {void PageChange( ... )}  \o \c {void MainWnidow::pageChange( int )}
    \row    \o \c {void TextChanged( ... )} \o \c {void MainWnidow::textChanged()}
    \row    \o \c {void ReadDB( char * )}   \o \c {void MainWindow::readDB( char * )}
    \row    \o \c {void SaveDB( char * )}   \o \c {void MainWindow::saveDB( char * )}
    \endtable

    \target mainwindow-ui-h-view-widget-modifications

    The \c SetPage() function implementation is moved to the \c
    MainWindow::setPage() function in \c mainwindow.ui.h. We remove the
    \c SetPage() function declaration and implementation from \c page.h
    and \c actions.cpp, respectively. In order to make \c
    MainWindow::setPage() work correctly, we need to modify the code to
    use the new widgets in our \e {Main Window} widget.

    \quotefromfile motif/walkthrough/view/mainwindow.ui.h
    \skipto void MainWindow::setPage( int pageNumber )
    \printto if ( pageNumber <= maxpages )

    First, we set the current value of the \c spinbox to the current page
    number.

    \printto if ( pages[pageNumber] ) {

    Next, we set the current text and cursor position of the \c textedit
    to the contents of the current page.

    \printto if ( pages[pageNumber]->label ) {

    If the current page has a custom label, we set it as the current text
    of the \c textlabel; otherwise we set the \c textlabel contents to
    "Page X" (where X is the current page number).

    \printto if ( pages[pageNumber]->majorTab ) {

    If the current page has major and/or minor tab text, we append these
    to the \c labeltext. This ensures that all information entered by the
    user remains visible.

    \printto } else {

    We should continue to handle the possibility that the current page
    does not exist. In this case, we clear the contents of the \c
    textedit widget and set the \c textlabel contents to the current page
    number (with an indication that the page is invalid).

    \printuntil textlabel->setText( labeltext );
    \printuntil }
    \printuntil }

    The \c PageChange() function is moved from \c todo.cpp to the \c
    MainWindow::pageChange() function in \c mainwindow.ui.h. As with the
    \c MainWindow::setPae() function, we need to modify the code to use
    the new widgets in our \e {Main Window} widget.

    Note: QTextEdit::text() returns a QString, which needs to be converted
    into a normal \c char* array. To do this we create a copy of the
    string in the local encoding. We need to make the copy using \c
    qstrdup() because the data contained in the QCString returned by
    QString::local8Bit() is deallocated when the QCString is destroyed.

    \skipto void MainWindow::pageChange( int pageNumber )
    \printuntil setPage( pageNumber - 1 );
    \printline

    The \c TextChanged() function does nothing more than set the \c
    modified variable to 1. Our new \c MainWindow::textChanged() function
    does exactly the same.

    \skipto void MainWindow::textChanged()
    \printuntil modified = 1;
    \printline

    Since both the \c MainWindow::pageChange() and \c
    MainWindow::textChanged() functions access the \c modified global
    variable, we add a forward declaration at the top of \c
    mainwindow.ui.h.

    \target io-cpp-view-widget-modifications

    The \c ReadDB() and \c SaveDB() implementations in \c io.cpp are
    renamed to \c MainWindow::readDB() and \c MainWindow::saveDB(),
    respectively. We need to modify the code in order to make the code
    work properly.

    First, We add \c #include statements for the \c MainWindow, QSpinBox
    and QTextEdit classes.

    \quotefromfile motif/walkthrough/view/io.cpp
    \skipuntil // Local includes
    \printuntil page.h
    \skipuntil // Qt includes
    \printuntil qtextedit.h

    The new \c MainWindow::readDB() and \c MainWindow::saveDB() functions
    will not use any Xt/Motif functions, so we remove the Xt/Motif \c
    #include statements and the global variables \c notebook and \c textw.
    These functions remain largely unchanged, maintaining compatibility
    with previous versions. Also, the \c ReadDB() and \c SaveDB()
    functions have been converted into \c MainWindow member functions, so
    we can pass \e this as the \e parent argument to the QMessageBox
    functions.

    \skipto QMessageBox::warning( this, "IO Error", message.arg(filename) );
    \printline

    After reading the file in the \c MainWindow::readDB() function, we set
    the current and maximum values of the \c spinbox to the appropriate
    values.

    \quotefromfile motif/walkthrough/view/io.cpp

    \skipto void MainWindow::readDB( char *filename )
    \skipto maxpages = number;
    \printuntil if (input) fclose(input);

    In the \c MainWindow::saveDB() function, we need to store the text
    currently displayed, so we use QTextEdit::text() instead of \c
    XmTextGetString(). Note: QTextEdit::text() returns a QString, which
    needs to be converted into a normal \c char* array. To do this we
    create a copy of the string in the local encoding. We need to make
    the copy using \c qstrdup() because the data contained in the QCString
    returned by QString::local8Bit() is deallocated when the QCString is
    destroyed.

    \skipto void MainWindow::saveDB( char *filename )
    \skipto Make sure to grab current page
    \printuntil pages[currentPage] -> page = qstrdup( textedit->text().local8Bit() );
    \printline

    \target actions-cpp-viewwidget-modifications

    Due to the removal of the \c majorPB and \c minorPB members from the
    \c Page struct, the \c FixPages() function in \c actions.cpp is no
    longer needed. We remove the implementation and forward declaration
    of \c FixPages() from \c actions.cpp and \c page.h, respectively.
    Calls to \c FixPages() are removed from the \c
    MainWindow::selNewPage() and \c MainWindow::selDeletePage(), both of
    which are in \c mainwindow.ui.h.

    We move \c AdjustPages() to \c mainwindow.ui.h and make it \c static,
    since it is only used in this file. We remove the forward declaration
    from \c page.h as well.

    After our modifications, the \c actions.cpp file is empty. We remove
    it from our project file and regenerate our \c Makefile.

    \target todo-cpp-view-widget-modifications

    Now that we have implemented our new \e View widget, we need to remove
    the old Motif based view widget from \c todo.cpp.

    Since we will not be using any Motif widgets, we remove all Motif \c
    #include statements, including \c qmotifwidget.h. 

    \quotefromfile motif/walkthrough/view/todo.cpp
    \skipuntil // Local includes
    \printuntil page.h
    \skipuntil // Qt includes
    \printuntil stdlib.h

    We also remove the forward declarations of the \c ReadDB() function
    and the \c notebook, \c textw and \c labelw global variables.

    \skipuntil // Global data
    \printuntil int modified = 0;

    Next, we remove the \c center widget, which uses QMotifWidget. The \e
    {Main Window} widget and \e View widget are contained entirely in our
    \c MainWindow class, so no extra initialization is needed after
    creating the \c mainwindow widget.

    \skipto int main( int argc, char **argv )
    \printuntil app.setMainWidget( &mainwindow );

    Since the \c ReadDB() and \c SetPage() functions have been changed into
    \c MainWindow member functions, we need to call them using our \c
    mainwindow instance.

    \skipto mainwindow.readDB(options.todoFile);
    \printuntil return app.exec();
    \printline

    The \e View widget has now been replaced. After building our project,
    we confirm that the application works correctly.
*/

/*!
    \page motif-walkthrough-9.html
    \title Replacing the Print Dialog

    \contentspage motif/walkthrough Home
    \previouspage motif-walkthrough-8.html Replacing the View Widget
    \nextpage motif-walkthrough-10.html Continuing Development

    The \e {Print} dialog is the last component in our application that
    uses Motif. The current \c Print() function does nothing more than
    write the plain text to a temporary file, and then executes 'lpr' to
    send the text to the printer. Since we will use QPrinter, we do not
    this function any more, so we remove it. The current \c
    MainWindow::filePrint() implementation is removed as well. We will
    write a new \c MainWindow::filePrint() implementation in \c
    mainwindow.ui.h.

    Note: The steps involved in using the QPrinter class are beyond
    the scope of this walkthrough and will not be discussed here.

    For completeness, the code to initialize a QPrinter object is included below.

    \quotefromfile motif/walkthrough/print/mainwindow.ui.h
    \skipto void MainWindow::filePrint()
    \printto qApp->setOverrideCursor( QCursor( Qt::WaitCursor ) );

    \section1 Using Rich Text for Printing

    Qt provides rich text using a subset of HTML. The QSimpleRichText
    class makes rich text printing simple. All we need to do is create a
    string with the proper format tags inserted at the appropriate
    places. For our example, we will keep the printing output similar to
    previous versions.

    First, we create the format tags that we will use.

    \skipuntil compose rich text string
    \printuntil const QString pagebreak = QString::fromLatin1( "<hr>" );

    Next we just loop over all pages, appending the page label, contents
    and formatting characters to a \c printtext variable (which is a
    QString).

    \printuntil printtext += pagebreak;
    \printline

    The rest of the \c MainWindow::filePrint() function is the actual
    printing code. Here we simply create a QSimpleRichText object using
    the string we created above, and draw this string on the QPrinter
    object using QPainter.

    \skipto QPaintDeviceMetrics metrics( p.device() );
    \printuntil qApp->restoreOverrideCursor();
    \printline

    \section1 Removing the Dependency on Xt/Motif

    Our application no longer uses any Xt or Motif widgets. We can now
    finish removing the dependencies on Xt and Motif.

    First, we cleanup the \c #include statements in \c mainwindow.ui.h.

    \quotefromfile motif/walkthrough/print/mainwindow.ui.h

    \skipuntil // Local includes
    \printuntil page.h
    \skipuntil // Qt includes
    \printuntil unistd.h

    The \c MainWindow::fileNew() function uses the \c Boolean and \c False
    keywords from the Xt library. C++ has these built into the language,
    so we use \c bool and \c false instead.

    The last modification needed to completely remove Xt and Motif from
    our application is to stop using the QMotif class. We remove the
    qmotif.h \c #include statement from \c todo.cpp, and remove the
    instantiation from the \c main() function.

    After doing this, we can remove the \c -lXm and \c -lqmotif from the
    \c LIBS variable in our project file. Our project file also contains
    source and headers for the the old custom Motif widgets previously
    used in our application. We remove these as well.

    After regenerating the \c Makefile and building our project, we
    confirm that the application works correctly.
*/

/*!
    \page motif-walkthrough-10.html
    \title Continuing Development

    \contentspage motif/walkthrough Home
    \previouspage motif-walkthrough-9.html Replacing the Print Dialog

    We have not quite finished with the migration to Qt, even though our
    project does not use Motif any more. Qt provides many useful features
    that we can begin using immediately. Some of the most interesting
    ones are presented below as a guide for where to start extending your
    existing projects.

    \section1 Using Unicode

    Support for \l internationalization is very easy
    with Qt. Using QString instead of \c {char*} for storing text gives
    us support for most of the written languages around the world. Our \c
    Page and \c Options structs look much simpler now.

    \quotefromfile motif/walkthrough/page.h

    \skipto struct Page
    \printuntil };

    \skipto struct Options
    \printuntil };

    All functions that use the \c Page and \c Options structs need to be
    updated to use QString properly. Since QString is also an implicitly
    shared class, we no longer have to do any memory management with our
    strings. We can remove all occurrences of the \c qstrdup() function,
    and we never need to use \e new or \e delete when done with a string.
    QString will allocate and delete data when needed.

    Here are the \c MainWindow::fileOpen() and \c MainWindow::pageChange()
    functions from \c mainwindow.ui.h. Notice that the code no longer
    uses \e delete or \c qstrdup() when storing text.

    \quotefromfile motif/walkthrough/mainwindow.ui.h

    \skipto void MainWindow::fileOpen()
    \printuntil setPage( currentPage );
    \printline
    \printline
    \dots
    \skipto void MainWindow::pageChange
    \printuntil setPage( pageNumber - 1 );
    \printline

    Almost all of the functions in our application are affected by this
    change. In most cases, we end up removing more code than we are
    adding. To keep the size of this walkthrough reasonable, we've only
    shown a small portion of the required changes, since the changes are
    very similar to those shown above.

    \section1 Writing Platform-Independent Code

    Qt provides many \l{Input/Output and Networking}{input and output}
    classes. We can use these in \c MainWindow::readDB() and
    \c MainWindow::saveDB().
    Currently, these functions use functions only found on Unix machines.
    Using QFile and QTextStream removes this dependency on Unix, and we can
    begin building and testing our application on Microsoft Windows and
    Apple Mac OS X.

    The platform-independent versions of the \c MainWindow::readDB() and
    \c MainWindow::saveDB() functions can be found in the \c io.cpp file.

    \section1 Designing a Modern User Interface

    Since we used the \e {Qt Designer} to design the \e {Main Window}
    widget, we can extend the interface easily. We can use some of the
    more advanced features of QMainWindow, which includes dockable
    toolbars. Adding these is simple with the \e {Qt Designer}. The
    final version of our project includes a toolbar, which provides quick
    access to the \e Open, \e Save, \e Print, \e {New Page} and \e {Delete
    to Trash} actions.  

    The possibilities are endless. An \e Edit menu, with the common \e
    Cut, \e Copy and \e Paste actions, could be added in a relatively
    short period of time. As our project expands to other platforms, we
    could add menus and dialogs that allow us synchronize todo lists
    between a normal desktop computer and a handheld device running with
    Qt/Embedded.
*/
