/*!
    \example layouts/basiclayouts
    \title Basic Layouts Example

    The Basic layout example shows how to use the standard layout
    managers that are available in Qt: QBoxLayout and QGridLayout.

    \image basiclayouts-example.png Screenshot of the Basic Layouts example

    The QBoxLayout class lines up widgets horizontally or
    vertically. QHBoxLayout and QVBoxLayout are convenience classes
    corresponding to the layout's orientation. They inherit
    QBoxLayout, and are the easiest way to use QBoxLayout.

    \section1 Dialog Class Definition

    \quotefromfile layouts/basiclayouts/dialog.h
    \skipto class Dialog
    \printuntil /^\}/

    The Dialog class inherits QWidget. It is a custom widget that
    displays its child widgets using the geometry managers:
    QHBoxLayout, OVBoxLayout and QGridLayout.

    We create three private functions to simplify the class
    constructor:

    The \c createMenu() function creates and populates a menu bar. The
    \c createHorizontalGroupBox() function creates a group box
    containing four buttons managed by a horizontal layout, and \c
    createGridGroupBox() creates a group box containing three line
    edits and a small editor managed by a grid layout.

    \section1 Dialog Class Implementation

    \quotefromfile layouts/basiclayouts/dialog.cpp
    \skipto Dialog
    \printto mainLayout

    In the constructor, we create several widgets that the example
    uses to demonstrate how the layout affect their appearances. Some
    of them are grouped together and given their own internal layouts.

    \printline mainLayout

    The main layout for the \c Dialog widget is a QVBoxLayout.

    The QBoxLayout class takes in general the space it gets (from its
    parent layout or from the parent widget), divides it up into a
    series of boxes, and makes each managed widget fill one box.  If
    the QBoxLayout's orientation is \c Qt::Horizontal the boxes are
    placed in a row. If the orientation is \c Qt::Vertical, the boxes
    are placed in a column.  The corresponding convenience classes are
    QHBoxLayout and QVBoxLayout, respectively.

    \printline setMenuBar

    When we call the QLayout::setMenubar() function, the layout places
    the provided menu bar at the top of the parent widget, and outside
    the widgets \l {QWidget::contentsMargins()}{content margins}. All
    child widgets are placed below the bottom edge of the menu bar.

    \skipto addWidget
    \printuntil /^\}/

    We use the QBoxLayout::addWidget() function to add the widgets to
    the end of the main layout. Each widget will get at least its
    minimum size and at most its maximum size. It is possible to
    specify a stretch factor in the \l
    {QBoxLayout::addWidget}{addWidget()} function, and any excess
    space is shared according to these stretch factors. If it's not
    specified, a widget's stretch factor is 0 by default.

    In the same way, we can use QBoxLayout::addLayout() to add another
    layout, and its widgets, to the end of the main layout. Again it
    is possible to specify a stretch factor which, if not specified,
    is 0 by default.

    Then, when we call QWidget::setLayout() to install the main layout
    on the \c Dialog widget, we automatically reparent all of the
    layout's widgets to be children of the \c Dialog widget.

    \skipto createMenu
    \printuntil /^\}/

    In the private \c createMenu() function we create a horizontal
    menu bar, and add a pull down \gui File menu containing an \gui
    Exit option.

    \skipto createHorizontalGroupBox
    \printuntil /^\}/

    When we create the horizontal group box, we use a QHBoxLayout as
    the internal layout. We create the buttons we want to put in the
    group box, add them to the layout and install the layout on the
    group box.

    \skipto createGridGroupBox
    \printuntil layout

    In the \c createGridGroupBox() function we use a QGridLayout which
    lays out widgets in a grid. It takes the space made available to
    it (by its parent layout or by the parent widget), divides it up
    into rows and columns, and puts each widget it manages into the
    correct cell.

    \skipto for
    \printto smallEditor

    For each row in the grid we create a label and an associated line
    edit, and add them to the layout. The QGridLayout::addWidget()
    function differ from the corresponding function in QBoxLayout: It
    needs the row and column specifying the grid cell to put the
    widget in.

    \skipto smallEditor
    \printuntil addWidget

    QGridlayout::addWidget() can in addition take arguments specifying
    the number of rows and columns the cell will be spanning. In this
    example, we create a small editor which we span over three rows
    and one column.

    For both the QBoxLayout::addWidget() and QGridLayout::addWidget()
    functions it is also possible to add a last argument specifying
    the widget's alignment. By default it fills the whole cell. But we
    could, for example, align a widget with the right edge by
    specifying the alignment to be Qt::AlignRight.

    \skipto setColumnStretch
    \printuntil /^\}/

    Each column in a grid layout has a stretch factor. The stretch
    factor is set using QGridLayout::setColumnStretch() and determines
    how much of the available space the column will get over and above
    its necessary minimum. If not specified, the stretch factor is 0
    by default.

    Columns and rows behave identically; there is an equivalent
    stretch factor for rows, as well as a QGridLayout::setRowStretch()
    function.

    In this example, we set the stretch factors for the second and
    third column (the first column is number 0). The stretch factor is
    relative to the other columns in this grid; columns with a higher
    stretch factor take more of the available space. So the third
    column in our grid layout will get more of the available space
    than the second, and the first column will not grow at all since
    its stretch factor has not been explicitly set and is 0 by
    default.
*/
