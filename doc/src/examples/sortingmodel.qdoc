/*!
    \example itemviews/sortingmodel
    \title Sorting Model Example

    The Sorting Model example shows how to use a proxy model with a source
    model to present both sorted and unsorted data to views.

    \image sortingmodel-example.png

    \omit
    Sort the "top-level" child items of the real parent according to the
    values in the specified column and the sort order.
    These items are not necessarily in the top level of the model; we
    sort items beneath the parent irrespective of its location in the model.

    Proxy model need to supply their own model indexes to views. They cannot
    just pass model indexes from the underlying model on to the view because
    the view may rely on the model specified in the item. Additionally, if
    the proxy model exposes a different structure for the items in the
    underlying model, and therefore assigns different locations for them,
    the view may get confused if the row and column numbers for the items
    returned are different to those it requested.

    When creating model indexes for use by views, we only need to ensure
    that the combination of values that they contain are unique for each
    item. This usually means that child items of a given parent can each
    use some property of the parent index (perhaps its internal identifier)
    as the internal identifier for that index. The row and column numbers
    will then uniquely identify the child items.

    However, to ensure that the model correctly handles persistent model
    indexes, the requirements for index properties need to be more strictly
    defined. Since the proxy model may change the locations of the items
    it supplies to views, combinations of the row and column numbers are
    not sufficient to uniquely identify children of a given parent since
    they may move around.

    The solution to this problem is to create each proxy model index using
    the internal identifier of the corresponding index from the underlying
    model. However, since the index() function needs to create indexes
    based on an item's row, column, and parent index, and since we cannot
    determine the correct child item from the underlying model (because the
    order of items may be different), we need to be able to relate these
    values to a unique index. We do this by mapping a model index containing
    the row, column, and parent identifier to a model index containing the
    row, column, and child identifier.

    Possible optimizations: we could define internalHash as

    QHash<QModelIndex,int> internalHash;

    since we have the row and column information needed to generate a
    unique index in the index() function, and we only need the internal
    identifier of the underlying index to complete the necessary information.
    We can then use createIndex(row, column, id) to recreate the index
    rather than store it in internalHash.
    \endomit
*/
