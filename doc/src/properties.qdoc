/*!
    \page properties.html
    \title Qt's Property System
    \ingroup architecture
    \brief An overview of Qt's property system.

    Qt provides a sophisticated property system similar to the ones
    supplied by some compiler vendors. However, as a compiler- and
    platform-independent library, Qt does not rely on non-standard
    compiler features like \c __property or \c [property]. The Qt
    solution works with \e any standard C++ compiler on every platform
    Qt supports. It is based on the \l {Meta-Object System} that also
    provides inter-object communication via \l{signals and slots}.

    \section1 Requirements for Declaring Properties

    To declare a property, use the \l {Q_PROPERTY()} {Q_PROPERTY()}
    macro in a class that inherits QObject. 

    \code
        Q_PROPERTY(type name
                   READ getFunction
                   [WRITE setFunction]
                   [RESET resetFunction]
                   [DESIGNABLE bool]
                   [SCRIPTABLE bool]
                   [STORED bool]
		   [USER bool])
    \endcode

    Here are some typical examples of property declarations taken from
    class QWidget.

    \code
        Q_PROPERTY(bool focus READ hasFocus)
	Q_PROPERTY(bool enabled READ isEnabled WRITE setEnabled)
	Q_PROPERTY(QCursor cursor READ cursor WRITE setCursor RESET unsetCursor)
    \endcode

    A property behaves like a class data member, but it has additional
    features that can be accessed through the \l {Meta-Object System}.

    \list 

    \o A \c READ accessor function is required. It is for reading the
    property value. It must be const and must return either the
    property's type or a pointer or reference to that type. e.g.,
    QWidget::focus is a read-only property with \c READ function
    QWidget::hasFocus().

    \o A \c WRITE accessor function is optional. It is for setting the
    property value. It must return void and must take exactly one
    argument, either of the property's type or a pointer or reference
    to that type. e.g., QWidget::enabled has the \c WRITE function
    QWidget::setEnabled().  Read-only properties do not need \c WRITE
    functions. e.g., QWidget::focus has no \c WRITE function.

    \o A \c RESET function is optional. It is for setting the property
    back to its context specific default value. e.g., QWidget::cursor
    has the typical \c READ and \c WRITE functions, QWidget::cursor()
    and QWidget::setCursor(), and it also has a \c RESET function,
    QWidget::unsetCursor(), since no call to QWidget::setCursor() can
    mean \e {reset to the context specific cursor}. The \c RESET
    function musrt return void and take no parameters.

    \o The \c DESIGNABLE attribute indicates whether the property
    should be visible in the property editor of GUI design tool (e.g.,
    \l {Qt Designer}). Most properties are \c DESIGNABLE (default
    true). Instead of true or false, you can specify a boolean
    member function.

    \o The \c SCRIPTABLE attribute indicates whether this property
    should be accessible by a scripting engine (default true).
    Instead of true or false, you can specify a boolean member
    function.

    \o The \c STORED attribute indicates whether the property should
    be thought of as existing on its own or as depending on other
    values. It also indicates whether the property value must be saved
    when storing the object's state. Most properties are \c STORED
    (default true), but e.g., QWidget::minimumWidth() has \c STORED
    false, because its value is just taken from the width component
    of property QWidget::minimumSize(), which is a QSize.

    \o The \c USER attribute indicates whether the property is
    designated as the user-facing or user-editable property for the
    class. Normally, there is only one \c USER property per class
    (default false). e.g., QAbstractButton::checked is the user
    editable property for (checkable) buttons. Note that QItemDelegate
    gets and sets a widget's \c USER property.

    \endlist

    The \c READ, \c WRITE, and \c RESET functions can be inherited.
    They can also be virtual. When they are inherited in classes where
    multiple inheritance is used, they must come from the first
    inherited class.

    The type in a Q_PROPERTY() declaration can be any QVariant
    supported type, or it can be a user-defined type.

    \code
        Q_PROPERTY(QDate date READ getDate WRITE setDate)
    \endcode

    Since the date property's type is the user-defined QDate class,
    the \c{<QDate>} header file must be included for the above
    property declaration.

    In the case of QList and QMap properties, the property value is a
    QVariant whose value is the entire list or map.  Note that the
    Q_PROPERTY string cannot contain commas, since commas separate
    macro arguments. Therefore, you must type \c QMap instead of \c
    QMap<QString,QVariant>. For coherence, we also expect the same for
    \c QValueList<QVariant>, the other template class supported by
    QVariant.

    \section1 Reading and Writing Properties with the Meta-Object System

    A property can be read and written using the generic functions
    QObject::property() and QObject::setProperty(), without knowing
    anything about the owning class except the property's name.  In
    the code snippet below, the call to QAbstractButton::setDown() and
    the call to QObject::setProperty() both set property "down".

    \code
        QPushButton *button = new QPushButton;
        QObject *object = button;
        // button and object point to the same object

        button->setDown(true);
        object->setProperty("down", true);
    \endcode

    Accessing a property through its \c WRITE accessor is the better
    of the two, because it is faster and gives better diagnostics at
    compile time, but setting the property this way requires that you
    know about the class at compile time. Accessing properties by name
    lets you access classes you don't know about at compile time. You
    can \e discover a class's properties at run time by querying its
    QObject, QMetaObject, and \l {QMetaProperty} {QMetaProperties}.

    \code
	QObject *object = ...
        const QMetaObject *metaobject = object->metaObject();
	int count = metaobject->propertyCount();
	for (int i=0; i<count; ++i) {
	    QMetaProperty metaproperty = metaobject->property(i);
	    const char *name = metaproperty.name();
	    QVariant value = object->property(name);
	    ...
	}
    \endcode

    In the above snippet, QMetaObject::property() is used to get \l
    {QMetaProperty} {metadata} about each property defined in some
    unknown class. The property name is fetched from the metadata and
    passed to QObject::property() to get the \l {QVariant} {value} of
    the property in the current \l {QObject}{object}.

    \section1 A Simple Example

    Suppose we have a class MyClass, which is derived from QObject and
    which contains the Q_OBJECT macro in its private section. We want
    to declare a property in MyClass to keep track of priorty value.
    The type of the property will be an enum defined in the class.

    We include a Q_PROPERTY() macro in the private section of MyClass
    to declare the property. The property is named priority, and its
    type is enum Property.  The required \c READ function is also
    named priority, and we include a \c WRITE function named
    setPriority.  We must register enum Priority in the \l
    {Meta-Object System} to make its values available as strings for
    use in calls to QObject::setProperty(). The Q_ENUMS() macro is
    used for this. We must also include our own declarations for the
    \c READ and \c WRITE functions. The MyClass declaration then looks
    like this:

    \code
        class MyClass : public QObject
        {
            Q_OBJECT
            Q_PROPERTY(Priority priority READ priority WRITE setPriority)
            Q_ENUMS(Priority)

        public:
            MyClass(QObject *parent = 0);
            ~MyClass();

            enum Priority { High, Low, VeryHigh, VeryLow };

            void setPriority(Priority priority);
            Priority priority() const;
        };
    \endcode

    The \c READ function is const and returns the property type. The
    \c WRITE function returns void and has exactly one parameter,
    which is of the property type. The meta-object compiler enforces
    these requirements.

    Given a pointer to an instance of MyClass or a pointer to an
    instance of QObject that happens to be an instance of MyClass, we
    have two ways to set its priority property.

    \code
        MyClass *myinstance = new MyClass;
        QObject *object = myinstance;

        myinstance->setPriority(MyClass::VeryHigh);
        object->setProperty("priority", "VeryHigh");
    \endcode


    \section2 Using Enums and Flags as property types.

    If you want to register an enum that is declared in another class,
    the enum must be fully qualified with the name of the class
    defining it. In addition, the class defining the enum has to
    inherit QObject as well as declare the enum using Q_ENUMS().

    A similar macro, Q_FLAGS(), is also available. Like Q_ENUMS(), it
    registers an enumeration type but marks it as a set of \e flags,
    i.e. the enumeration values can be OR'd together. An I/O class
    might have enumeration values \c Read and \c Write and accept
    \c{Read | Write}. 

    \section1 Adding Additional Information to a Class

    Connected to the property system is an additional macro,
    Q_CLASSINFO(), that can be used to attach additional
    \e{name}--\e{value} pairs to a class's meta-object, for example:

    \code
        Q_CLASSINFO("Version", "3.0.0")
    \endcode

    Like other meta-data, class information is accessible at run-time
    through the meta-object; see QMetaObject::classInfo() for details.

    \section1 Dynamic Properties

    In addition to properties defined using Q_PROPERTY in a class it is possible
    to dynamically add and remove properties to any QObject at run-time.

    If setProperty is called with a property not statically defined using Q_PROPERTY
    it is automatically added as dynamic property and its value is stored in the object.
    The value can be queried using the property() method, just like with static properties.

    \sa {Meta-Object System}, {Signals and Slots}
*/
