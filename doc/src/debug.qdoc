/****************************************************************************
**
** Qt Debugging Techniques
**
** Copyright  (C) 1992-2003 Trolltech AS. All rights reserved.
**
** This file is part of the Qt GUI Toolkit.
** EDITIONS: FREE, PROFESSIONAL, ENTERPRISE
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
****************************************************************************/

/*!
\page debug.html

\title Debugging Techniques

Here we present some useful hints to debugging your Qt-based software.

\section1 Command Line Options

When you run a Qt program you can specify several command line options
that can help with debugging.

\table
\header \i Option \i Result
\row \i -nograb
     \i The application should never grab \link QWidget::grabMouse()
	the mouse\endlink or \link QWidget::grabKeyboard() the
	keyboard \endlink. This option is set by default when the
	program is running in the \c gdb debugger under Linux.
\row \i -dograb
     \i Ignore any implicit or explicit -nograb. -dograb wins over
	-nograb even when -nograb is last on the command line.
\row \i -sync
     \i Runs the application in X synchronous mode. Synchronous mode
	forces the X server to perform each X client request
	immediately and not use buffer optimization. It makes the
	program easier to debug and often much slower. The -sync
	option is only valid for the X11 version of Qt.
\endtable


\section1 Warning and Debugging Messages

Qt includes four global functions for writing out warning and debug
text.
\list
\i \link ::qDebug() qDebug()\endlink for writing debug output for
testing etc.
\i \link ::qWarning() qWarning()\endlink for writing warning output
when program errors occur. 
\i \link ::qSystemWarning() qSystemWarning()\endlink for writing
warning output when system errors occur. The output is completed by
the system's last error message (if available).
\i \link ::qFatal() qFatal()\endlink for writing fatal error messages
and exiting.
\endlist

The Qt implementation of these functions prints the text to the \c
stderr output under Unix/X11 and to the debugger under Windows. You
can take over these functions by installing a message handler; \link
::qInstallMsgHandler() qInstallMsgHandler()\endlink. 

If the environment variable \c QT_FATAL_WARNINGS is defined,
qWarning() exits after printing the warning message. This makes it
possible to easily locate errors in a debugger.

Note that qDebug() and qWarning() are debugging tools only, they do
nothing if \c QT_NO_DEBUG was defined during compilation; whereas
qSystemWarning() and qFatal() also apply in release mode.

The debugging functions \l QObject::dumpObjectTree() and \l
QObject::dumpObjectInfo() are often useful when an application looks
or acts strangely. More useful if you use object names than not, but
often useful even without names.

\section1 Debugging Macros

The header file \c qglobal.h contains some debugging macros and
\c{#define}s.

Three important macros are:
\list
\i \link ::Q_ASSERT() Q_ASSERT(b)\endlink where b is a boolean
expression, writes the warning: "ASSERT: 'b"' in file file.cpp, line
234" and exits if b is false.
\i \link ::Q_ASSERT_X() Q_ASSERT_X(b, where, what)\endlink where b is a
boolean expression, where a location and  what a message, 
writes the warning: "ASSERTfailure in where: 'what', file file.cpp, line 234" 
and exits if b is false.
\i \link ::Q_CHECK_PTR() Q_CHECK_PTR(p)\endlink where p is a pointer.
Writes the warning "In file file.cpp, line 234: Out of memory" and
exits if p is 0.
\endlist

These macros are useful for detecting program errors, e.g. like this:
\code
  char *alloc( int size )
  {
      Q_ASSERT( size > 0 );
      char *p = new char[size];
      Q_CHECK_PTR( p );
      return p;
  }
\endcode

Note that Q_ASSERT, Q_ASSERT_X and Q_CHECK_PTR are null expressions if
\c QT_NO_DEBUG was defined during compilation. Any code in them will
simply not be executed. Here is an example of how you should \e not
use Q_ASSERT and Q_CHECK_PTR:

\code
  char *alloc( int size )
  {
      char *p;
      Q_CHECK_PTR( p = new char[size] ); // WRONG!
      return p;
  }
\endcode

The problem is tricky: \e p is set to a sane value only as long as the
correct checking flags are defined. If this code is compiled with the
QT_NO_DEBUG flag defined, the code in the Q_CHECK_PTR expression is
not executed (correctly, since it's only a debugging aid) and \e alloc
returns a wild pointer.

The Qt library contains hundreds of internal checks that will print
warning messages when some error is detected. We thus recommend using
a debug build of Qt when developing Qt-based software.

\section1 Common bugs

There is one bug that is so common that it deserves mention here: If
you include the Q_OBJECT macro in a class declaration and run the
\link moc.html moc\endlink, but forget to link the moc-generated
object code into your executable, you will get very confusing error
messages. Any link error complaining about a lack of \c{vtbl},
\c{_vtbl}, \c{__vtbl} or similar is likely to be a result of this
problem.

*/
