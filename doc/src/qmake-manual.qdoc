/*!
    \page qmake-manual.html
    \title qmake Manual
    \startpage index.html Qt Reference Documentation
    \nextpage Using qmake

    \keyword qmake

    \c qmake is an tool from Trolltech that helps simplify the build
    process for development project across different platforms.  \c qmake
    automates the generation of Makefiles so that only a few lines of
    information are needed to create each Makefile. \c qmake can be used for
    any software project, whether it is written in Qt or not.

    \c qmake generates a Makefile based on the information in a project
    file.  Project files are created by the developer, and are usually
    simple, but more sophisticated project files can be created for
    complex projects.
    \c qmake contains additional features to support development with Qt,
    automatically including build rules for \l{moc.html}{moc}
    and \l{uic.html}{uic}.
    \c qmake can also generate projects for Microsoft Visual studio
    without requiring the developer to change the project file.

    Table of contents:

    \list
    \o \l{Using qmake}
      \tableofcontents{1 Using qmake}
    \o \l{qmake Project Files}
      \tableofcontents{1 qmake Project Files}
    \o \l{Running qmake}
      \tableofcontents{1 Running qmake}
    \o \l{qmake Advanced Usage}
      \tableofcontents{1 qmake Advanced Usage}
    \o \l{qmake Reference}
      \tableofcontents{1 qmake Reference}
    \endlist

    Getting Started:

    \list
    \o \l{qmake Tutorial}
      \tableofcontents{1 qmake Tutorial}
    \o \l{qmake Common Projects}
      \tableofcontents{1 qmake Common Projects}
    \endlist
*/

/*!
    \page qmake-using.html
    \title Using qmake
    \contentspage qmake-manual.html Contents
    \previouspage qmake Manual
    \nextpage qmake Project Files

    \c qmake provides a project-oriented system for managing the build
    process for applications, libraries, and other components. This
    approach gives developers control over the source files used, and
    allows each of the steps in the process to be described concisely,
    typically within a single file. \c qmake expands the information in
    each project file to a Makefile that executes the necessary commands
    for compiling and linking.

    In this document, we provide a basic introduction to project files,
    describe some of the main features of \c qmake, and show how to use
    \c qmake on the command line.

    \section1 Describing a Project

    Projects are described by the contents of project (\c .pro) files.
    The information within these is used by \c qmake to generate a Makefile
    containing all the commands that are needed to build each project.
    Project files typically contain a list of source and header files,
    general configuration information, and any application-specific details,
    such as a list of extra libraries to link against, or a list of extra
    include paths to use.

    Project files can contain a number of different elements, including
    comments, variable declarations, built-in functions, and some simple
    control structures. In most simple projects, it is only necessary
    to declare the source and header files that are used to build the
    project with some basic configuration options.

    Complete examples of project files can be found in the
    \l{qmake Tutorial}.
    An introduction to project files can be found in the
    \l{qmake Project Files} chapter, and a more detailed description is
    available in the \l{qmake Reference}.

    \section1 Building a Project

    For simple projects, you only need to run \c qmake in the top
    level directory of your project. By default, \c qmake generates a
    Makefile that you then use to build the project, and you can then
    run your platform's \c make tool to build the project.

    \c qmake can also be used to generate project files. A full
    description of \c{qmake}'s command line options can be found in the
    \l{Running qmake} chapter of this manual.
*/

/*!
    \page qmake-project-files.html
    \title qmake Project Files
    \contentspage qmake-manual.html Contents
    \previouspage Using qmake
    \nextpage Running qmake

    Project files contain all the information required by \c qmake to build
    your application, library, or plugin. The resources used by your project
    are generally specified using a series of declarations, but support for
    simple programming constructs allow you to describe different build
    processes for different platforms and environments.

    \tableofcontents

    \section1 Project File Elements

    The project file format used by \c qmake can be used to support both
    simple and fairly complex build systems. Simple project files will
    use a straightforward declarative style, defining standard variables
    to indicate the source and header files that are used in the project.
    Complex projects may use the control flow structures to fine-tune the
    build process.

    The following sections describe the different types of elements used
    in project files.

    \section2 Variables

    In a project file, variables are used to hold lists of strings.
    In the simplest projects, these variables inform \c qmake about the
    configuration options to use, or supply filenames and paths to use
    in the build process.

    \c qmake looks for certain variables in each project file, and it
    uses the contents of these to determine what it should write to a
    Makefile. For example, the list of values in the \c HEADERS and
    \c SOURCES variables are used to tell \c qmake about header and
    source files in the same directory as the project file.

    Variables can also be used internally to store temporary lists of values,
    and existing lists of values can be overwritten or extended with new
    values.

    The following lines show how lists of values are assigned to variables:

    \quotefromfile snippets/qmake/variables.pro
    \printto SOURCES

    Note that the first assignment only includes values that are specified on
    the same line as the \c SOURCES variable. The second assignment splits
    the items across lines by using the \\ character.

    The list of values in a variable is extended in the following way:

    \printuntil CONFIG

    The \c CONFIG variable is another special variable that \c qmake
    uses when generating a Makefile. It is discussed in the section on
    configuration later in this chapter. In the above line, \c QT is
    added to the list of existing values contained in \c CONFIG.

    The following table lists the variables that \c qmake recognizes, and
    describes what they should contain.

    \table
    \header \o Variable \o Contents
    \row \o CONFIG    \o General project configuration options.
    \row \o DESTDIR   \o The directory in which the executable or binary file will
                      be placed.
    \row \o FORMS     \o A list of .ui files to be processed by \c uic.
    \row \o HEADERS   \o A list of filenames of header (.h) files used when
                      building the project.
    \row \o QT        \o Qt-specific configuration options.
    \row \o RESOURCES \o A list of resource (.rc) files to be included in the
                      final project. See the \l{The Qt Resource System} for
                      more information about these files.
    \row \o SOURCES   \o A list of source code files to be used when building
                      the project.
    \row \o TEMPLATE  \o The template to use for the project. This determines
                      whether the output of the build process will be an
                      application, a library, or a plugin.
    \endtable

    The contents of a variable can be read by prepending the variable name with
    \c $$. This can be used to assign the contents of one variable to another:

    \quotefromfile snippets/qmake/dereferencing.pro
    \printuntil TEMP_SOURCES =

    The \c $$ operator is used extensively with built-in functions that operate
    on strings and lists of values. These are described in the chapter on
    \l{qmake Advanced Usage}.

    \section2 Comments

    You can add comments to project files. Comments begin with the \c
    # symbol and continue to the end of the same line. For example:

    \quotefromfile snippets/qmake/comments.pro
    \printuntil .

    \section2 Built-in Functions and Control Flow

    \c qmake provides a number of built-in functions to allow the contents
    of variables to be processed. The most commonly used function in simple
    project files is the \c include function which takes a filename as an
    argument. The contents of the given file are included in the project
    file at the place where the \c include function is used.
    The \c include function is most commonly used to include other project
    files:

    \quotefromfile snippets/qmake/include.pro
    \printuntil include

    Support for conditional structures is made available via
    \l{qmake Advanced Usage#scopes}{scopes} that behave like \c if
    statements in programming languages:

    \quotefromfile snippets/qmake/scopes.pro
    \printuntil }

    The assignments inside the scope are only made if the condition is
    true. In this case, the special \c win32 variable must be set; this
    happens automatically on Windows, but this can also be specified on
    other platforms by running \c qmake with the \c{-win32} command line
    option (see \l{Running qmake} for more information).

    Simple loops are constructed by iterating over lists of values using
    the built-in \c for function. The following code adds directories
    to the \c SUBDIRS variable, but only if they exist:

    \quotefromfile snippets/qmake/functions.pro
    \printuntil /^\}/

    More complex operations on variables that would usually require loops
    are provided by built-in functions such as \c find, \c unique, and
    \c count. These functions, and many others are provided to manipulate
    strings and paths, support user input, and call external tools. A list
    of the functions available can be found in the
    \l{qmake Advanced Usage} chapter of this manual.

    \section1 Project Templates

    The \c TEMPLATE variable is used to define the type of project that will
    be built. If this is not declared in the project file, \c qmake assumes
    that an application should be built, and will generate an appropriate
    Makefile (or equivalent file) for the purpose.

    The types of project available are listed in the following table with
    information about the files that \c qmake will generate for each of them:

    \table
    \header \o Template      \o Description of \c qmake output
    \row    \o app (default) \o Creates a Makefile to build an application.
    \row    \o lib           \o Creates a Makefile to build a library.
    \row    \o subdirs       \o Creates a Makefile that will go into the specified
                             directories and run \c qmake on any project files found.
    \row    \o vcapp         \o Creates a Visual Studio Project file to build
                             an application.
    \row    \o vclib         \o Creates a Visual Studio Project file to build a library.
    \endtable

    See the \l{qmake Tutorial} for advice on writing project files for
    projects that use the \c app and \c lib templates.

    When the \c subdirs template is used, \c qmake generates a Makefile
    to examine each specified subdirectory, process any project file it finds
    there, and run the platform's \c make tool on the newly-created Makefile.

    The only system variable that is recognised for this template is the
    \c SUBDIRS variable.  This variable contains a list of all the
    subdirectories that contain project files to be processed.  It is
    essential that the project file in each subdirectory has the same name
    as the subdirectory, so that \c qmake can find it. For example, if the
    subdirectory is called \c myapp then the project file in that directory
    should be called \c myapp.pro.

    \target GeneralConfiguration
    \section1 General Configuration

    The \c CONFIG variable specifies the options and features that the compiler
    should use and the libraries that should be linked against. Anything can be
    added to the \c CONFIG variable, but the options covered below are
    recognized by \c qmake internally.

    The following options control the compiler flags that are used to build the
    project:

    \table
    \header \o Option   \o Description
    \row    \o release  \o The project is to be built in release mode.
                        This is ignored if \c debug is also specified.
    \row    \o debug    \o The project is to be built in debug mode.
    \row    \o warn_on  \o The compiler should output as many warnings as possible.
                        This is ignored if \c warn_off is specified.
    \row    \o warn_off \o The compiler should output as few warnings as possible.
    \endtable

    Note that each of the options specified in the \c CONFIG variable can also be
    used as a condition in scopes. This enables different configurations to be
    defined for \c release and \c debug builds, and is described in more detail
    in the \l{qmake-advanced-usage.html#Scopes}{Scopes} section of the
    Advanced Usage chapter of this manual.

    The following options define the type of project to be built. Note that some
    of these options only take effect when used on the relevant platform. On other
    platforms, they have no effect.

    \table
    \header \o Option \o Description
    \row    \o qt     \o The project is a Qt application and should link against the Qt
                      library. You can use the \c QT variable to control any additional
                      Qt modules that are required by your application.
    \row    \o thread \o The project is a multi-threaded application.
    \row    \o x11    \o The project is an X11 application or library.
    \endtable

    When using the \c app or \c lib templates, more specialized configuration
    options can be used to fine tune the build process. These are explained in
    details in the \l{qmake-common-projects.html}{Common Projects} chapter of
    this manual.

    For example, if your application uses the Qt library and you want to
    build it as a multi-threaded application in \c debug mode, your project
    file will contain the following line:

    \code
        CONFIG += qt thread debug
    \endcode

    Note, that you must use "+=", not "=", or \c qmake will not be able to
    use Qt's configuration to determine the settings needed for your project.

    \section1 Declaring Qt Libraries

    If you enable qmake's support for Qt with the \c CONFIG variable, it is
    possible to further specify which of the Qt libraries you will link with
    your application. This is achieved with the \c QT variable which can be
    used to declare the required extension modules. For example, we can enable
    the XML and network modules in the following way:

    \code
        CONFIG += qt
        QT += network xml
    \endcode

    Note that \c QT includes the core and GUI modules by default, so the above
    declaration \e adds the network and XML modules to this default list. The
    following assignment \e omits the default modules, and will lead to errors
    when the application's source code is being compiled:

    \code
        QT = network xml # This will omit the core and GUI modules.
    \endcode

    If you want to build a project \e without the GUI module, you need to
    exclude it with the "-=" operator. By default, \c QT contains both
    \c core and \c gui, so the following line will result in a minimal
    Qt project being built:

    \code
        QT -= gui # Only the core module is used.
    \endcode

    The table below shows the options that can be used with the \c QT variable
    and the features that are associated with each of them:

    \table
    \header \o Option                     \o Features
    \row    \o core (included by default) \o Classes that provide fundamental Qt
                                             features
    \row    \o gui  (included by default) \o Widgets and other GUI classes
    \row    \o network    \o \l{Network Module} classes
    \row    \o opengl     \o \l{Qt OpenGL Module} classes
    \row    \o sql        \o \l{SQL Module} classes
    \row    \o xml        \o \l{XML Module} classes
    \row    \o qt3support \o Enables the use of Qt 3 support classes (see the
                          \l{Porting to Qt 4} guide)
    \endtable

    \section1 Configuration Features

    \c qmake can be set up with extra configuration features that are specified
    in feature (.prf) files. These extra features often provide support for
    custom tools that are used during the build process. To add a feature to
    the build process, append the feature name (the stem of the feature filename)
    to the \c CONFIG variable.

    For example, \c qmake can configure the build process to take advantage
    of external libraries that are supported by
    \l{http://www.freedesktop.org/wiki/Software_2fpkgconfig}{pkg-config},
    such as the D-BUS and ogg libraries, with the following lines:

    \code
        CONFIG += link_pkgconfig
        PKGCONFIG += ogg dbus-1
    \endcode

    More information about features can be found in the
    \l{qmake Advanced Usage#Adding New Configuration Features}
    {Adding New Configuration Features} section of the \l{qmake Advanced Usage}
    chapter.

*/

/*!
    \page qmake-running.html
    \title Running qmake
    \contentspage qmake-manual.html Contents
    \previouspage qmake Project Files
    \nextpage qmake Advanced Usage

    The behavior of \c qmake can be customized when it is run by
    specifying various options on the command line. These allow the
    build process to be fine-tuned, provide useful diagnostic
    information, and can be used to specify the target platform for
    your project.

    \tableofcontents

    \target Commands
    \section1 Command-Line Options

    \section2 Syntax

    The syntax used to run \c qmake takes the following simple form:

    \code
        qmake [mode] [options] files
    \endcode

    \c qmake supports two different modes of operation: In the default mode,
    \c qmake will use the description in a project file to generate a Makefile,
    but it is also possible to use \c qmake to generate project files.
    If you want to explicitly set the mode, you must specify it before all
    other options. The \c mode can be either of the following two values:

    \list
    \o \c -makefile \BR
        \c qmake output will be a Makefile.
    \o \c -project \BR
        \c qmake output will be a project file.
    \endlist

    The following \c options are used to specify both general and mode-specific
    settings. Options that only apply to the Makefile mode are described in the
    \l{#MakefileMode}{Makefile Mode Options} section; options that influence the
    creation of project files are described in the
    \l{#ProjectMode}{Project File Options} section.

    The \c files argument represents a list of one or more project files, separated
    by spaces.

    \section2 Options

    A wide range of options can be specified on the command line to \c qmake in
    order to customize the build process, and to override default settings for
    your platform. The following basic options provide usage information, specify
    where \c qmake writes the output file, and control the level of debugging
    information that will be written to the console:

    \list
    \o \c -help \BR
        \c qmake will go over these features and give some useful help.
    \o \c -o file \BR
        \c qmake output will be directed to \e file. If this option
        is not specified, \c qmake will try to use a suitable file name for its
        output, depending on the mode it is running in.\BR
        If '-' is specified, output is directed to stdout.
    \o \c -d \BR
        \c qmake will output debugging information.
    \endlist

    For projects that need to be built differently on each target platform, with
    many subdirectories, you can run \c qmake with each of the following
    options to set the corresponding platform-specific variable in each
    project file:

    \list
    \o \c -unix \BR
        \c qmake will run in unix mode.  In this mode, Unix file
        naming and path conventions will be used, additionally testing for \c unix
        (as a scope) will succeed. This is the default mode on all Unices.
    \o \c -macx \BR
        \c qmake will run in Mac OS X mode.  In this mode, Unix file
        naming and path conventions will be used, additionally testing for \c macx
        (as a scope) will succeed. This is the default mode on Mac OS X.
    \o \c -win32 \BR
        \c qmake will run in win32 mode.  In this mode, Windows file naming and path
        conventions will be used, additionally testing for \c win32 (as a scope)
        will succeed. This is the default mode on Windows.
    \endlist

    The template used for the project is usually specified by the \c TEMPLATE
    variable in the project file. We can override or modify this by using the
    following options:

    \list
    \o \c -t tmpl \BR
        \c qmake will override any set \c TEMPLATE variables with tmpl, but only
        \e after the .pro file has been processed.
    \o \c -tp prefix \BR
        \c qmake will add the prefix to the \c TEMPLATE variable.
    \endlist

    The level of warning information can be fine-tuned to help you find problems in
    your project file:

    \list
    \o \c -Wall \BR
          \c qmake will report all known warnings.
    \o \c -Wnone \BR
          No warning information will be generated by \c qmake.
    \o \c -Wparser \BR
          \c qmake will only generate parser warnings. This will alert
          you to common pitfalls and potential problems in the parsing of your
          project files.
    \o \c -Wlogic \BR
          \c qmake will warn of common pitfalls and potential problems in your
          project file. For example, \c qmake will report whether a file is placed
          into a list of files multiple times, or if a file cannot be found.
    \endlist

    \target MakefileMode
    \section2 Makefile Mode Options

    \code
        qmake -makefile [options] files
    \endcode

    In Makefile mode, \c qmake will generate a Makefile that is used to build the
    project. Additionally, the following options may be used in this mode to
    influence the way the project file is generated:

    \list
    \o \c -after \BR
       \c qmake will process assignments given on the command line after
       the specified files.
    \o \c -nocache \BR
       \c qmake will ignore the .qmake.cache file.
    \o \c -nodepend \BR
       \c qmake will not generate any dependency information.
    \o \c -cache file \BR
       \c qmake will use \e file as the cache file, ignoring any other
       .qmake.cache files found.
    \o \c -spec spec \BR
       \c qmake will use \e spec as a path to platform and compiler information,
       and the value of \c QMAKESPEC will be ignored.
    \endlist

    You may also pass \c qmake assignments on the command line;
    they will be processed before all of the files specified. For example:

    \code
        qmake -makefile -unix -o Makefile "CONFIG+=test" test.pro
    \endcode

    This will generate a Makefile, from test.pro with Unix pathnames.  However
    many of the specified options aren't necessary as they are the default.
    Therefore, the line can be simplified on Unix to:

    \code
        qmake "CONFIG+=test" test.pro
    \endcode

    If you are certain you want your variables processed after the
    the files specified, then you may pass the \c -after option. When this
    is specified, all assignments on the command line after the \c -after
    option will be postponed until after the specified files are parsed.

    \target ProjectMode
    \section2 Project Mode Options

    \code
        qmake -project [options] files
    \endcode

    In project mode, \c qmake will generate a project file. Additionally, you
    may supply the following options in this mode:

    \list
    \o \c -r \BR
       \c qmake will look through supplied directories recursively
    \o \c -nopwd \BR
       \c qmake will not look in your current working directory for
       source code and only use the specified \c files
    \endlist

    In this mode, the \c files argument can be a list of files or directories.
    If a directory is specified, it will be included in the \c DEPENDPATH
    variable, and relevant code from there will be included in the generated
    project file. If a file is given, it will be appended to the correct
    variable, depending on its extension; for example, .ui files are added
    to \c FORMS, and .cpp files are added to \c SOURCES.

    You may also pass assignments on the command line in this mode. When doing
    so, these assignments will be placed last in the generated project file.
*/

/*!
    \page qmake-reference.html
    \title qmake Reference
    \contentspage qmake-manual.html Contents
    \previouspage qmake Advanced Usage
    \nextpage qmake Variable Reference

    This reference is a detailed index of all the variables and function
    that are available for use in \c qmake project files.

    \section1 Variable Reference

    The \l{qmake Variable Reference} describes the variables that are
    recognized by \c qmake when configuring the build process for
    projects.

    \section1 Function Reference

    The \l{qmake Function Reference} describes the function that can be
    used to process the contents of variables defined in project files.

    \target FrequentlyUsedVariables
    \section1 Frequently Used Variables

    The following variables are frequently used in project files to describe
    common aspects of the build process. These are fully described in the
    \l{qmake-variable-reference.html}{Variable Reference}.

    \list
    \o \l{qmake Variable Reference#CONFIG}{CONFIG}
    \o \l{qmake Variable Reference#DEF_FILE}{DEF_FILE}
    \o \l{qmake Variable Reference#DEFINES}{DEFINES}
    \o \l{qmake Variable Reference#DESTDIR}{DESTDIR}
    \o \l{qmake Variable Reference#DISTFILES}{DISTFILES}
    \o \l{qmake Variable Reference#DLLDESTDIR}{DLLDESTDIR}
    \o \l{qmake Variable Reference#FORMS}{FORMS}
    \o \l{qmake Variable Reference#HEADERS}{HEADERS}
    \o \l{qmake Variable Reference#INCLUDEPATH}{INCLUDEPATH}
    \o \l{qmake Variable Reference#LEXSOURCES}{LEXSOURCES}
    \o \l{qmake Variable Reference#LIBS}{LIBS}
    \o \l{qmake Variable Reference#MOC_DIR}{MOC_DIR}
    \o \l{qmake Variable Reference#OBJECTS_DIR}{OBJECTS_DIR}
    \o \l{qmake Variable Reference#RCC_DIR}{RCC_DIR}
    \o \l{qmake Variable Reference#REQUIRES}{REQUIRES}
    \o \l{qmake Variable Reference#SOURCES}{SOURCES}
    \o \l{qmake Variable Reference#SUBDIRS}{SUBDIRS}
    \o \l{qmake Variable Reference#TARGET}{TARGET}
    \o \l{qmake Variable Reference#TEMPLATE}{TEMPLATE}
    \o \l{qmake Variable Reference#UI_DIR}{UI_DIR}
    \o \l{qmake Variable Reference#UI_HEADERS_DIR}{UI_HEADERS_DIR}
    \o \l{qmake Variable Reference#UI_SOURCES_DIR}{UI_SOURCES_DIR}
    \o \l{qmake Variable Reference#VERSION}{VERSION}
    \o \l{qmake Variable Reference#YACCSOURCES}{YACCSOURCES}
    \endlist

    \section1 Environment Variables and Configuration

    The \l{Configuring qmake's Environment} chapter of this manual
    describes the environment variables that \c qmake uses when
    configuring the build process.
*/

/*!
    \page qmake-variable-reference.html
    \title qmake Variable Reference
    \contentspage qmake-manual.html Contents
    \previouspage qmake Reference
    \nextpage qmake Function Reference

    \tableofcontents{3}

    \target CONFIG
    \section1 CONFIG

     The \c CONFIG variable specifies project configuration and
    compiler options.  The values will be recognized internally by
    \c qmake and have special meaning.  They are as follows.

    These \c CONFIG values control compilation flags:

    \list
    \o release - Compile with optimization enabled, ignored if
        "debug" is specified
    \o debug - Compile with debug options enabled
    \o warn_on - The compiler should emit more warnings than normally, ignored if
         "warn_off" is specified
    \o warn_off - The compiler should only emit severe warnings.
    \endlist

    These options define the application/library type:

    \list
    \o qt - The target is a Qt application/library and requires the Qt header
         files/library.  The proper include and library paths for the Qt
         library will automatically be added to the project.
    \o opengl - The target requires the OpenGL (or Mesa)
        headers/libraries. The proper include and library paths for
        these libraries will automatically be added to the project.
    \o thread - The target is a multi-threaded application or library.  The
        proper defines and compiler flags will automatically be added to
        the project.
    \o x11 - The target is a X11 application or library.  The proper
        include paths and libraries will automatically be added to the
        project.
    \o windows - The target is a Win32 window application (app only). The
        proper include paths,compiler flags and libraries will
        automatically be added to the project.
    \o console - The target is a Win32 console application (app only). The
        proper include paths, compiler flags and libraries will
        automatically be added to the
        project.
    \o dll - The target is a shared object/DLL.The proper
        include paths, compiler flags and libraries will automatically be
        added to the project.
    \o staticlib - The target is a static library (lib only).  The proper
        compiler flags will automatically be added to the project.
    \o plugin - The target is a plugin (lib only). This enables dll as well.
    \endlist

    These options are used to set the compiler flags:

    \list
    \o exceptions - Exception support is enabled
    \o rtti - RTTI support is enabled
    \o stl - STL support is enabled
    \endlist

    These options define specific things depending on the platform and/or template:

    \list
    \o flat - When using the vcapp template this will put all the source files into the source group and
        the header files into the header group regardless of what directory they reside in.  Turning this
        option off will group the files within the source/header group depending on the directory they
        reside.  This is turned on by default.
    \endlist

    The \c CONFIG variable will also be checked when resolving
    scopes.  You may assign anything to this variable.

    For example:

    \code
        CONFIG += qt console newstuff
        ...
        newstuff {
            SOURCES += new.cpp
            HEADERS += new.h
        }
    \endcode

    \target DEFINES
    \section1 DEFINES

    \c qmake adds the values of this variable as compiler C
    preprocessor macros (-D option).

    For example:

    \code
        DEFINES += USE_MY_STUFF QT_DLL
    \endcode

    \target DEF_FILE
    \section1 DEF_FILE

    \e {This is only used on Windows when using the \c app template}.

    Specifies a .def file to be included in the project.

    \target DESTDIR
    \section1 DESTDIR

    Specifies where to put the \l{#TARGET}{target} file.

    For example:

    \code
        DESTDIR = ../../lib
    \endcode

    \target DLLDESTDIR
    \section1 DLLDESTDIR

    Specifies where to copy the \l{#TARGET}{target} dll.

    \target DISTFILES
    \section1 DISTFILES

    This variable contains a list of files to be included in the dist
    target. This feature is supported by UnixMake specs only.

    For example:

    \code
        DISTFILES += ../program.txt
    \endcode

    \target HEADERS
    \section1 HEADERS

    Defines the header files for the project.

    \c qmake will generate dependency information (unless \c -nodepend
    is specified on the \l{Running qmake#Commands}{command line})
    for the specified headers. \c qmake will also automatically detect if
    \c moc is required by the classes in these headers, and add the
    appropriate dependencies and files to the project for generating and
    linking the moc files.

    For example:

    \code
        HEADERS = myclass.h \
                  login.h \
                  mainwindow.h
    \endcode

    See also \l{#SOURCES}{SOURCES}.

    \target INCLUDEPATH
    \section1 INCLUDEPATH

    This variable specifies the #include directories which should be
    searched when compiling the project. Use ';' or a space as the
    directory separator.

    For example:

    \code
        INCLUDEPATH = c:\msdev\include d:\stl\include
    \endcode

    \target FORMS
    \section1 FORMS

    This variable specifies the .ui files (see \link
    designer-manual.html Qt Designer \endlink) to be processed through \c uic
    before compiling.  All dependencies, headers and source files required
    to build these .ui files will automatically be added to the project.

    For example:

    \code
        FORMS = mydialog.ui \
            mywidget.ui \
                myconfig.ui
    \endcode

    \target LEXSOURCES
    \section1 LEXSOURCES

    This variable contains a list of lex source files.  All
    dependencies, headers and source files will automatically be added to
    the project for building these lex files.

    For example:

    \code
        LEXSOURCES = lexer.l
    \endcode

    \target LIBS
    \section1 LIBS

    This variable contains a list of libraries to be linked into the project.
    If you are more comfortable with the Unix convension of -L/-l flags you are
    free to use them in a cross-platform manner and qmake will do the correct
    thing with these libraries on Windows (namely this means passing the full
    path of the library to the linker). The only limitation to this is the
    library must exist, for qmake to find which directory a -l lib lives in.

    For example:

    \code
        unix:LIBS += -lmath -L/usr/local/lib
        win32:LIBS += c:\mylibs\math.lib
    \endcode

    \target MOC_DIR
    \section1 MOC_DIR

    This variable specifies the directory where all intermediate moc
    files should be placed.

    For example:

    \code
        unix:MOC_DIR = ../myproject/tmp
        win32:MOC_DIR = c:\myproject\tmp
    \endcode

    \target OBJECTS_DIR
    \section1 OBJECTS_DIR

    This variable specifies the directory where all intermediate
    objects should be placed.

    For example:

    \code
        unix:OBJECTS_DIR = ../myproject/tmp
        win32:OBJECTS__DIR = c:\myproject\tmp
    \endcode

    \target UI_DIR
    \section1 UI_DIR

    This variable specifies the directory where all intermediate files from uic
    should be placed. This variable overrides both UI_SOURCES_DIR and
    UI_HEADERS_DIR.

    For example:

    \code
        unix:UI_DIR = ../myproject/ui
        win32:UI_DIR = c:\myproject\ui
    \endcode

    \target UI_HEADERS_DIR
    \section1 UI_HEADERS_DIR

    This variable specifies the directory where all declaration files (as
    generated by uic) should be placed.

    For example:

    \code
        unix:UI_HEADERS_DIR = ../myproject/ui/include
        win32:UI_HEADERS_DIR = c:\myproject\ui\include
    \endcode

    \target UI_SOURCES_DIR
    \section1 UI_SOURCES_DIR

    This variable specifies the directory where all implementation files (as generated
    by uic) should be placed.

    For example:

    \code
        unix:UI_SOURCES_DIR = ../myproject/ui/src
        win32:UI_SOURCES_DIR = c:\myproject\ui\src
    \endcode

    \target RCC_DIR
    \section1 RCC_DIR

    This variable specifies the directory where all intermediate
    resource files should be placed.

    For example:

    \code
        unix:RCC_DIR = ../myproject/resources
        win32:RCC_DIR = c:\myproject\resources
    \endcode

    \target REQUIRES
    \section1 REQUIRES

    This is a special variable processed by \c qmake.  If the
    contents of this variable do not appear in CONFIG by the time this
    variable is assigned, then a minimal Makefile will be generated that
    states what dependencies (the values assigned to REQUIRES) are
    missing.

    This is mainly used in Qt's build system for building the examples.

    \target SOURCES
    \section1 SOURCES

    This variable contains the name of all source files in the project.

    For example:

    \code
        SOURCES = myclass.cpp \
              login.cpp \
              mainwindow.cpp
    \endcode

    See also \l{#HEADERS}{HEADERS}

    \target SUBDIRS
    \section1 SUBDIRS

    This variable, when used with the \c subdirs
    \l{#TEMPLATE}{TEMPLATE} contains the names of all subdirectories
    to look for a project file.

    For example:

    \code
        SUBDIRS = kernel \
              tools
    \endcode

    \target TARGET
    \section1 TARGET

    This specifies the name of the target file.

    For example:

    \code
        TEMPLATE = app
        TARGET = myapp
        SOURCES = main.cpp
    \endcode

    The project file above would produce an executable named \c myapp on
    unix and 'myapp.exe' on windows.

    \target TEMPLATE
    \section1 TEMPLATE

    This variable contains the name of the template to use when
    generating the project.  The allowed values are:

    \list
    \o app - Creates a Makefile for building applications (the default)
    \o lib - Creates a Makefile for building libraries
    \o subdirs - Creates a Makefile for building targets in subdirectories
    \o vcapp - \e {win32 only}  Creates an application project file for
    Visual Studio
    \o vclib - \e {win32 only}  Creates a library project file for Visual
    Studio

    \endlist

    For example:

    \code
        TEMPLATE = lib
        SOURCES = main.cpp
        TARGET = mylib
    \endcode

    The template can be overridden by specifying a new template type with the
    \c -t command line option. This overrides the template type \e after the .pro
    file has been processed. With .pro files that use the template type to
    determine how the project is built, it is necessary to declare TEMPLATE on
    the command line rather than use the \c -t option.

    \target VERSION
    \section1 VERSION

    This variable contains the version number of the library if the
    \c lib \l{#TEMPLATE}{TEMPLATE} is specified.

    For example:

    \code
        VERSION = 1.2.3
    \endcode

    \target YACCSOURCES
    \section1 YACCSOURCES

    This variable contains a list of yacc source files to be included
    in the project.  All dependencies, headers and source files will
    automatically be included in the project.

    For example:

    \code
        YACCSOURCES = moc.y
    \endcode

    \target DESTDIR_TARGET
    \section1 DESTDIR_TARGET

    This variable is set internally by \c qmake, which is basically the
    \c DESTDIR variable with the \c TARGET variable appened at the end.
    The value of this variable is typically handled by \c qmake or
    \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \target DSP_TEMPLATE
    \section1 DSP_TEMPLATE

    This variable is set internally by \c qmake, which specifies where the
    dsp template file for basing generated dsp files is stored. The value
    of this variable is typically handled by \c qmake or
    \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \target LEXIMPLS
    \section1 LEXIMPLS

    This variable contains a list of lex implementation files.  The value
    of this variable is typically handled by \c qmake or \l{#QMAKESPEC}{qmake.conf} and rarely
    needs to be modified.

    \target LEXOBJECTS
    \section1 LEXOBJECTS

    This variable contains the names of intermediate lex object
    files.The value of this variable is typically handled by
    \c qmake and rarely needs to be modified.

    \target MAKEFILE
    \section1 MAKEFILE

    This variable specifies the name of the Makefile which
    \c qmake should use when outputting the dependency information
    for building a project.  The value of this variable is typically
    handled by \c qmake or \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \target MAKEFILE_GENERATOR
    \section1 MAKEFILE_GENERATOR

    This variable contains the name of the Makefile generator to use
    when generating a Makefile.  The value of this variable is typically
    handled internally by \c qmake and rarely needs to be modified.

    \target OBJECTS
    \section1 OBJECTS

    This variable is generated from the \link #SOURCES SOURCES
    \endlink variable.  The extension of each source file will have been
    replaced by .o (Unix) or .obj (Win32).  The value of this variable is
    typically handled by \c qmake or \l{#QMAKESPEC}{qmake.conf} and
    rarely needs to be modified.

    \target OBJMOC
    \section1 OBJMOC

    This variable is set by \c qmake if files can be found that
    contain the Q_OBJECT macro.  \c OBJMOC contains the
    name of all intermediate moc object files. The value of this variable
    is typically handled by \c qmake or \l{#QMAKESPEC}{qmake.conf} and rarely needs to be
    modified.

    \target PRECOMPILED_HEADER
    \section1 PRECOMPILED_HEADER

    This variable indicates the header file for creating a precompiled
    header file, to increase the compilation speed of a project.
    Precompiled headers are currently only supported on some platforms
    (Windows - all MSVC project types, Mac OS X - Xcode, Makefile,
    UNIX - gcc 3.3 and up).

    On other platforms, this variable has different meaning, as noted
    below.

    This variable contains a list of header files that require some
    sort of pre-compilation step (such as with moc). The value of this
    variable is typically handled by \c qmake or \l{#QMAKESPEC}{qmake.conf} and rarely needs to be
    modified.

    \target QMAKE
    \section1 QMAKE

    This variable contains the name of the \c qmake program
    itself and is placed in generated Makefiles.  The value of this
    variable is typically handled by \c qmake or \l{#QMAKESPEC}{qmake.conf} and rarely needs to be
    modified.

    \target QMAKESPEC_systemvariable
    \section1 QMAKESPEC

    This variable contains the name of the \c qmake
    configuration to use when generating Makefiles.  The value of this
    variable is typically handled by \c qmake and rarely needs to be modified.
    Use the \l{#QMAKESPEC}{QMAKESPEC} environment variable instead.

    \target QMAKE_APP_FLAG
    \section1 QMAKE_APP_FLAG

    This variable is empty unless the \c app
    \l{#TEMPLATE}{TEMPLATE} is specified.  The value of this
    variable is typically handled by \c qmake or \l{#QMAKESPEC}{qmake.conf} and rarely needs to be
    modified.  Use the following instead:

    \code
        app {
            # Conditional code for 'app' template here
        }
    \endcode

    \target QMAKE_APP_OR_DLL
    \section1 QMAKE_APP_OR_DLL

    This variable is empty unless the \c app or \c dll
    \l{#TEMPLATE}{TEMPLATE} is specified.  The value of this
    variable is typically handled by \c qmake or \l{#QMAKESPEC}{qmake.conf} and rarely needs to be
    modified.

    \target QMAKE_AR_CMD
    \section1 QMAKE_AR_CMD

    \e {This is used on Unix platforms only}

    This variable contains the command for invoking the program which
    creates, modifies and extracts archives. The value of this variable is
    typically handled by \c qmake or \l{#QMAKESPEC}{qmake.conf}
    and rarely needs to be modified.

    \target QMAKE_CFLAGS_DEBUG
    \section1 QMAKE_CFLAGS_DEBUG

    This variable contains the flags for the C compiler in debug mode.The value of this variable is
    typically handled by \c qmake or \l{#QMAKESPEC}{qmake.conf}
    and rarely needs to be modified.

    \target QMAKE_CFLAGS_MT
    \section1 QMAKE_CFLAGS_MT

    This variable contains the compiler flags for creating a
    multi-threaded application or when the version of Qt that you link
    against is a multi-threaded statically linked library.  The value of
    this variable is typically handled by \c qmake or
    \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \target QMAKE_CFLAGS_MT_DBG
    \section1 QMAKE_CFLAGS_MT_DBG

    This variable contains the compiler flags for creating a debuggable
    multi-threaded application or when the version of Qt that you link
    against is a debuggable multi-threaded statically linked library.  The
    value of this variable is typically handled by \c qmake or
    \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \target QMAKE_CFLAGS_MT_DLL
    \section1 QMAKE_CFLAGS_MT_DLL

    \e {This is used on Windows only}

    This variable contains the compiler flags for creating a
    multi-threaded dll or when the version of Qt that you link
    against is a multi-threaded dll.  The value of this variable is typically
    handled by \c qmake or \l{#QMAKESPEC}{qmake.conf} and
    rarely needs to be modified.

    \target QMAKE_CFLAGS_MT_DLLDBG
    \section1 QMAKE_CFLAGS_MT_DLLDBG

    \e {This is used on Windows only}

    This variable contains the compiler flags for creating a debuggable
    multi-threaded dll or when the version of Qt that you link
    against is a debuggable multi-threaded statically linked library.
    The value of this variable is typically handled by \c qmake or
    \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \target QMAKE_CFLAGS_RELEASE
    \section1 QMAKE_CFLAGS_RELEASE

    This variable contains the compiler flags for creating a non-debuggable
    application.  The value of this variable is typically
    handled by \c qmake or \l{#QMAKESPEC}{qmake.conf} and
    rarely needs to be modified.

    \target QMAKE_CFLAGS_SHLIB
    \section1 QMAKE_CFLAGS_SHLIB

    \e {This is used on Unix platforms only}

    This variable contains the compiler flags for creating a shared
    library. The value of this variable is typically handled by
    \c qmake or \l{#QMAKESPEC}{qmake.conf} and rarely needs
    to be modified.

    \target QMAKE_CFLAGS_THREAD
    \section1 QMAKE_CFLAGS_THREAD

    This variable contains the compiler flags for creating a multi-threaded
    application. The value of this variable is typically handled by
    \c qmake or \l{#QMAKESPEC}{qmake.conf} and rarely needs
    to be modified.

    \target QMAKE_CFLAGS_WARN_OFF
    \section1 QMAKE_CFLAGS_WARN_OFF

    This variable is not empty if the warn_off
    \l{#TEMPLATE}{TEMPLATE} option is specified.  The value of this
    variable is typically handled by \c qmake or \l{#QMAKESPEC}{qmake.conf}
    and rarely needs to be modified.

    \target QMAKE_CFLAGS_WARN_ON
    \section1 QMAKE_CFLAGS_WARN_ON

    This variable is not empty if the warn_on
    \l{#TEMPLATE}{TEMPLATE} option is specified.
    The value of this variable is typically handled by
    \c qmake or \l{#QMAKESPEC}{qmake.conf} and rarely needs
    to be modified.

    \target QMAKE_CLEAN
    \section1 QMAKE_CLEAN

    This variable contains any files which are not generated files (such as moc and uic
    generated files) and object files that should be removed when using "make clean".

    \target QMAKE_CXXFLAGS_DEBUG
    \section1 QMAKE_CXXFLAGS_DEBUG

    This variable contains the C++ compiler flags for creating a debuggable
    application. The value of this variable is typically handled by
    \c qmake or \l{#QMAKESPEC}{qmake.conf} and rarely needs
    to be modified.

    \target QMAKE_CXXFLAGS_MT
    \section1 QMAKE_CXXFLAGS_MT

    This variable contains the C++ compiler flags for creating a multi-threaded
    application. The value of this variable is typically handled by
    \c qmake or \l{#QMAKESPEC}{qmake.conf} and rarely needs
    to be modified.

    \target QMAKE_CXXFLAGS_MT_DBG
    \section1 QMAKE_CXXFLAGS_MT_DBG

    This variable contains the C++ compiler flags for creating a debuggable multi-threaded
    application. The value of this variable is typically handled by
    \c qmake or \l{#QMAKESPEC}{qmake.conf} and rarely needs
    to be modified.

    \target QMAKE_CXXFLAGS_MT_DLL
    \section1 QMAKE_CXXFLAGS_MT_DLL

    \c {This is used on Windows only}

    This variable contains the C++ compiler flags for creating a multi-threaded
    dll. The value of this variable is typically handled by
    \c qmake or \l{#QMAKESPEC}{qmake.conf} and rarely needs
    to be modified.

    \target QMAKE_CXXFLAGS_MT_DLLDBG
    \section1 QMAKE_CXXFLAGS_MT_DLLDBG

    \c {This is used on Windows only}

    This variable contains the C++ compiler flags for creating a multi-threaded debuggable
    dll. The value of this variable is typically handled by
    \c qmake or \l{#QMAKESPEC}{qmake.conf} and rarely needs
    to be modified.

    \target QMAKE_CXXFLAGS_RELEASE
    \section1 QMAKE_CXXFLAGS_RELEASE

    This variable contains the C++ compiler flags for creating an
    application. The value of this variable is typically handled by
    \c qmake or \l{#QMAKESPEC}{qmake.conf} and rarely needs
    to be modified.

    \target QMAKE_CXXFLAGS_SHLIB
    \section1 QMAKE_CXXFLAGS_SHLIB

    This variable contains the C++ compiler flags for creating a
    shared library.  The value of this variable is typically handled by
    \c qmake or \l{#QMAKESPEC}{qmake.conf} and rarely needs
    to be modified.

    \target QMAKE_CXXFLAGS_THREAD
    \section1 QMAKE_CXXFLAGS_THREAD

    This variable contains the C++ compiler flags for creating a
    multi-threaded application.  The value of this variable is typically handled by
    \c qmake or \l{#QMAKESPEC}{qmake.conf} and rarely needs
    to be modified.

    \target QMAKE_CXXFLAGS_WARN_OFF
    \section1 QMAKE_CXXFLAGS_WARN_OFF

    This variable contains the C++ compiler flags for suppressing compiler warnings.
     The value of this variable is typically handled by \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \target QMAKE_CXXFLAGS_WARN_ON
    \section1 QMAKE_CXXFLAGS_WARN_ON

    This variable contains C++ compiler flags for generating compiler warnings.
     The value of this variable is typically handled by \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \target QMAKE_EXTENSION_SHLIB
    \section1 QMAKE_EXTENSION_SHLIB

    This variable contains the extention for shared libraries.  The value of this
    variable is typically handled by \c qmake or \l{#QMAKESPEC}{qmake.conf}
    and rarely needs to be modified.

    \target QMAKE_FAILED_REQUIREMENTS
    \section1 QMAKE_FAILED_REQUIREMENTS

    This variable contains the list of requirements that were failed to be met when
    \c qmake was used.  For example, the sql module is needed and wasn't compiled into Qt.  The
    value of this variable is typically handled by \c qmake or \l{#QMAKESPEC}{qmake.conf}
    and rarely needs to be modified.

    \target QMAKE_FILETAGS
    \section1 QMAKE_FILETAGS

    This variable contains the file tags needed to be entered into the Makefile, such as SOURCES
    and HEADERS.  The value of this variable is typically handled by \c qmake or
    \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \target QMAKE_INCDIR
    \section1 QMAKE_INCDIR

    This variable contains the location of all known header files to be added to
    INCLUDEPATH when building an application.  The value of this variable is
    typically handled by \c qmake or \l{#QMAKESPEC}{qmake.conf} and rarely
    needs to be modified.

    \target POST_TARGETDEPS
    \section1 POST_TARGETDEPS

    All libraries that the \l{#TARGET}{target} depends on can be
    listed in this variable. Some backends do not support this, these include
    MSVC Dsp, and ProjectBuilder .pbproj files. Generally this is support
    internally by these build tools, this is usefull for explicitly listing
    dependant static libraries.

    This list will go after all builtin (and \link #PRE_TARGETDEPS
    $$PRE_TARGETDEPS \endlink) dependencies.

    \target PRE_TARGETDEPS
    \section1 PRE_TARGETDEPS

    All libraries that the \l{#TARGET}{target} depends on can be
    listed in this variable. Some backends do not support this, these include
    MSVC Dsp, and ProjectBuilder .pbproj files. Generally this is support
    internally by these build tools, this is usefull for explicitly listing
    dependant static libraries.

    This list will go before all builtin dependencies.

    \target QMAKE_INCDIR_OPENGL
    \section1 QMAKE_INCDIR_OPENGL

    This variable contains the location of OpenGL header files to be added
    to INCLUDEPATH when building an application with OpenGL support. The
    value of this variable is typically handled by \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \target QMAKE_INCDIR_QT
    \section1 QMAKE_INCDIR_QT

    This variable contains the location of all known header file
    paths to be added to INCLUDEPATH when building a Qt application. The value
    of this variable is typically handled by \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \target QMAKE_INCDIR_THREAD
    \section1 QMAKE_INCDIR_THREAD

    This variable contains the location of all known header file
    paths to be added to INCLUDEPATH when building a multi-threaded application.
    The value of this variable is typically handled by \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \target QMAKE_INCDIR_X11
    \section1 QMAKE_INCDIR_X11

    \e {This is used on Unix platforms only}

    This variable contains the location of X11 header file paths to be
    added to INCLUDEPATH when building a X11 application.  The
    value of this variable is typically handled by \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \target QMAKE_LFLAGS_CONSOLE
    \section1 QMAKE_LFLAGS_CONSOLE

    \e {This is used on Windows only}

    This variable contains link flags when building console
    programs.  The value of this variable is typically handled by
    \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \section1 QMAKE_LFLAGS_CONSOLE_DLL

    \e {This is used on Windows only}

    This variable contains link flags when building console
    dlls.  The value of this variable is typically handled by
    \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \section1 QMAKE_LFLAGS_DEBUG

    This variable contains link flags when building debuggable applications.  The
    value of this variable is typically handled by \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \section1 QMAKE_LFLAGS_PLUGIN

    This variable contains link flags when building plugins. The value
    of this variable is typically handled by \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \section1 QMAKE_LFLAGS_QT_DLL

    This variable contains link flags when building programs that
    use the Qt library built as a dll. The value of this variable is
    typically handled by \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \section1 QMAKE_LFLAGS_RELEASE

    This variable contains link flags when building applications for
    release. The value of this variable is typically handled by
    \c qmake or \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \section1 QMAKE_LFLAGS_SHAPP

    This variable contains link flags when building applications which are using
    the \c app template.  The value of this variable is typically handled by
    \c qmake or \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \section1 QMAKE_LFLAGS_SHLIB

    This variable contains link flags when building shared libraries
    The value of this variable is typically handled by \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \section1 QMAKE_LFLAGS_SONAME

    This variable specifies the link flags to set the name of shared objects,
    such as .so or .dll.  The value of this variable is typically handled by \c
    qmake or \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \section1 QMAKE_LFLAGS_THREAD

    This variable contains link flags when building multi-threaded projects.
    The value of this variable is typically handled by \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \section1 QMAKE_LFLAGS_WINDOWS

    \e {This is used on Windows only}

    This variable contains link flags when building windows projects.
    The value of this variable is typically handled by \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \section1 QMAKE_LFLAGS_WINDOWS_DLL

    \e {This is used on Windows only}

    This variable contains link flags when building windows dll projects.
    The value of this variable is typically handled by \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \section1 QMAKE_LIBDIR

    This variable contains the location of all known library
    directories.The value of this variable is typically handled by
    \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \section1 QMAKE_LIBDIR_FLAGS

    \e {This is used on Unix platforms only}

    This variable contains the location of all library
    directory with -L prefixed.  The value of this variable is typically handled by
    \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \section1 VPATH

    This variable tells \c qmake where to search for files it cannot
    open. With this you may tell \c qmake where it may look for things
    like SOURCES, and if it finds an entry in SOURCES that cannot be
    opened it will look through the entire VPATH list to see if it can
    find the file on its own.

    See also \l{#DEPENDPATH}{DEPENDPATH}.

    \target DEPENDPATH
    \section1 DEPENDPATH

    This variable contains the list of all directories to look in to
    resolve dependencies. This will be used when crawling through
    \c included files.

    \section1 QMAKE_LIBDIR_OPENGL

    This variable contains the location of the OpenGL library
    directory.The value of this variable is typically handled by
    \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \section1 QMAKE_LIBDIR_QT

    This variable contains the location of the Qt library
    directory.The value of this variable is typically handled by
    \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \section1 QMAKE_LIBDIR_X11

    \e {This is used on Unix platforms only}

    This variable contains the location of the X11 library
    directory.The value of this variable is typically handled by
    \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \section1 QMAKE_LIBS

    This variable contains all project libraries.  The value of this
    variable is typically handled by \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \section1 QMAKE_LIBS_CONSOLE

    \e {This is used on Windows only}

    This variable contains all project libraries that should be linked against
    when building a console application.  The value of this
    variable is typically handled by \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \section1 QMAKE_LIBS_OPENGL

    This variable contains all OpenGL libraries.  The value of this
    variable is typically handled by \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \section1 QMAKE_LIBS_OPENGL_QT

    This variable contains all OpenGL Qt libraries.The value of this
    variable is typically handled by \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \section1 QMAKE_LIBS_QT

    This variable contains all Qt libraries.The value of this
    variable is typically handled by \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \section1 QMAKE_LIBS_QT_DLL

    \e {This is used on Windows only}

    This variable contains all Qt libraries when Qt is built as a dll.  The
    value of this variable is typically handled by \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \section1 QMAKE_LIBS_QT_OPENGL

    This variable contains all the libraries needed to link against if
    OpenGL support is turned on. The
    value of this variable is typically handled by \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \section1 QMAKE_LIBS_QT_THREAD

    This variable contains all the libraries needed to link against if
    thread support is turned on.  The
    value of this variable is typically handled by \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \section1 QMAKE_LIBS_RT

    \e {This is used with Borland compilers only}

    This variable contains the runtime library needed to link against when
    building an application.  The
    value of this variable is typically handled by \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \section1 QMAKE_LIBS_RTMT

    \e {This is used with Borland compilers only}

    This variable contains the runtime library needed to link against when
    building a multi-threaded application.  The
    value of this variable is typically handled by \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \section1 QMAKE_LIBS_THREAD

    \e {This is used on Unix platforms only}

    This variable contains all libraries that need to be linked against
    when building a multi-threaded application.  The
    value of this variable is typically handled by \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \section1 QMAKE_LIBS_WINDOWS

    \e {This is used on Windows only}

    This variable contains all windows libraries.The value of this
    variable is typically handled by \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \section1 QMAKE_LIBS_X11

    \e {This is used on Unix platforms only}

    This variable contains all X11 libraries.The value of this
    variable is typically handled by \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \section1 QMAKE_LIBS_X11SM

    \e {This is used on Unix platforms only}

    This variable contains all X11 session management libraries.  The
    value of this variable is typically handled by \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \section1 QMAKE_LIB_FLAG

    This variable is not empty if the \c lib template is specified.  The
    value of this variable is typically handled by \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \section1 QMAKE_LINK_SHLIB_CMD

    This variable contains the command to execute when creating a
    shared library. The
    value of this variable is typically handled by \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \section1 QMAKE_POST_LINK

    This variable contains the command to execute after linking the TARGET
    together. This variable is normally empty and therefore nothing is
    executed, additionally some backends will not support this - mostly only
    Makefile backends.

    \section1 QMAKE_PRE_LINK

    This variable contains the command to execute before linking the TARGET
    together. This variable is normally empty and therefore nothing is
    executed, additionally some backends will not support this - mostly only
    Makefile backends.

    \section1 QMAKE_LN_SHLIB

    This variable contains the command to execute when creating a link
    to a shared library. The
    value of this variable is typically handled by \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \section1 QMAKE_MAKEFILE

    This variable contains the name of the Makefile to create. The
    value of this variable is typically handled by \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \section1 QMAKE_MOC_SRC

    This variable contains the names of all moc source files to
    generate and include in the project. The value of this variable is
    typically handled by \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \section1 QMAKE_QMAKE

    This variable contains the location of qmake if it is not in the path.
    The value of this variable is typically handled by \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \section1 QMAKE_QT_DLL

    This variable is not empty if Qt was built as a dll.  The
    value of this variable is typically handled by \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \section1 QMAKE_RUN_CC

    This variable specifies the individual rule needed to build an object.
    The value of this variable is typically handled by \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \section1 QMAKE_RUN_CC_IMP

    This variable specifies the individual rule needed to build an object.
    The value of this variable is typically handled by \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \section1 QMAKE_RUN_CXX

    This variable specifies the individual rule needed to build an object.
    The value of this variable is typically handled by \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \section1 QMAKE_RUN_CXX_IMP

    This variable specifies the individual rule needed to build an object.
    The value of this variable is typically handled by \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \section1 QMAKE_TARGET

    This variable contains the name of the project target.  The value of
    this variable is typically handled by \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \section1 QMAKE_UIC

    This variable contains the location of uic if it is not in the path.
    The value of this variable is typically handled by \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    It can be used to specify arguments to uic as well, such as additional plugin
    paths.  For example:

    \code
        QMAKE_UIC = uic -L /path/to/plugin
    \endcode

    \section1 RC_FILE

    This variable contains the name of the resource file for the application.
    The value of this variable is typically handled by \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \section1 RES_FILE

    This variable contains the name of the resource file for the application.
    The value of this variable is typically handled by \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \section1 SRCMOC

    This variable is set by \c qmake if files can be found that
    contain the Q_OBJECT macro.  \c SRCMOC contains the
    name of all the generated moc files. The value of this variable
    is typically handled by \c qmake or \l{#QMAKESPEC}{qmake.conf} and rarely needs to be
    modified.

    \section1 TARGET_EXT

    This variable specifies the target's extension.  The value of this variable
    is typically handled by \c qmake or \l{#QMAKESPEC}{qmake.conf} and rarely needs to be
    modified.

    \section1 TARGET_x

    This variable specifies the target's extension with a major version number.  The value of this variable
    is typically handled by \c qmake or \l{#QMAKESPEC}{qmake.conf} and rarely needs to be
    modified.

    \section1 TARGET_x.y.z

    This variable specifies the target's extension with version number.  The value of this variable
    is typically handled by \c qmake or \l{#QMAKESPEC}{qmake.conf} and rarely needs to be
    modified.

    \section1 UICIMPLS

    This variable contains a list of the generated implementation files by UIC.
    The value of this variable
    is typically handled by \c qmake or \l{#QMAKESPEC}{qmake.conf} and rarely needs to be
    modified.

    \section1 UICOBJECTS

    This variable is generated from the UICIMPLS variable.  The extension of each
    file will have been replaced by .o (Unix) or .obj (Win32).  The value of this variable is
    typically handled by \c qmake or \l{#QMAKESPEC}{qmake.conf} and
    rarely needs to be modified.

    \section1 VER_MAJ

    This variable contains the major version number of the library, if the
    \c lib \l{#TEMPLATE}{template} is specified.

    \section1 VER_MIN

    This variable contains the minor version number of the library, if the
    \c lib \l{#TEMPLATE}{template} is specified.

    \section1 VER_PAT

    This variable contains the patch version number of the library, if the
    \c lib \l{#TEMPLATE}{template} is specified.

    \section1 QMAKE_EXT_MOC

    This variable changes the extention used on included moc files.

    See also \l{Configuring qmake's Environment#Extensions}{File Extensions}.

    \section1 QMAKE_EXT_UI

    This variable changes the extention used on /e Designer UI files.

    See also \l{Configuring qmake's Environment#Extensions}{File Extensions}.

    \section1 QMAKE_EXT_PRL

    This variable changes the extention used on created PRL files.

    See also \l{Configuring qmake's Environment#Extensions}{File Extensions},
             \l{Configuring qmake's Environment#libdepend}{Library Dependencies}.

    \section1 QMAKE_EXT_LEX

    This variable changes the extention used on files given to lex.

    See also \l{Configuring qmake's Environment#Extensions}{File Extensions},
             \l{#LEXSOURCES}{LEXSOURCES}.

    \section1 QMAKE_EXT_YACC
    This variable changes the extention used on files given to yacc.

    See also \l{Configuring qmake's Environment#Extensions}{File Extensions},
             \l{#YACCSOURCES}{YACCSOURCES}.

    \section1 QMAKE_EXT_OBJ

    This variable changes the extention used on generated object files.

    See also \l{Configuring qmake's Environment#Extensions}{File Extensions}.

    \section1 QMAKE_EXT_CPP

    This variable changes the interpretation of all suffixes in this
    list of values as files of type C++ source code.

    See also \l{Configuring qmake's Environment#Extensions}{File Extensions}.

    \section1 QMAKE_EXT_H

    This variable changes the interpretation of all suffixes in this
    list of values as files of type C header files.

    See also \l{Configuring qmake's Environment#Extensions}{File Extensions}.

    \section1 YACCIMPLS

    This variable contains a list of yacc source files. The value of
    this variable is typically handled by \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.

    \section1 YACCOBJECTS

    This variable contains a list of yacc object files. The value of
    this variable is typically handled by \c qmake or
     \l{#QMAKESPEC}{qmake.conf} and rarely needs to be modified.
*/

/*!
    \page qmake-function-reference.html
    \title qmake Function Reference
    \contentspage qmake-manual.html Contents
    \previouspage qmake Variable Reference
    \nextpage Configuring qmake's Environment

    \c qmake provides built-in functions to allow the contents of
    variables to be processed, and to enable tests to be performed
    during the configuration process. Functions that process the
    contents of variables typically return values that can be assigned
    to other variables, and these values are obtained by prefixing
    function with the \c $$ operator. Functions that perform tests
    are usually used as the conditional parts of scopes; these are
    indicated in the function descriptions below.

    \tableofcontents{2}

    \section1 basename(file)

    Returns the basename of the file specified. For example:

    \code
       FILE = /etc/passwd
       FILENAME = $$basename($$FILE) #passwd
    \endcode

    \section1 CONFIG(config)
    [Conditional]

    This function can be used to test for variables placed into the CONFIG
    variable. This is the same as regular old style (tmake) scopes, but
    has the added advantage a second paramter can be passed to test for
    the active config. As CONFIG's are order dependent (ie the last one
    set will be considered the active config for mutual exclusive sets
    like debug and release) a second paramter can be used to specify a set
    of values to consider for example:

    \code
        CONFIG = debug
        CONFIG += release
        CONFIG(release, debug|release):message(Release build!) #will print
        CONFIG(debug, debug|release):message(Debug build!) #no print
    \endcode

    Because release is considered the active setting (for feature parsing)
    it will be the CONFIG used to generate the build file. In the common
    case a second paramter is not needed, but for specific mutual
    exclusive tests it is invaluable.

    \section1 contains(variablename, value)
    [Conditional]

    Succeeds if the variable \e variablename contains the value \e value;
    otherwise fails. You can check the return value of this function using
    a scope.

    For example:

    \code
        contains( drivers, network ) {
            # drivers contains 'network'
            message( "Configuring for network build..." )
            HEADERS += network.h
            SOURCES += network.cpp
        }
    \endcode

    The contents of the scope are only processed if the \c drivers
    variable contains the value, \c network. If this is the case, the
    appropriate files are added to the \c SOURCES and \c HEADERS
    variables.

    \section1 count(variablename, number)
    [Conditional]

    Succeeds if the variable \e variablename contains a list with the
    specified \e number of value; otherwise fails.

    This function is used to ensure that declarations inside a scope are
    only processed if the variable contains the correct number of values;
    for example:

    \quotefromfile snippets/qmake/functions.pro
    \skipto options =
    \printuntil }

    \section1 dirname(file)

    Returns the directory name part of the specified file. For example:

    \code
       FILE = /etc/X11R6/XF86Config
       DIRNAME = dirname($$FILE) #/etc/X11R6
    \endcode

    \section1 error(string)

    This function never returns a value. \c qmake displays the given
    \e string to the user, and exits. This function should only be used
    for unrecoverable errors.

    For example:

    \code
        error(A error has occurred in the configuration process.)
    \endcode

    \section1 exists(filename)
    [Conditional]

    Tests whether a file with the given \e filename exists.
    If the file exists, the function succeeds; otherwise it fails.
    If a regular expression is specified for the filename, this function
    succeeds if any file matches the regular expression specified.

    For example:
    \code
        exists( $(QTDIR)/lib/libqt-mt* ) {
              message( "Configuring for multi-threaded Qt..." )
              CONFIG += thread
        }
    \endcode

    Note that "/" can be used as a directory separator, regardless of the
    platform in use.

    \section1 find(variablename, substr)

    Places all the values in \e variablename that match \e substr. \e
    substr may be a regular expression, and will be matched accordingly.

    \code
        MY_VAR = one two three four
        MY_VAR2 = $$join(MY_VAR, " -L", -L) -Lfive
        MY_VAR3 = $$member(MY_VAR, 2) $$find(MY_VAR, t.*)
    \endcode

    MY_VAR2 will contain '-Lone -Ltwo -Lthree -Lfour -Lfive', and MYVAR3 will
    contains 'three two three'.

    \section1 for(iterate, list)

    This special test function will cause a loop to be started that
    iterates over all values in \e list, setting \e iterate to each
    value in turn. As a convenience, if \e list is 1..10 then iterate will
    iterate over the values 1 through 10.

    The use of an else scope afer a condition line with a for() loop is
    disallowed.

    For example:

    \code
        LIST = 1 2 3
        for(a, LIST):exists(file.$${a}):message(I see a file.$${a}!)
    \endcode

    \section1 include(filename)
    [Conditional]

    Includes the contents of the file specified by \e filename into the
    current project at the point where it is included. This function
    succeeds if \e filename is included; otherwise it fails. The included
    file is processed immediately.

    You can check whether the file was included by using this function as
    the condition for a scope; for example:

    \code
        include( shared.pri )
        OPTIONS = standard custom
        !include( options.pri ) {
            message( "No custom build options specified" )
        OPTIONS -= custom
        }
    \endcode

    \section1 infile(filename, var, val)
    [Conditional]

    Succeeds if the file \e filename (when parsed by \c qmake itself)
    contains the variable \e var with a value of \e val; otherwise fails.
    If you do not specify a third argument (\e val), the function will
    only test whether \e var has been declared in the file.

    \section1 isEmpty(variablename)
    [Conditional]

    Succeeds if the variable \e variablename is empty; otherwise fails.
    This is the equivalent of \c{count( variablename, 0 )}.

    For example:

    \code
        isEmpty( CONFIG ) {
        CONFIG += qt warn_on debug
        }
    \endcode

    \section1 join(variablename, glue, before, after)

    Joins the value of \e variablename with \c glue. If this value is
    non-empty it prefixes the value with \e before and suffix it with \e
    after. \e variablename is the only required field, the others default
    to empty strings. If you need to encode spaces in \e glue, \e before, or \e
    after you must quote them.

    \section1 member(variablename, position)

    Places the value in \e variablename in position \e position of the
    list. If the value of \e variablename is not long, an empty string is
    returned. \e variablename is the only required field. If not specified,
    \c position defaults to the first value in the list (0).

    \section1 message(string)

    This function simply writes a message to the console. Unlike the
    \c error() function, this function allows processing to continue.

    \code
        message( "This is a message" )
    \endcode

    The above line causes "This is a message" to be written to the console.
    The use of quotation marks is optional.

    \section1 prompt(question)

    Displays the specified \e question, and returns a value read from stdin.

    \section1 quote(string)

    Converts a whole \e string into a single entity and returns the result.
    Newlines, carriage returns, and tabs can be specified in the string
    with \\n \\r and \\t. The return value does not contain either single
    or double quotation marks unless you explicitly include them yourself,
    but will be placed into a single entry (for literal expansion).

    \section1 sprintf(string, arguments...)

    Replaces %1-%9 with the arguments passed in the comma-separated list
    of function \e arguments and returns the processed string.

    \section1 system(command)
    [Conditional]

    Executes the given \c command in a secondary shell, and succeeds
    if the command returns with a zero exit status; otherwise fails.
    You can check the return value of this function using a scope:

    For example:

    \code
        system(ls /bin):HAS_BIN=FALSE
    \endcode

    Alternatively, you can use this function to obtain stdout and stderr
    from the command, and assign it to a variable. For example, you can
    use this to interrogate information about the platform:

    \code
        UNAME = $$system(uname -s)
        contains( UNAME, [lL]inux ):message( This looks like Linux ($$UNAME) to me )
    \endcode

    \target unique
    \section1 unique(variablename)

    This will return a list of values in variable that are unique (that is
    with repetitive entries removed). For example:

    \code
       ARGS = 1 2 3 2 5 1
       ARGS = $$unique(ARGS) #1 2 3 5
    \endcode

    \section1 warning(string)

    This function will always succeed, and will display the given
    \e string to the user. message() is a synonym for warning().
*/

/*!
    \page qmake-environment-reference.html
    \contentspage qmake-manual.html Contents
    \previouspage qmake-function-reference.html qmake Function Reference
    \nextpage qmake Tutorial

    \title Configuring qmake's Environment

    \tableofcontents

    \target Properties
    \section1 Properties

    \c qmake has a system of persistant information, this allows you to
    \c set a variable in qmake once, and each time qmake is invoked this
    value can be queried. Use the following to set a property in qmake:

    \code
        qmake -set VARIABLE VALUE
    \endcode

    To retrieve this information back from qmake you can do:

    \code
        qmake -query VARIABLE
        qmake -query #queries all current VARIABLE/VALUE pairs..
    \endcode

    This information will be saved into a QSettings object (meaning it
    will be stored in different places for different platforms). As
    VARIABLE is versioned as well, you can set one value in an older
    version of qmake, and newer versions will retrieve this value, however
    if you -set VARIABLE into a newer version of qmake the older version
    will not use this value. You can however query a specific version of a
    variable if you prefix that version of qmake to VARIABLE, as in:

    \code
        qmake -query "1.06a/VARIABLE"
    \endcode

    qmake also has the notion of \c builtin properties, for example you can
    query the installation of Qt for this version of qmake with the
    QT_INSTALL_PREFIX property:

    \code
        qmake -query "QT_INSTALL_PREFIX"
    \endcode

    These builtin properties cannot have a version prefixed to them as
    they are not versioned and each qmake will have its own notion of
    these values. The list below outlines the builtin properties:

    \list
    \o QT_INSTALL_PREFIX - Where the version of Qt this qmake is built for resides
    \o QT_INSTALL_DATA - Where data for this version of Qt resides
    \o QMAKE_VERSION - The current version of qmake
    \endlist

    Finally, these values can be queried in a project file with a special
    notation such as:

    \code
        QMAKE_VERS = $$[QMAKE_VERSION]
    \endcode

    \target QMAKESPEC
    \section1 QMAKESPEC

    \c qmake requires a platform and compiler description file which
    contains many default values used to generate appropriate Makefiles.
    The standard Qt distribution comes with many of these files, located
    in the \c mkspecs subdirectory of the Qt installation.

    The QMAKESPEC environment variable can contain any of the following:

    \list
    \o A complete path to a directory containing a qmake.conf file.  In this case \c qmake will open the qmake.conf file from within that directory.  If the file does not exist, \c qmake will exit with an error.
    \o The name of a platform-compiler combination.  In this case, \c qmake will search in the directory specified by the QTDIR environment variable.
    \endlist

    Note: the QMAKESPEC path will automatically be added to the
    \l{qmake Variable Reference#INCLUDEPATH}{INCLUDEPATH} system variable.

    \target INSTALLS
    \section1 INSTALLS

    It is common on UNIX to be able to install from the same utility as
    you build with (e.g make install). For this \c qmake has introduce the
    concept of an install set. The notation for this is quite simple,
    first you fill in an "object" in qmake for example:

    \code
        documentation.path = /usr/local/program/doc
        documentation.files = docs/*
    \endcode

    In this way you are telling \c qmake several things about this
    install, first that you plan to install to /usr/local/program/doc (the
    path member), second that you plan to copy everything in the docs
    directory. Once this is done you may insert it in the install list:

    \code
        INSTALLS += documentation
    \endcode

    Now \c qmake will take over making sure the correct things are copied
    to the specified places. If however you require greater control you
    may use the \c extra member of the object:

    \code
        unix:documentation.extra = create_docs; mv master.doc toc.doc
    \endcode

    Then qmake will run the things in extra (this is of course platform
    specific, so you may need to test for your platform first, this case
    we test for unix). Then it will do the normal processings of the files
    member. Finally if you appened a builtin install to INSTALLS \c qmake
    (and do not specify a files or extra member) will decide what needs to
    be copied for you, currently the only supported builtin is target:

    \code
        target.path = /usr/local/myprogram
        INSTALLS += target
    \endcode

    With this \c qmake will know what you plan need copied, and do this
    for you.

    \target cache
    \section1 Cache File

    The cache file (mentioned above in the options) is a special file \c qmake
    will read to find settings not specified in the \c qmake.conf file, the
    .pro file, or the command line. If \c -nocache is not specified, \c qmake
    will try to find a file called \c .qmake.cache in parent directories.  If
    it fails to find this file, it will silently ignore this step of
    processing.

    \target LibDepend
    \section1 Library Dependencies

    Often when linking against a library \c qmake relies on the underlying
    platform to know what other libraries this library links against, and
    lets the platform pull them in. In many cases, however, this is not
    sufficent. For example when statically linking a library there are no
    libraries linked against, and therefore no dependencies to those
    libraries are created - however an application that later links
    against this library will need to know where to find the symbols that
    the linked in library will require. To help with this situation \c
    qmake will follow a library's dependencies when it feels appropriate,
    however this behaviour must be enabled in \c qmake. To enable requires
    two steps. First, you must enable it in the library - to do this you
    must tell \c qmake to save information about this library:

    \code
        CONFIG += create_prl
    \endcode

    This is only relevant to the lib template, and will be ignored for all
    others. When this option is enabled \c qmake will create a file
    (called a .prl file) which will save some meta information about the
    library. This metafile is itself just a qmake project file, but with
    all internal variables. You are free to view this file, and if deleted
    \c qmake will know to recreate it when necesary (either when the .pro
    file is later read, or if a dependent library (described below) has
    changed). When installing this library (by using target in INSTALLS,
    above) \c qmake will automatically copy the .prl file to your install
    path.

    The second step to enabling this processing is to turn on reading of
    the meta information created above:

    \code
        CONFIG += link_prl
    \endcode

    When this is turned on \c qmake will process all libraries linked to,
    and find their meta information. With this meta information \c qmake
    will figure out what is relevant to linking, specifically it will add
    to your list of DEFINES as well as LIBS. Once \c qmake has processed
    this file, it will then look through the newly introduced LIBS and
    find their dependent .prl files, and continue until all libraries have
    been resolved. At this point the Makefile is created as usual, and the
    libraries are linked explicity against your program.

    The internals of the .prl file are left closed so they can easily
    change later. It is not designed to be changed by hand however, and
    should only be created by \c qmake - these .prl files should also not
    be transfered from operating system to operating system as they may be
    platform dependent (like a Makefile).

    \target Extensions
    \section1 File Extensions

    Under normal circumstances \c qmake will try to use appropriate file extensions
    for your platform. There may be times, however, that you would like to override
    the behavior of these extensions. To do this, you must modify builtin variables
    in your .pro file, which will in turn changes \c qmake's interpretation of these
    files. You may do this as:

    \code
        QMAKE_EXT_MOC = .mymoc
    \endcode

    The variables are as follows:

    \list
    \o QMAKE_EXT_MOC - This modifies the extension placed on included moc files.
    \o QMAKE_EXT_UI - This modifies the extension used for designer UI files (usually in FORMS).
    \o QMAKE_EXT_PRL - This modifies the extension placed on
                       \l{#LibDepend}{library dependency files}.
    \o QMAKE_EXT_LEX - This changes the suffix used in files (usually in LEXSOURCES).
    \o QMAKE_EXT_YACC - This changes the suffix used in files (usually in YACCSOURCES).
    \o QMAKE_EXT_OBJ - This changes the suffix used on generated object files.
    \endlist

    All the above accept just the first value, so you must assign to it one value that
    will be used through your Makefile. There are two variables that accept a list of values,
    they are:

    \list
    \o QMAKE_EXT_CPP - Changes interpretation all files with these suffixes to be
                       C++ source files.
    \o QMAKE_EXT_H - Changes interpretation all files with these suffixes to be
                       C header files.
    \endlist

    \target Customizing
    \section1 Customizing Makefile Output

    \c qmake often tries to be all things to all build tools, this is often less
    than ideal when you really need to run special platform dependent
    commands. This can be achieved with specific instructions to the different
    \c qmake backends (currently this is only supported by the UNIX
    \l{qmake Variable Reference#MAKEFILE_GENERATOR}{generator}).

    The interfaces to customizing the Makefile are done through "objects" as in
    other places in qmake. The notation for this is quite simple, first you
    fill in an "object" in qmake for example:

    \code
        mytarget.target = .buildfile
        mytarget.commands = touch $$mytarget.target
        mytarget.depends = mytarget2

        mytarget2.commands = @echo Building $$mytarget.target
    \endcode

    The information above defines a qmake target called mytarget which contains
    a Makefile target called .buildfile, .buildfile is generated by 'touch
    .buildfile', and finally that this Makefile target depends on the qmake
    target mytarget2. Additionally we've defined the qmake target mytarget2
    which simply echo's something to stdout.

    The final step to making use of the above is to instruct qmake that this is
    actually an object used by the target building parts of qmake by:

    \code
        QMAKE_EXTRA_UNIX_TARGETS += mytarget mytarget2
    \endcode

    This is all you need to do to actually build custom targets in qmake, of
    course you may want to tie one of these targets to actually building the
    \l{qmake Variable Reference#TARGET}{qmake build target}. To do this, you simply need to
    include your Makefile target in the list of
    \l{qmake Variable Reference#PRE_TARGETDEPS}{PRE_TARGETDEPS}.

    For convenience there is also a method of customizing (UNIX) projects
    for generic new compilers (or even preprocessors).

    \code
        new_moc.output  = moc_${QMAKE_FILE_BASE}.cpp
        new_moc.commands = moc ${QMAKE_FILE_NAME} -o ${QMAKE_FILE_OUT}
        new_moc.depend_command = g++ -E -M ${QMAKE_FILE_NAME} | sed "s,^.*: ,,"
        new_moc.input = NEW_HEADERS
        QMAKE_EXTRA_UNIX_COMPILERS += new_moc
    \endcode

    With this you can create a new moc for qmake, the commands will be
    executed over all arguments given to a NEW_HEADERS variable (from the
    input variable), and write to output (and automatically hand this
    filename to the compiler to be linked into your target). Additionally
    \c qmake will execute depend_command to generate dependency information and
    place this in the project as well.

    These commands can easily be placed into a cache file, and subsequent
    .pro files can give several arguments to NEW_HEADERS.
*/

/*!
    \page qmake-advanced-usage.html
    \title qmake Advanced Usage
    \contentspage qmake-manual.html Contents
    \previouspage Running qmake
    \nextpage qmake Reference

    Many \c qmake project files simply describe the sources and header files used
    by the project, using a list of \c{name = value} and \c{name += value}
    definitions. \c qmake also provides other operators, functions, and scopes
    that can be used to process the information supplied in variable declarations.
    These advanced features allow Makefiles to be generated for multiple platforms
    from a single project file.

    \tableofcontents

    \section1 Operators

    In many project files, the assignment \c = append \c += operators can be used
    to include all the information about a project. The typical pattern of use is
    to assign a list of values to a variable, and append more values depending on
    the result of various tests. Since \c qmake defines certain variables using
    default values, it is sometimes necessary to use the removal \c -= operator
    to filter out values that are not required. The following operators can be
    used to manipulate the contents of variables.

    The \c = operator assigns a value to a variable:

    \code
        TARGET = myapp
    \endcode

    The above line sets the \c TARGET variable to \c myapp. This will overwrite any
    values previously set for \c TARGET with \c myapp.

    The \c += operator appends a new value to the list of values in a variable:

    \code
        DEFINES += QT_DLL
    \endcode

    The above line appends \c QT_DLL to the list of pre-processor defines to be put
    in the generated Makefile.

    The \c -= operator removes a value from the list of values in a variable:

    \code
        DEFINES -= QT_DLL
    \endcode

    The above line removes \c QT_DLL from the list of pre-processor defines to be
    put in the generated Makefile.

    The \c *= operator adds a value to the list of values in a variable, but only
    if it is not already present. This prevents values from being included many
    times in a variable. For example:

    \code
        DEFINES *= QT_DLL
    \endcode

    In the above line, \c QT_DLL will only be added to the list of pre-processor
    defines if it is not already defined. Note that the
    \l{qmake Function Reference#unique}{unique()}
    function can also be used to ensure that a variables only contains one
    instance of each value.

    The \c ~= operator replaces any values that match a regular expression with
    the specified value:

    \code
        DEFINES ~= s/QT_[DT].+/QT
    \endcode

    In the above line, any values in the list that start with \c QT_D or \c QT_T are
    replaced with \c QT.

    The \c $$ operator is used to extract the contents of a variable, and can be
    used to pass values between variables or supply them to functions:

    \code
        EVERYTHING = $$SOURCES $$HEADERS
        message("The project contains the following files:")
        message($$EVERYTHING)
    \endcode

    \target Scopes
    \section1 Scopes

    Scopes are similar to \c if statements in procedural programming languages.
    If a certain condition is true, the declarations inside the scope are processed.

    \section2 Scopes and Conditions

    A scope is written as a condition followed by a series of declarations
    contained within a pair of braces; for example:

    \quotefromfile snippets/qmake/scopes.pro
    \skipto win32
    \printuntil }

    The above code will add the \c paintwidget_win.cpp file to the sources listed
    in the generated Makefile if \c qmake is used on a Windows platform.
    If \c qmake is used on a platform other than Windows, the define will be
    ignored.

    The conditions used in a given scope can also be negated to provide an
    alternative set of declarations that will be processed only if the
    original condition is false. For example, suppose we want to process
    something on all platforms \e except for Windows. We can achieve this by
    negating the scope like this:

    \quotefromfile snippets/qmake/scopes.pro
    \skipto !win32
    \printuntil }

    Scopes can be nested to combine more than one condition. For instance, if
    you want to include a particular file for a certain platform only if
    debugging is enabled then you write the following:

    \quotefromfile snippets/qmake/scopes.pro
    \skipto macx {
    \printuntil /^\}/

    To save writing many nested scopes, you can nest scopes using the \c :
    operator. The nested scopes in the above example can be rewritten in
    the following way:

    \skipto macx:debug {
    \printuntil }

    You may also use the \c : operator to perform single line conditional
    assignments; for example:

    \code
        win32:DEFINES += QT_DLL
    \endcode

    The above line adds \c QT_DLL to the \c DEFINES variable only on the
    Windows platform.
    Generally, the \c : operator behaves like a logical AND operator, joining
    together a number of conditions, and requiring all of them to be true.

    You can also provide alternative declarations to those within a scope by
    using an \c else scope. Each \c else scope is processed if the conditions
    for the preceding scopes are false.
    This allows you to write complex tests when combined with other scopes
    (separated by the \c : operator as above). For example:

    \code
        win32:xml {
            message(Building for Windows)
            SOURCES += xmlhandler_win.cpp
        } else:xml {
            SOURCES += xmlhandler.cpp
        } else {
            message("Unknown configuration")
        }
    \endcode

    \section2 Configuration and Scopes

    The values stored in the
    \l{qmake-project-files.html#GeneralConfiguration}{\c CONFIG variable}
    are treated specially by \c qmake. Each of the possible values can be
    used as the condition for a scope. For example, the list of values
    held by \c CONFIG can be extended with the \c debug value:

    \quotefromfile snippets/qmake/configscopes.pro
    \skipto CONFIG += debug
    \printuntil CONFIG += debug

    As a result of this operation, any scopes that test for \c debug will
    be processed. We can use this feature to give the final executable an
    appropriate name:

    \skipto debug {
    \printuntil release {
    \printuntil }

    This feature makes it easy to change the configuration for a project
    without losing all the custom settings that might be needed for a specific
    configuration. In the above code, the declarations in the first scope are
    processed, and the final executable will be called \c application-debug.
    However, if \c release is specified instead of \c debug, the declarations
    in the second scope are processed instead, and the final executable will
    be called \c application.

    Since it is possible to put your own values on the \c CONFIG
    line, this provides you with a convenient way to customize project files
    and fine-tune the generated Makefiles.

    \section1 Variables

    Many of the variables used in project files are special variables that
    \c qmake uses when generating Makefiles, such as \c DEFINES, \c SOURCES,
    and \c HEADERS. It is possible for you to create your own variables to
    use; \c qmake creates new variables with a given name when it encounters
    an assignment to that name. For example:

    \code
        MY_VARIABLE = value
    \endcode

    There are no restricitions on what you do to your own variables, as \c
    qmake will ignore them unless it needs to evaluate them when processing
    a scope.

    You can also assign the value of a current variable to another
    variable by prefixing $$ to the variable name. For example:

    \code
        MY_DEFINES = $$DEFINES
    \endcode

    Now the MY_DEFINES variable contains what is in the DEFINES variable at
    this point in the project file.  This is also equivalent to:

    \code
        MY_DEFINES = $${DEFINES}
    \endcode

    The second notation allows you to append the contents of the variable to
    another value without separating the two with a space. For example, the
    following will ensure that the final executable will be given a name
    that includes the project template being used:

    \code
        TARGET = myproject_$${TEMPLATE}
    \endcode

    Variables can be used to store the contents of environment variables.
    These can be evaluated at the time that \c qmake is run, or included
    in the generated Makefile for evaluation when the project is built.

    To obtain the contents of an environment value when \c qmake is run,
    use the \c $$(...) operator:

    \quotefromfile snippets/qmake/environment.pro
    \skipto $$(QTDIR)
    \printuntil message(

    In the above assignment, the value of \c $QTDIR is read when the project
    file is processed.

    To obtain the contents of an environment value at the time when the
    generated Makefile is processed, use the \c $(...) operator:

    \quotefromfile snippets/qmake/environment.pro
    \skipto $(QTDIR)
    \printuntil message(when the Makefile

    In the above assignment, the value of \c $QTDIR is read immediately
    when the project file is processed, but \c $(QTDIR) is assigned to
    \c DESTDIR in the generated Makefile. This makes the build process
    more flexible as long as the environment variable is set correctly
    when the Makefile is processed.

    \target VariableProcessingFunctions
    \section1 Variable Processing Functions

    \c qmake provides a selection of built-in functions to allow the
    contents of variables to be processed. These functions process the
    arguments supplied to them and return a value, or list of values, as
    a result. In order to assign a result to a variable, it is necessary
    to use the \c $$ operator with this type of function in the same way
    used to assign contents of one variable to another:

    \quotefromfile snippets/qmake/functions.pro
    \skipto HEADERS =
    \printuntil HEADERS = $$unique(

    This type of function should be used on the right-hand side of
    assignments (i.e, as an operand).

    It is possible to define your own functions for processing the
    contents of variables. The following example function takes a variable
    name as its only argument, extracts a list of values from the variable
    with the \l{qmake-function-reference.html}{eval()} built-in function,
    and compiles a list of files:

    \quotefromfile snippets/qmake/replacefunction.pro
    \skipto defineReplace
    \printuntil

    \target ConditionalFunctions
    \section1 Conditional Functions

    \c qmake provides built-in functions that can be used as conditions
    when writing scopes. These functions do not return a value, but
    instead indicate "success" or "failure":

    \quotefromfile snippets/qmake/functions.pro
    \skipto count(options, 2)
    \printuntil }

    This type of function should be used in conditional expressions
    only.

    It is possible to define your own functions to provide conditions
    for scopes. The following example tests whether each file in a list
    exists and returns true if they all exist, or false if not:

    \quotefromfile snippets/qmake/testfunction.pro
    \skipto defineTest
    \printuntil /^\}/

    \section1 Adding New Configuration Features

    \c qmake lets you create your own \e features that can be included in
    project files by adding their names to the list of values specified by
    the \c CONFIG variable. Features are collections of custom functions and
    definitions in \c{.prf} files that can reside in one of many standard
    directories. The locations of these directories are defined in a number
    of places, and \c qmake checks each of them in the following order when
    it looks for \c{.prf} files:

    \list 1
    \o In a directory listed in the \c QMAKEFEATURES environment variable;
       this contains a colon-separated list of directories.
    \o In a directory listed in the \c QMAKEFEATURES property variable; this
       contains a colon-spearated list of directories.
    \o In a features directory beneath the project's root directory (where
       the .qmake.cache file is generated).
    \o In a features directory residing within a \c mkspecs directory.
       \c mkspecs directories can be located beneath any of the directories
       listed in the \c QMAKEPATH environment variable (a colon-separated list
       of directories). (\c{$QMAKEPATH/mkspecs/<features>})
    \o In a features directory residing beneath the directory provided by the
       \c QMAKESPEC environment variable. (\c{$QMAKESPEC/<features>})
    \o In a features directory residing in the \c data_install/mkspecs directory.
       (\c{data_install/mkspecs/<features>})
    \o In a features directory that exists as a sibling of the directory
       specified by the \c QMAKESPEC environment variable.
       (\c{$QMAKESPEC/../<features>})
    \endlist

    The following features directories are searched for features files:

    \list 1
    \o \c{features/unix}, \c{features/win32}, or \c{features/macx}, depending on
       the platform in use
    \o \c features/
    \endlist

    For example, consider the following assignment in a project file:

    \code
        CONFIG += myfeatures
    \endcode

    With this addition to the \c CONFIG variable, \c qmake will search the
    locations listed above for the \c myfeatures.prf file after it has
    finished parsing your project file. On Unix systems, it will look for
    the following file:

    \list 1
    \o \c $QMAKEFEATURES/myfeatures.prf (for each directory listed in the
       \c QMAKEFEATURES environment variable)
    \o \c $$QMAKEFEATURES/myfeatures.prf (for each directory listed in the
       \c QMAKEFEATURES property variable)
    \o \c myfeatures.prf (in the project's root directory)
    \o \c $QMAKEPATH/mkspecs/features/unix/myfeatures.prf and
       \c $QMAKEPATH/mkspecs/features/myfeatures.prf (for each directory
       listed in the \c QMAKEPATH environment variable)
    \o \c $QMAKESPEC/features/unix/myfeatures.prf and
       \c $QMAKESPEC/features/myfeatures.prf
    \o \c data_install/mkspecs/features/unix/myfeatures.prf and
       \c data_install/mkspecs/features/myfeatures.prf
    \o \c $QMAKESPEC/../features/unix/myfeatures.prf and
       \c $QMAKESPEC/../features/myfeatures.prf
    \endlist
*/

/*!
    \page qmake-precompiledheaders.html
    \title Using Precompiled Headers

    \target About

    Precompiled headers are a performance feature supported by some
    compilers to compile a stable body of code, and store the compiled
    state of the code in a binary file. During subsequent compilations,
    the compiler will load the stored state, and continue compiling the
    specified file. Each subsequent compilation is faster because the
    stable code does not need to be recompiled.

    \c qmake supports the use of precompiled headers (PCH) on some
    platforms and build environments, including:
    \list
    \o Windows
        \list
        \o nmake
        \o Dsp projects (VC 6.0)
        \o Vcproj projects (VC 7.0 \& 7.1)
        \endlist
    \o Mac OS X
        \list
        \o Makefile
        \o Xcode
        \endlist
    \o Unix
        \list
        \o GCC 3.3 and up
        \endlist
    \endlist

    \target ADD_PCH
    \section1 Adding Precompiled Headers to Your Project

    \target PCH_CONTENTS
    \section2 Contents of the Precompiled Header File

    The precompiled header must contain code which is \c stable
    and \c static throughout your project. A typical PCH might look
    like this:

    \section3 Example: \c stable.h

    \code
    // Add C includes here

    #if defined __cplusplus
    // Add C++ includes here
    #include <stdlib>
    #include <iostream>
    #include <vector>
    #include <qapplication.h> // Qt includes
    #include <qpushbutton.h>
    #include <qlabel.h>
    #include "thirdparty/include/libmain.h"
    #include "my_stable_class.h"
    ...
    #endif
    \endcode

    Note that a precompiled header file needs to separate C includes from
    CPP includes, since the precompiled header file for C files may not
    contain C++ code.

    \target PROJECT_OPTIONS
    \section2 Project Options

    To make your project use PCH, the only thing you need to change in
    your project settings (.pro), is to include the PRECOMPILED_HEADER option:

    \code
        PRECOMPILED_HEADER = stable.h
    \endcode

    \c qmake will handle the rest, to ensure the creation and use of the
    precompiled header file. You do not need to include the precompiled
    header file in HEADERS, as qmake will do this if the configuration
    supports PCH.

    All platforms that support precompiled headers have the configuration
    option \bold precompile_header set. Using this option, you may trigger
    conditional blocks in your .pro file, to add settings when using PCH.
    For example:

    \code
        precompile_header:!isEmpty(PRECOMPILED_HEADER) {
        DEFINES += USING_PCH
        }
    \endcode

    \target EXAMPLE_PROJECT
    \section1 Example Project

    You can find the following source code in the
    \c{qt/qmake/examples/precompile} directory:

    \section2 \c mydialog.ui

    \quotefile precompile/mydialog.ui
    \skipto <!
    \printuntil </UI>

    \section2 \c stable.h

    \quotefile precompile/stable.h
    \skipto /*
    \printuntil #endif

    \section2 \c myobject.h

    \quotefile precompile/myobject.h
    \skipto #include
    \printuntil }

    \section2 \c myobject.cpp

    \quotefile precompile/myobject.cpp
    \skipto #include
    \printuntil }

    \section2 \c util.cpp

    \quotefile precompile/util.cpp
    \skipto void
    \printuntil }

    \section2 \c main.cpp

    \quotefile precompile/main.cpp
    \skipto #include
    \printuntil }

    \section2 \c precompile.pro

    \quotefile precompile/precompile.pro
    \skipto #
    \printuntil .ui
*/

/*!
    \page qmake-tutorial.html
    \title qmake Tutorial
    \contentspage qmake-manual.html Contents
    \previouspage qmake Function Reference
    \nextpage qmake Common Projects

    This tutorial teaches you how to use \c qmake.  We recommend that
    you read the \c qmake user guide after completing this tutorial.

    \section1 Starting off Simple

    Let's assume that you have just finished a basic implementation of
    your application, and you have created the following files:

    \list
    \o hello.cpp
    \o hello.h
    \o main.cpp
    \endlist

    You will find these files in \c {qt/qmake/examples/tutorial}.  The
    only other thing you know about the setup of the application is that
    it's written in Qt.  First, using your favorite plain text editor,
    create a file called \c hello.pro in \c {qt/qmake/tutorial}.  The
    first thing you need to do is add the lines that tell \c qmake about
    the source and header files that are part of your development project.

    We'll add the source files to the project file first.  To do this you
    need to use the SOURCES variable.  Just start a new line with \c
    {SOURCES +=} and put hello.cpp after it.  You should have something
    like:

    \code
        SOURCES += hello.cpp
    \endcode

    We repeat this for each source file in the project, until we end up
    with:

    \code
        SOURCES += hello.cpp
        SOURCES += main.cpp
    \endcode

    If you prefer to use a Make-like syntax, with all the files listed in
    one go you can use the newline escaping like this:

    \code
        SOURCES = hello.cpp \
                  main.cpp
    \endcode

    Now that the source files are listed in the project file, the header
    files must be added. These are added in exactly the same way as source
    files, except that the variable name is HEADERS:

    Once you have done this, your project file should look something like
    this:

    \code
        HEADERS += hello.h
        SOURCES += hello.cpp
        SOURCES += main.cpp
    \endcode

    The target name is set automatically; it is the same as the project
    file, but with the suffix appropriate to the platform. For example, if
    the project file is called \c hello.pro, the target will be \c hello.exe
    on Windows and \c hello on Unix. If you want to use a different name
    you can set it in the project file:

    \code
        TARGET = helloworld
    \endcode

    The final step is to set the \c CONFIG variable. Since this is a Qt
    application, we need to put \c qt on the CONFIG line so that \c qmake
    will add the relevant libraries to be linked against and ensure that
    build lines for \c moc and \c uic are included in the makefile.

    The finished project file should look like this:

    \code
        CONFIG += qt
        HEADERS += hello.h
        SOURCES += hello.cpp
        SOURCES += main.cpp
    \endcode

    You can now use \c qmake to generate a makefile for your application.
    On the command line, in your application directory, type:

    \code
        qmake -o Makefile hello.pro
    \endcode

    Then type \c make or \c nmake depending on the compiler you use.

    \section1 Making an Application Debuggable

    The release version of an application doesn't contain any debugging
    symbols or other debuggin information. During development it is useful
    to produce a debugging version of the application that has the
    relevant information. This is easily achieved by adding \c debug to the
    CONFIG variable in the project file.

    For example:

    \code
        CONFIG += qt debug
        HEADERS += hello.h
        SOURCES += hello.cpp
        SOURCES += main.cpp
    \endcode

    Use \c qmake as before to generate a makefile and you will be able to
    debug your application.

    \section1 Adding Platform-Specific Source Files

    After a few hours of coding, you might have made a start on the
    platform specific part of your application, and decided to keep the
    platform dependent code separate.  So you now have two new files to
    include into your project file - \c hellowin.cpp and \c
    hellounix.cpp.  We can't just add these to the \c SOURCES
    variable since this will put both files in the makefile.  So what we
    need to do here is to use a scope which will be processed depending on
    which platform \c qmake is run on.

    A simple scope which will add in the platform dependent file for
    Windows looks like this:

    \code
        win32 {
            SOURCES += hellowin.cpp
        }
    \endcode

    So if \c qmake is run on Windows, it will add \c hellowin.cpp to the
    list of source files.  If \c qmake is run on any other platform, it
    will simply ignore it.  Now all that is left to be done is to create a
    scope for the unix dependent file.

    When you have done that, your project file should now look
    something like this:

    \code
        CONFIG += qt debug
        HEADERS += hello.h
        SOURCES += hello.cpp
        SOURCES += main.cpp
        win32 {
            SOURCES += hellowin.cpp
        }
        unix {
            SOURCES += hellounix.cpp
        }
    \endcode

    Use \c qmake as before to generate a makefile.

    \section1 Stopping qmake If a File Doesn't Exist

    You may not want to create a makefile if a certain file doesn't exist.
    We can check if a file exists by using the exists() function.  We can
    stop \c qmake from processing by using the error() function.  This
    works in the same way as scopes.  Simply replace the scope condition
    with the function. A check for a main.cpp file looks like this:

    \code
        !exists( main.cpp ) {
            error( "No main.cpp file found" )
        }
    \endcode

    The "!" is used to negate the test, i.e. \c{exists( main.cpp )} is
    true if the file exists and \c{!exists( main.cpp )} is true if the
    file doesn't exist.

    \code
        CONFIG += qt debug
        HEADERS += hello.h
        SOURCES += hello.cpp
        SOURCES += main.cpp
        win32 {
            SOURCES += hellowin.cpp
        }
        unix {
            SOURCES += hellounix.cpp
        }
        !exists( main.cpp ) {
            error( "No main.cpp file found" )
        }
    \endcode

    Use \c qmake as before to generate a makefile.  If you rename \c
    main.cpp temporarily, you will see the message and \c qmake will stop
    processing.

    \section1 Checking for More than One Condition

    Suppose you use Windows and you want to be able to see the qDebug()
    statements when you run your application on the command line.  Unless
    you build your application with the console setting, you won't see the
    output.  We can easily put \c console on the CONFIG line so that on
    Windows the makefile will have this setting.  But let's say that we
    only want to add the CONFIG line if we are running on Windows \c and when
    \c debug is already on the CONFIG line.  This requires using two
    nested scopes; just create one scope, then create the other inside
    that one.  Put the settings to be processed inside the last scope,
    like this:

    \code
        win32 {
            debug {
                CONFIG += console
            }
        }
    \endcode

    Nested scopes can be joined together using colons, so the final
    project file looks like this:

    \code
        CONFIG += qt debug
        HEADERS += hello.h
        SOURCES += hello.cpp
        SOURCES += main.cpp
        win32 {
            SOURCES += hellowin.cpp
        }
        unix {
            SOURCES += hellounix.cpp
        }
        !exists( main.cpp ) {
            error( "No main.cpp file found" )
        }
        win32:debug {
            CONFIG += console
        }
    \endcode

    That's it!  You have now completed the tutorial for \c qmake, and are
    ready to write project files for your development projects.
*/

/*!
    \page qmake-quickguide.html
    \title The Ten-Minute Guide to Using qmake

    \section1 Creating a Project File

    \c qmake uses information stored in project (.pro) files to determine
    what should go in the makefiles it generates.

    A basic project file contains information about the application. It
    declares the resources that are required to build the application,
    such as the files used to compile the application, any user interface
    descriptions, and which configuration settings to use.

    Here's a simple example project file:

    \code
        SOURCES = hello.cpp
        HEADERS = hello.h
        CONFIG += qt warn_on release
    \endcode

    We'll provide a brief line-by-line explanation, deferring the detail
    until later on in the manual.

    \code
        SOURCES = hello.cpp
    \endcode

    This line specifies the source files that implement the application. In this
    case there is just one file, \c hello.cpp. Most applications require
    multiple files; this situation is dealt with by listing all the files
    on the same line space separated, like this:

    \code
        SOURCES = hello.cpp main.cpp
    \endcode

    Alternatively, each file can be listed on a separate line, by escaping
    the newlines, like this:

    \code
        SOURCES = hello.cpp \
                  main.cpp
    \endcode

    A more verbose approach is to list each file separately, like this:

    \code
        SOURCES += hello.cpp
        SOURCES += main.cpp
    \endcode

    This approach uses "+=" rather than "=" which is safer, because it
    always adds a new file to the existing list rather than replacing the
    list.

    The HEADERS line is used to specify the header files created for use
    by the application, e.g.

    \code
        HEADERS += hello.h
    \endcode

    Any of the approaches used to list source files may be used for header
    files.

    The CONFIG line is used to give \c qmake information about the
    application's configuration.

    \code
        CONFIG += qt warn_on release
    \endcode

    The "+=" is used here, because we add our configuration options to any
    that are already present. This is safer than using "=" which replaces
    all options with just those specified.

    The \c qt part of the CONFIG line tells \c qmake that the application
    is built using Qt.  This means that \c qmake will link against the Qt
    libraries when linking and add in the neccesary include paths for
    compiling.

    The \c warn_on part of the CONFIG line tells \c qmake that it should
    set the compiler flags so that warnings are output.

    The \c release part of the CONFIG line tells \c qmake that the
    application must be built as a release application. During
    development, programmers may prefer to replace \c release with \c
    debug, which is discussed later.

    \omit
    The last line in the project file is the TARGET line:

    \code
        TARGET = hello
    \endcode

    The target line simply specifies what the name of the target should be
    for the application.  You shouldn't put an extension here because \c
    qmake will do this for you.
    \endomit

    Project files are plain text (i.e. use an editor like notepad, vim
    or xemacs) and must be saved with a \c .pro extension. The name of the
    application's executable will be the same as the project file's name,
    but with an extension appropriate to the platform. For example, a
    project file called \c hello.pro will produce \c hello.exe on Windows
    and \c hello on Unix.

    \section1 Generating a Makefile

    When you have created your project file it is very easy to generate a
    makefile, all you need to do is go to where you have created your
    project file and type:

    Makefiles are generated from the \c .pro files like this:

    \code
        qmake -o Makefile hello.pro
    \endcode

    For Visual Studio users, \c qmake can also generate \c .dsp files, for
    example:

    \code
        qmake -t vcapp -o hello.dsp hello.pro
    \endcode
*/

/*!
    \page qmake-common-projects.html
    \title qmake Common Projects
    \contentspage qmake-manual.html Contents
    \previouspage qmake Tutorial

    This chapter describes how to set up \c qmake project files for three
    common types of project that are based on Qt. Although all kinds of
    project use many of the same variables, each of them use special
    variables to define

    \tableofcontents

    \target Application
    \section1 Building an Application

    \section2 The \c app Template

    The \c app template tells \c qmake to generate a Makefile that will build
    an application. With this template, the type of application can be specified
    by adding one of the following options to the \c CONFIG variable definition:

    \table
    \header \o Option  \o Description
    \row    \o windows \o The application is a Windows GUI application.
    \row    \o console \o \c app template only: the application is a Windows console
                       application.
    \endtable

    When using this template the following \c qmake system variables are recognized.
    You should use these in your .pro file to specify information about your
    application.

    \list
    \o HEADERS - A list of all the header files for the application.
    \o SOURCES - A list of all the source files for the application.
    \o FORMS - A list of all the .ui files (created using \c{Qt Designer})
    for the application.
    \o LEXSOURCES - A list of all the lex source files for the application.
    \o YACCSOURCES - A list of all the yacc source files for the application.
    \o TARGET - Name of the executable for the application. This defaults
    to the name of the project file. (The extension, if any, is added
    automatically).
    \o DESTDIR - The directory in which the target executable is placed.
    \o DEFINES - A list of any additional pre-processor defines needed for the application.
    \o INCLUDEPATH - A list of any additional include paths needed for the application.
    \o DEPENDPATH - The dependency search path for the application.
    \o VPATH - The search path to find supplied files.
    \o DEF_FILE - Windows only: A .def file to be linked against for the application.
    \o RC_FILE - Windows only: A resource file for the application.
    \o RES_FILE - Windows only: A resource file to be linked against for the application.
    \endlist

    You only need to use the system variables that you have values for,
    for instance, if you don't have any extra INCLUDEPATHs then you don't
    need to specify any, \c qmake will add in the default ones needed.
    For instance, an example project file might look like this:

    \code
        TEMPLATE = app
        DESTDIR  = c:\helloapp
        HEADERS += hello.h
        SOURCES += hello.cpp
        SOURCES += main.cpp
        DEFINES += QT_DLL
        CONFIG  += qt warn_on release
    \endcode

    For items that are single valued, e.g. the template or the destination
    directory, we use "="; but for multi-valued items we use "+=" to \e
    add to the existing items of that type. Using "=" replaces the item's
    value with the new value, for example if we wrote \c{DEFINES=QT_DLL},
    all other definitions would be deleted.

    \target Library
    \section1 Building a Library

    \section2 The \c lib Template

    The \c lib template tells \c qmake to generate a Makefile that will
    build a library.  When using this template, in addition to the system variables
    mentioned above for the \c app template the \c VERSION variable is
    supported.  You should use these in your .pro file to specify
    information about the library.

    When using the \c lib template, the following options determine the type of
    library that is built:

    \table
    \header \o Option    \o Description
    \row    \o dll       \o The library is a shared library (dll).
    \row    \o staticlib \o The library is a static library.
    \row    \o plugin    \o The library is a plugin; this also enables the dll option.
    \endtable

    \list
    \o VERSION - The version number of the target library, for example, 2.3.1.
    \endlist
*/
