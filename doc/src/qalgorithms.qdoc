/*!
    \headerfile <QtAlgorithms>
    \title Generic Algorithms

    \brief The <QtAlgorithms> header file provides generic template-based algorithms.

    Qt provides a number of global template functions in \c
    <QtAlgorithms> that work on containers and perform well-know
    algorithms. You can use these algorithms with any \l {container
    class} that provides STL-style iterators, including Qt's QList,
    QLinkedList, QVector, QMap, and QHash classes.

    These functions have taken their inspiration from similar
    functions available in the STL \c <algorithm> header. Most of them
    have a direct STL equivalent; for example, qCopyBackward() is the
    same as STL's copy_backward() algorithm.

    If STL is available on all your target platforms, you can use the
    STL algorithms instead of their Qt counterparts. One reason why
    you might want to use the the STL algorithms is that STL provides
    dozens and dozens of algorithms, whereas Qt only provides the most
    important ones, making no attempt to duplicate functionality that
    is already provided by the C++ standard.

    Most algorithms take \l {STL-style iterators} as parameters. The
    algorithms are generic in the sense that they aren't bound to a
    specific iterator class; you can use them with any iterators that
    meet a certain set of requirements.

    Let's take the qFill() algorithm as an example. Unlike QVector,
    QList has no fill() function that can be used to fill a list with
    a particular value. If you need that functionality, you can use
    qFill():

    \code
	QList<QString> list;
        list << "one" << "two" << "three";

        qFill(list.begin(), list.end(), "eleven");
        // list: [ "eleven", "eleven", "eleven" ]
    \endcode

    qFill() takes a begin iterator, an end iterator, and a value.
    In the example above, we pass \c list.begin() and \c list.end()
    as the begin and end iterators, but this doesn't have to be
    the case:

    \code
	qFill(list.begin() + 1, list.end(), "six");
        // list: [ "eleven", "six", "six" ]
    \endcode

    The various algorithms have different requirements for the
    iterators they accept. For example, qFill() accepts two \l {input
    iterators}, the most minimal requirement for an iterator type. The
    requirements are specified for every algorithm. If an iterator of
    the wrong type is passed (for example, QList::ConstIterator is
    passed as an \l{output iterator}), you will always get a
    compiler error, although not necessarily a very informative one.

    Some algorithms have special requirements on the value type
    stored in the containers. For example, qEqual() requires that the
    value type supports operator==(), which it uses to compare items.
    Similarly, qDeleteAll() requires that the value type is a
    non-const pointer type (for example, QWidget *). The value type
    requirements are specified for each algorithm, and the compiler
    will produce an error if a requirement isn't met.

    \target binaryFind example

    The generic algorithms can be used on other container classes
    than those provided by Qt and STL. The syntax of STL-style
    iterators is modeled after C++ pointers, so it's possible to use
    plain arrays as containers and plain pointers as iterators. A
    common idiom is to use qBinaryFind() together with two static
    arrays: one that contains a list of keys, and another that
    contains a list of associated values. For example, the following
    code will look up an HTML entity (e.g., \c &amp;) in the \c
    name_table array and return the corresponding Unicode value from
    the \c value_table if the entity is recognized:

    \code
	QChar resolveEntity(const QString &entity)
        {
	    static const QLatin1String name_table[] = {
	        "AElig", "Aacute", ..., "zwnj"
            };
            static const ushort value_table[] = {
	        0x0061, 0x00c1, ..., 0x200c
            };
            int N = sizeof(name_table) / sizeof(name_table[0]);

	    const QLatin1String *name = qBinaryFind(name_table, name_table + N,
						    entity);
	    int index = name - name_table;
	    if (index == N)
		return QChar();

	    return QChar(value_table[index]);
	}
    \endcode

    This kind of code is for advanced users only; for most
    applications, a QMap- or QHash-based approach would work just as
    well:

    \code
	QChar resolveEntity(const QString &entity)
        {
	    static QMap<QString, int> entityMap;

	    if (!entityMap) {
		entityMap.insert("AElig", 0x0061);
		entityMap.insert("Aacute", 0x00c1);
                ...
		entityMap.insert("zwnj", 0x200c);
            }
            return QChar(entityMap.value(entity));
        }
    \endcode

    \section1 Types of Iterators

    The algorithms have certain requirements on the iterator types
    they accept, and these are specified individually for each
    function. The compiler will produce an error if a requirement
    isn't met.

    \section2 Input Iterators

    An \e{input iterator} is an iterator that can be used for reading
    data sequentially from a container. It must provide the following
    operators: \c{==} and \c{!=} for comparing two iterators, unary
    \c{*} for retrieving the value stored in the item, and prefix
    \c{++} for advancing to the next item.

    The Qt containers' iterator types (const and non-const) are all
    input iterators.

    \section2 Output Iterators

    An \e{output iterator} is an iterator that can be used for
    writing data sequentially to a container or to some output
    stream. It must provide the following operators: unary \c{*} for
    writing a value (i.e., \c{*it = val}) and prefix \c{++} for
    advancing to the next item.

    The Qt containers' non-const iterator types are all output
    iterators.

    \section2 Forward Iterators

    A \e{forward iterator} is an iterator that meets the requirements
    of both input iterators and output iterators.

    The Qt containers' non-const iterator types are all forward
    iterators.

    \section2 Bidirectional Iterators

    A \e{bidirectional iterator} is an iterator that meets the
    requirements of forward iterators but that in addition supports
    prefix \c{--} for iterating backward.

    The Qt containers' non-const iterator types are all bidirectional
    iterators.

    \section2 Random Access Iterators

    The last category, \e{random access iterators}, is the most
    powerful type of iterator. It supports all the requirements of a
    bidirectional iterator, and supports the following operations:

    \table
    \row \i \c{i += n} \i advances iterator \c i by \c n positions
    \row \i \c{i -= n} \i moves iterator \c i back by \c n positions
    \row \i \c{i + n} or \c{n + i} \i returns the iterator for the item \c
       n positions ahead of iterator \c i
    \row \i \c{i - n} \i returns the iterator for the item \c n positions behind of iterator \c i
    \row \i \c{i - j} \i returns the number of items between iterators \c i and \c j
    \row \i \c{i[n]} \i same as \c{*(i + n)}
    \row \i \c{i < j} \i returns true if iterator \c j comes after iterator \c i
    \endtable

    QList, QLinkedList, and QVector's non-const iterator types are
    random access iterators.

    \sa {container classes}, <QtGlobal>
*/

/*! \fn OutputIterator qCopy(InputIterator begin1, InputIterator end1, OutputIterator begin2)
    \relates <QtAlgorithms>

    Copies the items from range [\a begin1, \a end1) to range [\a
    begin2, ...), in the order in which they appear.

    The item at position \a begin1 is assigned to that at position \a
    begin2; the item at position \a begin1 + 1 is assigned to that at
    position \a begin2 + 1; and so on.

    Example:
    \code
        QList<QString> list;
	list << "one" << "two" << "three";

	QVector<QString> vect1(3);
        qCopy(list.begin(), list.end(), vect1.begin());
        // vect: [ "one", "two", "three" ]

        QVector<QString> vect2(8);
        qCopy(list.begin(), list.end(), vect2.begin() + 2);
        // vect: [ "", "", "one", "two", "three", "", "", "" ]
    \endcode

    \sa qCopyBackward(), {input iterators}, {output iterators}
*/

/*! \fn BiIterator2 qCopyBackward(BiIterator1 begin1, BiIterator1 end1, BiIterator2 end2)
    \relates <QtAlgorithms>

    Copies the items from range [\a begin1, \a end1) to range [...,
    \a end2).

    The item at position \a end1 - 1 is assigned to that at position
    \a end2 - 1; the item at position \a end1 - 2 is assigned to that
    at position \a end2 - 2; and so on.

    Example:
    \code
        QList<QString> list;
	list << "one" << "two" << "three";

	QVector<QString> vect(5);
        qCopyBackward(list.begin(), list.end(), vect.end());
        // vect: [ "", "", "one", "two", "three" ]
    \endcode

    \sa qCopy(), {bidirectional iterators}
*/

/*! \fn bool qEqual(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2)
    \relates <QtAlgorithms>

    Compares the items in the range [\a begin1, \a end1) with the
    items in the range [\a begin2, ...). Returns true if all the
    items compare equal; otherwise returns false.

    Example:
    \code
	QList<QString> list;
        list << "one" << "two << "three";

	QVector<QString> vect[3];
        vect[0] = "one";
        vect[1] = "two";
        vect[2] = "three";

	bool ret1 = qEqual(list.begin(), list.end(), vect.begin());
        // ret1 == true

        vect[2] = "seven";
	bool rec2 = qEqual(list.begin(), list.end(), vect.begin());
        // ret2 == false
    \endcode

    This function requires the item type (in the example above,
    QString) to implement \c operator==().

    \sa {input iterators}
*/

/*! \fn void qFill(ForwardIterator begin, ForwardIterator end, const T &value)
    \relates <QtAlgorithms>

    Fills the range [\a begin, \a end) with \a value.

    Example:
    \code
	QList<QString> list;
        list << "one" << "two" << "three";

        qFill(list.begin(), list.end(), "eleven");
        // list: [ "eleven", "eleven", "eleven" ]

	qFill(list.begin() + 1, list.end(), "six");
        // list: [ "eleven", "six", "six" ]
    \endcode

    \sa qCopy(), {forward iterators}
*/

/*! \fn InputIterator qFind(InputIterator begin, InputIterator end, const T &value)
    \relates <QtAlgorithms>

    Returns an iterator to the first occurrence of \a value in a
    container in the range [\a begin, \a end). Returns \a end if \a
    value isn't found.

    Example:
    \code
        QList<QString> list;
        list << "one" << "two" << "three";

        QList<QString>::Iterator i1 = qFind(list.begin(), list.end(),
				            "two");
	// i1 == list.begin() + 1

        QList<QString>::Iterator i2 = qFind(list.begin(), list.end(),
					    "seventy");
	// i2 == list.end()
    \endcode

    This function requires the item type (in the example above,
    QString) to implement \c operator==().

    If the items in the range are in ascending order, you can get
    faster results by using qLowerBound() or qBinaryFind() instead of
    qFind().

    \sa qBinaryFind(), {input iterators}
*/

/*! \fn void qCount(InputIterator begin, InputIterator end, const T &value, Size &n)
    \relates <QtAlgorithms>

    Sets \a n to the number of occurrences of \a value in the range
    [\a begin, \a end).

    Example:
    \code
	QList<int> list;
        list << 3 << 3 << 6 << 6 << 6 << 8;

	int countOf6;
        qCount(list.begin(), list.end(), 6, countOf6);
        // countOf6 == 3

	int countOf7;
        qCount(list.begin(), list.end(), 7, countOf7);
        // countOf7 == 0
    \endcode

    This function requires the item type (in the example above,
    \c int) to implement \c operator==().

    \sa {input iterators}
*/

/*! \fn void qSwap(T &var1, T &var2)
    \relates <QtAlgorithms>

    Exchanges the values of variables \a var1 and \a var2.

    Example:
    \code
	double pi = 3.14;
        double e = 2.71;

	qSwap(pi, e);
        // pi == 2.71, e == 3.14
    \endcode
*/

/*! \fn void qSort(BiIterator begin, BiIterator end)
    \relates <QtAlgorithms>

    Sorts the items in range [\a begin, \a end) in ascending order
    using the heap sort algorithm.

    Example:
    \code
	QList<int> list;
        list << 33 << 12 << 68 << 6 << 12;
	qSort(list.begin(), list.end());
        // list: [ 6, 12, 12, 33, 68 ]
    \endcode

    The sort algorithm is efficient on large data sets. It operates
    in \l {linear-logarithmic time}, O(\e{n} log \e{n}).

    This function requires the item type (in the example above,
    \c{int}) to implement \c operator<().

    If of two items neither is less than the other, the items are
    taken to be equal. It is then undefined which one of the two
    items will appear before the other after the sort.

    \sa qStableSort(), {bidirectional iterators}
*/

/*! \fn void qSort(BiIterator begin, BiIterator end, LessThan lessThan)
    \relates <QtAlgorithms>

    \overload

    Uses the \a lessThan function instead of \c operator<() to
    compare the items.

    For example, here's how to sort the strings in a QList<QString>
    in case-insensitive alphabetical order:

    \code
        bool caseInsensitiveLessThan(const QString &s1, const QString &s2)
        {
            return s1.toLower() < s2.toLower();
        }

        int doSomething()
        {
	    QList<QString> list;
            list << "AlPha" << "beTA" << "gamma" << "DELTA";
	    qSort(list.begin(), list.end(), caseInsensitiveLessThan);
            // list: [ "AlPha", "beTA", "DELTA", "gamma" ]
        }
    \endcode

    To sort values in reverse order, pass \c qGreater<T>() as the \a
    lessThan parameter. For example:

    \code
	QList<int> list;
        list << 33 << 12 << 68 << 6 << 12;
	qSort(list.begin(), list.end(), qGreater<int>());
        // list: [ 68, 33, 12, 12, 6 ]
    \endcode

    If of two items neither is "less than" the other, the items are
    taken to be equal. It is then undefined which one of the two
    items will appear before the other after the sort.
*/

/*! \fn void qSort(Container &container)
    \relates <QtAlgorithms>

    \overload

    This is the same as qSort(\a{container}.begin(), \a{container}.end());
*/

/*! \fn void qStableSort(BiIterator begin, BiIterator end)
    \relates <QtAlgorithms>

    Sorts the items in range [\a begin, \a end) in ascending order
    using the heap sort algorithm.

    Example:
    \code
	QList<int> list;
        list << 33 << 12 << 68 << 6 << 12;
	qStableSort(list.begin(), list.end());
        // list: [ 6, 12, 12, 33, 68 ]
    \endcode

    The sort algorithm is efficient on large data sets. It operates
    in \l {linear-logarithmic time}, O(\e{n} log \e{n}).

    This function requires the item type (in the example above,
    \c{int}) to implement \c operator<().

    If of two items neither is less than the other, the items are
    taken to be equal. The item that appeared before the other in the
    original container will still appear first after the sort. This
    property is often useful when sorting user-visible data.

    \sa qSort(), {bidirectional iterators}
*/

/*! \fn void qStableSort(BiIterator begin, BiIterator end, LessThan lessThan)
    \relates <QtAlgorithms>

    \overload

    Uses the \a lessThan function instead of \c operator<() to
    compare the items.

    For example, here's how to sort the strings in a QList<QString>
    in case-insensitive alphabetical order:

    \code
        bool caseInsensitiveLessThan(const QString &s1, const QString &s2)
        {
            return s1.toLower() < s2.toLower();
        }

        int doSomething()
        {
	    QList<QString> list;
            list << "AlPha" << "beTA" << "gamma" << "DELTA";
	    qStableSort(list.begin(), list.end(), caseInsensitiveLessThan);
            // list: [ "AlPha", "beTA", "DELTA", "gamma" ]
        }
    \endcode

    To sort values in reverse order, pass \c qGreater<T>() as the \a
    lessThan parameter. For example:

    \code
	QList<int> list;
        list << 33 << 12 << 68 << 6 << 12;
	qStableSort(list.begin(), list.end(), qGreater<int>());
        // list: [ 68, 33, 12, 12, 6 ]
    \endcode

    If of two items neither is "less than" the other, the items are
    taken to be equal. The item that appeared before the other in the
    original container will still appear first after the sort. This
    property is often useful when sorting user-visible data.
*/

/*! \fn void qStableSort(Container &container)
    \relates <QtAlgorithms>

    \overload

    This is the same as qStableSort(\a{container}.begin(), \a{container}.end());
*/

/*! \fn RandomAccessIterator qLowerBound(RandomAccessIterator begin, RandomAccessIterator end, const T &value)
    \relates <QtAlgorithms>

    Performs a binary search of the range [\a begin, \a end) and
    returns the position of the first ocurrence of \a value. If no
    such item is found, returns the position where it should be
    inserted.

    The items in the range [\a begin, \e end) must be sorted in
    ascending order; see qSort().

    Example:
    \code
	QList<int> list;
        list << 3 << 3 << 6 << 6 << 6 << 8;

        QList<int>::Iterator i = qLowerBound(list.begin(), list.end(), 5);
	list.insert(i, 5);
        // list: [ 3, 3, 5, 6, 6, 6, 8 ]

	i = qLowerBound(list.begin(), list.end(), 12);
        list.insert(i, 12);
        // list: [ 3, 3, 5, 6, 6, 6, 8, 12 ]
    \endcode

    This function requires the item type (in the example above,
    \c{int}) to implement \c operator<().

    qLowerBound() can be used in conjunction with qUpperBound() to
    iterate over all occurrences of the same value:

    \code
	QVector<int> vect;
        vect << 3 << 3 << 6 << 6 << 6 << 8;
        QVector<int>::Iterator begin6 =
	        qLowerBound(vect.begin(), vect.end(), 6);
        QVector<int>::Iterator end6 =
	        qUpperBound(begin6, vect.end(), 6);

	QVector<int>::Iterator i = begin6;
        while (i != end6) {
	    *i = 7;
            ++i;
        }
        // vect: [ 3, 3, 7, 7, 7, 8 ]
    \endcode

    \sa qUpperBound(), qBinaryFind()
*/

/*! \fn RandomAccessIterator qUpperBound(RandomAccessIterator begin, RandomAccessIterator end, const T &value)
    \relates <QtAlgorithms>

    Performs a binary search of the range [\a begin, \a end) and
    returns the position of the one-past-the-last occurrence of \a
    value. If no such item is found, returns the position where the
    item should be inserted.

    The items in the range [\a begin, \e end) must be sorted in
    ascending order; see qSort().

    Example:
    \code
	QList<int> list;
        list << 3 << 3 << 6 << 6 << 6 << 8;

        QList<int>::Iterator i = qUpperBound(list.begin(), list.end(), 5);
	list.insert(i, 5);
        // list: [ 3, 3, 5, 6, 6, 6, 8 ]

	i = qUpperBound(list.begin(), list.end(), 12);
        list.insert(i, 12);
        // list: [ 3, 3, 5, 6, 6, 6, 8, 12 ]
    \endcode

    This function requires the item type (in the example above,
    \c{int}) to implement \c operator<().

    qUpperBound() can be used in conjunction with qLowerBound() to
    iterate over all occurrences of the same value:

    \code
	QVector<int> vect;
        vect << 3 << 3 << 6 << 6 << 6 << 8;
        QVector<int>::Iterator begin6 =
	        qLowerBound(vect.begin(), vect.end(), 6);
        QVector<int>::Iterator end6 =
	        qUpperBound(vect.begin(), vect.end(), 6);

	QVector<int>::Iterator i = begin6;
        while (i != end6) {
	    *i = 7;
            ++i;
        }
        // vect: [ 3, 3, 7, 7, 7, 8 ]
    \endcode

    \sa qLowerBound(), qBinaryFind()
*/

/*! \fn RandomAccessIterator qBinaryFind(RandomAccessIterator begin, RandomAccessIterator end, const T &value)
    \relates <QtAlgorithms>

    Performs a binary search of the range [\a begin, \a end) and
    returns the position of an occurrence of \a value. If there are
    no occurrences of \a value, returns \a end.

    The items in the range [\a begin, \a end) must be sorted in
    ascending order; see qSort().

    If there are many occurrences of the same value, any one of them
    could be returned. Use qLowerBound() or qUpperBound() if you need
    finer control.

    Example:
    \code
	QVector<int> vect;
        vect << 3 << 3 << 6 << 6 << 6 << 8;

	QVector<int>::Iterator i =
		qBinaryFind(vect.begin(), vect.end(), 6);
	// i == vect.begin() + 2 (or 3 or 4)
    \endcode

    This function requires the item type (in the example above,
    QString) to implement \c operator<().

    See the \l{<QtAlgorithms>#binaryFind example}{detailed
    description} for an example usage.

    \sa qLowerBound(), qUpperBound(), {random access iterators}
*/

/*! \fn void qDeleteAll(ForwardIterator begin, ForwardIterator end)
    \relates <QtAlgorithms>

    Deletes all the items in the range [\a begin, \a end) using the
    C++ \c delete operator. The item type must be a pointer type (for
    example, \c{QWidget *}).

    Example:
    \code
	QList<Employee *> list;
        list.append(new Employee("Blackpool", "Stephen"));
        list.append(new Employee("Twist", "Oliver"));

	qDeleteAll(list.begin(), list.end());
        list.clear();
    \endcode

    Notice that qDeleteAll() doesn't remove the items from the
    container; it merely calls \c delete on them. In the example
    above, we call clear() on the container to remove the items.

    \sa {forward iterators}
*/

/*! \fn void qDeleteAll(const Container &c)
    \relates <QtAlgorithms>

    \overload

    This is the same as qDeleteAll(\a{c}.begin(), \a{c}.end()).
*/
