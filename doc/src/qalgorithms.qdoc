/*! \headerfile <qalgorithms.h>

    \title Generic Algorithms

    \brief The <qalgorithms.h> header file provides generic template-based algorithms.

    Qt provides a number of global template functions in \c
    <qalgorithm.h> that work on containers and perform well-know
    algorithms. You can use these algorithms with any \l {container
    class} that provides STL-style iterators, including Qt's QList,
    QLinkedList, QVector, QMap, and QHash classes.

    These functions are inspired from the functions available in the
    STL \c <algorithm> header. Most of them have a direct STL
    equivalent; for example, qCopyBackward() is the same as STL's
    copy_backward() algorithm.

    If STL is available on all your target platforms, you can use the
    STL algorithms instead of their Qt counterparts. One reason why
    you might want to use the this is that STL provides dozens and
    dozens of algorithms. Qt concentrates on the basic, most
    important ones, but doesn't attempt beyond that to duplicate
    functionality that is already provided by the C++ standard.

    Most algorithms take \l {STL-style iterators} as parameters. The
    algorithms are generic in the sense that they aren't bound to a
    specific iterator class; you can use them with any iterators that
    meet a certain set of requirements.

    Let's take the qFill() algorithm as an example. Unlike QVector,
    QList has no fill() function that can be used to fill a list with
    a certain value. If you need that functionality, you can use
    qFill():

    \code
	QList<QString> list;
        list << "one" << "two" << "three";

        qFill(list.begin(), list.end(), "eleven");
        // list: [ "eleven", "eleven", "eleven" ]
    \endcode

    qFill() takes a begin iterator, an end iterator, and a value.
    In the example above, we pass \c list.begin() and \c list.end()
    as the begin and end iterators, but this doesn't have to be
    the case:

    \code
	qFill(list.begin() + 1, list.end(), "six");
        // list: [ "eleven", "six", "six" ]
    \endcode

    The various algorithms have different requirements on the
    iterators they accept. For example, qFill() accepts two \l {input
    iterators}, the lowest requirement for an iterator type. The
    requirement are specified for every algorithm. If an iterator of
    the wrong type is passed (for example, QList::ConstIterator is
    passed as an \l{output iterator}), you will always get a
    compiler error, although not necessary a highly readable one.

    Some algorithms have special requirements on the value type
    stored in the containers. For example, qEqual() requires that the
    value type supports operator==(), which it uses to compare items.
    Similarly, qDeleteAll() requires that the value type is a
    non-const pointer type (for example, QWidget *). The requirements
    are specified for each algorithm, and the compiler will produce
    an error if such a constraint isn't met.

    The generic algorithms can be used on other container classes
    than those provided by Qt and STL. The syntax of STL-style
    iterators is modeled after C++ pointers, so it's possible to use
    plain arrays as containers and plain pointers as iterators. A
    common idiom is to use qBinaryFind() together with two static
    arrays: one that contains a list of keys, and another that
    contains a list of associated values. For example, the following
    code will look up an HTML entity (e.g., \c &amp;) in the \c
    name_table array and return the corresponding Unicode value from
    the \c value_table if the entity is recognized:

    \code
	QChar resolveEntity(const QString &entity)
        {
	    static const QLatin1String name_table[] = {
	        "AElig", "Aacute", ..., "zwnj"
            };
            static const Q_UINT16 value_table[] = {
	        0x0061, 0x00c1, ..., 0x200c
            };
            int N = sizeof(name_table) / sizeof(name_table[0]);

	    const QLatin1String *name = qBinaryFind(name_table, name_table + N,
						    entity);
	    int index = name - name_table;
	    if (index == N)
		return QChar();

	    return QChar(value_table[index]);
	}
    \endcode

    This kind of code is for advanced users only; for most
    applications, a QMap- or QHash-based approach would work just as
    well:

    \code
	QChar resolveEntity(const QString &entity)
        {
	    static QMap<QString, int> entityMap;

	    if (!entityMap) {
		entityMap.insert("AElig", 0x0061);
		entityMap.insert("Aacute", 0x00c1);
                ...
		entityMap.insert("zwnj", 0x200c);
            }
            return QChar(entityMap.value(entity));
        }
    \endcode

    \section1 Types of Iterators

    The algorithms have certain requirements on the iterator type
    they accept. The requirements on the iterator types are specified
    for each function. The compiler will produce an error if a
    requirement isn't met.

    \section2 Input Iterators

    An \e{input iterator} is an iterator that can be used for reading
    data sequentially from a container. It must provide the following
    operators: \c{==} and \c{!=} for comparing two iterators, unary
    \c{*} for retrieving the value stored in the item, and \c{++} for
    advancing to the next item.

    The Qt containers' iterator types (const and non-const) are all
    input iterators.

    \section2 Output Iterators

    An \e{output iterator} is an iterator that can be used for
    writing data sequentially to a container or to some output
    stream. It must provide the following operators: unary \c{*} for
    writing a value (i.e., \c{*it = val}) and \c{++} for advancing to
    the next item.

    The Qt containers' non-const iterator types are all output
    iterators.

    \section2 Forward Iterators

    A \e{forward iterator} is an iterator that meets the requirements
    of both input iterators and output iterators.

    The Qt containers' non-const iterator types are all output
    iterators.

    \section2 Bidirectional Iterators

    A \e{bidirectional iterator} is an iterator that meets the
    requirements of forward iterators but that in addition supports
    \c{--} for iterating backward.

    The Qt containers' non-const iterator types are all output
    iterators.

    \section2 Random Access Iterators

    The last category, \e{random access iterators}, is the most
    powerful type of iterator. It supports all the requirements of a
    bidirectional iterator, and supports the following operations:

    \table
    \row \i \c{i += n} \i advances iterator \c i by \c n positions
    \row \i \c{i -= n} \i moves iterator \c i back by \c n positions
    \row \i \c{i + n} or \c{n + i} \i returns the iterator for the item \c
       n positions ahead of iterator \c i
    \row \i \c{i - n} \i returns the iterator for the item \c n positions behind of iterator \c i
    \row \i \c{i - j} \i returns the number of items between iterators \c i and \c j
    \row \i \c{i[n]} \i same as \c{*(i + n)}
    \row \i \c{i < j} \i returns true if iterator \c j lies ahead of iterator \c i
    \endtable

    QList, QLinkedList, and QVector's non-const iterator types are
    random access iterators.

    \sa {container classes}
*/

/*! \fn OutputIterator qCopy(InputIterator begin1, InputIterator end1, OutputIterator begin2)
    \relates <qalgorithms.h>

    Copies the items from range [\a begin1, \a end1) to range [\a
    begin2, ...), in the order in which they appear.

    The item at position \a begin1 is assigned to that at position \a
    begin2; the item at position \a begin1 + 1 is assigned to that at
    position \a begin2 + 2; and so on.

    Example:
    \code
        QList<QString> list;
	list << "one" << "two" << "three";

	QVector<QString> vect1(3);
        qCopy(list.begin(), list.end(), vect1.begin());
        // vect: [ "one", "two", "three" ]

        QVector<QString> vect2(8);
        qCopy(list.begin(), list.end(), vect2.begin() + 2);
        // vect: [ "", "", "one", "two", "three", "", "", "" ]
    \endcode

    \sa qCopyBackward(), {input iterators}, {output iterators}
*/

/*! \fn BiIterator2 qCopyBackward(BiIterator1 begin1, BiIterator1 end1, BiIterator2 end2)
    \relates <qalgorithms.h>

    Copies the items from range [\a begin1, \a end1) to range [...,
    \a end2).

    The item at position \a end1 - 1 is assigned to that at position
    \a end2 - 1; the item at position \a end1 - 2 is assigned to that
    at position \a end2 - 2; and so on.

    Example:
    \code
        QList<QString> list;
	list << "one" << "two" << "three";

	QVector<QString> vect(5);
        qCopyBackward(list.begin(), list.end(), vect.end());
        // vect: [ "", "", "three", "two", "one" ]
    \endcode

    \sa qCopy(), {bidirectional iterators}
*/

/*! \fn bool qEqual(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2)
    \relates <qalgorithms.h>

    Compares the items in the range [\a begin1, \a end1) with the
    items in the range [\a begin2, ...). Returns true if all the
    items compare equal, false otherwise.

    Example:
    \code
	QList<QString> list;
        list << "one" << "two << "three";

	QVector<QString> vect[3];
        vect[0] = "one";
        vect[1] = "two";
        vect[2] = "three";

	bool ret1 = qEqual(list.begin(), list.end(), vect.begin());
        // ret1 is true

        vect[2] = "seven";
	bool rec2 = qEqual(list.begin(), list.end(), vect.begin());
        // ret2 is false
    \endcode

    This function requires the item type (in the example above,
    QString) to implement \c operator==().

    \sa {input iterators}
*/

/*! \fn void qFill(ForwardIterator begin, ForwardIterator end, const T &value)
    \relates <qalgorithms.h>

    Fills the range [\a begin, \a end) with \a value.

    Example:
    \code
	QList<QString> list;
        list << "one" << "two" << "three";

        qFill(list.begin(), list.end(), "eleven");
        // list: [ "eleven", "eleven", "eleven" ]

	qFill(list.begin() + 1, list.end(), "six");
        // list: [ "eleven", "six", "six" ]
    \endcode

    \sa qCopy(), {forward iterators}
*/

/*! \fn InputIterator qFind(InputIterator begin, InputIterator end, const T &value)
    \relates <qalgorithms.h>

    Returns an iterator to the first occurrence of \a value in a
    container in the range [\a begin, \a end). Returns \a end if \a
    value isn't found.

    Example:
    \code
        QList<QString> list;
        list << "one" << "two" << "three";

        QList<QString>::Iterator it1 = qFind(list.begin(), list.end(),
					     "two");
	// it1 == list.begin() + 1

        QList<QString>::Iterator it2 = qFind(list.begin(), list.end(),
					     "seventy");
	// it2 == list.end()
    \endcode

    This function requires the item type (in the example above,
    QString) to implement \c operator==().

    If the items in the range are in ascending order, you can get
    faster results by using qLowerBound() or qBinaryFind() instead of
    qFind().

    \sa qBinaryFind(), {input iterators}
*/

/*! \fn void qCount(InputIterator begin, InputIterator end, const T &value, Size &n)
    \relates <qalgorithms.h>

    Sets \a n to the number of occurrences of \a value in the range
    [\a begin, \a end).

    Example:
    \code
	QList<int> list;
        list << 3 << 3 << 6 << 6 << 6 << 8;

	int count6;
        qCount(list.begin(), list.end(), count6, 6);
        // count6 == 3

	int count7;
        qCount(list.begin(), list.end(), count7, 7);
        // count7 == 0
    \endcode

    This function requires the item type (in the example above,
    QString) to implement \c operator==().

    \sa {input iterators}
*/

/*! \fn void qSwap(T &var1, T &var2)
    \relates <qalgorithms.h>

    Exchanges the values of variables \a var1 and \a var2.

    Example:
    \code
	double pi = 3.14;
        double e = 2.71;

	qSwap(pi, e);
        // pi == 2.71, e == 3.14
    \endcode
*/

/*! \fn void qBubbleSort(BiIterator begin, BiIterator end)
    \relates <qalgorithms.h>

    Sorts the items in range [\a begin, \a end) in ascending order
    using the bubble sort algorithm.

    Example:
    \code
	QList<int> list;
        list << 33 << 12 << 68 << 6 << 12;
	qBubbleSort(list.begin(), list.end());
        // list: [ 6, 12, 12, 33, 68 ]
    \endcode

    The bubble sort algorithm can be very slow on large data sets.
    Its behavior is said to be \l quadratic. Use this algorithm only
    if you are certain that there are only a few items to sort, say,
    less than 30. If you can't guarantee that, use qHeapSort()
    instead.

    This function requires the item type (in the example above,
    \c{int}) to implement \c operator<().

    \sa qHeapSort(), {bidirectional iterators}
*/

/*! \fn void qBubbleSort(Container &c)
    \relates <qalgorithms.h>

    \overload

    This is the same as qBubbleSort(\a{c}.begin(), \a{c}.end());
*/

/*! \fn void qHeapSortPushDown(Value *heap, int first, int end)
    \relates <qalgorithms.h>

    \internal
    Used by qHeapSort().
*/

/*! \fn void qHeapSortHelper(BiIterator begin, BiIterator end, Value, uint n)
    \relates <qalgorithms.h>

    \internal
    Used by qHeapSort().
*/

/*! \fn void qHeapSort(BiIterator begin, BiIterator end)
    \relates <qalgorithms.h>

    Sorts the items in range [\a begin, \a end) in ascending order
    using the heap sort algorithm.

    Example:
    \code
	QList<int> list;
        list << 33 << 12 << 68 << 6 << 12;
	qHeapSort(list.begin(), list.end());
        // list: [ 6, 12, 12, 33, 68 ]
    \endcode

    The heap sort algorithm can be slower than bubble sort (qBubbleSort())
    for small data sets, but is much faster on large data sets. Its behavior
    is said to be \l {linear-logarithmic}, O(\e{n} log \e{n}).

    This function requires the item type (in the example above,
    \c{int}) to implement \c operator<().

    \sa qHeapSort(), {bidirectional iterators}
*/

/*! \fn void qHeapSort(Container &c)
    \relates <qalgorithms.h>

    \overload

    This is the same as qHeapSort(\a{c}.begin(), \a{c}.end());
*/

/*! \fn RandomAccessIterator qLowerBound(RandomAccessIterator begin, RandomAccessIterator end, const T &value)
    \relates <qalgorithms.h>

    Performs a binary search of the range [\a begin, \a end) and
    returns the position of the first ocurrence of \a value. If no
    such item is found, returns the position where it should be
    inserted.

    The items in the range [\a begin, \e end) must be sorted in
    ascending order beforehand.

    Example:
    \code
	QList<int> list;
        list << 3 << 3 << 6 << 6 << 6 << 8;

        QList<int>::Iterator it = qLowerBound(list.begin(), list.end(), 5);
	list.insert(it, 5);
        // list: [ 3, 3, 5, 6, 6, 6, 8 ]

	it = qLowerBound(list.begin(), list.end(), 12);
        list.insert(it, 12);
        // list: [ 3, 3, 5, 6, 6, 6, 8, 12 ]
    \endcode

    This function requires the item type (in the example above,
    \c{int}) to implement \c operator<().

    qLowerBound() can be used in conjunction with qUpperBound() to
    iterate over all occurrences of the same value:

    \code
	QVector<int> vect;
        vect << 3 << 3 << 6 << 6 << 6 << 8;
        QVector<int>::Iterator begin6 =
	        qLowerBound(vect.begin(), vect.end(), 6);
        QVector<int>::Iterator end6 =
	        qLowerBound(vect.begin(), vect.end(), 6);

	QVector<int>::Iterator it = begin6;
        while (it != end6) {
	    *it = 7;
            ++it;
        }
        // vect: [ 3, 3, 7, 7, 7, 8 ]
    \endcode

    \sa qUpperBound(), qBinaryFind()
*/

/*! \fn RandomAccessIterator qUpperBound(RandomAccessIterator begin, RandomAccessIterator end, const T &value)
    \relates <qalgorithms.h>

    Performs a binary search of the range [\a begin, \a end) and
    returns the position of the next-to-last occurrence of \a value.
    If no such item is found, returns the position where the item
    should be inserted.

    The items in the range [\a begin, \e end) must be sorted in
    ascending order beforehand.

    Example:
    \code
	QList<int> list;
        list << 3 << 3 << 6 << 6 << 6 << 8;

        QList<int>::Iterator it = qLowerBound(list.begin(), list.end(), 5);
	list.insert(it, 5);
        // list: [ 3, 3, 5, 6, 6, 6, 8 ]

	it = qLowerBound(list.begin(), list.end(), 12);
        list.insert(it, 12);
        // list: [ 3, 3, 5, 6, 6, 6, 8, 12 ]
    \endcode

    This function requires the item type (in the example above,
    \c{int}) to implement \c operator<().

    qUpperBound() can be used in conjunction with qLowerBound() to
    iterate over all occurrences of the same value:

    \code
	QVector<int> vect;
        vect << 3 << 3 << 6 << 6 << 6 << 8;
        QVector<int>::Iterator begin6 =
	        qLowerBound(vect.begin(), vect.end(), 6);
        QVector<int>::Iterator end6 =
	        qLowerBound(vect.begin(), vect.end(), 6);

	QVector<int>::Iterator it = begin6;
        while (it != end6) {
	    *it = 7;
            ++it;
        }
        // vect: [ 3, 3, 7, 7, 7, 8 ]
    \endcode

    \sa qLowerBound(), qBinaryFind()
*/

/*! \fn RandomAccessIterator qBinaryFind(RandomAccessIterator begin, RandomAccessIterator end, const T &value)
    \relates <qalgorithms.h>

    Performs a binary search of the range [\a begin, \a end) and
    returns the position of an occurrence of \a value. If there are
    no occurrences of \a value, returns \a end.

    The items in the range [\a begin, \e end) must be sorted in
    ascending order beforehand.

    If there are many occurrences of the same value, it is not
    specified which one is returned. Use qLowerBound() or
    qUpperBound() if you need more control.

    Example:
    \code
	QVector<int> vect;
        vect << 3 << 3 << 6 << 6 << 6 << 8;

	QVector<int>::Iterator it =
		qBinaryFind(vect.begin(), vect.end(), 6);
	// it == vect.begin() + 2 (or 3 or 4)
    \endcode

    This function requires the item type (in the example above,
    QString) to implement \c operator<().

    See the \l {detailed description} for an example usage.

    \sa qLowerBound(), qUpperBound(), {random access iterators}
*/

/*! \fn void qDeleteAll(ForwardIterator begin, ForwardIterator end)
    \relates <qalgorithms.h>

    Deletes all the items in the range [\a begin, \a end) using the
    C++ \c delete operator. The item type must be a pointer type (for
    example, \c{QWidget *}).

    Example:
    \code
	QList<Employee *> list;
        list.append(new Employee("Blackpool", "Stephen"));
        list.append(new Employee("Twist", "Oliver"));

	qDeleteAll(list.begin(), list.end());
        list.clear();
    \endcode

    Notice that qDeleteAll() doesn't remove the items from the
    container; it merely calls \c delete on them. In the example
    above, we call clear() on the container to remove the items.

    \sa {forward iterators}
*/

/*! \fn void qDeleteAll(const Container &c)
    \relates <qalgorithms.h>

    \overload

    This is the same as qDeleteAll(\a{c}.begin(), \a{c}.end()).
*/

/*! \fn QBackInsertIterator<Container> qBackInserter(Container &c)
    \relates <qalgorithms.h>

    \internal
*/
