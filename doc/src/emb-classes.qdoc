/****************************************************************************
**
** Copyright (C) 1992-$THISYEAR$ $TROLLTECH$. All rights reserved.
**
** This file is part of the Qt GUI Toolkit.
** EDITIONS: FREE, PROFESSIONAL, ENTERPRISE
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
****************************************************************************/

/*
    \page emb-classes.html

    \title The Qtopia Core Specific Classes
    \ingroup qtopia-core

    Qtopia Core classes fall into two groups: the majority are used by
    every Qtopia Core program, and some are only used by the Qtopia Core server.
    The Qtopia Core server program can also be a client, as in the case of a
    single-process installation. All Qtopia Core specific source files are
    in \c src/gui and are suffixed \c{_qws}. The > symbol
    indicates inheritance.

    \tableofcontents

    \omit
    ### font system is completely changed- must be mentioned
    \endomit

    \section1 QScreen > QLinuxFbScreen > accelerated screens, QTransformedScreen > QVfbScreen

    These encapsulate the framebuffer Qtopia Core is drawing to, provide
    support for mapping of coordinates for rotating framebuffers, allow
    manipulation of the color palette and provide access to offscreen
    graphics memory for devices with separate framebuffer memories.

    \section1 QScreenCursor > accelerated cursor > QVfbCursor

    This handles drawing the on-screen mouse cursor, and saving and
    restoring the screen under it for the non-accelerated cursor types.

    Subclassing \c QScreenCursor is optional in an accelerated driver (you
    would only want to do so if the hardware supports a hardware cursor).

\omit
    \section1 QLock, QLockHolder

    This encapsulates a System V semaphore, used for synchronising access
    to memory shared between Qtopia Core clients. \c QLockHolder is a utility class
    to make managing and destroying \c{QLock}s easier.

    There should be no need to modify this class unless porting
    Qtopia Core to an operating system without System V IPC.
\endomit

    \section1 QDirectPainter

    This is a class that gives you direct access to the
    framebuffer. It allows you bypass Qt window management, and access
    display memory directly.

    There should be no reason to modify this class.

    \section1 QWSSoundServer, Client

    The Qtopia Core server contains a simple sound player and mixer. Clients
    can request the server play sounds specified as files.

    There should be no need to modify this class unless porting
    Qtopia Core to an operating system without a Linux-style \c /dev/dsp.

    \section1 QWSWindow

    This contains the server's notion of an individual top level window:
    the region of the framebuffer it's allocated, the client that created
    it, and so forth.

    There should be no reason to modify this class.

    \section1 QWSKeyboardHandler > subtypes

    This handles keyboard/button input. \c QWSKeyboardHandler is subclassed
    to provide for reading \c /dev/tty, an arbitrary low-level USB event device
    (for USB keyboards) and some PDA button devices.

    Modifying \c QWSKeyboardHandler would allow you to support different
    types of keyboard (currently only a fairly standard US PC style
    keyboard is supported); subclassing it is the preferred way to handle
    non-pointer input devices.

    \section1 QWSMouseHandler > QWSCalibratedMouseHandler > mouse types

    This handles mouse/touch-panel input. Descendants of \c QWSCalibratedMouseHandler
    make use of filtering code which prevents 'jittering' of the pointer on
    touchscreens; some embedded devices do this filtering in the kernel in
    which case the driver doesn't need to inherit from \c QWSCalibratedMouseHandler.

    Subclassing \c QWSCalibratedMouseHandler is preferred for touch-panels without
    kernel filtering; inheriting \c QWSMouseHandler is the way to add any other
    type of pointing device (pen tablets, touchscreens, mice, trackballs
    and so forth).

    \section1 QWSDisplay

    This class exists only in the Qtopia Core server and keeps track of
    all the top-level windows in the system, as well as the keyboard and mouse.

    You would only want to modify this if making deep and drastic
    modifications to Qtopia Core window behavior (alpha blended windows
    for example).

    \section1 QWSServer

    This manages the Qtopia Core server's Unix-domain socket connections to
    clients. It sends and receives QWS protocol events and calls \c QWSDisplay
    in order to do such things as change the allocation region of windows.

    The only reason to modify this would be to use something other than
    some sort of socket-like mechanism to communicate between Qtopia Core
    applications (in which case modify \c QWSClient too). If you have
    something like Unix domain sockets, modify \c QWSSocket/\c QWSServerSocket
    instead. Don't add extra QWS events to communicate between
    applications, use \c QCop instead.

    \section1 QWSClient

    This encapsulates the client side of a Qtopia Core connection and can
    marshal and demarshal events.

    There should be no reason to modify this except to use something
    radically different from Unix domain sockets to communicate between
    Qtopia Core applications.

    \section1 QWSDisplay::Data

    This manages a client's QWSClient, reading and interpreting events
    from the QWS server. It connects to the QWS server on application
    startup, getting information about the framebuffer and creating the
    memory manager. Other information about the framebuffer comes directly
    from \c /dev/fb in QLinuxFbScreen.

    There should be no reason to modify this class.

    \section1 QWSCommands

    These encapsulate the data sent to and from the QWS server.

    There should be no reason to modify them.

    \section1 QCopChannel

    \c QCop is a simple inter-process communication (IPC) mechanism for
    communication between Qtopia Core applications. String messages with
    optional binary data can be sent to different channels.

    The mechanism itself is designed to be bare-bones in order for users
    to build whatever higher-level layer they like on top of it.

    \section1 QWSManager

    This provides Qtopia Core window management, drawing a title bar
    and handling user requests to move and resize windows, and so on.

    There should be no reason to modify it but you should subclass it
    if you want to modify window behavior (point to click versus
    focus follows mouse, for instance).

    \section1 QWSDecoration

    Descendants of this class are different styles for the Qtopia Core
    window manager, for instance \c QWSWindowsDecoration draws Qtopia Core
    window frames in the style of Windows CE.

    Subclass it in order to provide a new window manager appearance (the
    equivalent of a Windows XP or Enlightenment theme).

    \section1 QWSPropertyManager

    This provides the QWS client's interface to the QWS property system
    (a simpler version of the X property system, it allows you to attach
    arbitrary data to top-level windows, keyed by an integer).

    There should be no reason to modify this class.

    \section1 QWSSocket, QWSServerSocket

    Provides Unix-domain sockets.

    Modify this if you're porting to a non-Unix OS but have something
    analogous to Unix-domain sockets (a byte-oriented, reliable, ordered
    transmission mechanism, although you can probably implement it with
    something like a message queue as well).
*/
