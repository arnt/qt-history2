/****************************************************************************
**
** Copyright (C) 1992-$THISYEAR$ Trolltech AS. All rights reserved.
**
** This file is part of the Qt GUI Toolkit.
** EDITIONS: FREE, PROFESSIONAL, ENTERPRISE
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
****************************************************************************/

/*!
    \omit
    \page emb-classes.html

    \title The Qtopia Core Specific Classes

    Qtopia Core classes fall into two groups: the majority are used by
    every Qtopia Core program, and some are only used by the Qtopia Core server. 
    The Qtopia Core server program can also be a client, as in the case of a
    single-process installation. All Qtopia Core specific source files are
    in \c src/gui and are suffixed \c{_qws}. The > symbol
    indicates inheritance.

    \tableofcontents
\endomit
    \omit ### Font system is completely changed
    \section1 QFontManager

    There is one of these per application. At application startup time it
    reads the font definition file from \c $QTDIR/etc/fonts/fontdir (or \c
    /usr/local/etc/qt-embedded/fonts/fontdir if \c QTDIR is undefined). It
    keeps track of all the font information and maintains a cache of rendered
    fonts. It also creates the font factories. \c
    QFontManager::QFontManager()
    is the place to add constructors for new factories. It provides a
    high-level interface for requesting a particular font and calls
    \c QFontFactories to load fonts from disk on demand. Note that this only
    applies to BDF and TrueType fonts; Qtopia Core's optimised \c .qpf
    font file format bypasses the \c QFontManager mechanism altogether. 

    There should be no need to modify this class unless you wish to change
    font matching or caching behavior.

    \section1 QDiskFont

    This contains information about a single on-disk font file (e.g.
    \c{/usr/local/etc/qt-embedded/times.ttf}). It holds the file path,
    information about whether the font is scalable, its weight, size,
    Qtopia Core name, etc. This information is used so that \c QFontManager
    can find the closest matching disk font (it uses a scoring mechanism
    weighted towards matching names, then whether the font's italic, then
    its weight). 

    There should be no reason to modify this class.

    \section1 QRenderedFont

    There is one and only one \c QRenderedFont for every unique font
    currently loaded by the system (that is, each unique combination of
    name, size, weight, italic or not, anti-aliased or not).
    \c{QRenderedFont}s are reference counted; once no one is using the
    \c QRenderedFont it is deleted along with its cache of glyph bitmaps. The
    \c QDiskFont it was loaded from remains opened by its \c QFontFactory.

    There should be no reason to modify this class, unless you wish to
    change the way in which glyphs are cached.


    \section1 QFontFactory (and descendants QFontFactoryBDF, QFontFactoryTtf)

    These provide support for particular font formats, for instance the
    scalable Truetype and Type1 formats (both supported in
    \c QFontFactoryTtf, which uses Freetype 2) and the bitmap BDF format used
    by X. It's called to open an on-disk font; once a font is opened it
    remains opened so that the creation of new font instances from the
    disk font is fast. It can also create a \c QRenderedFont and convert from
    Unicode values to an index into the font file. For compactness, glyphs
    are stored in the order and indexes they are defined in the font
    rather than in Unicode order. 

    There should be no need to modify this class, but it should be
    inherited if you wish to add a different type of font renderer (e.g.
    for a custom vector font format).

    \section1 QGlyph

    This describes a particular image of a character from a \c QRenderedFont:
    for example, the letter 'A' at 10 points in Times New Roman, bold italic,
    anti-aliased. It contains pointers to a \c QGlyphMetrics structure with
    information about the character, and to the raw data for the glyph:
    this is either a 1-bit mask or an 8-bit alpha channel. Each \c QRenderedFont
    creates these on demand and caches them once created (note that this is
    not currently implemented for TrueType fonts). 

    You would only need to modify this class if you were, for example,
    modifying Qtopia Core to support textured fonts, in which case you
    would also need to modify \c QGfxRaster.
    \endomit
\omit
    \section1 QScreen > QLinuxFbScreen > accelerated screens, QTransformedScreen > QVfbScreen

    These encapsulate the framebuffer Qtopia Core is drawing to, provide
    support for mapping of coordinates for rotating framebuffers, allow
    manipulation of the colour palette and provide access to offscreen
    graphics memory for devices with separate framebuffer memories.

    \section1 QScreenCursor > accelerated cursor > QVfbCursor

    This handles drawing the on-screen mouse cursor, and saving and
    restoring the screen under it for the non-accelerated cursor types.

    Subclassing \c QScreenCursor is optional in an accelerated driver (you
    would only want to do so if the hardware supports a hardware cursor).
\endomit
    \omit ### QGfx has changed a lot
    \section1 QGfx > RasterBase > Raster > accelerated driver > QGfxVfb > QGfxTransformedRaster

    This class encapsulates drawing operations, a little like a low-level
    \c QPainter. \c QGfxRaster and its descendants are specifically intended
    for drawing into a raw framebuffer. They can take an offset for drawing
    operations and a clipping region in order to support drawing into windows.
    You will need to subclass the \c QGfxRaster template in order to implement
    an accelerated driver. 

    If you're brave, modifying \c QGfxRaster would allow you to customise how
    drawing is done or add support for a new bit depth/pixel format.
    \endomit
\omit
    \section1 QLock, QLockHolder

    This encapsulates a System V semaphore, used for synchronising access
    to memory shared between Qtopia Core clients. \c QLockHolder is a utility class
    to make managing and destroying \c{QLock}s easier. 

    There should be no need to modify this class unless porting
    Qtopia Core to an operating system without System V IPC.
\endomit
    \omit ### Not implemented in 4.0
    \section1 QDirectPainter

    This is a \c QPainter which also gives you a pointer to the framebuffer
    of the window it's pointing to, the window's clip region and so on.
    It's intended to allow you to easily do your own pixel-level manipulation
    of window contents. 

    There should be no reason to modify this class.
    \endomit
\omit
    \section1 QWSSoundServer, Client

    The Qtopia Core server contains a simple sound player and mixer. Clients
    can request the server play sounds specified as files. 

    There should be no need to modify this class unless porting
    Qtopia Core to an operating system without a Linux-style \c /dev/dsp.

    \section1 QWSWindow

    This contains the server's notion of an individual top level window:
    the region of the framebuffer it's allocated, the client that created
    it, and so forth. 

    There should be no reason to modify this class.

    \section1 QWSKeyboardHandler > subtypes

    This handles keyboard/button input. \c QWSKeyboardHandler is subclassed
    to provide for reading \c /dev/tty, an arbitrary low-level USB event device
    (for USB keyboards) and some PDA button devices. 

    Modifying \c QWSKeyboardHandler would allow you to support different
    types of keyboard (currently only a fairly standard US PC style
    keyboard is supported); subclassing it is the preferred way to handle
    non-pointer input devices.

    \section1 QWSMouseHandler > QWSCalibratedMouseHandler > mouse types

    This handles mouse/touch-panel input. Descendants of \c QWSCalibratedMouseHandler
    make use of filtering code which prevents 'jittering' of the pointer on
    touchscreens; some embedded devices do this filtering in the kernel in
    which case the driver doesn't need to inherit from \c QWSCalibratedMouseHandler.

    Subclassing \c QWSCalibratedMouseHandler is preferred for touch-panels without
    kernel filtering; inheriting \c QWSMouseHandler is the way to add any other
    type of pointing device (pen tablets, touchscreens, mice, trackballs
    and so forth).

    \section1 QWSDisplay

    This class exists only in the Qtopia Core server and keeps track of
    all the top-level windows in the system, as well as the keyboard and mouse.

    You would only want to modify this if making deep and drastic
    modifications to Qtopia Core window behavior (alpha blended windows
    for example).

    \section1 QWSServer 

    This manages the Qtopia Core server's Unix-domain socket connections to
    clients. It sends and receives QWS protocol events and calls \c QWSDisplay
    in order to do such things as change the allocation region of windows.

    The only reason to modify this would be to use something other than
    some sort of socket-like mechanism to communicate between Qtopia Core
    applications (in which case modify \c QWSClient too). If you have
    something like Unix domain sockets, modify \c QWSSocket/\c QWSServerSocket
    instead. Don't add extra QWS events to communicate between
    applications, use \c QCop instead.

    \section1 QWSClient

    This encapsulates the client side of a Qtopia Core connection and can
    marshal and demarshal events. 

    There should be no reason to modify this except to use something
    radically different from Unix domain sockets to communicate between
    Qtopia Core applications.

    \section1 QWSDisplayData

    This manages a client's QWSClient, reading and interpreting events
    from the QWS server. It connects to the QWS server on application
    startup, getting information about the framebuffer and creating the
    memory manager. Other information about the framebuffer comes directly
    from \c /dev/fb in QLinuxFbScreen. 

    There should be no reason to modify this class.

    \section1 QWSCommands

    These encapsulate the data sent to and from the QWS server. 

    There should be no reason to modify them.

    \section1 QCopChannel

    \c QCop is a simple inter-process communication (IPC) mechanism for
    communication between Qtopia Core applications. String messages with
    optional binary data can be sent to different channels. 

    The mechanism itself is designed to be bare-bones in order for users
    to build whatever higher-level layer they like on top of it.

    \section1 QWSManager

    This provides Qtopia Core window management, drawing a title bar
    and handling user requests to move and resize windows, and so on.

    There should be no reason to modify it but you should subclass it
    if you want to modify window behavior (point to click versus
    focus follows mouse, for instance).

    \section1 QWSDecoration

    Descendants of this class are different styles for the Qtopia Core
    window manager, for instance \c QWSWindowsDecoration draws Qtopia Core
    window frames in the style of Windows CE. 

    Subclass it in order to provide a new window manager appearance (the
    equivalent of a Windows XP or Enlightenment theme).

    \section1 QWSPropertyManager

    This provides the QWS client's interface to the QWS property system
    (a simpler version of the X property system, it allows you to attach
    arbitrary data to top-level windows, keyed by an integer). 

    There should be no reason to modify this class.

    \section1 QWSSocket, QWSServerSocket

    Provides Unix-domain sockets. 

    Modify this if you're porting to a non-Unix OS but have something
    analogous to Unix-domain sockets (a byte-oriented, reliable, ordered
    transmission mechanism, although you can probably implement it with
    something like a message queue as well).
    \endomit
*/
