/****************************************************************************
**
** Copyright (C) 1992-$THISYEAR$ Trolltech AS. All rights reserved.
**
** This file is part of the Qt GUI Toolkit.
** EDITIONS: FREE, PROFESSIONAL, ENTERPRISE
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
****************************************************************************/

/*!
    \page plugins-howto.html
    \title How to Create Qt Plugins

    Qt provides two APIs for creating plugins:

    \list
    \o A higher-level API for writing extensions to Qt itself: custom database
       drivers, image formats, text codecs, and styles.
    \o A lower-lever API for extending Qt applications.
    \endlist

    For example, if you want to write a custom QStyle subclass and
    have Qt applications load it dynamically, you would then use the
    higher-level API; whereas if you want to extend Qt Designer, you
    would use the lower-level API.

    Since the higher-level API is built on top of the lower-level API,
    some issues are common to both.

    Topics:

    \tableofcontents

    \section1 The Higher-Level API: Writing Qt Extensions

    Writing a plugin that extends Qt itself is achieved by
    subclassing the appropriate plugin base clase, implementing a few
    functions, and adding a macro. 

    There are five plugin base classes. Derived plugins are stored
    by default in the standard plugin directory.

    \table
    \header
    \o Base Class
    \o Default Path
    \row
    \o \l QImageIOPlugin
    \o \c{pluginsbase/imageformats}
    \row
    \o \l QSqlDriverPlugin
    \o \c{pluginsbase/sqldrivers}
    \row
    \o \l QStylePlugin
    \o \c{pluginsbase/styles}
    \row
    \o \l QTextCodecPlugin
    \o \c{pluginsbase/codecs}
    \endtable

    But where is the \c{pluginsbase} directory? When the application is
    run, Qt will first treat the application's executable directory as the
    \c{pluginsbase}. For example if the application is in \c{C:\Program
    Files\MyApp} and has a style plugin, Qt will look in \c{C:\Program
    Files\MyApp\styles}. (See QCoreApplication::applicationDirPath() for
    how to find out where the application's executable is.) Qt will also
    look in the directory specified by \c{qInstallPathPlugins()}. If you want
    Qt to look in additional places you can add as many paths as you need
    with calls to QCoreApplication::addLibraryPath(). And if you want to
    set your own path or paths you can use
    QCoreApplication::setLibraryPaths().

    Suppose that you have a new style class called 'MyStyle' that you want
    to make available as a plugin. The required code is straightforward:
    \code
        class MyStylePlugin : public QStylePlugin
        {
        public:
	    MyStylePlugin() {}
	    ~MyStylePlugin() {}

	    QStringList keys() const { 
	        return QStringList() << "mystyle"; 
	    }

	    QStyle* create( const QString& key ) { 
	        if ( key == "mystyle" ) 
		    return new MyStyle;
	        return 0;
	    }
        };

        Q_EXPORT_PLUGIN(MyStylePlugin)
    \endcode

    (Note that QStyleFactory is case-insensitive, and the lower case
    version of the key is used; other factories are case sensitive.)

    The constructor and destructor do not need to do anything, so are left
    empty. There are only two virtual functions that must be implemented.
    The first is keys() which returns a string list of the classes
    implemented in the plugin. (We've just implemented one class in the
    example above.) The second is a function that returns an object of the
    required class (or 0 if the plugin is asked to create an object of a
    class that it doesn't implement). For QStylePlugin, this second
    function is called create().

    For database drivers, image formats and text codecs,
    no explicit object creation is required. Qt will find and create them
    as required. Styles are an exception, since you might want to set a
    style explicitly in code. To apply a style, use code like this:

    \code
        QApplication::setStyle(QStyleFactory::create("MyStyle"));
    \endcode

    Some plugin classes require additional functions to be
    implemented. See the class documentation for details of the
    virtual functions that must be reimplemented for each type of
    plugin.

    Qt applications automatically know which plugins are available,
    because plugins are stored in the standard plugin subdirectories.
    Because of this applications don't require any code to find and load
    plugins, since Qt handles them automatically.

    The default directory for plugins is \c{QTDIR/plugins} (where QTDIR
    is the directory where Qt is installed),
    with each type of plugin in a subdirectory for that type, e.g. \c
    styles. If you want your applications to use plugins and you don't
    want to use the standard plugins path, have your installation process
    determine the path you want to use for the plugins, and save the path,
    e.g. using QSettings, for the application to read when it runs. The
    application can then call QCoreApplication::addLibraryPath() with this
    path and your plugins will be available to the application. Note that
    the final part of the path, i.e. \c styles, etc., cannot
    be changed.

    The normal way to include a plugin with an application is either to 
    compile it in with the application, or to compile it into a \c DLL (or
    \c so or other platform specific library type) and use it like any
    other library. If you want the plugin to be loadable then one approach
    is to create a subdirectory under the application, e.g. \c
    appdir/plugins/designer, and place the plugin in that directory.

    \section1 The Lower-Level API: Extending Qt Applications

    Qt application can be extended through plugins. This requires the
    application to detect and load plugins using QPluginLoader. In
    that context, plugins may provide arbitrary functionality and are
    not limited to database drivers, image formats, text codecs,
    and styles.

    The \l{tools/plugandpaint}{Plug & Paint} example documentation
    explains this process in detail.

    \section1 Loading and Verifying Plugins

    When loading plugins, the Qt library does some sanity checking to
    determine whether or not the plugin can be loaded and used. This
    provides the ability to have multiple versions and configurations of
    the Qt library installed side by side.

    \list
    \o Plugins linked with a Qt library that has a higher major and/or
       minor version number will not be loaded by a library with a lower
       major and/or minor version number.

       \e {Rationale:}
       A plugin linked against a newer Qt library may use new
       features that are not available in older versions. Trolltech
       has a policy of adding new features and APIs only between minor
       releases, which is why this test only looks at the major and minor
       version numbers, and not at the bug-fix version number.

    \o The Qt library and all plugins are built using a \e {build
       key}. The build key in the Qt library is examined against the build
       key in the plugin, and if they match, the plugin is loaded. If the
       build keys do not match, then the Qt library refuses to load the
       plugin.

       \e {Rationale:}
       See the Rationale for the build key below.
    \endlist

    \section1 The Build Key

    The build key contains the following information:
    \list
    \o Architecture, operating system and compiler.

       \e {Rationale:}
       In cases where different versions of the same compiler do not
       produce binary compatible code, the version of the compiler is
       also present in the build key.

    \o Configuration of the Qt library. The configuration is a list
       of the missing features that affect the available API in the
       library. 

       \e {Rationale:}
       Two different configurations of the same version of
       the Qt library are not binary compatible. The Qt library that
       loads the plugin uses the list of (missing) features to
       determine if the plugin is binary compatible.

       \e {Note:} There are cases where a plugin can use features that are
       available in two different configurations. However, the
       developer writing plugins would need to know which features are
       in use, both in their plugin and internally by the utility
       classes in Qt. The Qt library would require complex feature
       and dependency queries and verification when loading plugins.
       Requiring this would place an unnecessary burden on the developer, and
       increase the overhead of loading a plugin. To reduce both
       development time and application runtime costs, a simple string
       comparision of the build keys is used.

    \o Optionally, an extra string may be specified on the configure
       script command line.

       \e {Rationale:}
       When distributing binaries of the Qt library with an
       application, this provides a way for developers to write
       plugins that can only be loaded by the library with which the
       plugins were linked.
    \endlist
*/
