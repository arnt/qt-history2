/****************************************************************************
**
** Copyright (C) 1992-$THISYEAR$ Trolltech AS. All rights reserved.
**
** This file is part of the Qt GUI Toolkit.
** EDITIONS: FREE, PROFESSIONAL, ENTERPRISE
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
****************************************************************************/

/*!
    \page deployment.html

    \title Deploying Qt Applications

    Deploying an Qt application does not require any C++
    programming. All you need to do is to build Qt and your
    application following the procedures described in this
    documentation. We will demonstrate the procedures in terms of
    deploying the Plug & Paint application that is provided in Qt's
    examples directory.

    There are two ways of deploying an application:

    \list
        \o Static Linking
        \o Shared Libraries
    \endlist

    Static linking results in a stand-alone executable. The advantage
    is that you will only have a few files to deploy. The
    disadvantages are that the executables are large and with no
    flexibility (i.e a new version of the application, or of Qt, will
    require that the deployment process is repeated), and that you
    cannot deploy plugins using the static linking approach.

    To deploy plugins you must use a shared library. Shared libraries
    also provide smaller, more flexible executables. The disadvantage
    with this approach is that the total packages are larger: In the
    number of files to deploy as well as in byte size.

    Since Qt is not a system library, it has to be redistributed along
    with your application; the minimum is to redistribute the run-time
    of the modules used by the application. Using static linking,
    however, the Qt run-time is compiled into the
    executable. Depending on configuration, compiler specific
    libraries must be redistributed as well.

    The procedure of deploying Qt applications is different for the
    various platforms:

    \list
        \o \l{Deploying an Application on Qt/X11}{Qt/X11}
        \o \l{Deploying an Application on Qt/Windows}{Qt/Windows}
        \o \l{Deploying an Application on Qt/Mac}{Qt/Mac}
    \endlist


    \sa Installation {Window System Specific Notes}
*/

/*!
    \page deployment-x11.html

    \title Deploying an Application on Qt/X11

    Deployment on Unix is a huge topic, due to the proliferation of
    Unix systems (commercial Unices, Linux distributions, etc.). This
    documentation will describe how to determine which files you
    should include in your distribution, and how to make sure that the
    application will find them at run-time.

    \tableofcontents

    Before we start, be aware that programs compiled for one Unix
    flavor will probably not run on a different Unix system. For
    example, unless you use a cross-compiler, you cannot compile your
    application on Irix and distribute it on AIX.

    \section1 Static Linking

    Static linking is often the safest and easiest way to distribute
    an application on Unix since it relieves you from the task of
    distributing the Qt library and ensuring that it's located in the
    default search path for libraries on the target system. The main
    disadvantages are that the executable is larger (because it
    includes the Qt library), plugins won't work, and the user won't
    be able to independently upgrade the Qt library used by the
    application.

    To use this approach, you must start by building a static version
    of the Qt library:

    \code
        cd $QTDIR
        ./configure -static <other parameters>
        make sub-src
    \endcode

    If you want to have a static and a dynamic Qt library side by
    side, you can do the following instead:

    \code
        cd $QTDIR/src
        make staticlib
    \endcode

    When make is done, you will find a file called libqt.a or
    libqt-mt.a in the $QTDIR/lib directory.

    Because the linkers on most Unix systems prefer shared libraries
    over static ones if both exist, you must add these lines to your
    application's .pro file:

    \code
        mystaticconfig {
            QMAKE_LIBS_QT =
            QMAKE_LIBS_QT_THREAD =
            LIBS += $(QTDIR)/lib/libqt.a
        }
    \endcode

    Replace libqt.a with libqt-mt.a if you built Qt with thread
    support enabled. Also note that you might need to append more
    libraries to the LIBS line.

    The next step is to regenerate the makefile and rebuild the
    application:

    \code
        make clean
        qmake "CONFIG+=mystaticconfig"
        make
    \endcode

    To check that the application really links statically with Qt, run
    the ldd tool (available on most Unices):

    \code
        ldd ./application
    \endcode

    Verify that libqt (or libqt-mt) is not mentioned in the output.

    Applications that link against a static version of the Qt library
    cannot use Qt plugins. This is because the plugins link against
    the shared Qt library, and bad things will happen if you load two
    versions of the same library (one static, one shared).

    \section1 Shared Libraries

    The alternative to static linking is to compile Qt as a shared
    library. This is what you get if you don't pass the -static option
    to the configure script.

    The library binary is put in the "$QTDIR/lib" directory. On most
    systems, the extension for shared libraries is .so. A notable
    exception is HP-UX, which uses .sl.

    The main issue with shared libraries is that you must ensure that
    the dynamic linker will find the library. Unless told otherwise,
    the dynamic linker doesn't search the directory where your
    application resides. There are many ways to solve this:

    \list
    \o You can install the Qt library in one of the system
       library paths (e.g. "/usr/lib" on most systems).

    \o You can write a startup script for your application,
       where you modify the dynamic linker configuration (e.g.
       adding your application's directory to the LD_LIBRARY_PATH
       environment variable).

    \o You can pass a predetermined path to the -rpath command-line
       option when linking the application. This will tell the dynamic
       linker to look in this directory when starting up.
    \endlist

    \section1 Plugins

    When you build the Qt library, the search path for plugins (as
    well as a few other paths) is hard-coded into the library. For
    example, if you compile the Qt library in "/usr/local/qt", the
    first plugin search path will be hard-coded as
    "/usr/local/qt/plugins".

    To change this, you can add a custom search path when you start
    your application using QApplication::addLibraryPath() or
    QApplication::setLibraryPaths(). Alternatively, your installer
    application can change the hard-coded paths in the library for
    you. Take a look at the distributor example located in
    "$QTDIR/examples/distributor" to see how to achieve this.

    Starting with Qt/X11 3.3.0, you can place plugins under the
    directory where your application resides and Qt will find
    them. For example, if you want to distribute an SQL plugin with
    the application, you can copy over the plugin files from
    "$QTDIR/drivers/sqldrivers" to a directory called sqldrivers
    inside the application's directory.

    \section1 Other Libraries

    Any shared library that you link against is a potential problem
    when you want to distribute your application. In particular, the
    standard C++ library can be a problem if you're compiling your
    application with a compiler that is binary incompatible with the
    system compiler. When possible, the safest solution is to link
    against these libraries statically.

    You will probably want to link dynamically with the regular X11
    libraries, since some implementations will try to open other
    shared libraries with dlopen(), and if this fails the X11 library
    might cause your application to crash.

    It's also worth mentioning that Qt will look for certain X11
    extensions, such as Xinerama and Xcursor, and possibly pull them
    in, including all the libraries that they link against. If you
    can't guarantee the presence of a certain extension, the safest
    approach is to disable it when configuring Qt (e.g. "./configure"
    -no-xcursor).

    "Xft/FontConfig" and FreeType are other examples of libraries that
    aren't always available or that aren't always binary
    compatible. As strange as it may sound, some software vendors have
    had success by compiling their software on very old machines and
    have been very careful not to upgrade any of the software running
    on them.

*/

/*!
    \page deployment-windows.html

    \title Deploying an Application on Qt/Windows

    Deploying an application on Windows does not require any C++
    programming. All you need to do is to build Qt and your
    application in release mode, following the procedures described
    in this documentation. We will demonstrate the procedures in terms
    of deploying the \l {tools/plugandpaint}{Plug & Paint} application
    that is provided in Qt's examples directory.

    There are two ways of deploying an application:

    \list
        \o Static Linking
        \o Shared Libraries
    \endlist

    Static linking results in a stand-alone executable.  The advantage
    is that you will only have a few files to deploy. The
    disadvantages are that the executables are large and with no
    flexibility (i.e a new version of the application, or of Qt, will
    require that the deployment process is repeated), and that you
    cannot deploy plugins using the static linking approach.

    To deploy plugins you must use a shared library. Shared libraries
    also provide smaller, more flexible executables. The disadvantage
    with this approach is that the total packages are larger: In the
    number of files to deploy (one executable plus one or more \c
    {DLL}s) as well as in byte size.

    Since Qt is not a system library, it has to be redistributed along
    with your application; the minimum is to redistribute the run-time
    of the modules used by the application. Using static linking,
    however, the Qt run-time is compiled into the
    executable. Depending on configuration, compiler specific
    libraries must be redistributed. You can check which libraries
    your application is linking against by using the \c depends
    tool. For more information see the \l {Application Dependencies-
    the "depends" tool}{Application Dependencies} section.

    Contents:

    \tableofcontents

    \section1 Static Linking

    If you want to keep things simple by only having a few files to
    deploy, i.e. a stand-alone executable with the associated compiler
    specific \c {DLL}s, then you must build everything statically.

    \section2 Building Qt

    Before we can build our application we must make sure that Qt is
    built statically. To do this, go to a command prompt and type the
    following:

    \code
        cd C:\path\to\Qt
        configure -static <any other options you need>
    \endcode

    Remember to specify any other options you need, such as data base
    drivers, as arguments to \c configure. Once \c configure has
    finished, type the following:

    \code
        nmake sub-src
    \endcode

    This will build Qt statically in release mode. Note that we have
    used \c nmake in all the examples, but if you use MinGW you must
    use the \c mingw32-make instead.

    \section2 Building the Application

    Once Qt has finished building we can build the Plug & Paint
    application. First we must go into the directory that contains the
    application:

    \code
        cd examples\tools\plugandpaint
    \endcode

    We must then run \c qmake to create a new makefile for the
    application, and do a clean build to create the statically linked
    executable:

    \code
        qmake plugandpaint.pro
        nmake clean
        nmake
    \endcode

    Now, provided that everything compiled and linked without any
    errors, we should have a \c plugandpaint.exe file that is ready for
    deployment. One easy way to check that the application really can
    be run stand-alone is to copy it to a machine that doesn't have Qt
    or any Qt applications installed, and run it on that machine.

    Remember that if your application depends on compiler specific
    libraries, these must still be redistributed along with your
    application. You can check which libraries your application is
    linking against by using the \c depends tool. For more
    information, see the \l {Application Dependencies- the "depends"
    tool}{Application Dependencies} section.

    The \l {tools/plugandpaint}{Plug & Paint} example consists of
    several components: The application itself (\l
    {tools/plugandpaint}{Plug & Paint}), and the application-specific
    \l {tools/plugandpaintplugins/basictools}{Basic Tools} and \l
    {tools/plugandpaintplugins/extrafilters}{Extra Filters} plugins.
    Since we cannot deploy plugins using the static linking approach,
    the application we have prepared is incomplete. It will run, but
    the functionality will be disabled due to the missing plugins; to
    deploy plugins we must use a shared library.

    \section1 Shared Libraries

    The reason why plugin-based applications must link against Qt as a
    shared library, is that if we used static linking, the application
    and each plugin would pull in their own instance of Qt. Another
    reason why you might want to use the shared library approach, is
    if you want to use the same Qt \c {DLL}s for a family of
    applications. In fact, if you download the binary installation of
    Qt, you get Qt as a shared library. In addition, shared libraries
    provide flexibility. For example, if new versions of the deployed
    application or of Qt is developed, you only need to ship the new
    \c {DLL}s.

    We have two challenges when deploying the \l
    {tools/plugandpaint}{Plug & Paint} application using the shared
    libraries approach: The Qt runtime has to be correctly
    redistributed along with the application executable, and the
    plugins have to be installed in the correct location on the target
    system so that the application can find them.

    \section2 Building Qt and Plugins

    As with static linking, before we can build our application we
    must make sure that Qt is built as a shared library. To do this,
    go to a command prompt and type the following:

    \code
        cd C:\path\to\Qt
        configure -shared <any other options you need>
    \endcode

    Remember to specify any other options you need as arguments to \c
    configure. Once \c configure has finished, type the following:

    \code
        nmake sub-src
    \endcode

    This will build Qt as a shared library in release mode, as well as
    building the plugins.

    \section2 Building the Application

    When Qt has finished building, we can build the \l
    {tools/plugandpaint}{Plug & Paint} application. First, we must go
    into the directory that contains the application:

    \code
        cd ..\examples\tools\plugandpaint
    \endcode

    Now run \c qmake to create a new makefile for the application, and
    do a clean build to create the dynamically linked executable:

    \code
        qmake plugandpaint.pro
        nmake clean
        nmake
    \endcode

    If everything compiled and linked without any errors, we will get
    a \c plugandpaint.exe file. To deploy it, we must make sure that
    we copy the relevant Qt \c {DLL}'s (corresponding to the Qt
    modules used in the application) as well as the executable to the
    same directory in the \c release subdirectory. We'll cover the
    plugins shortly, but first we'll check that the application will
    work in a deployed environment: Either copy the executable and the
    Qt \c {DLL}s to a machine that doesn't have Qt or any Qt
    applications installed, or if you want to test on the build
    machine, ensure that the machine doesn't have Qt in its
    environment.

    Remember that if your application depends on compiler specific
    libraries, these must be redistributed along with your
    application. You can check which libraries your application is
    linking against by using the \c depends tool. For more
    information, see the \l {Application Dependencies - the "depends"
    Tool}{Application Dependencies} section.

    If the application starts without any problems, then we have
    successfully made a dynamically linked version of the \l
    {tools/plugandpaint}{Plug & Paint} application. But the
    application's functionality will still be missing since we have
    not yet deployed the associated plugins.

    \section2 Deploying the Plugins

    Plugins work differently to normal \c {DLL}s, so we can't just
    copy them into the same directory as our application's executable
    as we did with the Qt \c {DLL}s.  When looking for plugins, the
    application searches in a \c plugins subdirectory inside the
    directory of the application executable.

    So to make the plugins available to our application, we have to
    create the \c plugins subdirectory and copy over the relevant \c
    {DLL}s:

    \code
        plugins\pnp_basictools.dll
        plugins\pnp_extrafilters.dll
    \endcode

    An archive distributing all the Qt and C run-time \c {DLL}s and
    all the plugins required to run the \l {tools/plugandpaint}{Plug &
    Paint} application, would have to include the following files:

    \table 100%
    \header
        \o Component \o {2, 1} File Name
    \row
        \o The executable
        \o {2, 1} \c plugandpaint.exe
    \row
        \o The Basic Tools plugin
        \o {2, 1} \c plugins\pnp_basictools.dll
    \row
        \o The ExtraFilters plugin
        \o {2, 1} \c plugins\pnp_extrafilters.dll
    \row
        \o The Qt Core module
        \o {2, 1} \c qtcore4.dll
    \row
        \o The Qt GUI module
        \o {2, 1} \c qtgui4.dll
    \endtable

    In addition, the archive must contain the following compiler
    specific libraries depending on your version of Visual Studio:

    \table 100%
    \header
        \o \o VC++ 6.0 \o VC++ 7.1 (2003)
    \row
        \o The C run-time
        \o \c msvcrt.dll
        \o \c msvcr71.dll
    \row
        \o The C++ run-time
        \o \c msvcp60.dll
        \o \c msvcp71.dll
    \endtable

    To verify that the application now can be successfully deployed,
    you can extract this archive on a machine without Qt and without
    any compiler installed, and try to run it.

    One benefit of using plugins is that they can easily be made
    available to a whole family of applications. For example, if we
    have several applications that need JPEG support, including our \l
    {tools/plugandpaint}{Plug & Paint} application, we might decide to
    put the JPEG plugin in the "C:\\QtPlugins\\imageformats"
    directory.

    To make our application aware of this additional plugin
    directory, we must add the following line, before the application
    needs to load the plugins:

    qApp->addLibraryPath("C:\\QtPlugins\\imageformats");

    It's often most convenient to add the path in the application's \c
    main() function, right after the QApplication object is
    created. Once the path is added, the application will search it
    for plugins, in addition to looking in the \c plugins subdirectory
    in the application's own directory. Any number of additional paths
    can be added.

    \section1 Application Dependencies - the "depends" Tool

    You can check which libraries your application is linking against
    by using the \c depends tool. To use the \c depends tool, all you
    need to do is to run it like this:

    \code
        depends <application executable>
    \endcode

    This will provide a list of the libraries that your application
    depends on and other information.

    \image depends-screenshot

    Looking at the release build of the \l {tools/plugandpaint}{Plug &
    Paint} executable (\c plugandpaint.exe) with the \c depends tool,
    lists the following immediate dependencies to non-system
    libraries:

    \table 100%
        \header
            \o Qt
            \o VC++ 6.0
            \o VC++ 7.1 (2003)
            \o MinGW
        \row
        \o \list
               \o QTCORE4.DLL - The QtCore runtime
               \o QTGUI4.DLL - The QtGui runtime
           \endlist
        \o \list
               \o MSVCRT.DLL - The C runtime
               \o MSVCP60.DLL - The C++ runtime (only when STL is installed)
           \endlist
        \o \list
               \o MSVCR71.DLL - The C runtime
               \o MSVCP71.DLL - The C++ runtime (only when STL is installed)
           \endlist
        \o \list
               \o MINGWM10.DLL - The MinGW run-time
           \endlist
    \endtable

    Looking at the plugin \c {DLL}s lists the exact same dependencies.
*/

/*!
    \page deployment-mac.html

    \title Deploying an Application on Qt/Mac
*/
