/****************************************************************************
**
** Copyright (C) 1992-$THISYEAR$ Trolltech AS. All rights reserved.
**
** This file is part of the Qt GUI Toolkit.
** EDITIONS: FREE, PROFESSIONAL, ENTERPRISE
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
****************************************************************************/

/*!
    \page deployment.html

    \title Deploying Qt Applications

    Deploying an Qt application does not require any C++
    programming. All you need to do is to build Qt and your
    application following the procedures described in this
    documentation. We will demonstrate the procedures in terms of
    deploying the \l {tools/plugandpaint}{Plug & Paint} application
    that is provided in Qt's examples directory.

    There are two ways of deploying an application:

    \list
        \o Static Linking
        \o Shared Libraries
    \endlist

    Static linking results in a stand-alone executable. The advantage
    is that you will only have a few files to deploy. The
    disadvantages are that the executables are large and with no
    flexibility (i.e a new version of the application, or of Qt, will
    require that the deployment process is repeated), and that you
    cannot deploy plugins using the static linking approach, unless
    you use static plugins. Static plugins are plugins that are
    compiled into the application.

    If you don't use static plugins, you must use a shared library to
    deploy plugins (i.e. using dynamic plugins). Shared libraries also
    provide smaller, more flexible executables. The disadvantage with
    this approach is that the total packages are larger; In the number
    of files to deploy as well as in byte size.

    \table 100%
    \header
        \o {5,1} Qt's Libraries
    \row
        \o \l {QtCore}
        \o \l {QtGui}
        \o \l {QtNetwork}
        \o \l {QtOpenGL}
        \o \l {QtSql}
    \row
        \o \l {QtSvg}
        \o \l {QtXml}
        \o \l {QtDesigner}
        \o \l {QtAssistant}
        \o \l {Qt3Support}
    \endtable

    Since Qt is not a system library, it has to be redistributed along
    with your application; the minimum is to redistribute the run-time
    of the modules used by the application.  Using static linking,
    however, the Qt run-time is compiled into the
    executable. Depending on configuration, compiler specific
    libraries must be redistributed as well.

    The procedure of deploying Qt applications is different for the
    various platforms:

    \list
        \o \l{Deploying an Application on Qt/X11}{Qt/X11}
        \o \l{Deploying an Application on Qt/Windows}{Qt/Windows}
        \o \l{Deploying an Application on Qt/Mac}{Qt/Mac}
    \endlist

    \omit
    <qt.conf>
    <binary patching>
    <dynamic versus static plugins>
    \endomit

    \sa Installation {Window System Specific Notes}
*/

/*!
    \page deployment-x11.html

    \title Deploying an Application on Qt/X11

    Deployment on Unix is a huge topic, due to the proliferation of
    Unix systems (commercial Unices, Linux distributions, etc.). This
    documentation will describe how to determine which files you
    should include in your distribution, and how to make sure that the
    application will find them at run-time.

    \tableofcontents

    Before we start, be aware that programs compiled for one Unix
    flavor will probably not run on a different Unix system. For
    example, unless you use a cross-compiler, you cannot compile your
    application on Irix and distribute it on AIX.

    \section1 Static Linking

    Static linking is often the safest and easiest way to distribute
    an application on Unix since it relieves you from the task of
    distributing the Qt libraries and ensuring that they are located
    in the default search path for libraries on the target system.

    \section2 Building Qt

    To use this approach, you must start by installing a static version
    of the Qt library:

    \code
        cd /path/to/Qt
        ./configure -static -prefix /path/to/Qt <other parameters>
        make sub-src
    \endcode

    We specify the prefix so that we do not overwrite the existing Qt
    installation. The example above only build the Qt libraries,
    i.e. the examples and Qt Designer will not be built.  When \c make
    is done, you will find the Qt libraries in the \c /path/to/Qt/lib
    directory.

    When linking your application against static Qt libraries, note
    that you might need to add more libraries to the \c LIBS line in
    your project file. For more information, see the \l {Application
    and Plugin Dependencies} section.

    \section2 Building the Application

    The next step is to regenerate the makefile and rebuild the
    application:

    \code
        make clean
        PATH=/path/to/Qt/bin:$PATH
        export PATH
        qmake
        make
    \endcode

    Note that we must set the path to the static Qt that we just
    built. To check that the application really links statically with
    Qt, run the \c ldd tool (available on most Unices):

    \code
        ldd ./application
    \endcode

    Verify that the Qt libraries are not mentioned in the output.

    Now, provided that everything compiled and linked without any
    errors, we should have a \c plugandpaint file that is ready for
    deployment. One easy way to check that the application really can
    be run stand-alone is to copy it to a machine that doesn't have Qt
    or any Qt applications installed, and run it on that machine.

    The \l {tools/plugandpaint}{Plug & Paint} example consists of
    several components: The application itself (\l
    {tools/plugandpaint}{Plug & Paint}), and the application-specific
    \l {tools/plugandpaintplugins/basictools}{Basic Tools} and \l
    {tools/plugandpaintplugins/extrafilters}{Extra Filters}
    plugins. Since we cannot deploy plugins using the static linking
    approach alone, the application we have prepared is incomplete. It
    will run, but the functionality will be disabled due to the
    missing plugins. To deploy plugins we must either use a shared
    library or static plugins.

    \section2 Static Plugins

    ###

    \section1 Shared Libraries

    The alternative to static linking using static plugins is to
    compile Qt as a shared library using dynamic plugins.

    Another reason why you might want to use the shared library
    approach, is if you want to use the same Qt DLLs for a family of
    applications. In fact, if you download the binary installation of
    Qt, you get Qt as a shared library. In addition, shared libraries
    provide flexibility. For example, using the shared library
    approach, the user is able to independently upgrade the Qt library
    used by the application.

    We have two challenges when deploying the \l
    {tools/plugandpaint}{Plug & Paint} application using the shared
    libraries approach: The Qt runtime has to be correctly
    redistributed along with the application executable, and the
    plugins have to be installed in the correct location on the target
    system so that the application can find them.

    \section2 Building Qt

    We assume that you already have installed Qt as a shared library
    in the /path/to/Qt directory which is the default when installing
    Qt. For more information on how to build Qt, see the \l
    {Installation} document.

    \section2 Building the Application and Plugins

    After ensuring that Qt is built as a shared library, we can build
    the \l {tools/plugandpaint}{Plug & Paint} application. First, we
    must go into the directory that contains the application:

    \code
       cd /path/to/Qt/examples/tools/plugandpaint
    \endcode

    Now run qmake to create a new makefile for the application, and do
    a clean build to create the dynamically linked executable:

    \code
        qmake plugandpaint.pro
        make clean
        make
    \endcode

    This builds the application, now we need to build the plugins:

    \code
        cd ../plugandpaintplugins
        qmake plugandpaint.pro
        make clean
        make
    \endcode

    If everything compiled and linked without any errors, we will get
    a \c plugandpaint executable and the \c libpnp_basictools.so and
    \c libpnp_extrafilters.so plugin files.

    Now, we must put the plugins into a location where the application
    can find them.

    \section2 Deploying the Plugins

    When looking for plugins, the application searches in a plugins
    subdirectory inside the directory of the application
    executable. Either you have to manually copy the plugins into the
    \c plugins directory, or you can set the \c DESTDIR in the
    plugins' project files:

    \code
        DESTDIR = /path/to/Qt/plugandpaint/plugins
    \endcode

    Alternatively, you can add a custom search path when you start
    your application using QApplication::addLibraryPath() or
    QApplication::setLibraryPaths().

    When you build the Qt library, the search path for plugins (as
    well as a few other paths) is hard-coded into the library. By
    default, the first plugin search path will be hard-coded as \c
    /path/to/Qt/plugins. Alternatively, your \l {}{installer
    application} can change the hard-coded paths in the library for
    you.

    \section2 Packaging

    The main issue with shared libraries is that you must ensure that
    the dynamic linker will find the library. Unless told otherwise,
    the dynamic linker doesn't search the directory where your
    application resides. There are many ways to solve this:

    \list
    \o You can install the Qt library in one of the system
       library paths (e.g. \c /usr/lib on most systems).

    \o You can pass a predetermined path to the \c -rpath command-line
       option when linking the application. This will tell the dynamic
       linker to look in this directory when starting up.

    \o You can write a startup script for your application,
       where you modify the dynamic linker configuration (e.g.
       adding your application's directory to the \c LD_LIBRARY_PATH
       environment variable).
    \endlist

    The disadvantage of the first approach is that the user \e must
    have super user privileges. The disadvantage of the second
    approach is that the user \e may not have privileges to install
    into the predetemined path. In either case, the users don't have
    the option of installing to their home directory. For that reason
    we recommend using the third approach since it is the most
    flexible.

    The library binary is put in the \c /path/to/Qt/lib directory. And
    the Qt plugins are put in the \c /path/to/Qt/plugins directory. On
    most systems, the extension for shared libraries is \c .so. A
    notable exception is HP-UX, which uses \c .sl.

    \section1 Application and Plugin Dependencies

    Any shared library that you link against is a potential problem
    when you want to distribute your application. In particular, the
    standard C++ library can be a problem if you're compiling your
    application with a compiler that is binary incompatible with the
    system compiler. When possible, the safest solution is to link
    against these libraries statically.

    You will probably want to link dynamically with the regular X11
    libraries, since some implementations will try to open other
    shared libraries with dlopen(), and if this fails the X11 library
    might cause your application to crash.

    It's also worth mentioning that Qt will look for certain X11
    extensions, such as Xinerama and Xcursor, and possibly pull them
    in, including all the libraries that they link against. If you
    can't guarantee the presence of a certain extension, the safest
    approach is to disable it when configuring Qt (e.g. "./configure"
    -no-xcursor).

    "Xft/FontConfig" and FreeType are other examples of libraries that
    aren't always available or that aren't always binary
    compatible. As strange as it may sound, some software vendors have
    had success by compiling their software on very old machines and
    have been very careful not to upgrade any of the software running
    on them.
*/

/*!
    \page deployment-windows.html

    \title Deploying an Application on Qt/Windows

    This documentation will describe how to determine which files you
    should include in your distribution, and how to make sure that the
    application will find them at run-time.

    \tableofcontents

    \section1 Static Linking

    If you want to keep things simple by only having a few files to
    deploy, i.e. a stand-alone executable with the associated compiler
    specific \c {DLL}s, then you must build everything statically.

    \section2 Building Qt

    Before we can build our application we must make sure that Qt is
    built statically. To do this, go to a command prompt and type the
    following:

    \code
        cd C:\path\to\Qt
        configure -static <any other options you need>
    \endcode

    Remember to specify any other options you need, such as data base
    drivers, as arguments to \c configure. Once \c configure has
    finished, type the following:

    \code
        nmake sub-src
    \endcode

    This will build Qt statically in release mode. Note that we have
    used \c nmake in all the examples, but if you use MinGW you must
    use the \c mingw32-make instead.

    \section2 Building the Application

    Once Qt has finished building we can build the Plug & Paint
    application. First we must go into the directory that contains the
    application:

    \code
        cd examples\tools\plugandpaint
    \endcode

    We must then run \c qmake to create a new makefile for the
    application, and do a clean build to create the statically linked
    executable:

    \code
        qmake plugandpaint.pro
        nmake clean
        nmake
    \endcode

    This build the application, now we need to build the plugins:

    \code
        cd ..\plugandpaintplugins
        qmake plugandpaint.pro
        nmake clean
        nmake
    \endcode

    Now, provided that everything compiled and linked without any
    errors, we should have a \c plugandpaint.exe file that is ready for
    deployment. One easy way to check that the application really can
    be run stand-alone is to copy it to a machine that doesn't have Qt
    or any Qt applications installed, and run it on that machine.

    Remember that if your application depends on compiler specific
    libraries, these must still be redistributed along with your
    application. You can check which libraries your application is
    linking against by using the \c depends tool. For more
    information, see the \l {Application Dependencies- the "depends"
    tool}{Application Dependencies} section.

    The \l {tools/plugandpaint}{Plug & Paint} example consists of
    several components: The application itself (\l
    {tools/plugandpaint}{Plug & Paint}), and the application-specific
    \l {tools/plugandpaintplugins/basictools}{Basic Tools} and \l
    {tools/plugandpaintplugins/extrafilters}{Extra Filters} plugins.
    Since we cannot deploy plugins using the static linking approach,
    the application we have prepared is incomplete. It will run, but
    the functionality will be disabled due to the missing plugins; to
    deploy plugins we must use a shared library.

    \section1 Shared Libraries

    The reason why plugin-based applications must link against Qt as a
    shared library, is that if we used static linking, the application
    and each plugin would pull in their own instance of Qt. Another
    reason why you might want to use the shared library approach, is
    if you want to use the same Qt \c {DLL}s for a family of
    applications. In fact, if you download the binary installation of
    Qt, you get Qt as a shared library. In addition, shared libraries
    provide flexibility. For example, if new versions of the deployed
    application or of Qt is developed, you only need to ship the new
    \c {DLL}s.

    We have two challenges when deploying the \l
    {tools/plugandpaint}{Plug & Paint} application using the shared
    libraries approach: The Qt runtime has to be correctly
    redistributed along with the application executable, and the
    plugins have to be installed in the correct location on the target
    system so that the application can find them.

    \section2 Building Qt

    As with static linking, before we can build our application we
    must make sure that Qt is built as a shared library. To do this,
    go to a command prompt and type the following:

    \code
        cd C:\path\to\Qt
        configure -shared <any other options you need>
    \endcode

    Remember to specify any other options you need as arguments to \c
    configure. Once \c configure has finished, type the following:

    \code
        nmake sub-src
    \endcode

    This will build Qt as a shared library in release mode.

    \section2 Building the Application and Plugins

    When Qt has finished building, we can build the \l
    {tools/plugandpaint}{Plug & Paint} application. First, we must go
    into the directory that contains the application:

    \code
        cd ..\examples\tools\plugandpaint
    \endcode

    Now run \c qmake to create a new makefile for the application, and
    do a clean build to create the dynamically linked executable:

    \code
        qmake plugandpaint.pro
        nmake clean
        nmake
    \endcode

    This build the application, now we need to build the plugins:

    \code
        cd ..\plugandpaintplugins
        qmake plugandpaint.pro
        nmake clean
        nmake
    \endcode

    If everything compiled and linked without any errors, we will get
    a \c plugandpaint.exe file. To deploy it, we must make sure that
    we copy the relevant Qt \c {DLL}'s (corresponding to the Qt
    modules used in the application) as well as the executable to the
    same directory in the \c release subdirectory. We'll cover the
    plugins shortly, but first we'll check that the application will
    work in a deployed environment: Either copy the executable and the
    Qt \c {DLL}s to a machine that doesn't have Qt or any Qt
    applications installed, or if you want to test on the build
    machine, ensure that the machine doesn't have Qt in its
    environment.

    Remember that if your application depends on compiler specific
    libraries, these must be redistributed along with your
    application. You can check which libraries your application is
    linking against by using the \c depends tool. For more
    information, see the \l {Application Dependencies - the "depends"
    Tool}{Application Dependencies} section.

    If the application starts without any problems, then we have
    successfully made a dynamically linked version of the \l
    {tools/plugandpaint}{Plug & Paint} application. But the
    application's functionality will still be missing since we have
    not yet deployed the associated plugins.

    \section2 Deploying the Plugins

    Plugins work differently to normal \c {DLL}s, so we can't just
    copy them into the same directory as our application's executable
    as we did with the Qt \c {DLL}s.  When looking for plugins, the
    application searches in a \c plugins subdirectory inside the
    directory of the application executable.

    So to make the plugins available to our application, we have to
    create the \c plugins subdirectory and copy over the relevant \c
    {DLL}s:

    \code
        plugins\pnp_basictools.dll
        plugins\pnp_extrafilters.dll
    \endcode

    An archive distributing all the Qt and C run-time \c {DLL}s and
    all the plugins required to run the \l {tools/plugandpaint}{Plug &
    Paint} application, would have to include the following files:

    \table 100%
    \header
        \o Component \o {2, 1} File Name
    \row
        \o The executable
        \o {2, 1} \c plugandpaint.exe
    \row
        \o The Basic Tools plugin
        \o {2, 1} \c plugins\pnp_basictools.dll
    \row
        \o The ExtraFilters plugin
        \o {2, 1} \c plugins\pnp_extrafilters.dll
    \row
        \o The Qt Core module
        \o {2, 1} \c qtcore4.dll
    \row
        \o The Qt GUI module
        \o {2, 1} \c qtgui4.dll
    \endtable

    In addition, the archive must contain the following compiler
    specific libraries depending on your version of Visual Studio:

    \table 100%
    \header
        \o \o VC++ 6.0 \o VC++ 7.1 (2003)
    \row
        \o The C run-time
        \o \c msvcrt.dll
        \o \c msvcr71.dll
    \row
        \o The C++ run-time
        \o \c msvcp60.dll
        \o \c msvcp71.dll
    \endtable

    To verify that the application now can be successfully deployed,
    you can extract this archive on a machine without Qt and without
    any compiler installed, and try to run it.

    One benefit of using plugins is that they can easily be made
    available to a whole family of applications. For example, if we
    have several applications that need JPEG support, including our \l
    {tools/plugandpaint}{Plug & Paint} application, we might decide to
    put the JPEG plugin in the "C:\\QtPlugins\\imageformats"
    directory.

    To make our application aware of this additional plugin
    directory, we must add the following line, before the application
    needs to load the plugins:

    qApp->addLibraryPath("C:\\QtPlugins\\imageformats");

    It's often most convenient to add the path in the application's \c
    main() function, right after the QApplication object is
    created. Once the path is added, the application will search it
    for plugins, in addition to looking in the \c plugins subdirectory
    in the application's own directory. Any number of additional paths
    can be added.

    \section1 Application Dependencies - the "depends" Tool

    Depending on configuration, compiler specific libraries must be
    redistributed along with your application. You can check which
    libraries your application is linking against by using the \c
    depends tool. To use the \c depends tool, all you need to do is to
    run it like this:

    \code
        depends <application executable>
    \endcode

    This will provide a list of the libraries that your application
    depends on and other information.

    \image depends-screenshot

    Looking at the release build of the \l {tools/plugandpaint}{Plug &
    Paint} executable (\c plugandpaint.exe) with the \c depends tool,
    lists the following immediate dependencies to non-system
    libraries:

    \table 100%
        \header
            \o Qt
            \o VC++ 6.0
            \o VC++ 7.1 (2003)
            \o MinGW
        \row
        \o \list
               \o QTCORE4.DLL - The QtCore runtime
               \o QTGUI4.DLL - The QtGui runtime
           \endlist
        \o \list
               \o MSVCRT.DLL - The C runtime
               \o MSVCP60.DLL - The C++ runtime (only when STL is installed)
           \endlist
        \o \list
               \o MSVCR71.DLL - The C runtime
               \o MSVCP71.DLL - The C++ runtime (only when STL is installed)
           \endlist
        \o \list
               \o MINGWM10.DLL - The MinGW run-time
           \endlist
    \endtable

    Looking at the plugin \c {DLL}s lists the exact same dependencies.
*/

/*!
    \page deployment-mac.html

    \title Deploying an Application on Qt/Mac
*/
