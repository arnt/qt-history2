/****************************************************************************
**
** Documentation for sql programming.
**
** Copyright (C) 1992-$THISYEAR$ Trolltech AS. All rights reserved.
**
** This file is part of the Qt GUI Toolkit.
** EDITIONS: FREE, PROFESSIONAL, ENTERPRISE
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
****************************************************************************/

/*! \page sql-intro.html

    \title Introduction to the SQL Module

    \if defined(commercial)
    This module is part of the \link commercialeditions.html Qt Enterprise Edition
    \endlink.
    \endif

    \table
    \row \o QSql \o QSqlDatabase \o QSqlDriver \o QSqlDriverCreator
    \row \o QSqlDriverCreatorBase \o QSqlDriverPlugin \o QSqlError \o QSqlField
    \row \o QSqlIndex \o QSqlQuery \o QSqlQueryModel \o QSqlRecord
    \row \o QSqlRelation \o QSqlRelationalDelegate \o QSqlRelationalTableModel \o QSqlResult
    \row \o QSqlTableModel \o{3,1} See also: \l{sql-driver.html}{Supported Database Drivers}
    \endtable

    Qt's SQL classes help you provide seamless database integration
    to your Qt applications.

    This document is divided into six sections:

    \list
    \o \l{SQL Module Architecture}. This section describes how the
    classes fit together.

    \o \l{Connecting to Databases}. This section explains how to set
    up database connections using the \l QSqlDatabase class.

    \o \l{Executing SQL Statements}. This section demonstrates how to
    issue standard data manipulation statements (\c SELECT, \c
    INSERT, \c UPDATE, and \c DELETE) on tables in the database using
    QSqlQuery.

    \o \l{Using SQL Model Classes}. This section explains how to use
    the QSqlQueryModel and QSqlTableModel classes, which provide a
    higher-level API than the raw SQL used with \l QSqlQuery.

    \o \l{Presenting Data in a Table View}. This section shows how to
    display SQL data using a QTableView.

    \o \l{Creating Data-Aware Forms}. This section shows how to
    create more complex user interfaces based on a database.
    \endlist

    This overview assumes that you have at least a basic knowledge of
    SQL. You should be able to understand simple \c SELECT, \c
    INSERT, \c UPDATE, and \c DELETE statements. Although the \l
    QSqlTableModel class provides an interface to database browsing
    and editing that does not \e require a knowledge of SQL, a basic
    understanding of SQL is highly recommended. A standard text
    covering SQL databases is \e {An Introduction to Database Systems
    (7th Ed.)} by C. J. Date, ISBN 0201385902.

    \section1 SQL Module Architecture

    The SQL classes are divided into three layers:

    \table
    \row \i \bold{Driver Layer}
         \i This comprises three classes: QSqlResult, QSqlDriver, and
            QSqlDriverFactoryInterface. This layer provides the
            low-level bridge between the specific databases and the
            SQL API layer. This layer is
            \l{sql-driver.html}{documented separately} since it is
            only relevant to driver writers.

    \row \i \bold{SQL API Layer}
         \i These classes provide access to databases. Connections
            are made using the QSqlDatabase class. Database
            interaction is achieved by using the QSqlQuery class. In
            addition to QSqlDatabase and QSqlQuery, the SQL API layer
            is supported by QSqlError, QSqlField, QSqlIndex, and
            QSqlRecord.

    \row \i \bold{User Interface Layer}
         \i These classes link the data from a database to data-aware
            widgets. They include QSqlQueryModel, QSqlTableModel, and
            QSqlRelationalTableModel. These classes are designed to
            work with Qt's \l{model/view classes}.
    \endtable

    \section1 Connecting to Databases

    Before you can use QSqlQuery or QSqlQueryModel to access a
    database, you must create at least one database connection.

    Database connections are identified by arbitrary strings.
    QSqlDatabase also supports the concept of a \e{default
    connection}, which is used by the Qt SQL class if no other
    connection is specified. This mechanism is very convenient in
    applications that use only one database connection.

    The following code establishes a connection to a MySQL database
    called \c flightdb on the local host:

    \quotefromfile snippets/sqldatabase/sqldatabase.cpp
    \skipto sql_intro_snippets
    \skipto QSqlDatabase db =
    \printuntil ok = db.open()

    The first argument to QSqlDatabase::addDatabase() is the name of
    the driver. See the
    \l{QSqlDatabase::addDatabase()}{addDatabase()} documentation for
    a list of drivers. We call setHostName(), setDatabaseName(),
    setUserName(), and setPassword() to initialize the connection
    information.

    Since no name was specified for the connection, the connection
    serves as the default connection. To specify a name, pass it as
    the second argument to QSqlDatabase::addDatabase(). For example:

    \skipto firstDB
    \printuntil secondDB

    At the end, we call QSqlDatabase::open() to open the database and
    give us access to the data. If this call fails it will return
    false; error information can be obtained from
    QSqlDatabase::lastError().

    Once a connection is established, we can call the static function
    QSqlDatabase::database() from anywhere to get a pointer to a
    database connection. If we call it without a parameter, it will
    return the default connection. If called with the identifier used
    for a connection, it will return a reference to the specified
    connection. For example:

    \skipto ::database()
    \printline defaultDB =
    \printline firstDB =
    \printline secondDB =

    To remove a database connection, first close the database using
    QSqlDatabase::close(), then remove it using the static method
    QSqlDatabase::removeDatabase().

    \section1 Executing SQL Statements

    The QSqlQuery class provides an interface for executing SQL
    statements and navigating through the result set of a query.

    The QSqlQueryModel and QSqlTableModel classes described in the
    \l{Using SQL Model Classes}{next section} provide a higher-level
    interface for accessing databases. If you are unfamiliar with
    SQL, you might want to skip this section and use these classes
    instead.

    \section2 Executing a Query

    To execute an SQL statement, simply create a QSqlQuery object and
    call QSqlQuery::exec() with the statement:

    \skipto SELECT1
    \printuntil exec(

    The QSqlQuery constructor accepts an optional QSqlDatabase object
    that specifies which database connection to use. In the example
    above, we don't specify any connection; the default connection is
    used.

    To check if an error occurred, we can call QSqlQuery::isActive().
    The error is available as QSqlQuery::lastError(). For example:

    \printline isActive
    \printline showMessage

    \section2 Navigating the Result Set

    QSqlQuery provides access to the result set one record at a time.
    After the call to \l{QSqlQuery::exec()}{exec()}, QSqlQuery's
    internal pointer is located one position \e{before} the first
    record. We must call QSqlQuery::next() once to
    advance to the first record, then \l{QSqlQuery::next()}{next()}
    again repeatedly to access the other records, until it returns
    false:

    \skipto while (query.next())
    \printuntil }

    The QSqlQuery::value() function returns the value of a field in
    the current record. Fields are specified as zero-based indexes.

    You can iterate back and forth using QSqlQuery::next(),
    QSqlQuery::previous(), QSqlQuery::first(), QSqlQuery::last(), and
    QSqlQuery::seek(). The current row index is returned by
    QSqlQuery::at(), and the total number of rows in the result set
    is avaliable as QSqlQuery::size() for databases that support it.

    To determine whether a database driver supports a given feature,
    use QSqlDriver::hasFeature() as follows:

    \skipto FEATURE
    \skipto defaultDB
    \printuntil }

    If you iterate through a result set only using next() and seek()
    with positive values, you can call
    QSqlQuery::setForwardOnly(true) before calling exec(). This is an
    easy optimization that will speed up the query significantly when
    operating on large datasets.

    \section2 Inserting, Updating, and Deleting Records



    \section2 Transactions


    \section1 Using SQL Model Classes

    \section1 Presenting Data in a Table View

    \section1 Creating Data-Aware Forms

    \e{The Qt 4.0 beta 2 release will include some classes that will
    make it easy to create data-aware forms, i.e. forms that get
    their data from a database. For the moment, there is no such
    support in Qt.}
*/
