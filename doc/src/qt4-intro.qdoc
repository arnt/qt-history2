/*!
    \page qt4-intro.html
    \title What's New in Qt 4

    \startpage index.html Qt Reference Documentation
    \nextpage The Tulip Container Classes

    This document covers the most important differences between Qt 3
    and Qt 4. Although it is not intended to be a comprehensive
    porting guide, it tells you about the most important portability
    issues that you may encounter. It also explains how to turn on Qt
    3 compatibility support.

    \tableofcontents

    \section1 New Technologies

    Qt 4 introduces the following core technologies:

    \list
    \o \link qt4-tulip.html Tulip \endlink, a new set of template container classes.

    \o \link qt4-interview.html Interview \endlink, a model/view architecture for item views.

    \o \link qt4-arthur.html Arthur \endlink, the Qt 4 painting framework.

    \o \link qt4-scribe.html Scribe \endlink, the Unicode text
    renderer with a public API for performing low-level text layout.

    \o \link qt4-mainwindow.html Mainwindow \endlink, a modern
    action-based mainwindow, toolbar, menu, and docking architecture.
    \endlist

    Qt 4 also includes the new \e{Qt Designer} user interface design
    tool. See the \l{qt4-designer.html}{Qt Designer overview} to get
    started.

    In addition, the following modules have been significantly improved
    since Qt 3:

    \list
    \o A fully cross-platform \l{accessibility}
    module, with support for the emerging SP-API Unix standard in
    addition to Microsoft and Mac Accessibility.
    \o The \l{qt4-sql.html}{SQL module}, which is now based on the
    Interview model/view framework.
    \o The \l{qt4-network.html}{network module}, with better support
    for UDP and synchronous sockets.
    \o The \l{qt4-styles.html}{style API}, which is now decoupled from
    the widgets, meaning that you can draw any user interface element on
    any device (widget, pixmap, etc.).
    \o Enhanced \l{qt4-threads.html}{thread support}, with signal-slot
    connections across threads and per-thread event loops.
    \o A new \l{resources.html}{resource system} for embedding images
    and other resource files into the application executable.
    \endlist

    \section1 Build System

    Unlike previous Qt releases, Qt 4 is a collection of smaller
    libraries:

    \table
    \header \o Library          \o Description
    \row    \o \l{QtCore}       \o Core non-GUI functionality
    \row    \o \l{QtGui}        \o Core GUI functionality
    \row    \o \l{QtNetwork}    \o Network module
    \row    \o \l{QtOpenGL}     \o OpenGL module
    \row    \o \l{QtSql}        \o SQL module
    \row    \o \l{QtXml}        \o XML module
    \row    \o \l{Qt3Support}   \o Qt 3 support classes
    \row    \o \l{QAxContainer} \o ActiveQt client extension
    \row    \o \l{QAxServer}    \o ActiveQt server extension
    \row    \o \l{QtMotif}      \o Motif migration extension
    \endlist

    QtCore contains tool classes like QString, QList, and QFile, as
    well as kernel classes like QObject and QTimer. The QApplication
    class has been refactored so that it can be used in non-GUI
    applications. It is split into QCoreApplication (in \l QtCore)
    and QApplication (in \l QtGui).

    This split makes it possible to develop server applications using Qt
    without linking in any unnecessary GUI-related code and without
    requiring GUI-related system libraries to be present on the target
    machine (e.g. Xlib on X11, Carbon on Mac OS X).

    If you use qmake to generate your makefiles, qmake will by default
    link your application against QtCore and QtGui. To remove the
    dependency upon QtGui, add the line

    \code
        QT -= gui
    \endcode

    to your .pro file. To enable the other libraries, add the line

    \code
        QT += network opengl sql qt3support
    \endcode

    Another change to the build system is that moc now understands
    preprocessor directives. qmake automatically passes the defines set
    for your project (using "DEFINES +=") on to moc, which has its own
    built-in C++ preprocessor.

    To compile code that uses .ui files, you will also need this line in
    the .pro file:

    \code
        CONFIG += uic3
    \endcode

    \section1 Include Syntax

    The syntax for including Qt class definitions has become

    \code
        #include <QClassName>
    \endcode

    For example:

    \code
        #include <QString>
        #include <QApplication>
        #include <QSqlTableModel>
    \endcode

    This is guaranteed to work for any public Qt class. The old syntax,

    \code
        #include <qclassname.h>
    \endcode

    still works, but we encourage you to switch to the new syntax.

    If you attempt to include a header file from a library that isn't
    linked against the application, this will result in a
    compile-time warning (e.g., "QSqlQuery: No such file or
    directory"). You can remedy to this problem either by removing
    the offending include or by specifying the missing library in the
    QT entry of your \c .pro file (see \l{Build System} above).

    To include the definitions for all the classes in a library, simply
    specify the name of that library. For example:

    \code
        #include <QtCore>
    \endcode

    \section1 Namespaces

    Qt 2 introduced a class called Qt for global-like constants
    (e.g., \c{Qt::yellow}). The C++ namespace construct was not used
    because not all compilers understood it when it was released.

    With Qt 4, the Qt class has become the Qt namespace. If you want
    to access a constant that is part of the Qt namespace, prefix it
    with \c Qt:: (e.g., \c{Qt::yellow}), or add the directive

    \code
        using namespace Qt;
    \endcode

    at the top of your source files, after your \c #include
    directives. If you use the \c{using namespace} syntax you don't
    need the prefix (e.g., \c yellow is sufficient).

    When porting Qt 3 applications, you may run into some source
    compatibility problems with some of these symbols. For example,
    in Qt 3, it was legal to write \c QWidget::yellow instead of \c
    Qt::yellow, because QWidget inherited from Qt. This won't work in
    Qt 4; you must write \c Qt::yellow or add the "using namespace"
    directive and drop the \c Qt:: prefix.

    The \l{qt3to4.html}{qt3to4 porting tool} automates this conversion.

    \section1 QObject/QWidget Constructors

    In Qt 4 we have tried to simplify the constructors of QObject/QWidget
    subclasses. This makes subclassing easier, at the same time as it
    helps make the Qt library more efficient.

    Constructors no longer take a "const char *name" parameter. If
    you want to specify a name for a QObject, you must call
    QObject::setObjectName() after construction. The object name is
    now a QString.

    QWidget's \c WFlags data type has been split in two:
    Qt::WindowFlags specifies low-level window flags (the type of
    window and the frame style), whereas Qt::WidgetAttribute
    specifies various higher-level attributes about the widget (e.g.,
    WA_StaticContents). Widget attributes can be set at any time
    using QWidget::setAttribute(); low-level window flags can be
    passed to the QWidget constructor or set later using
    QWidget::setParent(). As a consequence, the constructors of most
    QWidget subclasses don't need to provide a \c WFlags parameter.

    The \e parent parameter of all QObject classes in Qt defaults to a
    null pointer, as it used to do in Qt 1. This enables a style of
    programming where widgets are created without parents and then
    inserted in a layout, at which point the layout automatically
    reparents them.

    \section1 Dynamic Casts

    Qt 4 provides a qobject_cast<>() function that performs a dynamic cast
    based on the meta-information generated by moc for QObject
    subclasses. Unlike the standard C++ dynamic_cast<>() construct,
    qobject_cast<>() works even when RTTI is disabled, and it works correctly
    across DLL boundaries.

    Here's the Qt 3 idiom to cast a type to a subtype:

    \code
        // DEPRECATED
        if (obj->inherits("QPushButton")) {
            QPushButton *pushButton = (QPushButton *)obj;
            ...
        }
    \endcode

    The Qt 4 idiom is both cleaner and safer, because typos will always
    result in compiler errors:

    \code
        QPushButton *pushButton = qobject_cast<QPushButton *>(obj);
        if (pushButton) {
            ...
        }
    \endcode

    \section1 QPointer<T>

    The QPointer<T> class provides a pointer to type T (where T inherits
    from QObject) that is automatically set to 0 when the referenced
    object is destroyed. Guarded pointers are useful whenever you want to
    store a pointer to an object you do not own.

    Example:

    \code
        QLabel *label = new QLabel;
        QPointer<QLabel> safeLabel = label;
        safeLabel->setText("Hello world!");
        delete label;
        // safeLabel is now 0, whereas label is a dangling pointer
    \endcode

    QPointer<T> is more or less the same as the old QGuardedPtr<T> class,
    except that it is now implemented in a much more lightweight manner
    than before. The cost of one QPointer<T> object is now approximately
    the same as that of a signal--slot connection.

    \section1 Paint Events

    Qt 4 supports double buffering transparently on all platforms. This
    feature can be turned off on a per-widget basis by calling
    QWidget::setAttribute(Qt::WA_PaintOnScreen).

    A consequence of this is that all painting must now be done from the
    paintEvent() function. This is also required by the HIView API on Mac
    OS X. In practice, this is seldom a problem, since you can call
    update() from anywhere in your code to create a paint event, with the
    region to update as the argument.

    To help porting, QWidget supports a Qt::WA_PaintOutsidePaintEvent
    attribute that can be set to make it possible to paint outside
    \l{QWidget::paintEvent()}{paintEvent()} on Windows, X11, and
    Qt/Embedded.

    \section1 Qt 3 Support Layer

    Qt 4 provides an extension library that applications based on Qt 3
    can link against. This allows for more compatibility than ever
    before, without bloating Qt.

    \list
    \o  Classes that have been replaced by a different class with the
        same name, such as QListView, and classes that no longer exist in Qt 4
        are available with a \c 3 in their name (e.g., Q3ListView, Q3Accel).

    \o  Other classes provide compatibility functions. Most of these are
        implemented inline, so that they don't bloat the Qt libraries.
    \endlist

    To enable the Qt 3 support classes and functions, add the line

    \code
        QT += qt3support
    \endcode

    to your \c .pro file.

    On Visual C++ 7 and GCC 3.2+, using compatibility functions often results
    in a compiler warning (e.g., "'find' is deprecated"). If you want to turn
    off that warning, add the line

    \code
        DEFINES += QT3_SUPPORT
    \endcode

    to your \c .pro file.

    If you want to use compatibility functions but don't want to link
    against the Qt3Support library, add the line

    \code
        DEFINES += QT3_SUPPORT_WARNINGS
    \endcode

    or

    \code
        DEFINES += QT3_SUPPORT
    \endcode

    to your \c .pro file, depending on whether you want compatibility
    function calls to generate compiler warnings or not.

    \section1 Supported Platforms

    See
    \l{http://www.trolltech.com/products/qt/qt4-platforms.html}{Trolltech's
    web site} for more information on the planned supported platforms
    for Qt 4.0.
*/
