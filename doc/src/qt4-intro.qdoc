/*!
    \page qt4-intro.html
    \title What's New in Qt 4

    \startpage index.html Qt Reference Documentation
    \nextpage The Tulip Container Classes

    This document covers the most important differences between Qt 3
    and Qt 4. Although it is not intended to be a comprehensive
    porting guide, it tells you about the most important portability
    issues that you may encounter. It also explains how to turn on Qt
    3 compatibility support.

    \tableofcontents

    \section1 New Technologies in Qt 4

    Qt 4 introduces the following core technologies:

    \list
    \o \l{The Tulip Container Classes}{Tulip}, a new set of template container classes.

    \o \l{The Interview Framework}{Interview}, a model/view architecture for item views.

    \o \l{The Arthur Paint System}{Arthur}, the Qt 4 painting framework.

    \o \l{The Scribe Classes}{Scribe}, the Unicode text renderer with a public API
    for performing low-level text layout.

    \o \l{The Qt 4 Main Window Classes}{Mainwindow}, a modern action-based
    mainwindow, toolbar, menu, and docking architecture.

    \o The new \l{The New Qt Designer}{\QD} user interface design tool.
    \endlist

    \section1 Recent Additions to Qt 4

    The following features have been added to Qt since the first release of Qt 4:

    In Qt 4.2:
    \list
    \o The \l{Graphics View} framework for producing interactive graphics.
    \o \l{Desktop Integration}{Desktop integration} facilities for applications.
    \o \l{Qt Style Sheets} enable easy, yet powerful customization of
    user interfaces.
    \o Support for the \l{D-Bus} Inter-Process Communication (IPC) and Remote
    Procedure Calling (RPC) mechanism.
    \o An \l{Undo Framework}{Undo framework} based on the
    \l{Books about GUI Design#Design Patterns}{Command pattern}.
    \o Support for model-based \l{QCompleter}{text completion} in standard and
    custom widgets.
    \o New widgets and GUI features, such as QCalendarWidget and
    QGLFramebufferObject.
    \o Classes to provide higher level application infrastructure, such as
    QFileSystemWatcher and QDataWidgetMapper.
    \endlist

    In Qt 4.1:
    \list
    \o Integrated support for rendering
    \l{The Arthur Paint System#SVG Rendering Support}{Scalable Vector Graphics}
    (SVG) drawings and animations.
    \o Support for
       \l{QWidget#Transparency and Double Buffering}{child widget transparency}
       on all platforms.
    \o A Portable Document Format (PDF) backend for Qt's printing system.
    \o A \l{QTestLib Manual}{unit testing framework} for Qt applications and
       libraries.
    \o Modules for \l{QtDesigner}{extending \QD} and
       \l{QtUiTools}{dynamic user interface building}.
    \o New \l{Proxy Models}{proxy models} to enable view-specific sorting and
       filtering of data displayed using item views.
    \o Support for \l{Installing Qt/Mac}{universal binaries} on Mac OS X.
    \o Additional features for developers using \l{QtOpenGL}{OpenGL}, such as
    support for pixel and sample buffers.
    \o A flexible \l{QSyntaxHighlighter}{syntax highlighting class} based on the
       \l{Scribe} rich text framework.
    \o Support for \l{QNetworkProxy}{network proxy} servers using the SOCKS5
       protocol.
    \o Support for OLE verbs and MIME data handling in \l{ActiveQt}.
    \endlist

    For more information about improvements in the current release, see
    the \l{http://www.trolltech.com/developer/notes/changes/changes-4.1.4/}
    {detailed list of changes}.

    \section1 Significant Improvements

    The following modules have been significantly improved for Qt 4:

    \list
    \o A fully cross-platform \l{accessibility}
    module, with support for the emerging SP-API Unix standard in
    addition to Microsoft and Mac Accessibility.
    \o The \l{qt4-sql.html}{SQL module}, which is now based on the
    Interview model/view framework.
    \o The \l{qt4-network.html}{network module}, with better support
    for UDP and synchronous sockets.
    \o The \l{qt4-styles.html}{style API}, which is now decoupled from
    the widgets, meaning that you can draw any user interface element on
    any device (widget, pixmap, etc.).
    \o Enhanced \l{qt4-threads.html}{thread support}, with signal-slot
    connections across threads and per-thread event loops.
    \o A new \l{resource system} for embedding images
    and other resource files into the application executable.
    \endlist

    \section1 Build System

    Unlike previous Qt releases, Qt 4 is a collection of smaller
    libraries:

    \table
    \header \o Library          \o Description
    \row    \o \l{QtCore}       \o Core non-GUI functionality
    \row    \o \l{QtGui}        \o Core GUI functionality
    \row    \o \l{QtNetwork}    \o Network module
    \row    \o \l{QtOpenGL}     \o OpenGL module
    \row    \o \l{QtSql}        \o SQL module
    \row    \o \l{QtSvg}        \o SVG rendering classes
    \row    \o \l{QtXml}        \o XML module
    \row    \o \l{Qt3Support}   \o Qt 3 support classes
    \row    \o \l{QAxContainer} \o ActiveQt client extension
    \row    \o \l{QAxServer}    \o ActiveQt server extension
    \row    \o \l{QtAssistant}  \o Classes for launching Qt Assistant
    \row    \o \l{QtDesigner}   \o Classes for extending and embedding Qt Designer
    \row    \o \l{QtUiTools}       \o Classes for dynamic GUI generation
    \row    \o \l{QtTest}       \o Tool classes for unit testing
    \endtable

    QtCore contains tool classes like QString, QList, and QFile, as
    well as kernel classes like QObject and QTimer. The QApplication
    class has been refactored so that it can be used in non-GUI
    applications. It is split into QCoreApplication (in \l QtCore)
    and QApplication (in \l QtGui).

    This split makes it possible to develop server applications using Qt
    without linking in any unnecessary GUI-related code and without
    requiring GUI-related system libraries to be present on the target
    machine (e.g. Xlib on X11, Carbon on Mac OS X).

    If you use qmake to generate your makefiles, qmake will by default
    link your application against QtCore and QtGui. To remove the
    dependency upon QtGui, add the line

    \code
        QT -= gui
    \endcode

    to your .pro file. To enable the other libraries, add the line

    \code
        QT += network opengl sql qt3support
    \endcode

    Another change to the build system is that moc now understands
    preprocessor directives. qmake automatically passes the defines set
    for your project (using "DEFINES +=") on to moc, which has its own
    built-in C++ preprocessor.

    To compile code that uses .ui files, you will also need this line in
    the .pro file:

    \code
        CONFIG += uic3
    \endcode

    \section1 Include Syntax

    The syntax for including Qt class definitions has become

    \code
        #include <QClassName>
    \endcode

    For example:

    \code
        #include <QString>
        #include <QApplication>
        #include <QSqlTableModel>
    \endcode

    This is guaranteed to work for any public Qt class. The old syntax,

    \code
        #include <qclassname.h>
    \endcode

    still works, but we encourage you to switch to the new syntax.

    If you attempt to include a header file from a library that isn't
    linked against the application, this will result in a
    compile-time warning (e.g., "QSqlQuery: No such file or
    directory"). You can remedy to this problem either by removing
    the offending include or by specifying the missing library in the
    QT entry of your \c .pro file (see \l{Build System} above).

    To include the definitions for all the classes in a library, simply
    specify the name of that library. For example:

    \code
        #include <QtCore>
    \endcode

    \section1 Namespaces

    Qt 2 introduced a class called Qt for global-like constants
    (e.g., \c{Qt::yellow}). The C++ namespace construct was not used
    because not all compilers understood it when it was released.

    With Qt 4, the Qt class has become the Qt namespace. If you want
    to access a constant that is part of the Qt namespace, prefix it
    with \c Qt:: (e.g., \c{Qt::yellow}), or add the directive

    \code
        using namespace Qt;
    \endcode

    at the top of your source files, after your \c #include
    directives. If you use the \c{using namespace} syntax you don't
    need the prefix (e.g., \c yellow is sufficient).

    When porting Qt 3 applications, you may run into some source
    compatibility problems with some of these symbols. For example,
    in Qt 3, it was legal to write \c QWidget::yellow instead of \c
    Qt::yellow, because QWidget inherited from Qt. This won't work in
    Qt 4; you must write \c Qt::yellow or add the "using namespace"
    directive and drop the \c Qt:: prefix.

    The \l qt3to4.html porting tool automates this conversion.

    \section1 QObject/QWidget Constructors

    In Qt 4 we have tried to simplify the constructors of QObject/QWidget
    subclasses. This makes subclassing easier, at the same time as it
    helps make the Qt library more efficient.

    Constructors no longer take a "const char *name" parameter. If
    you want to specify a name for a QObject, you must call
    QObject::setObjectName() after construction. The object name is
    now a QString. The reasons for this change are:

    \list
    \o  Code that used it looked confusing, for example:

        \code
        QLabel *label1 = new QLabel("Hello", this);
        QLabel *label2 = new QLabel(this, "Hello");
        \endcode

        \c label1 is a QLabel that displays the text "Hello"; \c
        label2 is a QLabel with no text, with the object name
        "Hello".

    \o  From surveys we did, most users didn't use the name, although
        they blindly followed Qt's convention and provided a "const
        char *name" in their subclasses's constructors. For example:

        \code
        MyWidget::MyWidget(QWidget *parent, const char *name)
            : QWidget(parent, name)
        {
            ...
        }
        \endcode

    \o  The name parameter was in Qt since version 1, and it always
        was documented as: "It is not very useful in the current
        version of Qt, but it will become increasingly important in
        the future." Ten years later, it still hasn't fulfilled its
        promise.
    \endlist

    QWidget's \c WFlags data type has been split in two:
    Qt::WindowFlags specifies low-level window flags (the type of
    window and the frame style), whereas Qt::WidgetAttribute
    specifies various higher-level attributes about the widget (e.g.,
    WA_StaticContents). Widget attributes can be set at any time
    using QWidget::setAttribute(); low-level window flags can be
    passed to the QWidget constructor or set later using
    QWidget::setParent(). As a consequence, the constructors of most
    QWidget subclasses don't need to provide a \c WFlags parameter.

    The \e parent parameter of all QObject classes in Qt defaults to
    a 0 pointer, as it used to do in Qt 1. This enables a style of
    programming where widgets are created without parents and then
    inserted in a layout, at which point the layout automatically
    reparents them.

    \section1 Dynamic Casts

    Qt 4 provides a qobject_cast<>() function that performs a dynamic cast
    based on the meta-information generated by moc for QObject
    subclasses. Unlike the standard C++ dynamic_cast<>() construct,
    qobject_cast<>() works even when RTTI is disabled, and it works correctly
    across DLL boundaries.

    Here's the Qt 3 idiom to cast a type to a subtype:

    \code
        // DEPRECATED
        if (obj->inherits("QPushButton")) {
            QPushButton *pushButton = (QPushButton *)obj;
            ...
        }
    \endcode

    The Qt 4 idiom is both cleaner and safer, because typos will always
    result in compiler errors:

    \code
        QPushButton *pushButton = qobject_cast<QPushButton *>(obj);
        if (pushButton) {
            ...
        }
    \endcode

    \section1 QPointer<T>

    The QPointer<T> class provides a pointer to type T (where T inherits
    from QObject) that is automatically set to 0 when the referenced
    object is destroyed. Guarded pointers are useful whenever you want to
    store a pointer to an object you do not own.

    Example:

    \code
        QLabel *label = new QLabel;
        QPointer<QLabel> safeLabel = label;
        safeLabel->setText("Hello world!");
        delete label;
        // safeLabel is now 0, whereas label is a dangling pointer
    \endcode

    QPointer<T> is more or less the same as the old QGuardedPtr<T> class,
    except that it is now implemented in a much more lightweight manner
    than before. The cost of one QPointer<T> object is now approximately
    the same as that of a signal--slot connection.

    \section1 Paint Events

    Qt 4 supports double buffering transparently on all platforms. This
    feature can be turned off on a per-widget basis by calling
    QWidget::setAttribute(Qt::WA_PaintOnScreen).

    A consequence of this is that all painting must now be done from the
    paintEvent() function. This is also required by the HIView API on Mac
    OS X. In practice, this is seldom a problem, since you can call
    update() from anywhere in your code to create a paint event, with the
    region to update as the argument.

    To help porting, QWidget supports a Qt::WA_PaintOutsidePaintEvent
    attribute that can be set to make it possible to paint outside
    \l{QWidget::paintEvent()}{paintEvent()} on Windows and X11.

    \section1 Qt 3 Support Layer

    Qt 4 provides an extension library that applications based on Qt 3,
    called Qt3Support, that Qt applications can link against. This allows
    for more compatibility than ever before, without bloating Qt.

    \list
    \o  Classes that have been replaced by a different class with the
        same name, such as QListView, and classes that no longer exist in Qt 4
        are available with a \c 3 in their name (e.g., Q3ListView, Q3Accel).

    \o  Other classes provide compatibility functions. Most of these are
        implemented inline, so that they don't bloat the Qt libraries.
    \endlist

    To enable the Qt 3 support classes and functions, add the line

    \code
        QT += qt3support
    \endcode

    to your \c .pro file.

    On Visual C++ 7 and GCC 3.2+, using compatibility functions often results
    in a compiler warning (e.g., "'find' is deprecated"). If you want to turn
    off that warning, add the line

    \code
        DEFINES += QT3_SUPPORT
    \endcode

    to your \c .pro file.

    If you want to use compatibility functions but don't want to link
    against the Qt3Support library, add the line

    \code
        DEFINES += QT3_SUPPORT_WARNINGS
    \endcode

    or

    \code
        DEFINES += QT3_SUPPORT
    \endcode

    to your \c .pro file, depending on whether you want compatibility
    function calls to generate compiler warnings or not.
*/

/*
  \page qt4.3-intro.html
  \title What's New in Qt 4.3

  Qt 4.3 provides many improvements and enhancements over the previous releases
  in the Qt 4 series. This documents covers the most important features in this
  release, separated by category.

  A comprehensive list of changes between Qt 4.2 and Qt 4.3 is included
  in the \c changes-4.3.0 file provided with Qt, and is also
  \l{http://www.trolltech.com/developer/notes/changes/changes-4.3.0}{available
  online}.

  A list of other Qt 4 features can be found on the
  \bold{\l{What's New in Qt 4}} page.

  \bold{Highlights}

  \tableofcontents

  \section1 Graphics View

  Support for interactive graphics is provided by the \l{Graphics View} framework.
  This framework is an enhanced replacement for the Canvas module, previously
  provided with Qt 3, with a refined set of features.

  \image graphicsview-shapes.png

  The framework enables \bold{responsive handling of large numbers of canvas items}
  through the use of a space-partitioning scheme. Support for collision detection,
  coordinate transformations, and item groups make it easier than before to manage
  items for interactive displays.

  \image elasticnodes-example.png

  An \bold{improved API} aims to make common uses easier while making advanced
  uses more accessible to developers.

  \image graphicsview-map.png

  Graphics View's \bold{enhanced presentation system}, takes advantage of Qt 4's
  paint system to render items using anti-aliasing, and taking advantage of OpenGL
  to improve rendering performance. Support for printing is built into the
  framework, making it possible to produce high quality documents from interactive
  applications.

  \image graphicsview-text.png

  A selection of \bold{predefined item types} is provided that contains, amongst
  others, a text item that supports inline editing.

  In addition, various \l{Qt Examples#Graphics View Examples}{graphics view examples}
  have been written to demonstrate key features of the framework, including ports
  of Canvas module examples from Qt 3.


  \section1 Desktop Integration

  This release introduces a set of features that are designed to make it easier
  to write applications that are integrated into users' desktop environments.

  \raw HTML
  <table align="center">
  <tr><td>
  \endraw
  \inlineimage cleanlooks-tabwidget.png
  \raw HTML
  </td><td>
  \endraw
  \inlineimage cleanlooks-treeview.png
  \raw HTML
  </td><td>
  \endraw
  \inlineimage cleanlooks-combobox.png
  \BR
  \inlineimage cleanlooks-timeedit.png
  \BR
  \inlineimage cleanlooks-dateedit.png
  \raw HTML
  </td></tr>
  </table>
  \endraw

  \bold{The \l{QCleanlooksStyle}{Cleanlooks} widget style}, designed to closely
  resemble the Clearlooks style for GTK+ applications, enables Qt applications
  to fit in with non-Qt applications on suitably-configured GNOME desktops.
  See the \l{Cleanlooks Style Widget Gallery} to see how Qt's widgets look
  in this style.

  QDesktopServices provides \bold{cross-platform support for opening and launching
  URLs}, making it possible for applications to launch a web browser, mail
  composer, and other external resources by using the facilities of the user's
  desktop environment.

  To enable \bold{closer integration with the GNOME deskop environment} and tools,
  Qt 4.2 now contains support for the Glib eventloop. This makes it possible
  for Qt applications to use plugins made using other Glib-based frameworks,
  and even enables Qt plugins to be created for use with non-Qt applications.

  \raw HTML
  <div align="center">
  \endraw
  \inlineimage plastique-dialogbuttonbox.png
  \inlineimage cleanlooks-dialogbuttonbox.png
  \raw HTML
  </div>
  \endraw

  The QDialogButtonBox class enables dialogs to be created that use the
  \bold{appropriate button order for the user's chosen desktop environment}.
  This enables dialogs created for KDE and Windows to be reused for Mac OS X
  and GNOME.

  \raw HTML
  <table align="center">
  <tr><td>
  \endraw
  \inlineimage plastique-printdialog.png
  \raw HTML
  </td><td>
  \endraw
  \inlineimage plastique-printdialog-properties.png
  \raw HTML
  </td></tr>
  </table>
  \endraw

  On X11 platforms, \bold{support for the \l{Common Unix Printing System (CUPS)}}
  has been greatly enhanced. Printer settings made available by CUPS can now be
  accessed via QPrintDialog for improved control over the printing process.

  \bold{System tray support} on all desktop platforms is provided by the new
  QSystemTrayIcon class, which exposes a comprehensive set of features via an
  intuitive Qt-style API.


  \section1 Text Completion Framework

  \image completer-example.png

  The new QCompleter class provides a \bold{framework for handling text completion
  in input widgets}. Completion facilities can be set up for use in QLineEdit,
  QComboBox and custom widgets. An \l{tools/completer}{example is included} which
  shows how text completion can be used with a selection of different models and
  data sets.

  \section1 Widget Style Sheets

  \omit
  \image stylesheets-example-detail.png
  \endomit

  \bold{Widgets can be styled using style sheets} that follow a syntax similar to
  that used by Cascading Style Sheets (CSS) for HTML. Many of the more common
  customizations to widget styles can be made using style sheets, making it largely
  unnecessary for developers to create entire custom widget styles with QStyle
  subclasses.

  The style sheet for any given widget can be accessed via its
  \l{QWidget::}{styleSheet} property. Style sheets are fully described in
  the \l{Qt Style Sheets} document.

  \section1 Undo Framework

  \bold{An \l{Undo framework} based on the
  \l{Books about GUI Design#Design Patterns}{Command pattern}} has been introduced
  to help developers provide undo/redo features in applications. The provision of
  an undo framework in Qt means that developers can take advantage of a common,
  well-tested set of classes to improve usability and concentrate on higher-level
  functionality.

  The framework provides support for command compression to improve usability
  when many low-level or similar repetitive commands are used. Command macros
  can also be employed by developers to enable sequences of commands to be
  programatically applied via the framework in single steps.
  Additionally, the concept of a \e{clean state} is supported, enabling
  applications to clear the undo buffer when certain operations are performed,
  such as saving a file.

  \target D-BUS
  \section1 Inter-Process Communication (D-BUS)

  Qt 4.2 provides support for Inter-Process Communication (IPC) using
  the D-BUS protocol. This service-oriented protocol provides fast,
  low latency communication that can be used for same-machine
  communication between applications, yet also allows Remote Procedure
  Calling (RPC) mechanisms to be implemented.

  Using the QtDBus module, an application can provide services to
  other applications by exporting objects, as well as use such
  exported services itself. The QtDBus module also extends Qt's \l
  {Signals and Slots} mechanism, making it possible to connect to
  other applications.

  See the \l{Introduction to D-BUS} document for more information
  about using D-BUS with Qt.

  \section1 New Widgets and GUI Features

  Qt 4.2 also provides a number of new features for graphical user interface
  applications, expanding the range of available widgets while extending overall
  functionality.

  \raw HTML
  <table align="center">
  <tr><td valign="top">
  \endraw
  \inlineimage plastique-fontcombobox.png
  \raw HTML
  </td><td>
  \endraw
  \inlineimage plastique-fontcombobox-open.png
  \raw HTML
  </td></tr>
  </table>
  \endraw

  A \l{QFontComboBox}{specialized font combobox} is now available for use in text
  editing and related applications.

  \image qcalendarwidget-maximum.png

  Facilities for \bold{displaying monthly calendars and date selection} are
  provided by QCalendarWidget, a class adapted from the \l{Calendar Widget}
  Qt Solution.

  The \bold{\l{Main Window and Related Classes}{main window classes} have been
  updated to be more responsive to user activity}. In particular, when a user
  moves a floating dock window over a dock area by the user, any other dock
  windows in that area will automatically make room to allow it to be dropped
  there. These enhancements can be seen in the
  \l{Dock Widgets Example}{Dock Widgets} example.

  \bold{Access to OpenGL framebuffer objects} is provided by the
  QGLFramebufferObject class; this enables textures to be painted with a series
  of calls to QPainter functions in the usual way for QPaintDevice subclasses.

  \bold{Improved support for platform-native message boxes} is provided by
  QMessageBoxEx. This class uses QDialogButtonBox to positioned buttons using
  the appropriate conventions for the user's platform and desktop environment.

  \section1 Extended Infrastructure

  Many improvements have been made to the classes and tools that provide
  underlying functionality in Qt. Many of these changes involve introducing
  higher level functionality that aims to make application development easier
  while providing a more robust working environment for users.

  The QFileSystemWatcher class enables applications to \bold{monitor files and
  directories for changes}. This feature is often used by applications and
  libraries that share access to files with other applications.

  The \l{Model/View Classes}{item view classes} have been optimized for
  performance and reliability, and new classes have been introduced:
  \list
  \o QStandardItem and QStandardItemEditorCreator aim to make the
     QStandardItemModel class easier to use.
  \o \bold{QDataWidgetMapper enables mappings to be made between items in a model
     and selections of widgets} in a user interface, making it possible to design
     data-aware widgets and forms.
  \endlist

  The \bold{HTML import and export facilities have been enhanced} in the
  \l{Rich Text Processing}{rich text classes}, and now include support for
  CSS-like style sheets.

  \bold{A \l{QTimeLine}{time line class} has been introduced for use in widgets
  that provide animations.} By using a mechanism that uses signals and slots to
  notify other application components about changes to a time line, this class
  can also be used for other timing purposes with non-GUI classes.

  The addition of a \bold{Scalable Vector Graphics (SVG) icon engine} enables
  icons to be created from pictures in this vector graphics format. This reduces
  the number of fixed-size images that developers need to include with
  applications, and avoids the need to provide sufficiently high resolution
  images to cover all possible icon sizes.

  Support for \bold{detection and reporting of network interfaces} is provided by
  the QNetworkInterface class.

  Qt's keyboard handling has been improved to support
  \bold{physical key recognition}.
  This allows keyboard shortcuts to be created that specify the keys that users
  see on their keyboard instead of generic logical key assignments.

  QKeySequence now provides \bold{a range of standard shortcuts} that developers
  can use when creating actions. These describe commonly-used high-level actions,
  such as \gui{Undo}, \gui{Copy}, and \gui{Paste}, and enable shortcuts to be
  specified in a true cross-platform way.

  Support for \l{Qt's Property System#Dynamic Properties}{dynamic properties}
  extends the standard Qt property system, enabling
  \bold{new properties to be added to instances of QObject subclasses at run-time}.

  \section1 Qtopia Core

  Many improvements in Qt are specific to Qtopia Core and are concerned with
  graphics support and rendering performance.

  \bold{Direct painting to the screen} can be enabled on by \l{Qtopia
  Core Performance Tuning#Bypassing the Backing Store}{bypassing the
  backing store} on a per-application basis.

  \bold{Support for 18 and 24 bits-per-pixel color depths} has been added to the paint
  system. Color depths that assign 6 bits to each color (or alpha) channel are
  commonly used on mobile devices.

  Alongside many general improvements and optimizations, the \bold{transformed
  screen driver has been optimized} to improve performance when rendering rotated
  content.

  \omit

  \section1 Other Improvements

  Many other enhancements have been made Internally, Other improvements
  Menu handling has been updated to allow widgets to be inserted as menu items.

  Support for widgets in menus.

  * Backing store interface

  * delayed widget creation

  * Linguist improvements

  * Text control (not 100% certain we'll have a public API)
  \endomit
*/
