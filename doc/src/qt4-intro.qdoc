/*!
    \page qt4-intro.html
    \title What's New in Qt 4

    We are pleased to present our second beta release for Qt 4. We
    are releasing this code to our users because we want you to have
    the opportunity to give us your feedback before the Qt 4.0 API is
    completely frozen. The feedback we receive will help us to ensure
    that the final Qt 4.0 release provides as much value and
    productivity as possible. We expect to release the final Qt 4.0
    in Q2, 2005.

    This beta release is not meant to be used in production code.
    However, you can already start using it for new projects. The API
    might change before Qt 4.0 final is released, but only in minor
    ways. You can also start porting your Qt 3 based projects over
    to Qt 4. The \l{porting4.html}{Porting Guide} and the
    \l{qt3to4.html}{qt3to4 porting tool} will help you with the
    process.

    We suggest that you write new small programs to experience what
    the next generation of Qt programming will be like. In
    particular, there are five new technologies that we hope you will
    try out and give us feedback on. All are new to Qt, written
    specifically for Qt 4:

    \list
    \o \link qt4-tulip.html Tulip \endlink, a new set of template container classes.

    \o \link qt4-interview.html Interview \endlink, a model/view architecture for item views.

    \o \link qt4-arthur.html Arthur \endlink, the Qt 4 painting framework.

    \o \link qt4-scribe.html Scribe \endlink, the Unicode text
    renderer with a public API for performing low-level text layout.

    \o \link qt4-mainwindow.html Mainwindow \endlink, a modern
    action-based mainwindow, toolbar, menu, and docking architecture.
    \endlist

    This beta release also previews the new \e{Qt Designer} user
    interface design tool. The tool is still heavily under
    development, but you can already try it out and give us feedback.
    See the \l{qt4-designer.html}{Qt Designer overview} to get
    started.

    In addition, the following modules have been significantly improved
    since Qt 3:

    \list
    \o A fully cross-platform \l{qt4-accessibility.html}{accessibility}
    module, with support for the emerging SP-API Unix standard in
    addition to Microsoft and Mac Accessibility.
    \o The \l{qt4-sql.html}{SQL module}, which is now based on the
    Interview model/view framework.
    \o The \l{qt4-network.html}{network module}, with better support
    for UDP and synchronous sockets.
    \o The \l{qt4-styles.html}{style API}, which is now decoupled from
    the widgets, meaning that you can draw any user interface element on
    any device (widget, pixmap, etc.).
    \o Enhanced \l{qt4-threads.html}{thread support}, with signal-slot
    connections across threads and per-thread event loops.
    \o A new \l{resources.html}{resource system} for embedding images
    and other resource files into the application executable.
    \endlist

    \section1 Supported Platforms

    For this beta release, we have tested the entire range of
    platforms targeted by the final Qt 4.0 release, with three
    exceptions: Windows with Borland C++, HP-UX i, and HP-UX with aCC
    1.x.

    While testing, we found out that we needed to install patches on
    some of the compilers. If you run into problems when compiling,
    make sure to get the most recent upgrades from your compiler
    vendor.

    \section1 How to Provide Feedback

    \input betafeedback.qdocinc

    \section1 Getting Started with Qt 4

    This document covers the most important differences between Qt 3 and
    Qt 4. Although it is not intended to be a comprehensive porting
    guide, it tells you about the most important portability issues that
    you may encounter. It also explains how to turn on Qt 3 compatibility
    support, and provides a brief overview of some Qt 4 features beyond
    the five main technologies in this preview.

    \tableofcontents

    \section2 Build System

    Unlike previous Qt releases, Qt 4 is a collection of smaller
    libraries.

    \list
    \o \bold{QtCore}: core non-GUI functionality
    \o \bold{QtGui}: core GUI functionality
    \o \bold{QtNetwork}: network module
    \o \bold{QtOpenGL}: OpenGL module
    \o \bold{QtSql}: SQL module
    \o \bold{QtXml}: XML module
    \o \bold{Qt3Compat}: Qt 3 compatibility classes (see \l{Qt 3 Compatibility} below)
    \endlist

    QtCore contains tool classes like QString, QList, and QFile, as
    well as kernel classes like QObject and QTimer. A few classes
    have been refactored so that they can be used in non-GUI
    applications:

    \list
    \o QApplication is split into QCoreApplication (in QtCore) and
       QApplication (in QtGui).
    \o QVariant is split into QCoreVariant and QVariant.
    \endlist

    This split makes it possible to develop server applications using Qt
    without linking in any unnecessary GUI-related code and without
    requiring GUI-related system libraries to be present on the target
    machine (e.g. Xlib on X11, Carbon on Mac OS X).

    If you use qmake to generate your makefiles, qmake will by default
    link your application against QtCore and QtGui. To remove the
    dependency upon QtGui, add the line

    \code
        QT -= gui
    \endcode

    to your .pro file. To enable the other libraries, add the line

    \code
        QT += network opengl sql compat
    \endcode

    Another change to the build system is that moc now understands
    preprocessor directives. qmake automatically passes the defines set
    for your project (using "DEFINES +=") on to moc, which has its own
    built-in C++ preprocessor.

    To compile code that uses .ui files, you will also need this line in
    the .pro file:

    \code
        CONFIG += uic3
    \endcode

    \section2 Include Syntax

    The syntax for including Qt class definitions has become

    \code
        #include <QClassName>
    \endcode

    For example:

    \code
        #include <QString>
        #include <QApplication>
        #include <QSqlTableModel>
    \endcode

    This is guaranteed to work for any public Qt class. The old syntax,

    \code
        #include <qclassname.h>
    \endcode

    still works, but we encourage you to switch to the new syntax.

    If you attempt to include a header file from a library that isn't
    linked against the application, this will result in a
    compile-time warning (e.g., "QSqlQuery: No such file or
    directory"). You can remedy to this problem either by removing
    the offending include or by specifying the missing library in the
    QT entry of your \c .pro file (see \l{Build System} above).

    To include the definitions for all the classes in a library, simply
    specify the name of that library. For example:

    \code
        #include <QtCore>
    \endcode

    \section2 Namespaces

    Qt 2 introduced a class called Qt for global-like constants
    (e.g., \c{Qt::yellow}). The C++ namespace construct was not used
    because not all compilers understood it when it was released.

    With Qt 4, the Qt class has become the Qt namespace. If you want
    to access a constant that is part of the Qt namespace, prefix it
    with \c Qt:: (e.g., \c{Qt::yellow}), or add the directive

    \code
        using namespace Qt;
    \endcode

    at the top of your source files, after your \c #include
    directives. If you use the "using namespace" syntax you don't
    need the prefix (e.g., yellow is sufficient).

    When porting Qt 3 applications, you may run into some source
    compatibility problems with some of these symbols. For example,
    in Qt 3, it was legal to write \c QWidget::yellow instead of \c
    Qt::yellow, because QWidget inherited from Qt. This won't work in
    Qt 4; you must write \c Qt::yellow or add the "using namespace"
    directive and drop the \c Qt:: prefix.

    The \l{qt3to4.html}{qt3to4 porting tool} automates this conversion.

    \section2 QObject/QWidget Constructors

    In Qt 4 we have tried to simplify the constructors of QObject/QWidget
    subclasses. This makes subclassing easier, at the same time as it
    helps make the Qt library more efficient.

    Constructors no longer take a "const char *name" parameter. If
    you want to specify a name for a QObject, you must call
    QObject::setObjectName() after construction. The object name is
    now a QString.

    QWidget's WFlags data type has been split in two: Qt::WFlags
    specifies low-level window flags (the type of window and the
    frame style), whereas Qt::WidgetAttribute specifies various
    higher-level attributes about the widget (e.g.,
    WA_StaticContents). Widget attributes can be set at any time
    using QWidget::setAttribute(); low-level window flags can be
    passed to the QWidget constructor or set later using
    QWidget::setParent(). As a consequence, the constructors of most
    QWidget subclasses don't need to provide a WFlags parameter.

    The \e parent parameter of all QObject classes in Qt defaults to a
    null pointer, as it used to do in Qt 1. This enables a style of
    programming where widgets are created without parents and then
    inserted in a layout, at which point the layout automatically
    reparents them.

    \section2 Dynamic Casts

    Qt 4 provides a qt_cast<>() function that performs a dynamic cast
    based on the meta-information generated by moc for QObject
    subclasses. Unlike the standard C++ dynamic_cast<>() construct,
    qt_cast<>() works even when RTTI is disabled, and it works correctly
    across DLL boundaries.

    Here's the Qt 3 idiom to cast a type to a subtype:

    \code
        // DEPRECATED
        if (obj->inherits("QPushButton")) {
            QPushButton *pushButton = (QPushButton *)obj;
            ...
        }
    \endcode

    The Qt 4 idiom is both cleaner and safer, because typos will always
    result in compiler errors:

    \code
        QPushButton *pushButton = qt_cast<QPushButton *>(obj);
        if (pushButton) {
            ...
        }
    \endcode

    \section2 QPointer<T>

    The QPointer<T> class provides a pointer to type T (where T inherits
    from QObject) that is automatically set to 0 when the referenced
    object is destroyed. Guarded pointers are useful whenever you want to
    store a pointer to an object you do not own.

    Example:

    \code
        QLabel *label = new QLabel;
        QPointer<QLabel> safeLabel = label;
        safeLabel->setText("Hello world!");
        delete label;
        // safeLabel is now 0, whereas label is a dangling pointer
    \endcode

    QPointer<T> is more or less the same as the old QGuardedPtr<T> class,
    except that it is now implemented in a much more lightweight manner
    than before. The cost of one QPointer<T> object is now approximately
    the same as that of a signal--slot connection.

    \section2 Paint Events

    Qt 4 supports double buffering transparently on all platforms. This
    feature can be turned off on a per-widget basis by calling
    QWidget::setAttribute(Qt::WA_PaintOnScreen).

    A consequence of this is that all painting must now be done from the
    paintEvent() function. This is also required by the HIView API on Mac
    OS X. In practice, this is seldom a problem, since you can call
    update() from anywhere in your code to create a paint event, with the
    region to update as the argument.

    To help porting, QWidget supports a Qt::WA_PaintOutsidePaintEvent
    attribute that can be set to make it possible to paint outside
    \l{QWidget::paintEvent()}{paintEvent()} on Windows, X11, and
    Qt/Embedded.

    \section2 Qt 3 Compatibility

    Qt 4 provides an extension library that applications based on Qt 3
    can link against. This allows for more compatibility than ever
    before, without bloating Qt.

    \list
    \o  Classes that have been replaced by a different class with the
        same name, such as QListView, and classes that no longer exist in Qt 4
        are available with a \c 3 in their name (e.g., Q3ListView, Q3Accel).

    \o  Other classes provide compatibility functions. Most of these are
        implemented inline, so that they don't bloat the Qt libraries.
    \endlist

    To enable the compatibility classes and functions, add the line

    \code
        QT += compat
    \endcode

    to your \c .pro file.

    On Visual C++ 7 and GCC 3.2+, using compatibility function results in
    a compiler warning (e.g., "'find' is deprecated"). If you want to turn
    off that warning, add the line

    \code
        DEFINES += QT_COMPAT
    \endcode

    to your \c .pro file.

    If you want to use compatibility functions but don't want to link
    against the compatibility library, add the line

    \code
        DEFINES += QT_COMPAT_WARNINGS
    \endcode

    or

    \code
        DEFINES += QT_COMPAT
    \endcode

    to your \c .pro file, depending on whether you want compatibility
    function calls to generate compiler warnings or not.
*/
