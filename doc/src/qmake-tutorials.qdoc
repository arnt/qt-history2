/*!
    \page qmake-tutorial.html
    \title qmake Tutorial

    This tutorial teaches you how to use \c qmake.  We recommend that
    you read the \c qmake user guide after completing this tutorial.

    \section1 Starting off Simple

    Let's assume that you have just finished a basic implementation of
    your application, and you have created the following files:

    \list
    \i hello.cpp
    \i hello.h
    \i main.cpp
    \endlist

    You will find these files in \c {qt/qmake/examples/tutorial}.  The
    only other thing you know about the setup of the application is that
    it's written in Qt.  First, using your favorite plain text editor,
    create a file called \c hello.pro in \c {qt/qmake/tutorial}.  The
    first thing you need to do is add the lines that tell \c qmake about
    the source and header files that are part of your development project.  

    We'll add the source files to the project file first.  To do this you
    need to use the SOURCES variable.  Just start a new line with \c
    {SOURCES +=} and put hello.cpp after it.  You should have something
    like:

    \code
        SOURCES += hello.cpp
    \endcode

    We repeat this for each source file in the project, until we end up
    with:

    \code
        SOURCES += hello.cpp
        SOURCES += main.cpp
    \endcode

    If you prefer to use a Make-like syntax, with all the files listed in
    one go you can use the newline escaping like this:

    \code
        SOURCES = hello.cpp \
                  main.cpp
    \endcode

    Now that the source files are listed in the project file, the header
    files must be added. These are added in exactly the same way as source
    files, except that the variable name is HEADERS:

    Once you have done this, your project file should look something like
    this:

    \code
        HEADERS += hello.h
        SOURCES += hello.cpp 
        SOURCES += main.cpp 
    \endcode

    The target name is set automatically; it is the same as the project
    file, but with the suffix appropriate to the platform. For example, if
    the project file is called \c hello.pro, the target will be \c hello.exe
    on Windows and \c hello on Unix. If you want to use a different name
    you can set it in the project file:

    \code
        TARGET = helloworld
    \endcode

    The final step is to set the \c CONFIG variable. Since this is a Qt
    application, we need to put \c qt on the CONFIG line so that \c qmake
    will add the relevant libraries to be linked against and ensure that
    build lines for \c moc and \c uic are included in the makefile.

    The finished project file should look like this:

    \code
        CONFIG += qt
        HEADERS += hello.h
        SOURCES += hello.cpp
        SOURCES += main.cpp 
    \endcode

    You can now use \c qmake to generate a makefile for your application.
    On the command line, in your application directory, type:

    \code
        qmake -o Makefile hello.pro
    \endcode

    Then type \c make or \c nmake depending on the compiler you use.  

    \section1 Making an Application Debuggable

    The release version of an application doesn't contain any debugging
    symbols or other debuggin information. During development it is useful
    to produce a debugging version of the application that has the
    relevant information. This is easily achieved by adding \c debug to the
    CONFIG variable in the project file.

    For example:

    \code
        CONFIG += qt debug
        HEADERS += hello.h
        SOURCES += hello.cpp
        SOURCES += main.cpp 
    \endcode

    Use \c qmake as before to generate a makefile and you will be able to
    debug your application.

    \section1 Adding Platform-Specific Source Files

    After a few hours of coding, you might have made a start on the
    platform specific part of your application, and decided to keep the
    platform dependent code separate.  So you now have two new files to
    include into your project file - \c hellowin.cpp and \c
    hellounix.cpp.  We can't just add these to the \c SOURCES
    variable since this will put both files in the makefile.  So what we
    need to do here is to use a scope which will be processed depending on
    which platform \c qmake is run on.

    A simple scope which will add in the platform dependent file for
    Windows looks like this:

    \code
        win32 {
            SOURCES += hellowin.cpp
        }
    \endcode

    So if \c qmake is run on Windows, it will add \c hellowin.cpp to the
    list of source files.  If \c qmake is run on any other platform, it
    will simply ignore it.  Now all that is left to be done is to create a
    scope for the unix dependent file.

    When you have done that, your project file should now look
    something like this:

    \code
        CONFIG += qt debug
        HEADERS += hello.h
        SOURCES += hello.cpp
        SOURCES += main.cpp 
        win32 {
            SOURCES += hellowin.cpp
        }
        unix {
            SOURCES += hellounix.cpp
        }
    \endcode

    Use \c qmake as before to generate a makefile.  

    \section1 Stopping qmake If a File Doesn't Exist

    You may not want to create a makefile if a certain file doesn't exist.
    We can check if a file exists by using the exists() function.  We can
    stop \c qmake from processing by using the error() function.  This
    works in the same way as scopes.  Simply replace the scope condition
    with the function. A check for a main.cpp file looks like this:

    \code
        !exists( main.cpp ) {
            error( "No main.cpp file found" )
        }
    \endcode

    The "!" is used to negate the test, i.e. \c{exists( main.cpp )} is
    true if the file exists and \c{!exists( main.cpp )} is true if the
    file doesn't exist.

    \code
        CONFIG += qt debug
        HEADERS += hello.h
        SOURCES += hello.cpp
        SOURCES += main.cpp 
        win32 {
            SOURCES += hellowin.cpp
        }
        unix {
            SOURCES += hellounix.cpp
        }
        !exists( main.cpp ) {
            error( "No main.cpp file found" )
        }
    \endcode

    Use \c qmake as before to generate a makefile.  If you rename \c
    main.cpp temporarily, you will see the message and \c qmake will stop
    processing.

    \section1 Checking for More than One Condition

    Suppose you use Windows and you want to be able to see the qDebug()
    statements when you run your application on the command line.  Unless
    you build your application with the console setting, you won't see the
    output.  We can easily put \c console on the CONFIG line so that on
    Windows the makefile will have this setting.  But let's say that we
    only want to add the CONFIG line if we are running on Windows \c and when
    \c debug is already on the CONFIG line.  This requires using two
    nested scopes; just create one scope, then create the other inside
    that one.  Put the settings to be processed inside the last scope,
    like this:

    \code
        win32 {
            debug {
                CONFIG += console
            }
        }
    \endcode

    Nested scopes can be joined together using colons, so the final
    project file looks like this:

    \code
        CONFIG += qt debug
        HEADERS += hello.h
        SOURCES += hello.cpp
        SOURCES += main.cpp 
        win32 {
            SOURCES += hellowin.cpp
        }
        unix {
            SOURCES += hellounix.cpp
        }
        !exists( main.cpp ) {
            error( "No main.cpp file found" )
        }
        win32:debug {
            CONFIG += console
        }
    \endcode


    That's it!  You have now completed the tutorial for \c qmake, and are
    ready to write project files for your development projects.
*/

/*!
    \page qmake-quickguide.html
    \title The Ten-Minute Guide to Using qmake

    \section1 Creating a Project File

    \c qmake uses information stored in project (.pro) files to determine
    what should go in the makefiles it generates.

    A basic project file contains information about the application. It
    declares the resources that are required to build the application,
    such as the files used to compile the application, any user interface
    descriptions, and which configuration settings to use.

    Here's a simple example project file:

    \code
        SOURCES = hello.cpp
        HEADERS = hello.h
        CONFIG += qt warn_on release
    \endcode

    We'll provide a brief line-by-line explanation, deferring the detail
    until later on in the manual.

    \code
        SOURCES = hello.cpp
    \endcode

    This line specifies the source files that implement the application. In this
    case there is just one file, \c hello.cpp. Most applications require
    multiple files; this situation is dealt with by listing all the files
    on the same line space separated, like this:

    \code
        SOURCES = hello.cpp main.cpp
    \endcode

    Alternatively, each file can be listed on a separate line, by escaping
    the newlines, like this:

    \code
        SOURCES = hello.cpp \
                  main.cpp
    \endcode

    A more verbose approach is to list each file separately, like this:

    \code
        SOURCES += hello.cpp
        SOURCES += main.cpp
    \endcode

    This approach uses "+=" rather than "=" which is safer, because it
    always adds a new file to the existing list rather than replacing the
    list.

    The HEADERS line is used to specify the header files created for use
    by the application, e.g. 

    \code 
        HEADERS += hello.h
    \endcode

    Any of the approaches used to list source files may be used for header
    files.

    The CONFIG line is used to give \c qmake information about the
    application's configuration.

    \code 
        CONFIG += qt warn_on release
    \endcode

    The "+=" is used here, because we add our configuration options to any
    that are already present. This is safer than using "=" which replaces
    all options with just those specified.

    The \c qt part of the CONFIG line tells \c qmake that the application
    is built using Qt.  This means that \c qmake will link against the Qt
    libraries when linking and add in the neccesary include paths for
    compiling.

    The \c warn_on part of the CONFIG line tells \c qmake that it should
    set the compiler flags so that warnings are output.

    The \c release part of the CONFIG line tells \c qmake that the
    application must be built as a release application. During
    development, programmers may prefer to replace \c release with \c
    debug, which is discussed later.

    \omit
    The last line in the project file is the TARGET line:

    \code
        TARGET = hello
    \endcode

    The target line simply specifies what the name of the target should be
    for the application.  You shouldn't put an extension here because \c
    qmake will do this for you.
    \endomit

    Project files are plain text (i.e. use an editor like notepad, vim
    or xemacs) and must be saved with a \c .pro extension. The name of the
    application's executable will be the same as the project file's name,
    but with an extension appropriate to the platform. For example, a
    project file called \c hello.pro will produce \c hello.exe on Windows
    and \c hello on Unix.

    \section1 Generating a Makefile

    When you have created your project file it is very easy to generate a
    makefile, all you need to do is go to where you have created your
    project file and type:

    Makefiles are generated from the \c .pro files like this:

    \code
        qmake -o Makefile hello.pro 
    \endcode

    For Visual Studio users, \c qmake can also generate \c .dsp files, for
    example:

    \code
        qmake -t vcapp -o hello.dsp hello.pro
    \endcode
*/

/*!
    \page qmake-common-projects.html

    \title Common Projects

    \section1 

    \section2 The \c app Template

    The \c app template tells \c qmake to generate a Makefile that will build
    an application. With this template, the type of application can be specified
    by adding one of the following options to the \c CONFIG variable definition:

    \table
    \header \i Option  \i Description
    \row    \i windows \i The application is a Windows GUI application.
    \row    \i console \i \c app template only: the application is a Windows console
                       application.
    \endtable

    When using this template the following \c qmake system variables are recognized.
    You should use these in your .pro file to specify information about your
    application.

    \list
    \i HEADERS - A list of all the header files for the application.
    \i SOURCES - A list of all the source files for the application.
    \i FORMS - A list of all the .ui files (created using \c{Qt Designer})
    for the application.
    \i LEXSOURCES - A list of all the lex source files for the application.
    \i YACCSOURCES - A list of all the yacc source files for the application.
    \i TARGET - Name of the executable for the application. This defaults
    to the name of the project file. (The extension, if any, is added
    automatically).
    \i DESTDIR - The directory in which the target executable is placed.
    \i DEFINES - A list of any additional pre-processor defines needed for the application.
    \i INCLUDEPATH - A list of any additional include paths needed for the application.
    \i DEPENDPATH - The dependency search path for the application.
    \i VPATH - The search path to find supplied files. 
    \i DEF_FILE - Windows only: A .def file to be linked against for the application.
    \i RC_FILE - Windows only: A resource file for the application.
    \i RES_FILE - Windows only: A resource file to be linked against for the application.
    \endlist

    You only need to use the system variables that you have values for,
    for instance, if you don't have any extra INCLUDEPATHs then you don't
    need to specify any, \c qmake will add in the default ones needed.
    For instance, an example project file might look like this:

    \code
        TEMPLATE = app
        DESTDIR  = c:\helloapp
        HEADERS += hello.h
        SOURCES += hello.cpp 
        SOURCES += main.cpp
        DEFINES += QT_DLL
        CONFIG  += qt warn_on release
    \endcode

    For items that are single valued, e.g. the template or the destination
    directory, we use "="; but for multi-valued items we use "+=" to \e
    add to the existing items of that type. Using "=" replaces the item's
    value with the new value, for example if we wrote \c{DEFINES=QT_DLL},
    all other definitions would be deleted.

    \section2 The \c lib Template

    The \c lib template tells \c qmake to generate a Makefile that will
    build a library.  When using this template, in addition to the system variables
    mentioned above for the \c app template the \c VERSION variable is
    supported.  You should use these in your .pro file to specify
    information about the library.

    When using the \c lib template, the following options determine the type of
    library that is built:

    \table
    \header \i Option    \i Description
    \row    \i dll       \i The library is a shared library (dll).
    \row    \i staticlib \i The library is a static library.
    \row    \i plugin    \i The library is a plugin; this also enables the dll option.
    \endtable


    \list
    \i VERSION - The version number of the target library, for example, 2.3.1.
    \endlist

    \section2 The \c subdirs Template

    The \c subdirs template tells qmake to generate a Makefile that will go
    into the specified subdirectories and generate a Makefile for the
    project file in the directory and call make on it.

    The only system variable that is recognised for this template is the
    \c SUBDIRS variable.  This variable contains a list of all the
    subdirectories that contain project files to be processed.  It is
    essential that the project file in the sub directory has the same name
    as the subdirectory, so that \c qmake can find it.  For
    example, if the subdirectory is called \c myapp then the project file
    in that directory should be called \c myapp.pro in that directory.
*/
