/*!
    \page qmake-tutorial.html
    \title qmake Tutorial

    This tutorial teaches you how to use \c qmake.  We recommend that
    you read the \c qmake user guide after completing this tutorial.

    \section1 Starting off Simple

    Let's assume that you have just finished a basic implementation of
    your application, and you have created the following files:

    \list
    \i hello.cpp
    \i hello.h
    \i main.cpp
    \endlist

    You will find these files in \c {qt/qmake/examples/tutorial}.  The
    only other thing you know about the setup of the application is that
    it's written in Qt.  First, using your favorite plain text editor,
    create a file called \c hello.pro in \c {qt/qmake/tutorial}.  The
    first thing you need to do is add the lines that tell \c qmake about
    the source and header files that are part of your development project.  

    We'll add the source files to the project file first.  To do this you
    need to use the SOURCES variable.  Just start a new line with \c
    {SOURCES +=} and put hello.cpp after it.  You should have something
    like:

    \code
        SOURCES += hello.cpp
    \endcode

    We repeat this for each source file in the project, until we end up
    with:

    \code
        SOURCES += hello.cpp
        SOURCES += main.cpp
    \endcode

    If you prefer to use a Make-like syntax, with all the files listed in
    one go you can use the newline escaping like this:

    \code
        SOURCES = hello.cpp \
                  main.cpp
    \endcode

    Now that the source files are listed in the project file, the header
    files must be added. These are added in exactly the same way as source
    files, except that the variable name is HEADERS:

    Once you have done this, your project file should look something like
    this:

    \code
        HEADERS += hello.h
        SOURCES += hello.cpp 
        SOURCES += main.cpp 
    \endcode

    The target name is set automatically; it is the same as the project
    file, but with the suffix appropriate to the platform. For example, if
    the project file is called \c hello.pro, the target will be \c hello.exe
    on Windows and \c hello on Unix. If you want to use a different name
    you can set it in the project file:

    \code
        TARGET = helloworld
    \endcode

    The final step is to set the \c CONFIG variable. Since this is a Qt
    application, we need to put \c qt on the CONFIG line so that \c qmake
    will add the relevant libraries to be linked against and ensure that
    build lines for \c moc and \c uic are included in the makefile.

    The finished project file should look like this:

    \code
        CONFIG += qt
        HEADERS += hello.h
        SOURCES += hello.cpp
        SOURCES += main.cpp 
    \endcode

    You can now use \c qmake to generate a makefile for your application.
    On the command line, in your application directory, type:

    \code
        qmake -o Makefile hello.pro
    \endcode

    Then type \c make or \c nmake depending on the compiler you use.  

    \section1 Making an Application Debuggable

    The release version of an application doesn't contain any debugging
    symbols or other debuggin information. During development it is useful
    to produce a debugging version of the application that has the
    relevant information. This is easily achieved by adding \c debug to the
    CONFIG variable in the project file.

    For example:

    \code
        CONFIG += qt debug
        HEADERS += hello.h
        SOURCES += hello.cpp
        SOURCES += main.cpp 
    \endcode

    Use \c qmake as before to generate a makefile and you will be able to
    debug your application.

    \section1 Adding Platform-Specific Source Files

    After a few hours of coding, you might have made a start on the
    platform specific part of your application, and decided to keep the
    platform dependent code separate.  So you now have two new files to
    include into your project file - \c hellowin.cpp and \c
    hellounix.cpp.  We can't just add these to the \c SOURCES
    variable since this will put both files in the makefile.  So what we
    need to do here is to use a scope which will be processed depending on
    which platform \c qmake is run on.

    A simple scope which will add in the platform dependent file for
    Windows looks like this:

    \code
        win32 {
            SOURCES += hellowin.cpp
        }
    \endcode

    So if \c qmake is run on Windows, it will add \c hellowin.cpp to the
    list of source files.  If \c qmake is run on any other platform, it
    will simply ignore it.  Now all that is left to be done is to create a
    scope for the unix dependent file.

    When you have done that, your project file should now look
    something like this:

    \code
        CONFIG += qt debug
        HEADERS += hello.h
        SOURCES += hello.cpp
        SOURCES += main.cpp 
        win32 {
            SOURCES += hellowin.cpp
        }
        unix {
            SOURCES += hellounix.cpp
        }
    \endcode

    Use \c qmake as before to generate a makefile.  

    \section1 Stopping qmake If a File Doesn't Exist

    You may not want to create a makefile if a certain file doesn't exist.
    We can check if a file exists by using the exists() function.  We can
    stop \c qmake from processing by using the error() function.  This
    works in the same way as scopes.  Simply replace the scope condition
    with the function. A check for a main.cpp file looks like this:

    \code
        !exists( main.cpp ) {
            error( "No main.cpp file found" )
        }
    \endcode

    The "!" is used to negate the test, i.e. \c{exists( main.cpp )} is
    true if the file exists and \c{!exists( main.cpp )} is true if the
    file doesn't exist.

    \code
        CONFIG += qt debug
        HEADERS += hello.h
        SOURCES += hello.cpp
        SOURCES += main.cpp 
        win32 {
            SOURCES += hellowin.cpp
        }
        unix {
            SOURCES += hellounix.cpp
        }
        !exists( main.cpp ) {
            error( "No main.cpp file found" )
        }
    \endcode

    Use \c qmake as before to generate a makefile.  If you rename \c
    main.cpp temporarily, you will see the message and \c qmake will stop
    processing.

    \section1 Checking for More than One Condition

    Suppose you use Windows and you want to be able to see the qDebug()
    statements when you run your application on the command line.  Unless
    you build your application with the console setting, you won't see the
    output.  We can easily put \c console on the CONFIG line so that on
    Windows the makefile will have this setting.  But let's say that we
    only want to add the CONFIG line if we are running on Windows \c and when
    \c debug is already on the CONFIG line.  This requires using two
    nested scopes; just create one scope, then create the other inside
    that one.  Put the settings to be processed inside the last scope,
    like this:

    \code
        win32 {
            debug {
                CONFIG += console
            }
        }
    \endcode

    Nested scopes can be joined together using colons, so the final
    project file looks like this:

    \code
        CONFIG += qt debug
        HEADERS += hello.h
        SOURCES += hello.cpp
        SOURCES += main.cpp 
        win32 {
            SOURCES += hellowin.cpp
        }
        unix {
            SOURCES += hellounix.cpp
        }
        !exists( main.cpp ) {
            error( "No main.cpp file found" )
        }
        win32:debug {
            CONFIG += console
        }
    \endcode


    That's it!  You have now completed the tutorial for \c qmake, and are
    ready to write project files for your development projects.
*/

/*!
    \page qmake-quickguide.html
    \title The Ten-Minute Guide to Using qmake

    \section1 Creating a Project File

    \c qmake uses information stored in project (.pro) files to determine
    what should go in the makefiles it generates.

    A basic project file contains information about the application. It
    declares the resources that are required to build the application,
    such as the files used to compile the application, any user interface
    descriptions, and which configuration settings to use.

    Here's a simple example project file:

    \code
        SOURCES = hello.cpp
        HEADERS = hello.h
        CONFIG += qt warn_on release
    \endcode

    We'll provide a brief line-by-line explanation, deferring the detail
    until later on in the manual.

    \code
        SOURCES = hello.cpp
    \endcode

    This line specifies the source files that implement the application. In this
    case there is just one file, \c hello.cpp. Most applications require
    multiple files; this situation is dealt with by listing all the files
    on the same line space separated, like this:

    \code
        SOURCES = hello.cpp main.cpp
    \endcode

    Alternatively, each file can be listed on a separate line, by escaping
    the newlines, like this:

    \code
        SOURCES = hello.cpp \
                  main.cpp
    \endcode

    A more verbose approach is to list each file separately, like this:

    \code
        SOURCES += hello.cpp
        SOURCES += main.cpp
    \endcode

    This approach uses "+=" rather than "=" which is safer, because it
    always adds a new file to the existing list rather than replacing the
    list.

    The HEADERS line is used to specify the header files created for use
    by the application, e.g. 

    \code 
        HEADERS += hello.h
    \endcode

    Any of the approaches used to list source files may be used for header
    files.

    The CONFIG line is used to give \c qmake information about the
    application's configuration.

    \code 
        CONFIG += qt warn_on release
    \endcode

    The "+=" is used here, because we add our configuration options to any
    that are already present. This is safer than using "=" which replaces
    all options with just those specified.

    The \c qt part of the CONFIG line tells \c qmake that the application
    is built using Qt.  This means that \c qmake will link against the Qt
    libraries when linking and add in the neccesary include paths for
    compiling.

    The \c warn_on part of the CONFIG line tells \c qmake that it should
    set the compiler flags so that warnings are output.

    The \c release part of the CONFIG line tells \c qmake that the
    application must be built as a release application. During
    development, programmers may prefer to replace \c release with \c
    debug, which is discussed later.

    \omit
    The last line in the project file is the TARGET line:

    \code
        TARGET = hello
    \endcode

    The target line simply specifies what the name of the target should be
    for the application.  You shouldn't put an extension here because \c
    qmake will do this for you.
    \endomit

    Project files are plain text (i.e. use an editor like notepad, vim
    or xemacs) and must be saved with a \c .pro extension. The name of the
    application's executable will be the same as the project file's name,
    but with an extension appropriate to the platform. For example, a
    project file called \c hello.pro will produce \c hello.exe on Windows
    and \c hello on Unix.

    \section1 Generating a Makefile

    When you have created your project file it is very easy to generate a
    makefile, all you need to do is go to where you have created your
    project file and type:

    Makefiles are generated from the \c .pro files like this:

    \code
        qmake -o Makefile hello.pro 
    \endcode

    For Visual Studio users, \c qmake can also generate \c .dsp files, for
    example:

    \code
        qmake -t vcapp -o hello.dsp hello.pro
    \endcode
*/
