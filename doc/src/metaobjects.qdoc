/****************************************************************************
**
** Explanation of moc and the meta-object system.
**
** Copyright (C) 1992-$THISYEAR$ Trolltech AS. All rights reserved.
**
** This file is part of the Qt GUI Toolkit.
** EDITIONS: FREE, PROFESSIONAL, ENTERPRISE
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
****************************************************************************/

/*!
    \page metaobjects.html

    \title Meta-Object System

    \keyword meta-object
    \keyword Q_OBJECT

    Qt's Meta-Object System provides the signals and slots mechanism for
    inter-object communication, runtime type information, and the dynamic
    property system.

    The Meta-Object System is based on three things:
    \list 1
    \i the \l QObject class
    \i the \c Q_OBJECT macro inside the private section of the class
    declaration
    \i the \link moc.html Meta-Object Compiler\endlink (\c moc)
    \endlist

    The \c moc tool reads a C++ source file. If it finds one or more
    class declarations that contain the \c Q_OBJECT macro, it produces
    another C++ source file which contains the meta-object code for
    the classes that contain the \c Q_OBJECT macro. This generated
    source file is either \c{#include}'d into the class's source file or
    compiled and linked with the class's implementation.

    In addition to providing the \link signalsandslots.html signals and
    slots \endlink mechanism for communication between objects (the main
    reason for introducing the system), the meta-object code provides
    additional features in QObject:

    \list

    \i \link QObject::className() className() \endlink returns the
    class name as a string at runtime, without requiring native
    runtime type information (RTTI) support through the C++ compiler.

    \i \link QObject::inherits() inherits() \endlink function
    returns whether an object is an instance of a class that inherits a
    specified class within the QObject inheritance tree.

    \i \link QObject::tr() tr() \endlink and
    \link QObject::trUtf8() trUtf8() \endlink translate strings
    for \l{i18n.html}{internationalization}.

    \i \link QObject::setProperty() setProperty() \endlink and \link
    QObject::property() property() \endlink dynamically
    set and get \link properties.html object properties\endlink by
    name.

    \i \link QObject::metaObject() metaObject() \endlink
    returns the associated \link QMetaObject meta-object \endlink for the
    class.

    \endlist

    \target qtcast
    It is also possible to perform dynamic casts using qobject_cast<T>()
    on QObject classes. The qobject_cast<T>() function behaves similarly
    to the standard C++ \c dynamic_cast<T>(), with the advantages
    that it doesn't require RTTI support and it works across dynamic
    library boundaries. It attempts to cast its argument to the
    pointer type specified in angle-brackets, returning a casted
    pointer if the object is of the correct type (determined at
    run-time) and 0 otherwise.

    For example, let's assume \c MyWidget inherits from QWidget and
    is declared with the \c Q_OBJECT macro:

    \quotefromfile snippets/qtcast/qtcast.cpp
    \skipto obj = new MyWidget
    \printline obj =

    The \c obj variable, of type \c{QObject *}, actually refers to a
    \c MyWidget object.

    \printline widget = qobject_cast

    The cast from QObject to QWidget is successful, because the
    object is actually a \c MyWidget, which is a widget.

    \printline myWidget = qobject_cast

    Likewise, the cast to \c MyWidget is successful. qobject_cast<T>()
    makes no distinction between built-in Qt types and custom types.

    \printline label = qobject_cast
    \printline //

    The cast to QLabel, on the other hand, fails. The pointer is then
    set to 0. This makes it possible to handle objects of different
    types differently at run-time, based on the type:

    \printline if (QLabel *label
    \printuntil /\}$/

    While it is possible to use QObject as a base class without the
    \c Q_OBJECT macro and without meta-object code, neither signals and slots
    nor the other features described here will be available if the
    \c Q_OBJECT macro is not used. From the meta-object system's point of
    view, a QObject subclass without meta code is equivalent to its
    closest ancestor with meta-object code. This means for example, that
    className() will not return the actual name of your class, but the
    class name of this ancestor.
    
    Therefore, we strongly recommend that all subclasses of QObject
    use the \c Q_OBJECT macro regardless of whether or not they
    actually use signals, slots, and properties.
*/
