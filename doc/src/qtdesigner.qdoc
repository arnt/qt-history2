/*!
    \module QtDesigner
    \title QtDesigner Module
    \contentspage Qt's Modules
    \previouspage QtXml
    \nextpage QtAssistant

    \brief The QtDesigner module provides classes for extending \QD.

    \sa {Qt Designer Manual}
*/

/*!
    \class QDesignerMemberSheetExtension

    \brief The QDesignerMemberSheetExtension class allows you to
    manipulate a widget's member functions which is displayed in Qt
    Designer's signal and slot editor.

    \inmodule QtDesigner

    QDesignerMemberSheetExtension is a collection of functions that is
    typically used to query a widget's member functions, and to
    manipulate the member functions' appearance in \QD's signal
    and slot editor. For example:

    \code
        QDesignerMemberSheetExtension *memberSheet  = 0;
        QExtensionManager manager = core()->extensionManager();

        memberSheet = qt_extension<QDesignerMemberSheetExtension*>(manager, widget);
        int index = memberSheet->indexOf(setEchoMode);
        memberSheet->setVisible(index, false);

        delete sheet;
    \endcode

    The member sheet (and any other extension), can be retrieved by
    querying \QD's extension manager using the qt_extension()
    function. When you want to release the extension, you only need to
    delete the pointer.

    All widgets have a default member sheet which populates \QD's
    signal and slot editor with the widget's member functions. But
    QDesignerMemberSheetExtension also provides an interface for
    creating custom member sheet extensions.

    \warning \QD uses the QDesignerMemberSheetExtension to feed its
    signal and slot editor. Whenever a connection between two widgets
    is requested, Qt Designer will query for the widgets' member sheet
    extensions. If a widget has an implemented member sheet extension,
    this extension will override the default member sheet.

    To create a member sheet extension, your extension class must
    inherit from both QObject and QDesignerMemberSheetExtension. Then,
    since we are implementing an interface, we must ensure that it's
    made known to the meta object system using the Q_INTERFACES()
    macro:

    \code
       class MyMemberSheetExtension : public QObject,
               public QDesignerMemberSheetExtension
       {
           Q_OBJECT
           Q_INTERFACES(QDesignerMemberSheetExtension)

       public:
           ...
       }
    \endcode

    This enables Qt Designer to use qobject_cast() to query for
    supported interfaces using nothing but a QObject pointer.

    In Qt Designer the extensions are not created until they are
    required. For that reason, when implementing a property sheet
    extension, you must also create a QExtensionFactory, i.e a class
    that is able to make an instance of your extension, and register
    it using a QExtensionManager.

    The QExtensionManager class provides extension management
    facilities for Qt Designer. When a widget's member sheet extension
    is required, Qt Designer will run through all its registered
    factories calling QExtensionFactory::createExtension() for each
    until the first one that is able to create a member sheet
    extension for that widget, is found. This factory will then make
    an instance of the extension. If no such factory is found, \QD
    will use the default member sheet.

    There are four available types of extensions in Qt Designer:
    QDesignerContainerExtension , QDesignerMemberSheetExtension,
    QDesignerPropertySheetExtension and
    QDesignerTaskMenuExtension. Qt Designer's behavior is the same
    whether the requested extension is associated with a multi page
    container, a member sheet, a property sheet or a task menu.

    The QExtensionFactory class provides a standard extension
    factory, and can also be used as an interface for custom
    extension factories. You can either create a new
    QExtensionFactory and reimplement the
    QExtensionFactory::createExtension() function. For example:

    \code
        QObject *ANewExtensionFactory::createExtension(QObject *object,
                const QString &iid, QObject *parent) const
        {
            if (iid != Q_TYPEID(QDesignerMemberSheetExtension))
                return 0;

            if (MyCustomWidget *widget = qobject_cast<MyCustomWidget*>
                   (object))
                return new MyMemberSheetExtension(widget, parent);

            return 0;
        }
    \endcode

    Or you can use an existing factory, expanding the
    QExtensionFactory::createExtension() function to make the factory
    able to create a member sheet extension as well. For example:

    \code
        QObject *AGeneralExtensionFactory::createExtension(QObject *object,
                const QString &iid, QObject *parent) const
        {
            if (iid == Q_TYPEID(QDesignerTaskMenuExtension)) {
                if (MyCustomWidget *widget = qobject_cast<MyCustomWidget*>
                        (object))
                    return new MyTaskMenuExtension(widget, parent);

            } else if (iid == Q_TYPEID(QDesignerMemberSheetExtension)) {
                if (MyCustomWidget *widget = qobject_cast<MyCustomWidget*>
                        (object))
                    return new MyMemberSheetExtension(widget, parent);

            } else {
                return 0;
            }
        }
    \endcode

    For a complete example using an extension class, see \l
    {designer/taskmenuextension}{Task Menu Extension example}. The
    example shows how to create a custom widget plugin for Qt
    Designer, and how to to use the QDesignerTaskMenuExtension class
    to add custom items to Qt Designer's task menu.

    \sa QExtensionFactory, QExtensionManager, {Qt Designer}
*/

/*!
    \fn QDesignerMemberSheetExtension::~QDesignerMemberSheetExtension()

    Destroys the member sheet extension.
*/

/*!
    \fn int QDesignerMemberSheetExtension::count() const

    Returns the extension's number of functions.
*/

/*!
    \fn int QDesignerMemberSheetExtension::indexOf(const QString &name) const

    Returns the index of the member function specified by the given \a
    name.

    \sa memberName()
*/

/*!
    \fn QString QDesignerMemberSheetExtension::memberName(int index) const

    Returns the name of the member function with the given \a index.

    \sa indexOf()
*/

/*!
    \fn QString QDesignerMemberSheetExtension::memberGroup(int index) const

    Returns the name of the member group specified for the function
    with the given \a index.

    \sa indexOf(), setMemberGroup()
*/

/*!
    \fn void QDesignerMemberSheetExtension::setMemberGroup(int index, const QString &group)

    Sets the member group of the member function with the given \a
    index, to \a group.

    \sa indexOf(), memberGroup()
*/

/*!
    \fn bool QDesignerMemberSheetExtension::isVisible(int index) const

    Returns true if the member function with the given \a index is
    visible in \QD's signal and slot editor, otherwise false.

    \sa indexOf(), setVisible()
*/

/*!
    \fn void QDesignerMemberSheetExtension::setVisible(int index, bool visible)

    If \a visible is true, the member function with the given \a index
    is visible in \QD's signal and slot editor; otherwise the member
    function is hidden.

    \sa indexOf(), isVisible()
*/

/*!
    \fn virtual bool QDesignerMemberSheetExtension::isSignal(int index) const

    Returns true if the member function with the given \a index is a
    signal, otherwise false.

    \sa indexOf()
*/

/*!
    \fn bool QDesignerMemberSheetExtension::isSlot(int index) const

    Returns true if the member function with the given \a index is a
    slot, otherwise false.

    \sa indexOf()
*/

/*!
    \fn bool QDesignerMemberSheetExtension::inheritedFromWidget(int index) const

    Returns true if the member function with the given \a index is
    inherited from QWidget, otherwise false.

    \sa indexOf()
*/

/*!
    \fn QString QDesignerMemberSheetExtension::declaredInClass(int index) const

    Returns the name of the class in which the member function with
    the given \a index is declared.

    \sa indexOf()
*/

/*!
    \fn QString QDesignerMemberSheetExtension::signature(int index) const

    Returns the signature of the member function with the given \a
    index.

    \sa indexOf()
*/

/*!
    \fn QList<QByteArray> QDesignerMemberSheetExtension::parameterTypes(int index) const

    Returns the parameter types of the member function with the given
    \a index as a QByteArray list.

    \sa indexOf(), parameterNames()
*/

/*!
    \fn QList<QByteArray> QDesignerMemberSheetExtension::parameterNames(int index) const

    Returns the parameter names of the member function with the given
    \a index as a QByteArray list.

    \sa indexOf(), parameterTypes()
*/


// Doc: Interface only

/*!
    \class QDesignerLayoutDecorationExtension
    \brief The QDesignerLayoutDecorationExtension class provides an extension to a layout in \QD.
    \inmodule QtDesigner
    \internal
*/

/*!
    \enum QDesignerLayoutDecorationExtension::InsertMode

    This enum describes the modes that are used to insert items into a layout.

    \value InsertWidgetMode Widgets are inserted into empty cells in a layout.
    \value InsertRowMode    Whole rows are inserted into a vertical or grid layout.
    \value InsertColumnMode Whole columns are inserted into a horizontal or grid layout.
*/

/*!
    \fn virtual QDesignerLayoutDecorationExtension::~QDesignerLayoutDecorationExtension()

    Destroys the extension.
*/

/*!
    \fn virtual QList<QWidget*> QDesignerLayoutDecorationExtension::widgets(QLayout *layout) const

    Returns the widgets that are managed by the given \a layout.

    \sa insertWidget(), removeWidget()
*/

/*!
    \fn QRect QDesignerLayoutDecorationExtension::itemInfo(int index) const

    Returns the rectangle covered by the item at the given \a index in the layout.
*/

/*!
    \fn int QDesignerLayoutDecorationExtension::indexOf(QWidget *widget) const

    Returns the index of the specified \a widget in the layout.
*/

/*!
    \fn int QDesignerLayoutDecorationExtension::indexOf(QLayoutItem *item) const

    Returns the index of the specified layout \a item.
*/

/*!
    \fn QDesignerLayoutDecorationExtension::InsertMode QDesignerLayoutDecorationExtension::currentInsertMode() const

    Returns the current insertion mode.
*/

/*!
    \fn int QDesignerLayoutDecorationExtension::currentIndex() const

    Returns the current index in the layout.
*/

/*!
    \fn QPair<int, int> QDesignerLayoutDecorationExtension::currentCell() const

    Returns a pair containing the row and column of the current cell in the layout.
*/

/*!
    \fn void QDesignerLayoutDecorationExtension::insertWidget(QWidget *widget, const QPair<int, int> &cell)

    Inserts the given \a widget into the specified \a cell in the layout.

    \sa removeWidget()
*/

/*!
    \fn void QDesignerLayoutDecorationExtension::removeWidget(QWidget *widget)

    Removes the specified \a widget from the layout.

    \sa insertWidget()
*/

/*!
    \fn void QDesignerLayoutDecorationExtension::insertRow(int row)

    Inserts a new row into the form at the position specified by \a row.
*/

/*!
    \fn void QDesignerLayoutDecorationExtension::insertColumn(int column)

    Inserts a new column into the form at the position specified by \a column.
*/

/*!
    \fn void QDesignerLayoutDecorationExtension::simplify()

    Simplifies the layout by removing unnecessary empty rows and columns, and by changing the
    number of rows or columns spanned by widgets.
*/

/*!
    \fn int QDesignerLayoutDecorationExtension::findItemAt(const QPoint &position) const

    Returns the index of the item in the layout that covers the given \a position.
*/

/*!
    \fn int QDesignerLayoutDecorationExtension::findItemAt(int row, int column) const

    Returns the item in the layout that occupies the specified \a row and \a column in the layout.

    Currently, this only applies to grid layouts.
*/

/*!
    \fn void QDesignerLayoutDecorationExtension::adjustIndicator(const QPoint &position, int index)

    Adjusts the indicator for the item specified by \a index so that
    it lies at the given \a position on the form.
*/


// Doc: Interface only

/*!
    \class QDesignerContainerExtension
    \brief The QDesignerContainerExtension class allows you to add pages to
    a multipage container plugin in Qt Designer.
    \inmodule QtDesigner

    QDesignerContainerExtension provide an interface for creating
    custom container extensions. A container extension consists of a
    collection of functions that \QD needs to manage a multipage
    container plugin, and a list of the container's pages.

    \warning This is \e not an extension for container plugins in
    general.

    To create a container extension, your extension class must inherit
    from both QObject and QDesignerContainerExtension. For example:

    \code
        class MyContainerExtension : public QObject,
               public QDesignerContainerExtension
        {
            Q_OBJECT
            Q_INTERFACES(QDesignerContainerExtension)

        public:
            MyContainerExtension(MyCustomWidget *widget,
                                 QObject *parent = 0);
            int count() const;
            QWidget *widget(int index) const;
            int currentIndex() const;
            void setCurrentIndex(int index);
            void addWidget(QWidget *widget);
            void insertWidget(int index, QWidget *widget);
            void remove(int index);

        private:
            MyCustomWidget *myWidget;
        };
    \endcode

    Since we are implementing an interface, we must ensure that it's
    made known to the meta object system using the Q_INTERFACES()
    macro. This enables \QD to use the qobject_cast() function to
    query for supported interfaces using nothing but a QObject
    pointer.

    You must reimplement several functions to enable \QD to manage
    your multipaged container widget: \QD uses count() to keep track
    of the number pages in your container, widget() to return the page
    at a given index in the list of the container's pages, and
    currentIndex() to return the list index of the selected page. \QD
    uses the addWidget() function to add a given page to the container,
    expecting it to be appended to the list of pages, while it expects
    the insertWidget() function to add a given page to the container by
    inserting it at a specified index in the list of pages.

    In Qt Designer the extensions are not created until they are
    required. For that reason you must also create a
    QExtensionFactory, i.e a class that is able to make an instance of
    your extension, and register it using a QExtensionManager.

    The QExtensionManager class provides extension management
    facilities for \QD. When a container extension is required, Qt
    Designer will run through all its registered factories calling
    QExtensionFactory::createExtension() for each until the first one
    that is able to create a container extension, is found. This
    factory will then create the extension for the plugin.

    There are four available types of extensions in \QD:
    QDesignerContainerExtension , QDesignerMemberSheetExtension,
    QDesignerPropertySheetExtension and QDesignerTaskMenuExtension. Qt
    Designer's behavior is the same whether the requested extension is
    associated with a multi page container, a member sheet, a property
    sheet or a task menu.

    The QExtensionFactory class provides a standard extension factory,
    and can also be used as an interface for custom extension
    factories. You can either create a new QExtensionFactory and
    reimplement the QExtensionFactory::createExtension() function. For
    example:

    \code
        QObject *ANewExtensionFactory::createExtension(QObject *object,
                const QString &iid, QObject *parent) const
        {
            if (iid != Q_TYPEID(QDesignerContainerExtension))
                return 0;

            if (MyCustomWidget *widget = qobject_cast<MyCustomWidget*>
                   (object))
                return new MyContainerExtension(widget, parent);

            return 0;
        }
    \endcode

    Or you can use an existing factory, expanding the
    QExtensionFactory::createExtension() function to make the factory
    able to create a container extension as well. For example:

    \code
        QObject *AGeneralExtensionFactory::createExtension(QObject *object,
                const QString &iid, QObject *parent) const
        {
            if (iid == Q_TYPEID(QDesignerTaskMenuExtension)) {
                if (MyCustomWidget *widget = qobject_cast<MyCustomWidget*>
                        (object))
                    return new MyTaskMenuExtension(widget, parent);

            } else if (iid == Q_TYPEID(QDesignerContainerExtension)) {
                if (MyCustomWidget *widget = qobject_cast<MyCustomWidget*>
                        (object))
                    return new MyContainerExtension(widget, parent);

            } else {
                return 0;
            }
        }
    \endcode

    For a complete example using an extension class, see the \l
    {designer/taskmenuextension}{Task Menu Extension example}. The
    example shows how to create a custom widget plugin for Qt
    Designer, and how to to use the QDesignerTaskMenuExtension class
    to add custom items to \QD's task menu.

    \sa QExtensionFactory, QExtensionManager, {Qt Designer}
*/

/*!
    \fn QDesignerContainerExtension::~QDesignerContainerExtension()

    Destroys the extension.
*/

/*!
    \fn int QDesignerContainerExtension::count() const

    Returns the number of pages in the container.
*/

/*!
    \fn QWidget *QDesignerContainerExtension::widget(int index) const

    Returns the page at the given \a index in the extension's list of
    pages.

    \sa addWidget(), insertWidget()
*/

/*!
    \fn int QDesignerContainerExtension::currentIndex() const

    Returns the index of the currently selected page in the
    container.

    \sa setCurrentIndex()
*/

/*!
    \fn void QDesignerContainerExtension::setCurrentIndex(int index)

    Sets the the currently selected page in the container to be the
    page at the given \a index in the extension's list of pages.

    \sa currentIndex()
*/

/*!
    \fn void QDesignerContainerExtension::addWidget(QWidget *page)

    Adds the given \a page to the container by appending it to the
    extension's list of pages.

    \sa insertWidget(), remove(), widget()
*/

/*!
    \fn void QDesignerContainerExtension::insertWidget(int index, QWidget *page)

    Adds the given \a page to the container by inserting it at the
    given \a index in extension's list of pages.

    \sa addWidget(), remove(), widget()
*/

/*!
    \fn void QDesignerContainerExtension::remove(int index)

    Removes the page at the given \a index from the extension's list
    of pages.

    \sa addWidget(), insertWidget()
*/


// Doc: Interface only

/*!
    \class QDesignerTaskMenuExtension
    \brief The QDesignerTaskMenuExtension class allows you to add custom
    menu entries to Qt Designer's task menu.
    \inmodule QtDesigner

    QDesignerTaskMenuExtension provides an interface for creating
    custom task menu extensions. It is typically used to create task
    menu entries that is specific to a plugin in \QD.

    Qt Designer uses the QDesignerTaskMenuExtension to feed its task
    menu. Whenever a task menu is requested, Qt Designer will query
    for the selected widget's task menu extension.

    \image taskmenuextension-example-faded.png

    A task menu extension is a collection of QActions. The actions
    appear as entries in the task menu when the plugin with the
    specified extension is selected. The image above show the custom
    \gui {Edit State...} action which appear in addition to \QD's
    default task menu entries: \gui Cut, \gui Copy, \gui Paste etc.

    To create a custom task menu extension, your extension class must
    inherit from both QObject and QDesignerTaskMenuExtension. For
    example:

    \code
        class MyTaskMenuExtension : public QObject,
                public QDesignerTaskMenuExtension
        {
            Q_OBJECT
            Q_INTERFACES(QDesignerTaskMenuExtension)

        public:
            MyTaskMenuExtension(MyCustomWidget *widget, QObject *parent);

            QAction *preferredEditAction() const;
            QList<QAction *> taskActions() const;

        private slots:
            void mySlot();

        private:
            MyCustomWidget *widget;
            QAction *myAction;
        };
    \endcode

    Since we are implementing an interface, we must ensure that it's
    made known to the meta object system using the Q_INTERFACES()
    macro. This enables \QD to use the qobject_cast() function to
    query for supported interfaces using nothing but a QObject
    pointer.

    You must reimplement the taskActions() function to return a list
    of actions that will be included in \QD task menu. Optionally, you
    can reimplement the preferredEditAction() function to set the
    action that is invoked when selecting your plugin and pressing
    \key F2. The preferred edit action must be one of the actions
    returned by taskActions(), and, if it's not defined, pressing \key F2
    will simply be ignored.

    In \QD the extensions are not created until they are required. A
    task menu extension, for example, is created when you click the
    right mouse button over a widget in \QD's workspace. For that
    reason you must also create a QExtensionFactory, i.e a class that
    is able to make an instance of your extension, and register it
    using a QExtensionManager.

    The QExtensionManager class provides extension management
    facilities for \QD. When a task menu extension is required, Qt
    Designer will run through all its registered factories calling
    QExtensionFactory::createExtension() for each until the first one
    that is able to create a task menu extension for the selected
    widget, is found. This factory will then make an instance of the
    extension.

    There are four available types of extensions in \QD:
    QDesignerContainerExtension , QDesignerMemberSheetExtension,
    QDesignerPropertySheetExtension and QDesignerTaskMenuExtension.
    \QD's behavior is the same whether the requested extension is
    associated with a container, a member sheet, a property sheet or a
    task menu.

    The QExtensionFactory class provides a standard extension factory,
    and can also be used as an interface for custom extension
    factories. You can either create a new QExtensionFactory and
    reimplement the QExtensionFactory::createExtension() function. For
    example:

    \code
        QObject *ANewExtensionFactory::createExtension(QObject *object,
                const QString &iid, QObject *parent) const
        {
            if (iid != Q_TYPEID(QDesignerTaskMenuExtension))
                return 0;

            if (MyCustomWidget *widget = qobject_cast<MyCustomWidget*>(object))
                return new MyTaskMenuExtension(widget, parent);

            return 0;
        }
    \endcode

    Or you can use an existing factory, expanding the
    QExtensionFactory::createExtension() function to make the factory
    able to create a task menu extension as well. For example:

    \code
        QObject *AGeneralExtensionFactory::createExtension(QObject *object,
                const QString &iid, QObject *parent) const
        {
            if (iid == Q_TYPEID(QDesignerContainerExtension)) {
                if (MyCustomWidget *widget = qobject_cast<MyCustomWidget*>
                        (object))
                    return new MyContainerExtension(widget, parent);

            } else if (iid == Q_TYPEID(QDesignerTaskMenuExtension)) {
                if (MyCustomWidget *widget = qobject_cast<MyCustomWidget*>
                        (object))
                    return new MyTaskMenuExtension(widget, parent);

            } else {
                return 0;
            }
        }
    \endcode

    For a complete example using the QDesignerTaskMenuExtension class,
    see the \l {designer/taskmenuextension}{Task Menu Extension
    example}. The example shows how to create a custom widget plugin
    for Qt Designer, and how to to use the QDesignerTaskMenuExtension
    class to add custom items to \QD's task menu.

    \sa QExtensionFactory, QExtensionManager, {Qt Designer}
*/

/*!
    \fn QDesignerTaskMenuExtension::~QDesignerTaskMenuExtension()

    Destroys the task menu extension.
*/

/*!
    \fn QAction *QDesignerTaskMenuExtension::preferredEditAction() const

    Returns the action that is invoked when selecting a plugin with
    the specified extension and pressing \key F2.

    The action must be one of the actions returned by taskActions().
*/

/*!
    \fn QList<QAction*> QDesignerTaskMenuExtension::taskActions() const

    Returns the task menu extension as a list of actions which will be
    included in \QD task menu when a plugin with the specified
    extension is selected.

    The function must be reimplemented to add actions to the list.
*/


// Doc: Interface only

/*!
    \class QDesignerCustomWidgetCollectionInterface
    \brief The QDesignerCustomWidgetCollectionInterface class provides an interface that is used
    to manage collections of custom widgets in \QD.
    \inmodule QtDesigner
*/

/*!
    \fn QDesignerCustomWidgetCollectionInterface::~QDesignerCustomWidgetCollectionInterface() {

    Destroys the interface.
*/

/*!
    \fn QList<QDesignerCustomWidgetInterface*> QDesignerCustomWidgetCollectionInterface::customWidgets() const

    Returns a list of interfaces to the custom widgets in the container.
*/


// Doc: Interface only

/*!
    \class QDesignerCustomWidgetInterface
    \brief The QDesignerCustomWidgetInterface class provides an interface to a custom widget in
    \QD.
    \inmodule QtDesigner

    \sa {Creating Custom Widgets for Qt Designer}
*/

/*!
    \fn QDesignerCustomWidgetInterface::~QDesignerCustomWidgetInterface()

    Destroys the custom widget interface.
*/

/*!
    \fn QString QDesignerCustomWidgetInterface::name() const

    Returns the name of the class that implements the custom widget.
*/

/*!
    \fn QString QDesignerCustomWidgetInterface::group() const

    Returns the name of the group to which the custom widget belongs.
*/

/*!
    \fn QString QDesignerCustomWidgetInterface::toolTip() const

    Returns a short description of the widget that can be used by \QD in a tool tip.
*/

/*!
    \fn QString QDesignerCustomWidgetInterface::whatsThis() const

    Returns a description of the widget that can be used by \QD in "What's This?" help for the
    widget.
*/

/*!
    \fn QString QDesignerCustomWidgetInterface::includeFile() const

    Returns the path to the include file that \l uic uses when creating code for the custom
    widget.
*/

/*!
    \fn QIcon QDesignerCustomWidgetInterface::icon() const

    Returns the icon used to represent the custom widget in \QD's widget box.
*/

/*!
    \fn bool QDesignerCustomWidgetInterface::isContainer() const

    Returns true if the custom widget is intended to be used as a container; otherwise returns
    false.

    Most custom widgets are not used to hold other widgets, so their implementations of this
    function will return false, but custom containers will return true to ensure that they
    behave correctly in \QD.
*/

/*!
    \fn QWidget *QDesignerCustomWidgetInterface::createWidget(QWidget *parent)

    Returns a new widget with the given \a parent.
*/

/*!
    \fn bool QDesignerCustomWidgetInterface::isInitialized() const

    Returns true if the widget has been initialized; otherwise returns false.

    \sa initialize()
*/

/*!
    \fn void QDesignerCustomWidgetInterface::initialize(QDesignerFormEditorInterface *core)

    Initializes the widget for use with the form editor with the specified \a core interface.

    \sa isInitialized()
*/

/*!
    \fn QString QDesignerCustomWidgetInterface::domXml() const

    Returns the XML that is used to describe widget properties to \QD.
*/

/*!
    \fn QString QDesignerCustomWidgetInterface::codeTemplate() const

    Returns the code template that \QD includes in forms that contain the custom widget when
    they are saved.

    \l uic uses the code template to provide code for constructing the custom widget.
*/


// Doc: Abstract class

/*!
    \class QDesignerDnDItemInterface
    \brief The QDesignerDnDItemInterface class provides an interface that is used to manage items
    during a drag and drop operation.
    \inmodule QtDesigner
    \internal
*/

/*!
    \enum QDesignerDnDItemInterface::DropType

    This enum describes the result of a drag and drop operation.

    \value MoveDrop The item was moved.
    \value CopyDrop The item was copied.
*/

/*!
    \fn QDesignerDnDItemInterface::QDesignerDnDItemInterface()

    Constructs a new interface to a drag and drop item.
*/

/*!
    \fn QDesignerDnDItemInterface::~QDesignerDnDItemInterface()

    Destroys the interface to the item.
*/

/*!
    \fn DomUI *QDesignerDnDItemInterface::domUi() const

    Returns a user interface object for the item.
*/

/*!
    \fn QWidget *QDesignerDnDItemInterface::widget() const

    Returns the widget being copied or moved in the drag and drop operation.

    \sa source()
*/

/*!
    \fn QWidget *QDesignerDnDItemInterface::decoration() const

    Returns the widget used to represent the item.
*/

/*!
    \fn QPoint QDesignerDnDItemInterface::hotSpot() const

    Returns the cursor's hotspot.

    \sa QDrag::hotSpot()
*/

/*!
    \fn DropType QDesignerDnDItemInterface::type() const

    Returns the type of drag and drop operation in progress.
*/

/*!
    \fn QWidget *QDesignerDnDItemInterface::source() const

    Returns the widget that is the source of the drag and drop operation; i.e. the original
    container of the widget being dragged.

    \sa widget()
*/


// Doc: Abstract class

/*!
    \class QDesignerIconCacheInterface
    \brief The QDesignerIconCacheInterface class provides an interface to \QD's icon cache.
    \inmodule QtDesigner
    \internal
*/

/*!
    \fn QDesignerIconCacheInterface::QDesignerIconCacheInterface(QObject *parent)

    Constructs a new interface with the given \a parent.
*/

/*!
    \fn QIcon QDesignerIconCacheInterface::nameToIcon(const QString &filePath, const QString &qrcPath)

    Returns the icon associated with the name specified by \a filePath in the resource
    file specified by \a qrcPath.

    If \a qrcPath refers to a valid resource file, the name used for the file path is a path
    within those resources; otherwise the file path refers to a local file.

    \sa {The Qt Resource System}, nameToPixmap()
*/

/*!
    \fn QPixmap QDesignerIconCacheInterface::nameToPixmap(const QString &filePath, const QString &qrcPath)

    Returns the pixmap associated with the name specified by \a filePath in the resource
    file specified by \a qrcPath.

    If \a qrcPath refers to a valid resource file, the name used for the file path is a path
    within those resources; otherwise the file path refers to a local file.

    \sa {The Qt Resource System}, nameToIcon()
*/

/*!
    \fn QString QDesignerIconCacheInterface::iconToFilePath(const QIcon &icon) const

    Returns the file path associated with the given \a icon. The file path is a path within
    an application resources.
*/

/*!
    \fn QString QDesignerIconCacheInterface::iconToQrcPath(const QIcon &icon) const

    Returns the path to the resource file that refers to the specified \a icon. The resource
    path refers to a local file.
*/

/*!
    \fn QString QDesignerIconCacheInterface::pixmapToFilePath(const QPixmap &pixmap) const

    Returns the file path associated with the given \a pixmap. The file path is a path within
    an application resources.
*/

/*!
    \fn QString QDesignerIconCacheInterface::pixmapToQrcPath(const QPixmap &pixmap) const

    Returns the path to the resource file that refers to the specified \a pixmap. The resource
    path refers to a local file.
*/

/*!
    \fn QList<QPixmap> QDesignerIconCacheInterface::pixmapList() const

    Returns a list of pixmaps for the icons provided by the icon cache.
*/

/*!
    \fn QList<QIcon> QDesignerIconCacheInterface::iconList() const

    Returns a list of icons provided by the icon cache.
*/

/*!
    \fn QString QDesignerIconCacheInterface::resolveQrcPath(const QString &filePath, const QString &qrcPath, const QString &workingDirectory) const

    Returns a path to a resource specified by the \a filePath within
    the resource file located at \a qrcPath. If \a workingDirectory is
    a valid path to a directory, the path returned will be relative to
    that directory; otherwise an absolute path is returned.

    \omit
    ### Needs checking
    \endomit
*/


// Doc: Interface only

/*!
    \class QDesignerPropertySheetExtension

    \brief The QDesignerPropertySheetExtension class allows you to
    manipulate a widget's properties which is displayed in Qt
    Designer's property editor.

    \inmodule QtDesigner

    QDesignerPropertySheetExtension is a collection of functions that
    is typically used to query a widget's properties, and to
    manipulate the properties' appearance in the property editor. For
    example:

    \code
        QDesignerPropertySheetExtension *propertySheet  = 0;
        QExtensionManager manager = core()->extensionManager();

        propertySheet = qt_extension<QDesignerPropertySheetExtension*>(manager, widget);
        int index = propertySheet->indexOf(QLatin1String("margin"));

        propertySheet->setProperty(index, 10);
        propertySheet->setChanged(index, true);

        delete sheet;
    \endcode

    The property sheet, or any other extension, can be retrieved by
    querying \QD's extension manager using the qt_extension()
    function. When you want to release the extension, you only need to
    delete the pointer.

    All widgets have a default property sheet which populates \QD's
    property editor with the widget's properties (that is the ones
    defined with the Q_PROPERTY() macro). But
    QDesignerPropertySheetExtension also provides an interface for
    creating custom property sheet extensions.

    \warning \QD uses the QDesignerPropertySheetExtension to feed its
    property editor. Whenever a widget is selected in its workspace,
    \QD will query for the widget's property sheet extension. If the
    selected widget has an implemented property sheet extension, this
    extension will override the default property sheet.

    To create a property sheet extension, your extension class must
    inherit from both QObject and
    QDesignerPropertySheetExtension. Then, since we are implementing
    an interface, we must ensure that it's made known to the meta
    object system using the Q_INTERFACES() macro:

    \code
       class MyPropertySheetExtension : public QObject,
               public QDesignerPropertySheetExtension
       {
           Q_OBJECT
           Q_INTERFACES(QDesignerPropertySheetExtension)

       public:
           ...
       }
    \endcode

    This enables \QD to use qobject_cast() to query for supported
    interfaces using nothing but a QObject pointer.

    In Qt Designer the extensions are not created until they are
    required. For that reason, when implementing a property sheet
    extension, you must also create a QExtensionFactory, i.e a class
    that is able to make an instance of your extension, and register
    it using a QExtensionManager.

    The QExtensionManager class provides extension management
    facilities for Qt Designer. When a property sheet extension is
    required, Qt Designer will run through all its registered
    factories calling QExtensionFactory::createExtension() for each
    until the first one that is able to create a property sheet
    extension for the selected widget, is found. This factory will
    then make an instance of the extension. If no such factory can be
    found, \QD will use the default property sheet.

    There are four available types of extensions in Qt Designer:
    QDesignerContainerExtension, QDesignerMemberSheetExtension,
    QDesignerPropertySheetExtension and QDesignerTaskMenuExtension. Qt
    Designer's behavior is the same whether the requested extension is
    associated with a multi page container, a member sheet, a property
    sheet or a task menu.

    The QExtensionFactory class provides a standard extension factory,
    and can also be used as an interface for custom extension
    factories. You can either create a new QExtensionFactory and
    reimplement the QExtensionFactory::createExtension() function. For
    example:

    \code
        QObject *ANewExtensionFactory::createExtension(QObject *object,
                const QString &iid, QObject *parent) const
        {
            if (iid != Q_TYPEID(QDesignerPropertySheetExtension))
                return 0;

            if (MyCustomWidget *widget = qobject_cast<MyCustomWidget*>
                   (object))
                return new MyPropertySheetExtension(widget, parent);

            return 0;
        }
    \endcode

    Or you can use an existing factory, expanding the
    QExtensionFactory::createExtension() function to make the factory
    able to create a property sheet extension extension as well. For
    example:

    \code
        QObject *AGeneralExtensionFactory::createExtension(QObject *object,
                const QString &iid, QObject *parent) const
        {
            if (iid == Q_TYPEID(QDesignerTaskMenuExtension)) {
                if (MyCustomWidget *widget = qobject_cast<MyCustomWidget*>
                        (object))
                    return new MyTaskMenuExtension(widget, parent);

            } else if (iid == Q_TYPEID(QDesignerPropertySheetExtension)) {
                if (MyCustomWidget *widget = qobject_cast<MyCustomWidget*>
                        (object))
                    return new MyPropertySheetExtension(widget, parent);

            } else {
                return 0;
            }
        }
    \endcode

    For a complete example using an extension class, see the \l
    {designer/taskmenuextension}{Task Menu Extension example}. The
    example shows how to create a custom widget plugin for Qt
    Designer, and how to to use the QDesignerTaskMenuExtension class
    to add custom items to Qt Designer's task menu.

    \sa QExtensionFactory, QExtensionManager, {Qt Designer}
*/

/*!
    \fn QDesignerPropertySheetExtension::~QDesignerPropertySheetExtension()

    Destroys the property sheet extension.
*/

/*!
    \fn int QDesignerPropertySheetExtension::count() const

    Returns the selected widget's number of properties.
*/

/*!
    \fn int QDesignerPropertySheetExtension::indexOf(const QString &name) const

    Returns the index for a given property \a name.

    \sa propertyName()
*/

/*!
    \fn QString QDesignerPropertySheetExtension::propertyName(int index) const

    Returns the name of the property at the given \a index.

    \sa indexOf()
*/

/*!
    \fn QString QDesignerPropertySheetExtension::propertyGroup(int index) const

    Returns the property group for the property at the given \a index.

    \QD's property editor supports property groups, i.e. sections of
    related properties. A property can be related to a group using the
    setProperty() function. The default group of any property is the
    name of the class that defines it. The QObject::objectName
    property, for example, appears within the QObject property group.

    \sa indexOf(), setPropertyGroup()
*/

/*!
    \fn void QDesignerPropertySheetExtension::setPropertyGroup(int index, const QString &group)

    Sets the property group for the property at the given \a index to
    \a group.

    Relating a property to a group makes it appear within that group's
    section in the property editor. The default property group of any
    property is the name of the class that defines it. The
    QObject::objectName property, for example, appears within the
    QObject property group.

    \sa indexOf(), property(), propertyGroup()
*/

/*!
    \fn bool QDesignerPropertySheetExtension::hasReset(int index) const

    Returns true if the property at the given \a index has a reset
    button in \QD's property editor, otherwise false.

    \sa indexOf(), reset()
*/

/*!
    \fn bool QDesignerPropertySheetExtension::reset(int index)

    Resets the value of the property at the given \a index, to the
    default value.

    \sa indexOf(), hasReset(), isChanged()
*/

/*!
    \fn bool QDesignerPropertySheetExtension::isVisible(int index) const

    Returns true if the property at the given \a index is visible in
    \QD's property editor, otherwise false.

    \sa indexOf(), setVisible()
*/

/*!
    \fn void QDesignerPropertySheetExtension::setVisible(int index, bool visible)

    If \a visible is true, the property at the given \a index is
    visible in \QD's property editor; otherwise the property is
    hidden.

    \sa indexOf(), isVisible()
*/

/*!
    \fn bool QDesignerPropertySheetExtension::isAttribute(int index) const

    Returns true if the property at the given \a index is an attribute,
    which will be \e excluded from the .ui file, otherwise false.

    \sa indexOf(), setAttribute()
*/

/*!
    \fn void QDesignerPropertySheetExtension::setAttribute(int index, bool attribute)

    If \a attribute is true, the property at the given \a index is
    made an attribute which will be \e excluded from the .ui file;
    otherwise it will be included.

    \sa indexOf(), isAttribute()
*/

/*!
    \fn QVariant QDesignerPropertySheetExtension::property(int index) const

    Returns the value of the property at the given \a index.

    \sa indexOf(), setProperty(), propertyGroup()
*/

/*!
    \fn void QDesignerPropertySheetExtension::setProperty(int index, const QVariant &value)

    Sets the \a value of the property at the given \a index.

    \sa indexOf(), property(), propertyGroup()
*/

/*!
    \fn bool QDesignerPropertySheetExtension::isChanged(int index) const

    Returns true if the value of the property at the given \a index
    differs from the property's default value, otherwise false.

    \sa indexOf(), setChanged(), reset()
*/

/*!
    \fn void QDesignerPropertySheetExtension::setChanged(int index, bool changed)

    Sets whether the property at the given \a index is different from
    its default value, or not, depending on the \a changed parameter.

    \sa indexOf(), isChanged()
*/
