/****************************************************************************
**
** Copyright (C) 1992-$THISYEAR$ Trolltech AS. All rights reserved.
**
** This file is part of the Qt GUI Toolkit.
** EDITIONS: FREE, PROFESSIONAL, ENTERPRISE
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
****************************************************************************/

/*!
    \page moc.html

    \title Using the Meta-Object Compiler (moc)

    \keyword moc

    The Meta-Object Compiler, \c moc, is the program that handles
    \link metaobjects.html Qt's C++ extensions\endlink.

    The \c moc tool reads a C++ header file. If it finds one or more
    class declarations that contain the \c Q_OBJECT macro, it
    produces a C++ source file containing the meta-object code for
    those classes. Among other things, meta-object code is required
    for the signals and slots mechanism, the run-time type information,
    and the dynamic property system.

    The C++ source file generated by \c moc must be compiled and
    linked with the implementation of the class.

    If you use \link qmake-manual.html qmake\endlink to create your
    Makefiles, build rules will be included that call the moc when
    required, so you will not need to use the moc directly. For more
    background information on \c moc, see \link templates.html Why
    doesn't Qt use templates for signals and slots?\endlink

    \section1 Usage

    \c moc is typically used with an input file containing class
    declarations like this:

    \code
        class MyClass : public QObject
        {
            Q_OBJECT

        public:
            MyClass(QObject *parent = 0);
            ~MyClass();

        signals:
	    void mySignal();

        public slots:
	    void mySlot();
        };
    \endcode

    In addition to the signals and slots shown above, \c moc also
    implements object properties as in the next example. The \c
    Q_PROPERTY() macro declares an object property, while \c
    Q_ENUMS() declares a list of enumeration types within the class
    to be usable inside the \link properties.html property
    system\endlink. In the following example, we declare a property
    of the enumeration type \c Priority that is also called \c
    priority and has a get function \c priority() and a set function
    \c setPriority().

    \code
        class MyClass : public QObject
        {
            Q_OBJECT
            Q_PROPERTY(Priority priority READ priority WRITE setPriority)
            Q_ENUMS(Priority)

        public:
            enum Priority { High, Low, VeryHigh, VeryLow };

            MyClass(QObject *parent = 0);
            ~MyClass();

            void setPriority(Priority priority);
            Priority priority() const;
        };
    \endcode

    Properties can be modified in subclasses with the \c Q_OVERRIDE()
    macro. The \c Q_FLAGS() macro declares enums that are to be used
    as flags, i.e. OR'd together. Another macro, \c Q_CLASSINFO(),
    allows you to attach additional name/value pairs to the class'
    meta-object:

    \code
        class MyClass : public QObject
        {
            Q_OBJECT
            Q_CLASSINFO("Author", "Oscar Peterson")
            Q_CLASSINFO("Status", "Active")

        public:
            MyClass(QObject *parent = 0);
            ~MyClass();
        };
    \endcode

    The output produced by \c moc must be compiled and linked, just
    like the other C++ code in your program; otherwise, the build
    will fail in the final link phase. If you use \c qmake, this is
    done automatically. Whenever \c qmake is run, it parses the
    project's header files and generates make rules to invoke \c moc
    for those files that contain a \c Q_OBJECT macro.

    If the class declaration is found in the file \c myclass.h, the
    moc output should be put in a file called \c moc_myclass.cpp.
    This file should then be compiled as usual, resulting in an
    object file, e.g. \e moc_myclass.obj on Windows. This object
    should then be included in the list of object files that are
    linked together in the final building phase of the program.

    If the class declaration is found in an implementation file, say,
    \c myclass.cpp, the \c moc output should be put in a file called
    \c myclass.moc. This file should be \c{#include}'d in the
    implementation file; in other words, \c myclass.cpp should
    contain the line

    \code
        #include "myclass.moc"
    \endcode

    at the end. This will cause the \c{moc}-generated code to be
    compiled and linked together with the normal class definition in
    \e myclass.cpp, so it is not necessary to compile and link it
    separately.

    This approach can be used in cases where you want the
    implementation file to be self-contained, or in cases where the
    \c Q_OBJECT class is implementation-internal and thus should not
    be visible in the header file.

    \section1 Automating \c moc Usage with Makefiles

    For anything but the simplest test programs, it is recommended
    that you automate running the \c{moc}. By adding some rules to
    your program's Makefile, \e make can take care of running moc
    when necessary and handling the moc output.

    We recommend using Trolltech's free makefile generation tool,
    \link qmake-manual.html qmake\endlink, for building your
    makefiles. This tool generates a makefile that does all the
    necessary \c moc handling.

    If you want to create your makefiles yourself, here are some tips
    on how to include moc handling.

    For \c Q_OBJECT class declarations in header files, here is a
    useful makefile rule if you only use GNU make:

    \code
        moc_%.cpp: %.h
                moc $< -o $@
    \endcode

    If you want to write portably, you can use individual rules with the
    following form:

    \code
        moc_foo.cpp: foo.h
                moc $< -o $@
    \endcode

    You must also remember to add \c moc_foo.cpp to your \c SOURCES
    (substitute your favorite name) variable and \e moc_foo.o or \e
    moc_foo.obj to your \c OBJECTS variable.

    (While we prefer to name our C++ source files \c .cpp, you can
    use any other extension, such as \c .C, \c .cc, \c .CC, \c .cxx,
    and \c .c++, if you prefer.)

    For \c Q_OBJECT class declarations in implementation (\c .cpp)
    files, we suggest a makefile rule like this:

    \code
        foo.o: foo.moc

        foo.moc: foo.cpp
                moc -i $< -o $@
    \endcode

    This guarantees that make will run the moc before it compiles
    \c foo.cpp. You can then put

    \code
        #include "foo.moc"
    \endcode

    at the end of \c foo.cpp, where all the classes declared in that
    file are fully known.

    \section1 Command-Line Options

    Here are the command-line options supported by the moc:

    \table
    \header \i Option \i Description
    \row
    \i \c{-o <file>}
    \i Write output to \c <file> rather than to standard output.
    \row
    \i \c -f
    \i Force the generation of an \c #include statement in the
    output. This is the default for files whose extension starts with
    \c H or \c h. This option is only useful if you have header files
    that do not follow the standard naming conventions.
    \row
    \i \c -i
    \i Do not generate an \c #include statement in the output.
    This may be used to run the moc on on a C++ file containing one or
    more class declarations. You should then \c #include the meta-object
    code in the \c .cpp file.
    \row
    \i \c -nw
    \i Do not generate any warnings. (Not recommended.)
    \row
    \row
    \i \c {-p <path>}
    \i Makes the moc prepend \c {<path>/} to the file name in the
    generated \c #include statement.
    \row
    \endtable

    You can explicitly tell the moc not to parse parts of a header
    file. \c moc defines the preprocessor symbol \c Q_MOC_RUN. Any
    code surrounded by

    \code
        #ifndef Q_MOC_RUN
	    ... 
        #endif
    \endcode

    is skipped by the \c moc.

    \section1 Diagnostics

    \c moc will warn you about a number of dangerous or illegal
    constructs in the \c Q_OBJECT class declarations.

    If you get linkage errors in the final building phase of your
    program, saying that \c YourClass::className() is undefined or
    that \c YourClass lacks a vtable, something has been done wrong.
    Most often, you have forgotten to compile or \c #include the
    moc-generated C++ code, or (in the former case) include that
    object file in the link command. If you use \c qmake, try
    rerunning it to update your makefile. This should do the trick.

    \section1 Limitations

    \c moc does not handle all of C++. The main problem is that class
    templates cannot have signals or slots. Here is an example:

    \code
        class SomeTemplate<int> : public QFrame
        {
            Q_OBJECT
	    ...

        signals:
            void mySignal(int);
        };
    \endcode

    Less importantly, the following constructs are illegal. All of
    them have alternatives which we think are usually better, so
    removing these limitations is not a high priority for us.

    \section2 Multiple Inheritance Requires QObject to Be First

    If you are using multiple inheritance, \c moc assumes that the
    first inherited class is a subclass of QObject. Also, be sure
    that only the first inherited class is a QObject.

    \code
        // correct
        class SomeClass : public QObject, public OtherClass
        {
	    ...
        };
    \endcode

    \section2 Function Pointers Cannot Be Signal or Slot Parameters

    In most cases where you would consider using function pointers as
    signal or slot parameters, we think inheritance is a better
    alternative. Here is an example of illegal syntax:

    \code
        class SomeClass : public QObject
        {
            Q_OBJECT

        public slots:
	    void apply(void (*apply)(List *, void *), char *); // WRONG
        };
    \endcode

    You can work around this restriction like this:

    \code
        typedef void (*ApplyFunction)(List *, void *);

        class SomeClass : public QObject
        {
            Q_OBJECT

        public slots:
            void apply(ApplyFunction, char *);
        };
    \endcode

    It may sometimes be even better to replace the function pointer
    with inheritance and virtual functions.

    \section2 Friend Declarations Cannot Be Placed in Signals or Slots Sections

    Sometimes it will work, but in general, friend declarations
    cannot be placed in signals or slots sections. Put them in the
    private, protected, or public sections instead. Here is an
    example of the illegal syntax:

    \code
        class SomeClass : public QObject
        {
            Q_OBJECT

        signals:
            friend class ClassTemplate<char>; // WRONG
        };
    \endcode

    \section2 Signals and Slots Cannot Be Upgraded

    The C++ feature of upgrading an inherited member function to
    public status is not extended to cover signals and slots. Here is
    an illegal example:

    \code
        class MyModel : public QAbstractItemModel
        {
	    Q_OBJECT

        public slots:
	    QAbstractItemModel::resetPersistentIndexes; // WRONG
	    ...
        };
    \endcode

    (The QAbstractItemModel::resetPersistentIndexes() slot is
    protected.)

    \section2 Type Macros Cannot Be Used for Signal and Slot Parameters

    Since QObject::connect() does not expand \c{#define}, type macros
    that take an argument will not work in signals and slots. Here is
    an illegal example:

    \code
        #ifdef ultrix
        #define SIGNEDNESS(a) unsigned a
        #else
        #define SIGNEDNESS(a) a
        #endif

        class Whatever : public QObject
        {
	    Q_OBJECT

        signals:
            void someSignal(SIGNEDNESS(int));
        };
    \endcode

    A \c #define without parameters won't work either, unless you
    expand it in the QObject::connect() call.

    \section2 Nested Classes Cannot Be in the Signals or Slots Sections or Have Signals or Slots

    Here's an example:

    \code
        class A
        {
	    Q_OBJECT

        public:
            class B
            {
	    public slots:   // WRONG
	        void b();
            };

        signals:
            class B         // WRONG
            {
	        void b();
            }:
        };
    \endcode

    \section2 Constructors Cannot Be Used in Signals or Slots Sections

    It is a mystery to us why anyone would put a constructor in
    either the signals or slots sections. You can't anyway (except
    that it happens to work in some cases). Put them in private,
    protected or public sections, where they belong. Here is an
    example of the illegal syntax:

    \code
        class SomeClass : public QObject
        {
	    Q_OBJECT

        public slots:
	    SomeClass(QObject *parent)    // WRONG
	        : QObject(parent) {}
        };
    \endcode
*/
