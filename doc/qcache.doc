/*!
    \class QCache
    \brief The QCache class is a template class that provides a cache.

    \ingroup qtl
    \ingroup tools
    \ingroup shared
    \mainclass
    \reentrant

    QCache\<Key, T\> defines a cache that store objects of type T
    associated with keys of type Key. For example, here's the
    definition of a cache that stores objects of type Employee
    associated with an integer key:

    \code
	QCache<int, Employee> cache;
    \endcode

    Here's how to insert an object in the cache:

    \code
	Employee *employee = new Employee;
        employee->setId(37);
        employee->setName("Richard Schmit");

	cache.insert(employee->id(), employee);
    \endcode

    The advantage of using QCache over some other key-based data
    structure (such as QMap or QHash) is that QCache automatically
    takes ownership of the items that are inserted into the cache and
    deletes them to make place for new items, if necessary. When
    inserting an item into the cache, you can specify a \e{cost},
    which should be grossly proportional to the amount of memory
    taken by the item. When the sum of all items' costs (totalCost())
    exceeds the cache's limit (maxCost()), QCache starts deleting
    items in the cache to stay under the limit, starting with less
    recently accessed items.

    By default, QCache's maxCost() is 100. You can specify a
    different value in the QCache constructor:

    \code
	QCache<int, MyDataStructure> cache(5000);
    \endcode

    Each time you call insert(), you can specify a cost as third
    argument (after the key and a pointer to the object to insert).
    After the call, the inserted item is owned by the QCache, which
    may delete it at any time to make place for other item.

    To look up items in the cache, use find() or operator[](). This
    function looks up an item by its key, and returns either a
    pointer to the cached object (which is owned by the cache) or 0.

    If you want to remove an item from the cache for a certain key,
    call remove(). This will also delete the item. If you want to
    remove an item from the cache without deleting it, call take().

    \sa QHash, QMap
*/

/*! \fn QCache::QCache(int maxCost = 100)

    Constructs a cache whose contents will never have a total cost
    greater than \a maxCost.
*/

/*! \fn QCache::~QCache()

    Destroys the cache. Deletes all items from the cache.
*/

/*! \fn int QCache::maxCost() const

    Returns the maximum allowed total cost of the cache.

    \sa setMaxCost(), totalCost()
*/

/*! \fn void QCache::setMaxCost(int cost)

    Sets the maximum allowed total cost of the cache to \a cost. If
    the current total cost is greater than \a cost, some items are
    deleted immediately.

    \sa maxCost(), totalCost()
*/

/*! \fn int QCache::totalCost() const

    Returns the total cost of the items in the cache. This value is
    never larger than maxCost().

    \sa setMaxCost()
*/

/*! \fn int QCache::size() const

    Returns the number of items in the cache.

    \sa isEmpty()
*/

/*! \fn int QCache::count() const

    Same as size().
*/

/*! \fn bool QCache::isEmpty() const

    Returns true if the cache contains no item; otherwise
    returns false.

    \sa size()
*/

/*! \fn bool QCache::operator!() const

    \internal
*/

/*! \fn QCache::operator QSafeBool() const

    Returns true if the cache contains at least one item; otherwise
    returns false.

    Example:
    \code
	static QCache<QString, MyGraphData *> cache;
        ...
        if (cache)
	    do_something(cache);
    \endcode

    This is the same as \c{!cache.isEmpty()}.

    \sa isEmpty()
*/

/*! \fn void QCache::clear();

    Removes all items from the cache.

    \sa remove(), take()
*/

/*! \fn void QCache::insert(const Key &key, T *data, int cost = 1)

    Inserts the item \a data into the cache with key \a key and
    associated cost \a cost. Any item with the same key already in
    the cache will be removed.

    After this call, the object pointed to by \a data is owned by the
    QCache and can be deleted at any time.

    \sa take(), remove()
*/

/*! \fn T *QCache::find(const Key &key) const

    Returns the item associated with key \a key, or 0 if the key does
    not exist in the cache.

    \warning The returned object is owned by QCache and can be
    deleted at any time.

    \sa take(), remove()
*/

/*! \fn bool QCache::contains(const Key &key) const

    Returns true if the cache contains an item associated with key \a
    key; otherwise returns false.

    \sa take(), remove()
*/

/*! \fn T *QCache::operator[](const Key &key) const

    Returns the item associated with key \a key, or 0 if the key does
    not exist in the cache.

    This is the same as find().

    \warning The returned object is owned by QCache and can be
    deleted at any time.
*/

/*! \fn bool QCache::remove(const Key &key)

    Removes any item associated with key \a key. Returns true if the
    item was found in the cache; otherwise returns false.

    \sa take(), clear()
*/

/*! \fn T *QCache::take(const Key &key)

    Takes the item associated with key \a key out of the cache
    without deleting it. Returns a pointer to the item taken out, or
    0 if the key does not exist in the cache.

    \sa remove()
*/

/*! \fn bool QCache::ensure_constructed()

    \internal
*/
