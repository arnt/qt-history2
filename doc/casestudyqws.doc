/****************************************************************************
** $Id: $
**
** Qt/Embedded Case Study
**
** Copyright (C) 1992-2000 Trolltech AS.  All rights reserved.
**
** This file is part of the Qt GUI Toolkit.
**
** This file may be distributed under the terms of the Q Public License
** as defined by Trolltech AS of Norway and appearing in the file
** LICENSE.QPL included in the packaging of this file.
**
** This file may be distributed and/or modified under the terms of the
** GNU General Public License version 2 as published by the Free Software
** Foundation and appearing in the file LICENSE.GPL included in the
** packaging of this file.
**
** Licensees holding valid Qt Enterprise Edition or Qt Professional Edition
** licenses may use this file in accordance with the Qt Commercial License
** Agreement provided with the Software.
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
**   information about Qt Commercial License Agreements.
** See http://www.trolltech.com/qpl/ for QPL licensing information.
** See http://www.trolltech.com/gpl/ for GPL licensing information.
**
** Contact info@trolltech.com if any conditions of this licensing are
** not clear to you.
**
**********************************************************************/
 
/*! \page casestudy-qws.html

\title Qt/Embedded Case Study - Cassiopeia E-100

\section1 Introduction

This document describes the steps involved in installing Linux on an embedded
device and building a Qt/Embedded application.  The target device is the
Cassiopeia E-100/E-105.  The device has a MIPS Vr4121 processor, 16MB RAM
(32MB in the E-105), a Compact Flash slot and a 240x320 16 bit per pixel LCD
display.

The only part of this document that is specific to the Cassiopeia is the
installation of Linux and the development tools.  The example application
can be compiled and run on your desktop machine.

\section1 Installing Linux

All the information and software required to get Linux running on the
VR series of processors is available from the 
\link http://www.linux-vr.org/ Linux VR\endlink web site.  In Summary:

\section2 Install the tools

Follow the instructions at
\l http://www.linux-vr.org/tools.html.

\section2 Build the kernel

Get a sample root ramdisk from
\l ftp://ftp.ltc.com/pub/linux/mips/ramdisk/ramdisk.

Follow the instructions at
\l http://www.linux-vr.org/ramdisk.html
to create a ramdisk.o file.

Now build your kernel
\l http://www.linux-vr.org/kernel.html
using this ramdisk object.  Make sure you have at least the following
configuration:

\list
\i Development/incomplete drivers
\i Casio E105 Platform
\i Network and System V IPC
\i RAM disk and Initial RAM disk support
\i Support for console on virtual terminal (so that you can see boot messages)
\i \c /proc and ext2 filesystem support
\i Simple Frame Buffer with HPC device control
\endlist

\section2 Booting Linux

Follow the instructions at
\l http://www.linux-vr.org/booting.html.

You should see the linux boot messages on the LCD display.

\section1 A Qt/Embedded Application

Usually a device such as the Cassiopeia would have a shell, configured as the
Qt/Embedded server, that allows client applications to be launched.
For the purposes of this tutorial, we will write a simple application that
serves as the Qt/Embedded server and client.  A more complete Qt/Embbeded
server can be found in \c $QTDIR/examples/compact.

The application that we will write is a simple note pad.  It will allow
notes to be created, viewed and deleted.  Since the Cassiopeia doesn't have
a keyboard, we will include a simple on-screen keyboard for input.

\section2 Note Pad

Our note pad user interface is very simple.  It consists of a toolbar with
"New" and "Delete" buttons, a combo box to select the note to view and
an editing area.

Take a moment to browse the source code for Note Pad in \c
$QTDIR/examples/notepad/. The code is quite simple, but there are some
things worth noting:

\list 1
\i Two fonts are set - helvetica 10 point as the application's default font,
and helvetica 12 point for the editor.  Since we will use prerendered fonts
these fonts must be prepared as \link fonts-qws.html described
here\endlink.
\i The QApplication is constructed with the QApplication::GuiServer type
specified.  This makes the note pad a Qt/Embedded server.  One server must
be running for Qt/Embedded clients to run.  In this case our application is
both server and client because it is the only application we wish to run on
our device.
\i The Cassiopeia (usually) has no keyboard so we must provide some means
of character input with the pen.  The simplest method is to display a small
keyboard.  The compact example includes a keyboard, so we use this code.
Key and pointer input is Qt/Embedded specific, so it is surrounded
by #ifdef Q_WS_QWS ...  #endif so that we can compile the example with Qt/X11
or Qt/Windows if we wish.
\i The touch panel needs to be calibrated.  There is a calibration module
included in the compact demo, so we use this.
\endlist

\section2 Creating a suitable Qt/Embedded Library

Since our application is quite simple we can remove some unnecessary
features from Qt/Embedded.  Edit \c $QTDIR/src/tools/qconfig.h and
disable the following features:
\code
    #define QT_NO_IMAGEIO_BMP
    #define QT_NO_IMAGEIO_PPM
    #define QT_NO_IMAGEIO_XBM
    #define QT_NO_IMAGEIO_PNG
    #define QT_NO_ASYNC_IO
    #define QT_NO_ASYNC_IMAGE_IO
    #define QT_NO_TRUETYPE
    #define QT_NO_BDF
    #define QT_NO_FONTDATABASE
    #define QT_NO_MIME
    #define QT_NO_SOUND
    #define QT_NO_PROPERTIES
    #define QT_NO_CURSOR
    #define QT_NO_NETWORKPROTOCOL
    #define QT_NO_COLORNAMES
    #define QT_NO_TRANSFORMATIONS
    #define QT_NO_PSPRINTER
    #define QT_NO_PICTURE
    #define QT_NO_LISTVIEW
    #define QT_NO_CANVAS
    #define QT_NO_DIAL
    #define QT_NO_WORKSPACE
    #define QT_NO_TABLE
    #define QT_NO_LCDNUMBER
    #define QT_NO_STYLE_MOTIF
    #define QT_NO_STYLE_PLATINUM
    #define QT_NO_COLORDIALOG
    #define QT_NO_PROGRESSDIALOG
    #define QT_NO_TABDIALOG
    #define QT_NO_WIZARD
    #define QT_NO_EFFECTS
\endcode

See \link features.html Qt Features\endlink for a description of the
features that can be disabled.  This leaves us with a small set of
widgets and dialogs necessary for our application.  Cross-compile the
library for the mips target on the x86 platform:
\code
    cd $QTDIR
    ./configure -xplatform linux-mips-g++ -platform linux-x86-g++
    make
    mipsel-linux-strip $QTDIR/lib/libqt.so.2.2.0
\endcode

The library is stripped to conserve ramdisk space.

\section2 Installation

Compile the application:
\code
    cd examples/notepad
    make
    mipsel-linux-strip notepad
\endcode

We have chosen to link the application dynamically.  While this is important
if we plan to run multiple applications, it is a waste of space in an
application such as notepad that is supposed to be the only application
running.  You can link statically by configuring with:
\code
    ./configure -static -xplatform linux-mips-g++ -platform linux-x86-g++
\endcode

We must install our application and its support files in the ramdisk.  Mount
the ramdisk using loopback device (you will need loopback device support
in your kernel):
\code
    mkdir /mnt/ramdisk
    mount -o loop ~/ramdisk /mnt/ramdisk
\endcode

Copy the Qt/Embedded library to the ramdisk \c /lib directory and make the
necessary links:
\code
    cd /mnt/ramdisk/lib
    cp $QTDIR/lib/libqt.so.2.2.0 .
    ln -s libqt.so.2.2.0 libqt.so.2.2
    ln -s libqt.so.2.2.0 libqt.so.2
\endcode

The fonts must be installed in \c /usr/local/qt-embedded/etc/fonts:
\code
    cd /mnt/ramdisk
    mkdir usr/local
    mkdir usr/local/qt-embedded
    mkdir usr/local/qt-embedded/etc
    mkdir usr/local/qt-embedded/etc/fonts
    cp helvetica_100_50.qlf helvetica_120_50.qlf usr/local/qt-embedded/etc/fonts
\endcode

When the kernel boots it looks for several files to run.  In order to
have our application run when the kernel boots, we change its name to
\c /bin/sh.  A \c /tmp directory is also used by Qt/Embedded:
\code
    cp $QTDIR/examples/notepad/notepad /mnt/ramdisk/bin/sh
    mkdir /mnt/ramdisk/tmp
    umount /mnt/ramdisk
\endcode

Create a ramdisk object, link it with the kernel, copy it to the compact flash
and boot Linux.  You should see the calibration screen appear on the LCD
display.

*/
