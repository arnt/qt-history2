/****************************************************************************
** $Id: qvaluelist.doc,v 1.5 1999/09/25 14:22:10 ettrich Exp $
**
** QValueList and QValueListIterator class documentation
**
** Copyright (C) 1992-2000 Trolltech AS.  All rights reserved.
**
** This file is part of the Qt GUI Toolkit.
**
** This file may be distributed under the terms of the Q Public License
** as defined by Trolltech AS of Norway and appearing in the file
** LICENSE.QPL included in the packaging of this file.
**
** This file may be distributed and/or modified under the terms of the
** GNU General Public License version 2 as published by the Free Software
** Foundation and appearing in the file LICENSE.GPL included in the
** packaging of this file.
**
** Licensees holding valid Qt Enterprise Edition or Qt Professional Edition
** licenses may use this file in accordance with the Qt Commercial License
** Agreement provided with the Software.
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
**   information about Qt Commercial License Agreements.
** See http://www.trolltech.com/qpl/ for QPL licensing information.
** See http://www.trolltech.com/gpl/ for GPL licensing information.
**
** Contact info@trolltech.com if any conditions of this licensing are
** not clear to you.
**
**********************************************************************/


/*****************************************************************************
  QValueList documentation
 *****************************************************************************/

/*!
  \class QValueList qvaluelist.h
  \brief The QValueList class is a value-based template class that provides doubly linked lists.

  \ingroup qtl
  \ingroup tools
  \ingroup shared
  
  QValueList is a Qt implementation of an STL-like list container.  It
  can be used in your application if the standard list<> is not
  available.  QValueList is part of the <a href="qtl.html"> Qt Template
  Library</a>.

  QValueList<T> defines a template instance to create
  a list of values that all have the class T. Please note that
  QValueList does not store pointers to the
  members of the list; it holds a copy of every member. This is why these
  kinds of classes are called "value based"; QPtrList and QDict are
  "pointer based".

  QValueList contains and manages a collection of objects of type T
  and provides iterators that allow the contained objects to be
  addressed.  QValueList owns the contained elements.  For more
  relaxed ownership semantics, see QPtrCollection and friends which are
  pointer-based containers.

  Some classes cannot be used within a QValueList - for example, all classes
  derived from QObject and thus all classes that implement widgets.
  Only values can be used in a QValueList. To qualify as a value the class
  must provide:

  <ul>
  <li>A copy constructor
  <li>An assignment operator
  <li>A default constructor, i.e., a constructor that does not take any arguments.
  </ul>

  Note that C++ defaults to field-by-field assignment operators and
  copy constructors if no explicit version is supplied. In many cases
  this is sufficient.

  QValueList uses an STL-like syntax to manipulate and address the
  objects it contains.  For historical reasons, QValueList contains
  additional functions which essentially perform the same task.  It is
  recommended that the STL-like functions be used in application code
  to ease the transition to a future version of Qt.  See <a
  href="qtl.html">this document</a> for more information.

  Example:
  \code
    #include <qvaluelist.h>
    #include <qstring.h>
    #include <stdio.h>

    class Employee
    {
    public:
	Employee(): s(0) {}
	Employee( const QString& name, int salary )
	    : n(name), s(salary)
	{}

	QString     name()   const	 	{ return n; }
	int	    salary() const	 	{ return s; }
	void	    setSalary( int salary )	{ s = salary; }
    private:
	QString     n;
	int         s;
    };

    void main()
    {
	typedef QValueList<Employee> EmployeeList;
	EmployeeList list;		// list of Employee

	list.push_back( Employee("Bill", 50000) );
	list.push_back( Employee("Steve",80000) );
	list.push_back( Employee("Ron",  60000) );

	Employee joe( "Joe", 50000 );
	list.push_back( joe );
	joe.setSalary( 4000 );
	
	EmployeeList::Iterator it;
	for( it = list.begin(); it != list.end(); ++it )
	    printf( "%s earns %d\n", (*it).name().latin1(), (*it).salary().latin1() );
    }
  \endcode

  Program output:
  \code
	Bill earns 50000
	Steve earns 80000
	Ron earns 60000
	Joe earns 50000
  \endcode

  As you can see, the latest changes to Joe's salary did not affect the value
  in the list because the list created a copy of Joe's entry.

  There are several ways to find items in the list.  The begin() and
  end() functions return iterators to the beginning and end of the
  list.  The advantage of getting an iterator is that you can now move
  forward or backward from this position by incrementing/decrementing
  the iterator.  The iterator returned by end() points to the element
  which is one past the last element in the container. The
  past-the-end iterator is still associated with the list it belongs
  to, however it is \e not dereferenceable; operator*() will not
  return a well-defined value. If the list is empty(), the iterator
  returned by begin() will equal the iterator returned by end().
  Since end() returns a past-the-end iterator, the size() of the list
  is equal to end() - begin().

  Another way to find an element in the list is by using the
  std::find() or <a href="qtl.h#qFind">qFind()</a> algorithms.  For
  example:

\code
  QValueList<int> list;
  ...
  QValueListIterator<int> it = std::find( list.begin(), list.end(), 3 );
  if ( it != list.end() )
      // it points to the found element
\endcode

  It is safe to have multiple iterators on the list at the same time.
  If some member of the list is removed, only iterators pointing to
  the removed member become invalid. Inserting into the list does not
  invalidate any iterator. For convenience, the function back() returns
  a reference to the last element in the list, and front() one for
  the first.  If the list is empty(), both back() and front() have
  undefined behavior (your application will crash or do unpredictable
  things).  Use back() and front() with caution, for example:

\code
  QValueList<int> list;
  list.push_back( 1 );
  list.push_back( 2 );
  list.push_back( 3 );
  ...
  if ( !list.empty() ) {
      // OK: modify the first element
      int& i = list.front();
      i = 18;
  }
  ...
  QValueList<double> dlist;
  double d = dlist.back(); // WARNING: undefined (probably a crash)
\endcode

  Because QValueList is value-based there is no need to be careful about
  deleting elements in the list. The list holds its own copies and
  will free them if the corresponding member or the list itself is
  deleted. You can force the list to free all of its items with
  clear().

  QValueList is shared implicitly, which means it can be copied in
  constant time. If multiple QValueList instances share the same data
  and one needs to modify its contents, this modifying instance makes
  a copy and modifies its private copy; it thus does not affect the
  other instances.  This is often called "copy on write".  If a
  QValueList is being used in a multi-threaded program, you must
  protect all access to the list.  See QMutex.

  There are several ways to insert elements into the list.  The
  push_front() and push_back() functions insert elements into the
  beginning and the end of the list respectively.  The insert()
  function comes in several flavors and can be used to add one or more
  elements at specific positions within the list.

  Items can be also be removed from the list in several ways. There
  are several variants of the erase() function which removes a
  specific element from the list.  The remove() function will find and
  remove elements according to a specific element value.

  Lists can be also sorted with the sort() function, or it can be
  sorted using the <a href="qtl.html">Qt Template Library</a>.  For
  example with qHeapSort():

  Example:
  \code
	  QValueList<int> l;
	  l.push_back( 5 );
	  l.push_back( 8 );
	  l.push_back( 3 );
	  l.push_back( 4 );
	  qHeapSort( l );
  \endcode

  \sa QValueListIterator
*/

/*! \enum QValueList::iterator 
	The list's iterator type. */
/*! \enum QValueList::const_iterator 
	The list's const iterator type. */
/*! \enum QValueList::value_type 
	The type of the object stored in the list. */
/*! \enum QValueList::pointer 
	The pointer to T type. */
/*! \enum QValueList::const_pointer 
	The const pointer to T type. */
/*! \enum QValueList::reference 
	The reference to T type. */
/*! \enum QValueList::const_reference 
	The const reference to T type. */
/*! \enum QValueList::size_type 
	An unsigned integral type, \c size_t. */
/*! \enum QValueList::difference_type 
	A signed integral type, \c ptrdiff_t. */

/*!
  \fn QValueList::QValueList()
  Constructs an empty list.
*/

/*!
  \fn QValueList::QValueList( const QValueList<T>& l )
  Constructs a copy of \e l.

  This operation costs O(1) time because QValueList is shared
  implicitly.

  The first modification to a list does however take O(n) time.
*/

/*! \fn QValueList::QValueList( const std::list<T>& l )
  Contructs a copy of \a l.
*/

/*!
  \fn QValueList::~QValueList()

  Destroys the list. References to the values in the list and all
  iterators of this list become invalidated. Note that it is
  impossible for an iterator to check whether or not it is valid -
  QValueList is highly tuned for performance, not error checking.
*/

/*!
  \fn bool QValueList::operator== ( const QValueList<T>& l ) const
  Compares both lists.

  Returns TRUE if both lists are equal otherwise returns FALSE.
*/

/*! \fn bool QValueList::operator== ( const std::list<T>& l ) const
  Returns TRUE if both lists are equal otherwise returns FALSE.
*/

/*!
  \fn QValueList<T>& QValueList::operator= ( const QValueList<T>& l )
  Assigns \e l to this list and returns a reference to this list.

  All iterators of the current list become invalidated by this operation.
  The cost of such an assignment is O(1) since QValueList is implicitly
  shared.
*/

/*! \fn QValueList<T>& QValueList::operator= ( const std::list<T>& l )
  Assigns the contents of \a l to the list.

  All iterators of the current list become invalidated by this operation.
*/

/*!
  \fn bool QValueList::operator!= ( const QValueList<T>& l ) const
  Compares both lists.

  Returns TRUE if both lists are unequal.
*/

/*!
  \fn Iterator QValueList::insert( Iterator it, const T& x )
  Inserts the value \e x in front of the iterator \e it.

  Returns an iterator pointing at the inserted item.

  \sa append(), prepend()
*/

/*!
  \fn uint QValueList::remove( const T& x )

  Removes all items that have value \e x and returns the number of removed
  items.

  \sa clear()
*/

/*!
  \fn void QValueList::clear()
  Removes all items from the list.

  \sa remove()
*/

/*!
  \fn Iterator QValueList::begin()
  Returns an iterator pointing to the first element in the list. This
  iterator equals end() if the list is empty.
  \sa first(), end()
*/

/*!
  \fn ConstIterator QValueList::begin() const
  Returns an iterator pointing to the first element in the list. This
  iterator equals end() if the list is empty.
  \sa first(), end()
*/

/*!
  \fn Iterator QValueList::end()
  Returns an iterator pointing behind the last element in the list. This
  iterator equals begin() if the list is empty.

  \sa last(), begin()
*/

/*!
  \fn ConstIterator QValueList::end() const
  Returns an iterator pointing behind the last element in the list. This
  iterator equals begin() if the list is empty.

  \sa last(), begin()
*/

/*!
  \fn QDataStream& operator>>( QDataStream& s, QValueList<T>& l )
  \relates QValueList
  Reads a list from the stream. The type \e T stored in the list must implement
  the streaming operator, too.
*/

/*!
  \fn QDataStream& operator<<( QDataStream& s, const QValueList<T>& l )
  \relates QValueList
  Writes a list to the stream. The type \e T stored in the list must implement
  the streaming operator, too.
*/

/*! \fn size_type QValueList::size() const
  Returns the number of elements in the list.
*/

/*! \fn size_type QValueList::max_size() const
  Returns the maximum possible size for the list.
*/

/*! \fn bool QValueList::empty() const
  Returns TRUE if and only if the list's size is zero.
*/

/*! \fn void QValueList::swap( QValueList<T>& x )
  Swaps the contents of this list with the contents of \a x.
*/

/*! \fn void QValueList::push_front( const T& x )
  Inserts \a x at the beginning of the list.
*/
 
/*! \fn void QValueList::push_back( const T& x )
  Inserts \a x at the end of the list.
*/

/*! \fn iterator QValueList::erase( iterator pos )
  Deletes the element pointed to by \a pos from the list.  No
  iterators other than \a pos or other iterators pointing at the same
  element as \a pos are invalidated.  Returns an iterator to the next
  element after \a pos, or end() if there is no such element.
*/

/*! \fn iterator QValueList::erase( iterator first, iterator last ) 
  Deletes all elements from \a first to \a last (not including \a
  last).  No iterators are invalidated, except those pointing to the
  removed elements themselves.  Returns \a last.
*/

/*! \fn reference QValueList::front()
  Returns a reference to the first element.  If the list contains no
  first element (i.e., empty() returns TRUE), the return value is
  undefined.
*/

/*! \fn const_reference QValueList::front() const
  Returns a reference to the first element.  If the list contains no
  first element (i.e., empty() returns TRUE), the return value is
  undefined.
*/

/*! \fn reference QValueList::back()
  Returns a reference to the last element.  If the list contains no
  last element (i.e., empty() returns TRUE), the return value is
  undefined.
*/

/*! \fn const_reference QValueList::back() const
  Returns a reference to the last element.  If the list contains no
  last element (i.e., empty() returns TRUE), the return value is
  undefined.
*/

/*! \fn void QValueList::pop_front()
  Removes the first element.  If there is no first element, this
  operation is undefined.
*/

/*! \fn void QValueList::pop_back() 
  Removes the last element.  If there is no last element, this
  operation is undefined.
*/

/*! \fn void QValueList::insert( iterator pos, size_type n, const T& x )
  Inserts \a n copies of \a x before \a pos.
*/

/*! \fn void QValueList::sort()
  Sorts the list using \<. 
*/

/*!
  \fn void QValueList::detach()
  If the list does not share its data with another QValueList instance, nothing
  happens. Otherwise the function creates a new copy of this data and detaches
  from the shared one. This function is called whenever the list is modified.
  The implicit sharing mechanism is implemented this way.
*/

/*!
  \fn QValueList<T>& QValueList::operator<< ( const T& x )

  Adds the value \e x to the end of the list.

  Returns a reference to the list.
*/

/*!
  \fn const T& QValueList::operator[] ( uint i ) const

  \warning This function is a linear search and can be
  extremely slow for large lists.  QValueList is not optimized for
  random element access.  Use a different container instead, such as
  QValueVector.

  Returns a const reference to the item with index \e i in the list.
  It is up to you to check whether this item really exists. You can do that easily
  with the count() function. However this operator does not check whether \e i
  is in range and will deliver undefined results if it does not exist.
*/

/*!
  \fn T& QValueList::operator[] ( uint i )

  \warning This function is a linear search and can be
  extremely slow for large lists.  QValueList is not optimized for
  random element access.  Use a different container instead, such as
  QValueVector.

  Returns a reference to the item with index \e i in the list.
  It is up to you to check whether this item really exists. You can do that easily
  with the count() function. However this operator does not check whether \e i
  is in range and will deliver undefined results if it does not exist.
  In contrast to the const operator[], you may manipulate the value returned by this
  operator.
*/

/*!
  \fn Iterator QValueList::at( uint i )


  Returns an iterator pointing to the item at position \e i in the list, or
  end() if the index is out of range.
*/

/*!
  \fn ConstIterator QValueList::at( uint i ) const

  \warning This function is a linear search and can be
  extremely slow for large lists.  QValueList is not optimized for
  random element access.  Use a different container instead, such as
  QValueVector.

  Returns an iterator pointing to the item at position \e i in the list, or
  end() if the index is out of range.
*/

/*!
  \fn Iterator QValueList::fromLast()

  Returns an iterator to the last element in the list, or end() if
  there is no last element.

  Use the end() function instead.  For example:

\code
  QValueList<int> l;
  ...
  QValueListIterator<int> it = l.end();
  --it;
  if ( it != end() )
      // ...
\endcode

*/

/*!
  \fn ConstIterator QValueList::fromLast() const

  Returns an iterator to the last element in the list, or end() if
  there is no last element.

  Use the end() function instead.  For example:

\code
  QValueList<int> l;
  ...
  QValueListIterator<int> it = l.end();
  --it;
  if ( it != end() )
      // ...
\endcode

*/

// *****************************************************
// Note : The following documentation is for historical reasons. 
// These functions should be avoided in new code.
// *****************************************************

/*!
  \obsolete
  \fn QValueList<T> QValueList::operator+ ( const QValueList<T>& l ) const

  The \c std::copy() or qCopy() algorithms should be used instead.

  Creates a new list and fills it with the elements of this list. Then the
  elements of \e l are appended.

  Returns the new list.
*/

/*! \obsolete
  \fn QValueList<T>& QValueList::operator+= ( const QValueList<T>& l )
  
  The \c std::copy() or qCopy algorithms should be used instead.  For
  example:

  \code
  QValueList<int> l1;
  QValueList<int> l2;
  ...
  std::copy( l2.begin(), l2.end(), std::back_inserter( l1 ) );
  \endcode

  Adds \e list to this list.

  Returns a reference to this list.
*/

/*!
  \obsolete
  \fn QValueList<T>& QValueList::operator+= ( const T& x )

  The push_back() function should be used instead.  For example:

  \code
  QValueList<int> l;
  l.push_back( 1 );
  \endcode

  Adds the value \e x to the end of the list.

  Returns a reference to the list.
*/

/*!
  \obsolete
  \fn uint QValueList::count() const

  Use the size() function instead.

*/

/*!
  \obsolete
  \fn bool QValueList::isEmpty() const

  Use the empty() function instead.

  \sa size()
*/

/*!
  \obsolete
  \fn Iterator QValueList::append( const T& x )

  The push_back() function should be used instead.  For example:

  \code
  QValueList<int> l;
  l.push_back( 1 );
  \endcode

*/

/*!
  \obsolete
  \fn Iterator QValueList::prepend( const T& x )

  The push_front() function should be used instead.  For example:

  \code
  QValueList<int> l;
  l.push_front( 2 );
  l.push_front( 1 );
  \endcode

*/

/*!
  \obsolete
  \fn Iterator QValueList::remove( Iterator it )

  Use the erase() function instead.

  \sa clear()
*/


/*!
  \obsolete
  \fn Iterator QValueList::find( const T& x )

  Use the std::find() or qFind() algorithms instead.

*/

/*!
  \obsolete
  \fn ConstIterator QValueList::find( const T& x ) const

  Use the std::find() or qFind() algorithms instead.

*/

/*!
  \obsolete
  \fn Iterator QValueList::find( Iterator it, const T& x )

  Use the std::find() or qFind() algorithms instead.

*/

/*!
  \obsolete
  \fn ConstIterator QValueList::find( ConstIterator it, const T& x ) const

  Use the std::find() or qFind() algorithms instead.

*/

/*!
  \obsolete
  \fn uint QValueList::contains( const T& x ) const

  Use the std::count() or qCount() algorithms instead.

*/

/*!
  \obsolete
  \fn int QValueList::findIndex( const T& x ) const
 
  Use the std::find() or qFind() algorithms instead.

*/

/*!
  \obsolete
  \fn T& QValueList::first()

  Use the front() function instead.

*/

/*!
  \obsolete
  \fn const T& QValueList::first() const

  Use the front() function instead.

*/

/*!
  \obsolete
  \fn T& QValueList::last()

  Use the back() function instead.

*/

/*!
  \obsolete
  \fn const T& QValueList::last() const

  Use the back() function instead.

*/

/*****************************************************************************
  QValueListIterator documentation
 *****************************************************************************/
/*!
  \class QValueListIterator qvaluelist.h
  \brief The QValueListIterator class provides an iterator for QValueList.

  \ingroup qtl
  \ingroup tools

  An iterator is an class for iterating across container classes - a
  generalization of the index in an array. A pointer into a
  <code>const char *</code> and an index into an <code>int[]</code>
  are both iterators, and the general idea is to provide that
  functionality for any data structure.

  The QValueListIterator class is an iterator for QValueList
  instantiations.

  Example:
  \include qtl/qvaluelistiterator.cpp

  Program output:
  \code
	Bill earns 50000
	Steve earns 80000
	Ron earns 60000
	Joe earns 50000
  \endcode

  In contrast to QPtrList there are no built in functions in QValueList
  to traverse the list. The only way to do this is to use iterators.

  QValueList is highly optimized for performance and memory usage.  On
  the other hand, this means you have to be a bit more careful with
  what you are doing. QValueList does not know about all its iterators
  and the iterators don't know to which list they belong. That makes
  things very fast, but if you're not careful, you can get spectacular
  bugs.

  QPtrListIterator will be able to give warnings while QValueListIterator
  may end up in an undefined state.

  For every Iterator there is a ConstIterator. When accessing a
  QValueList in a const environment or if the reference or pointer to
  the list is itself const, then you have to use the
  ConstIterator. Its semantics are the same as the Iterator, but it
  returns only const references.

  \sa QValueList, QValueListConstIterator
*/

/*! \enum  QValueListIterator::iterator_category 
	The type of iterator category, \c std::bidirectional_iterator_tag. */
/*! \enum  QValueListIterator::value_type
	The type of value, a pair. */
/*! \enum  QValueListIterator::difference_type
	A signed integral type.*/
/*! \enum  QValueListIterator::pointer
	Pointer to value_type. */
/*! \enum  QValueListIterator::reference
	Reference to value_type. */

/*!
  \fn QValueListIterator::QValueListIterator()
  Creates un uninitialized iterator.
*/

/*!
  \fn QValueListIterator::QValueListIterator( NodePtr p )
  Internal function.
*/

/*!
  \fn QValueListIterator::QValueListIterator( const QValueListIterator<T>& it )
  Constructs a copy of the iterator \e it.
*/

/* Unfortunately not with MSVC
  \fn T *QValueListIterator::operator->()
  Pointer operator. Returns a pointer to the current iterator item.
  The great advantage of this operator is that you can treat the
  iterator like a pointer.

  Example:
  \code
	QValueList<int>::Iterator it = list.begin();
	for( ; it != end(); ++it )
		it->show();
  \endcode
*/

/*!
  \fn T& QValueListIterator::operator*()
  Asterisk operator. Returns a reference to the current iterator item.
*/

/*!
  \fn const T& QValueListIterator::operator*() const
  Asterisk operator. Returns a reference to the current iterator item.
*/

/*!
  \fn QValueListIterator<T>& QValueListIterator::operator++()
  Prefix ++ makes the succeeding item current and returns
  an iterator pointing to the new current item.
  The iterator cannot check whether it reached the end of the list. Incrementing
  the iterator as returned by end() causes undefined results.
*/

/*!
  \fn QValueListIterator<T> QValueListIterator::operator++(int)
  Postfix ++ makes the succeeding item current and returns
  an iterator pointing to the new current item.
  The iterator cannot check whether it reached the end of the list. Incrementing
  the iterator as returned by end() causes undefined results.
*/

/*!
  \fn QValueListIterator<T>& QValueListIterator::operator--()
  Prefix -- makes the previous item current and returns
  an iterator pointing to the new current item.
  The iterator cannot check whether it reached the beginning of the list. Decrementing
  the iterator as returned by begin() causes undefined results.
*/

/*!
  \fn QValueListIterator<T> QValueListIterator::operator--(int)
  Postfix -- makes the previous item current and returns
  an iterator pointing to the new current item.
  The iterator cannot check whether it reached the beginning of the list. Decrementing
  the iterator as returned by begin() causes undefined results.
*/

/*!
  \fn bool QValueListIterator::operator==( const QValueListIterator<T>& it ) const
  Compares both iterators and returns TRUE if they point to the same item.
*/

/*!
  \fn bool QValueListIterator::operator!=( const QValueListIterator<T>& it ) const
  Compares both iterators and returns TRUE if they point to different items.
*/

/*****************************************************************************
  QValueListConstIterator documentation
 *****************************************************************************/

/*!
  \class QValueListConstIterator qvaluelist.h
  \brief The QValueListConstIterator class provides an iterator for QValueList.

  \ingroup qtl
  \ingroup tools

  In contrast to QValueListIterator, this class is used to iterate over a const
  list. It does not allow modification of the values of the list because it would
  break the const semantics.

  For more information on QValueList iterators, see QValueListIterator.

  \sa QValueListIterator, QValueList
*/

/*! \enum  QValueListConstIterator::iterator_category 
	The type of iterator category, \c std::bidirectional_iterator_tag. */
/*! \enum  QValueListConstIterator::value_type
	The type of value, a pair. */
/*! \enum  QValueListConstIterator::difference_type
	A signed integral type.*/
/*! \enum  QValueListConstIterator::pointer
	Pointer to value_type. */
/*! \enum  QValueListConstIterator::reference
	Reference to value_type. */

/*!
  \fn QValueListConstIterator::QValueListConstIterator()
  Creates un uninitialized iterator.
*/

/*!
  \fn QValueListConstIterator::QValueListConstIterator( NodePtr p )
  Internal function.
*/

/*!
  \fn QValueListConstIterator::QValueListConstIterator( const QValueListConstIterator<T>& it )
  Constructs a copy of the iterator \e it.
*/

/*!
  \fn QValueListConstIterator::QValueListConstIterator( const QValueListIterator<T>& it )
  Constructs a copy of the iterator \e it.
*/

/* Unfortunately not with MSVC
  \fn const T *QValueListConstIterator::operator->()
  Pointer operator. Returns a pointer to the current iterator item.
  The great advantage of this operator is that you can treat the
  iterator like a pointer.

  Example:
  \code
	QValueList<int>::Iterator it = list.begin();
	for( ; it != end(); ++it )
		it->show();
  \endcode
*/

/*!
  \fn const T& QValueListConstIterator::operator*() const
  Asterisk operator. Returns a reference to the current iterator item.
*/

/*!
  \fn QValueListConstIterator<T>& QValueListConstIterator::operator++()
  Prefix ++ makes the succeeding item current and returns
  an iterator pointing to the new current item.
  The iterator cannot check whether it reached the end of the list. Incrementing
  the iterator as returned by end() causes undefined results.
*/

/*!
  \fn QValueListConstIterator<T> QValueListConstIterator::operator++(int)
  Postfix ++ makes the succeeding item current and returns
  an iterator pointing to the new current item.
  The iterator cannot check whether it reached the end of the list. Incrementing
  the iterator as returned by end() causes undefined results.
*/

/*!
  \fn QValueListConstIterator<T>& QValueListConstIterator::operator--()
  Prefix -- makes the previous item current and returns
  an iterator pointing to the new current item.
  The iterator cannot check whether it reached the beginning of the list. Decrementing
  the iterator as returned by begin() causes undefined results.
*/

/*!
  \fn QValueListConstIterator<T> QValueListConstIterator::operator--(int)
  Postfix -- makes the previous item current and returns
  an iterator pointing to the new current item.
  The iterator cannot check whether it reached the beginning of the list. Decrementing
  the iterator as returned by begin() causes undefined results.
*/

/*!
  \fn bool QValueListConstIterator::operator==( const QValueListConstIterator<T>& it ) const
  Compares both iterators and returns TRUE if they point to the same item.
*/

/*!
  \fn bool QValueListConstIterator::operator!=( const QValueListConstIterator<T>& it ) const
  Compares both iterators and returns TRUE if they point to different items.
*/


/*! \enum QValueList::Iterator

  This iterator is an instantiation of QValueListIterator for the same
  type as this QValueList.  In other words, if you instantiate
  QValueList<int>, Iterator is a QValueListIterator<int>.  Several
  member function use it, such as QValueList::begin(), which returns
  an iterator pointing to the first item in the list.

  Functionally, this is almost the same as ConstIterator. The only
  difference is you cannot use ConstIterator for non-const operations,
  and that the compiler often can generate better code if you use
  ConstIterator.

  \sa QValueListIterator ConstIterator
*/

/*! \enum QValueList::ConstIterator

  This iterator is an instantiation of QValueListConstIterator for the
  same type as this QValueList.  In other words, if you instantiate
  QValueList<int>, ConstIterator is a QValueListConstIterator<int>.
  Several member function use it, such as QValueList::begin(), which
  returns an iterator pointing to the first item in the list.

  Functionally, this is almost the same as Iterator. The only
  difference is you cannot use ConstIterator for non-const operations,
  and that the compiler often can generate better code if you use
  ConstIterator.

  \sa QValueListIterator Iterator
*/
