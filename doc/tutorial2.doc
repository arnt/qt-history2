/*! \file /home/mark/p4/qt-3.0/examples/chart/chart.pro */
/*! \file /home/mark/p4/qt-3.0/examples/chart/element.h */
/*! \file /home/mark/p4/qt-3.0/examples/chart/element.cpp */
/*! \file /home/mark/p4/qt-3.0/examples/chart/main.cpp */
/*! \file /home/mark/p4/qt-3.0/examples/chart/canvastext.h */
/*! \file /home/mark/p4/qt-3.0/examples/chart/canvasview.h */
/*! \file /home/mark/p4/qt-3.0/examples/chart/canvasview.cpp */
/*! \file /home/mark/p4/qt-3.0/examples/chart/chartform.h */
/*! \file /home/mark/p4/qt-3.0/examples/chart/chartform.cpp */
/*! \file /home/mark/p4/qt-3.0/examples/chart/chartform_canvas.cpp */
/*! \file /home/mark/p4/qt-3.0/examples/chart/chartform_files.cpp */
/*! \file /home/mark/p4/qt-3.0/examples/chart/optionsform.h */
/*! \file /home/mark/p4/qt-3.0/examples/chart/optionsform.cpp */
/*! \file /home/mark/p4/qt-3.0/examples/chart/setdataform.h */
/*! \file /home/mark/p4/qt-3.0/examples/chart/setdataform.cpp */

/*!

\page tutorial2.html

\title Tutorial #2

This tutorial presents a more "real world" example of Qt programming
than the first tutorial. It introduces many aspects of Qt programming,
including the creation of menus (including a recent files list),
toolbars and dialogs, loading and saving user settings, etc. 

If you're completely new to Qt, please read \link how-to-learn-qt.html
How to Learn Qt\endlink if you haven't already done so.

\list
\i \link tutorial2-01.html Introduction\endlink
\i \link tutorial2-02.html The 'Big Picture'\endlink
\i \link tutorial2-03.html Data Elements\endlink
\endlist

<p align=right>
<a href="tutorial2-01.html">Introduction &raquo;</a> 
</p>
*/

/*!

\page tutorial2-01.html

\title Introduction

In this tutorial we will develop a single application called \c chart,
which is used to display simple pie and bar charts based on data that
the user enters. 

The tutorial gives an overview of the development of the application
and includes code snippets and accompanying explanations. The complete
source for the application is in \c examples/chart.

\img chart-main.png The chart application

<p align=right>
<a href="tutorial2.html">&laquo; Contents</a> |
<a href="tutorial2-02.html">The 'Big Picture' &raquo;</a>
</p>

*/

/*!

\page tutorial2-02.html

\title The 'Big Picture'

The \c chart program allows users to create, save, load and visualise
simple data sets. Each data element that the user enters can be given
a color and pattern for the pie segment or bar, some label text and
the text's position and color. 

The program consists of a simple \c main.cpp that loads the chart
form. The chart form has a menubar and toolbar which provide access to
the program's functionality. The program provides two dialogs, one to
set options (also called preferences or settings), and the other to
create and edit a data set. Both dialogs are launched from chart form
menu options or toolbar buttons.

The chart form's main widget is a QCanvasView which displays the
QCanvas on which we draw the pie chart or bar graph. We subclass
QCanvasView to obtain some specialised behaviour. Similarly we
subclass the QCanvasText class (used to place text items on a canvas)
since we require slightly more than the standard class provides.

The project file, \c chart.pro, is used to create the Makefile that is
used to build the application.

<p align=right>
<a href="tutorial2-01.html">&laquo; Introduction</a> |
<a href="tutorial2.html">Contents</a> |
<a href="tutorial2-03.html">Data Elements &raquo;</a>
</p>

*/

/*!

\page tutorial2-03.html

\title Data Elements

We will use a C++ class called \c Element to provide storage and
access for data elements.

\quotefile chart/element.h
\skipto #include
\printto class

The \c Element class is a purely internal data class, yet it
\c{#include}s four Qt classes. Although Qt is often perceived as a GUI
toolkit it provides many non-GUI classes to support most aspects of
application programming. We use \c qcolor.h so that we can hold the
paint color and text color in the \c Element class. The use of \c
qnamespace.h is slightly obscure. Most Qt classes are derived from the
Qt superclass which contains various enumerations. The \c Element
class does not derive from Qt, so we need to include \c qnamespace.h
to have access to the Qt enum names. An alternative approach would
have been to have made \c Element a Qt subclass. We include \c
qstring.h to make use of Qt's Unicode strings. As a convenience we
will \c typedef a vector container for Elements, which is why we pull
in the \c qvaluevector.h.

\skipto QValueVector
\printline

Qt provides a number of containers, some value based like
QValueVector, and others pointer based. (See \link collection.html
Collection Classes\endlink.) Here we've just typedefed one container
type; we will keep each data set of elements in one \c ElementVector.

\skipto const double EPSILON
\printline

Elements may only have positive values. Because we hold values as
doubles we cannot readily compare them with zero. Instead we specify a
value, \c EPSILON, which is close to zero, and consider any value
greater than \c EPSILON to be positive and valid.

\skipto class
\printto Element(

We define three public enums for Elements. \c INVALID is used by the
isValid() function. It is useful because we are going to use a fixed
size vector of Elements, and can mark unused Elements by giving them
\c INVALID values. The \c NO_POSITION enum is used to signify that the
user has not positioned the Element's label; any positive position
value is taken to be the position. 

The \c MAX_PROPOINTS enum is problematic. We need to store the (x, y)
position for the text label for every chart type. And we have chosen
to store these positions in a fixed-size array. Because of this we
must specify the maximum number of points needed. This value must be
changed if we change the number of chart types, which means that the
\c Element class is strongly coupled to the number of chart types
provided by the \c ChartForm class. In a realistic example we might
have used a vector to store these points and dynamically resized it
depending on how many chart types are available. 

If we stored the actual points, then every time the user resized the
main window (and therefore the canvas), the text would retain its
original (now incorrect) position. So instead of storing absolute (x,
y) positions we store \e proportional positions, i.e. x/width and
y/height. We can then multiply these positions by width and height
respectively when we come to draw the text and the text will be
positioned correctly regardless of any resizing.

\printto Element()


<p align=right>
<a href="tutorial2-02.html">&laquo; The 'Big Picture'</a> |
<a href="tutorial2.html">Contents</a> |
<a href="tutorial2-03.html">???? &raquo;</a>
</p>

*/
