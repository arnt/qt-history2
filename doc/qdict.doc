/****************************************************************************
** $Id: qdict.doc,v 1.1 1995/12/15 15:40:11 hanord Exp $
**
** QDict and QDictIterator class documentation
**
** Copyright (C) 1995 by Troll Tech AS.  All rights reserved.
*****************************************************************************/


/*****************************************************************************
  QDict documentation
 *****************************************************************************/

/*----------------------------------------------------------------------------
  \class QDict qdict.h
  \brief The QDict class is a template class that provides a dictionary based on \c char* keys.

  \ingroup collection

  QDict is implemented as both a template and a macro class. Define a
  template instance QDict\<X\> to create a dictionary that operates on
  pointers to X, or X*.

  A dictionary is a collection that associates an item with a key.
  The key is used for inserting and looking up an item.  QDict has
  \c char* keys.

  Example:
  \code
    #include <qdict.h>
    #include <stdio.h>

    void main()
    {
	QDict<char> dict( 17, FALSE );	// case-insensitive dict of char*

	dict.insert( "France", "Paris" );
	dict.insert( "Russia", "Moscow" );
	dict.insert( "Norway", "Oslo" );

	printf( "%s\n", dict["Norway"] );
	printf( "%s\n", dict["FRANCE"] );
	printf( "%s\n", dict["russia"] );

	if ( !dict["italy"] )
	    printf( "italy not defined\n" );
    }
  \endcode

  Program output:
  \code
	Oslo
	Paris
	Moscow
	italy not defined
  \endcode

  The dictionary in our example maps \c char* keys to \c char* items.
  Note that the mapping is case-insensitive (set in the constructor).
  QDict implements the [] operator to lookup an item.

  The dictionary item's class or type, \c char* in our example, must be
  defined prior to the dictionary definition. Some compilers allow a
  QDict\<X\> before X is defined and assume that X has no destructor.

  \code
    // Bad code: X's destructor will never be called
    class X;
    QDict<X> dict;

    // Good code: X is defined before it is used
    class X {
 	...
    };
    QDict<X> dict;
  \endcode

  A dictionary can also be instantiated through a macro expansion, but this
  is necessary only for compilers that do not support templates. See the
  \link collectionclasses.html collection classes documentation\endlink
  for a general discussion on template-based versus macro-based collections.

  Macro expansion:
  \code
      ...
    declare(QDictM,X);			// declares the dictionary

    void main()
    {
	QDictM(X) dict;			// dict of pointers to X
      ...
  \endcode

  If you want to make your code work for compilers that do not have
  template support, but use templates if they are available, you
  can use \c typedef:

  \code
      ...
    #if defined(USE_TEMPLATECLASS)
    typedef QDictT<X>	      XDict;
    #else
    typedef declare(QDictM,X) XDict;
    #endif

    void main()
    {
	XDict dict;			// dict of pointers to X
      ...
  \endcode
  
  QDictT refers to the QDict template and QDictM refers to the QDict macro.
  QDict defaults to QDictT if templates are supported, QDictM otherwise.

  QDict is implemented as a hash array with a fixed number of entries.  
  Each array entry points to a singly linked list of buckets, in which
  the dictionary items are stored.

  When an item is inserted with a key, the key is converted (hashed) to
  an integer index into the hash array. The item is inserted before the
  first bucket in the list of buckets.

  Looking up an item is normally very fast. The key is again hashed to an
  array index. Then QDict scans the list of buckets and returns the item
  found or null if the item was not found.  It is not permitted to insert
  null pointers into a dictionary.

  The size of the hash array is very important. In order to get good
  performance, you should use a suitably large prime number.
  Suitable means equal to or larger than the maximum expected number
  of dictionary items.

  Items with equal keys are allowed.  When inserting two items with the
  same key, only the last inserted item will be visible (last in, first out)
  until it is removed.

  Example:
  \code
    #include <qdict.h>
    #include <stdio.h>

    void main()
    {
	QDict<char> dict;		// case-sensitive dict of char*

	dict.insert( "Germany", "Berlin" );
	dict.insert( "Germany", "Bonn" );

	printf( "%s\n", dict["Germany"] );
	dict.remove( "Germany" );	// Oct 3rd 1989
	printf( "%s\n", dict["Germany"] );
    }
  \endcode

  Program output:
  \code
	Bonn
	Berlin
  \endcode

  The QDictIterator class can traverse the dictionary contents, but only
  in an arbitrary order.  Multiple iterators may independently traverse the
  same dictionary.

  Calling setAutoDelete(TRUE) for a dictionary tells it to delete items
  that are removed .  The default is to not delete items when they are
  removed.

  When inserting an item into a dictionary, only the pointer is copied, not
  the item itself. This is called a shallow copy. It is possible to make the
  dictionary copy all of the item's data (known as a deep copy) when an
  item is inserted.  insert() calls the virtual function
  QCollection::newItem() for the item to be inserted.
  Reimplement it if you want deep copies.

  When removing a dictionary item, the virtual function
  QCollection::deleteItem() is called.  QDict's default implementation
  is to delete the item if auto-deletion is enabled.

  \sa QDictIterator, QIntDict,
      \link collectionclasses.html collection classes\endlink
 ----------------------------------------------------------------------------*/


/*----------------------------------------------------------------------------
  \fn QDict::QDict( int size, bool caseSensitive=TRUE, bool copyKeys=TRUE )
  Constructs a dictionary with the following properties:
  \arg \e size is the size of the internal hash array.
  \arg \e caseSensitive specifies whether to use case-sensitive lookup or not.
  \arg \e copyKeys specifies whether to copy the key strings.

  Setting \e size to a suitably big prime number makes the hash distribution
  better and hence the loopup faster.

  Setting \e caseSensitive to TRUE will treat "abc" and "Abc" as different
  keys.  Setting it to FALSE will make the dictionary ignore case.
  Case-insensitive comparision includes only the 26 standard letters A..Z,
  not French, German or Scandinavian accents.

  Setting \e copyKeys to TRUE will make the dictionary copy the key
  when an item is inserted.  Setting it to FALSE will make the dictionary
  only use the pointer to the key.
 ----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------
  \fn QDict::QDict( const QDict\<type\> &dict )
  Constructs copy of \e dict.

  Each item in \e dict are inserted into this dictionary.
  Only the pointers are copied (shallow copy).
 ----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------
  \fn QDict::~QDict()
  Removes all items from the dictionary and destroys it.

  All iterators that access this dictionary will be reset.

  \sa setAutoDelete()
 ----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------
  \fn QDict\<type\> &QDict::operator=(const QDict\<type\> &dict)
  Assigns \e dict to this dictionary and returns a reference to this
  dictionary.

  This dictionary is first cleared, then each item in \e dict is inserted
  into this dictionary.
  Only the pointers are copied (shallow copy), unless newItem() has been
  reimplemented().
 ----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------
  \fn uint QDict::count() const
  Returns the number of items in the dictionary.
  \sa isEmpty()
 ----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------
  \fn uint QDict::size() const
  Returns the size of the internal hash array.
  \sa count()
 ----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------
  \fn bool QDict::isEmpty() const
  Returns TRUE if the dictionary is empty, i.e. count() == 0, otherwise
  FALSE.
  \sa count()
 ----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------
  \fn void QDict::insert( const char *key, const type *item )
  Inserts the \e key with the \e item into the dictionary.

  The key does not have be a unique dictionary key.  If multiple items
  are inserted with the same key, only the last item will be visible.

  Null items are not permitted.

  \sa replace()
 ----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------
  \fn void QDict::replace( const char *key, const type *item )
  Replaces an item which has a key equal to \e key with \e item.

  If the item does not already exist, it will be inserted.

  Null items are not permitted.

  Equivalent to:
  \code
    QDict<char> dict;
	...
    if ( dict.find(key) )
	dict.remove( key );
    dict.insert( key, item );
  \endcode

  \sa insert()
 ----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------
  \fn bool QDict::remove( const char *key )
  Removes the item associated with \e key from the dictionary.
  Returns TRUE if successful, or FALSE if the key does not exist in the
  dictionary.

  If there are two or more items with equal keys, then the last inserted
  of these will be removed.

  The removed item is deleted if \link QCollection::setAutoDelete()
  auto-deletion\endlink is enabled.

  All dictionary iterators that refer to the removed item will be set to
  point to the next item in the dictionary travering order.

  \sa take(), clear(), setAutoDelete()
 ----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------
  \fn type *QDict::take( const char *key )
  Takes the item associated with \e key out of the dictionary without
  deleting it (even if \link QCollection::setAutoDelete()
  auto-deletion\endlink is enabled).

  If there are two or more items with equal keys, then the last inserted
  of these will be taken.

  Returns a pointer to the item taken out, or null if the key does not
  exist in the dictionary.

  All dictionary iterators that refer to the taken item will be set to
  point to the next item in the dictionary travering order.

  \sa remove(), clear(), setAutoDelete()
 ----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------
  \fn void QDict::clear()
  Removes all items from the dictionary.

  The removed items are deleted if \link QCollection::setAutoDelete()
  auto-deletion\endlink is enabled.

  All dictionary iterators that access this dictionary will be reset.

  \sa remove(), take(), setAutoDelete()
 ----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------
  \fn type *QDict::find( const char *key )
  Returns the item associated with \e key, or null if the key does not
  exist in the dictionary.

  If there are two or more items with equal keys, then the last inserted
  of these will be found.

  Case-sensitivity can be specified in the constructor.

  Equivalent to the [] operator.

  \sa operator[]
 ----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------
  \fn type *QDict::operator[]( const char *key )
  Returns the item associated with \e key, or null if the key does not
  exist in the dictionary.

  If there are two or more items with equal keys, then the last inserted
  of these will be found.

  Case-sensitivity can be specified in the constructor.

  Equivalent to the find() function.

  \sa find()
 ----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------
  \fn void QDict::statistics()
  Debugging-only function that prints out the dictionary distribution
  using debug().
 ----------------------------------------------------------------------------*/


/*****************************************************************************
  QDictIterator documentation
 *****************************************************************************/

/*----------------------------------------------------------------------------
  \class QDictIterator qdict.h
  \brief The QDictIterator class provides an iterator for QDict collections.

  \ingroup iterators

  QDictIterator is implemented as both a template and a macro class.
  Define a template instance QDictIterator\<X\> to create a
  dictionary iterator that operates on QDict\<X\> (dictionary of X*).

  Example:
  \code
    #include <qdict.h>
    #include <stdio.h>

    void main()
    {
	QDict<char> dict( 17, FALSE );	// case-insensitive dict of char*

	dict.insert( "France", "Paris" );
	dict.insert( "Russia", "Moscow" );
	dict.insert( "Norway", "Oslo" );

	QDictIterator<char> it( dict ); // iterator for dict

        while ( it.current() ) {
	    printf( "%s -> %s\n", it.currentKey(), it.current() );
	    ++it;
	}
    }
  \endcode

  Program output:
  \code
	Russia -> Moscow
	Norway -> Oslo
	France -> Paris
  \endcode

  Note that the traversal order is arbitrary and may not occur in the
  order above.

  A macro expansion can be used instead of templates, but then you
  must first declare a QDictIterator:

  Macro expansion:
  \code
      ...
    declare(QDictIteratorM,X);		  // declares the iterator

    void main()
    {
      ...
	QDictIteratorM(X) it;		  // dictionary iterator
      ...
  \endcode

  See the \link QDict QDict documentation\endlink for how to combine
  templates and macros in the same code.

  Multiple iterators may independently traverse the same dictionary.
  A QDict knows about all iterators that are operating on the dictionary.
  When an item is removed from the dictionary, the QDict update all iterators
  that are referring to the removed item to point to the next item in the
  traversing order.

  \sa QDict, \link collectionclasses.html collection classes\endlink
 ----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------
  \fn QDictIterator::QDictIterator( const QDict\<type\> &dict )
  Constructs an iterator for \e dict.  The current iterator item is
  set to point on the first item in the \e dict.
 ----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------
  \fn QDictIterator::~QDictIterator()
  Destroys the iterator.
 ----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------
  \fn uint QDictIterator::count() const
  Returns the number of items in the dictionary.
  \sa isEmpty()
 ----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------
  \fn bool QDictIterator::isEmpty() const
  Returns TRUE if the dictionary is empty, i.e. count() == 0, otherwise FALSE.
  \sa count()
 ----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------
  \fn type *QDictIterator::toFirst()
  Sets the current iterator item to point to the first item in the
  dictionary and returns a pointer to the item.
  Sets the current item to null and returns null if if the dictionary is
  empty.
 ----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------
  \fn QDictIterator::operator type *() const
  Cast operator. Returns a pointer to the current iterator item.
  Same as current().
 ----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------
  \fn type *QDictIterator::current() const
  Returns a pointer to the current iterator item.
 ----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------
  \fn const char *QDictIterator::currentKey() const
  Returns a pointer to the key for the current iterator item.
 ----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------
  \fn type *QDictIterator::operator()()
  Makes the succeeding item current and returns the original current item.

  If the current iterator item was the last item in the dictionary or if it
  was null, null is returned.
 ----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------
  \fn type *QDictIterator::operator++()
  Prefix ++ makes the succeeding item current and returns the new current
  item.

  If the current iterator item was the last item in the dictionary or if it
  was null, null is returned.
 ----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------
  \fn type *QDictIterator::operator+=( uint jump )
  Returns the item \e jump positions after the current item, or null if
  it is beyond the last item.  Makes this the current item.
 ----------------------------------------------------------------------------*/
