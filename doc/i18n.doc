/****************************************************************************
** $Id: i18n.doc,v 1.12 1999/03/18 02:42:32 warwick Exp $
**
** Explanation of moc and the meta object system
**
** Copyright (C) 1992-1999 Troll Tech AS.  All rights reserved.
**
** This file is part of the Qt GUI Toolkit.
**
** This file may be distributed under the terms of the Q Public License
** as defined by Troll Tech AS of Norway and appearing in the file
** LICENSE.QPL included in the packaging of this file.
**
** Licensees with valid Qt Professional Edition licenses may distribute and
** use this file in accordance with the Qt Professional Edition License
** provided at sale or upon request.
**
** See http://www.troll.no/pricing.html or email sales@troll.no for
** information about the Professional Edition licensing, or see
** http://www.troll.no/qpl/ for QPL licensing information.
**
*****************************************************************************/

/*! \page i18n.html

<title>
Qt toolkit - Internationalization
</title></head><body bgcolor="#ffffff">

\postheader

<h1 align=center>Internationalization with Qt</h1><br clear="all">

Internationalization of software is the process of allowing the
software to be used efficiently by all people of the world.  This
means adapting to user and locality preferences such as language,
input techniques, character sets, and presentation conventions.


<h2>Step by Step</h2>

Writing cross-platform international software with Qt is a gentle,
incremental process.  Your software can become internationalized
in the following stages:

<ol>
 <li><b>Use QString for all user-visible text.</b>
	<p>
	Since QString uses the Unicode encoding internally, all the
	languages of the world can be processed transparently using
	familiar text processing operations.  Also, since all Qt functions
	that present text to the user take a QString as a parameter,
	there is no char* to QString conversion time.
	<p>
	Strings that are in "programmer space" - such as QObject
	names and file format texts need not use QString - the
	traditional char*, or the QCString class will suffice.
	</p>
 <li><b>Use \link QObject::tr() tr()\endlink for all literal text.</b>
	<p>
	Whe you use <tt>"quoted text"</tt> in the program for text
	that will be presented to the user, ensure it goes through
	the QApplication::translate() function by using tr() if the
	quoted text is in a QObject/QWidget subclass, eg.:
	\code
	LoginWidget::LoginWidget()
	{
	    QLabel *label = new QLabel( tr("Password:"), this );
	    ...
	}
	\endcode
	or, if the quoted text is not in a member function, by using
	the tr() function of an approriate class, or the
	QApplication::translate() function directly:
	\code
	void some_global_function(LoginWidget* logwid)
	{
	    QLabel *label = new QLabel( LoginWidget::tr("Password:"), logwid );
	}

	void same_global_function(LoginWidget* logwid)
	{
	    QLabel *label = new QLabel( qApp->translate("LoginWidget", "Password:"), logwid );
	}
	\endcode
	</p>
 <li><b>Use QTranslator to load translated text.</b>
	<p>
	Once you are using tr() sufficiently, you can start producing
	translations of the user-visible text in your program.
	<p>
	Provided with Qt is a utility program, findtr, that will extract
	information about text to be translated.  It recognizes the constructs
	above, plus two additions: qt_tr_noop() and qt_translate_noop(),
       	for use in code where it is convenient to put the strings
	outside the tr() parameters:
	\code
	QString FriendlyConversation::greeting(int greet_type)
	{
	    static const char* greeting_strings[] = {
		qt_tr_noop("Hello"),
		qt_tr_noop("Goodbye")
	    };
	    return tr(greeting_strings[greet_type]);
	}

	static const char* greeting_strings[] = {
	    qt_translate_noop("FriendlyConversation","Hello"),
	    qt_translate_noop("FriendlyConversation","Goodbye")
	};
	QString FriendlyConversation::greeting(int greet_type)
	{
	    return tr(greeting_strings[greet_type]);
	}
	\endcode
	<i>The current version is a simple shell script that produces
	    a .po file, which can be converted to a .qm file that QTranslator
	    can load.</i>
	</p>
 <li><b>Use the QString::arg() for simple arguments.</b>
	<p>
	The printf style of inserting arguments in strings
	is a poor choice for internationalized text, as it is often
	necessary to change the order of arguments when translating.
	The QString::arg() functions offer simple
	means for numbered arguments.
	</p>
 <li><b>Support encodings.</b>
	<p>
	The QTextCodec class and the facilities in QTextStream
	make it easy to support many input and
	output encodings for your users' data.  Ideally, we recommend
	that Unicode I/O be used as this maximizes the portability
	of documents between users around the world, but in reality
	it is useful to support all the appropriate formats that
	your users' will need to process existing documents. In general,
	Unicode (Utf16 or Utf8) is the best for information transferred
	between arbitrary people, while within a language or national group,
	a local standard is often more appropriate.
	</p>
 <li><b>Localization.</b>
	<p>
	Localization is the process of adapting to local conventions
	such as date presentation.
	</p>
</ol>


<h2>System Support</h2>

Operating system and window system support for Unicode is still in
the early stages, and varies between systems.  The level of support
available in the underlying system influences the support Qt provides
on that platform, but applications written with Qt need not generally
be too concerned with the actual limitations.
<dl compact>
  <dt>Unix/X11
    <dd><ul>
     <li>Locale-oriented fonts and input methods.  Qt hides these and
	    provides Unicode input and output.
     <li>Filesystem conventions such as UTF-8 are under development
	    in some Unix variants.  All Qt file functions allow Unicode,
	    but currently converts all filenames to Latin-1.
     <li>File I/O defaults to Latin-1, with Unicode options in QTextStream.
     </ul>
  <dt>Windows NT
    <dd><ul>
     <li>Qt provides full Unicode support, including input methods, fonts,
	    drag-and-drop, file names.
     <li>File I/O defaults to Latin-1, with Unicode options in QTextStream.
	  Note that some Windows programs do not understand big-endian
	  Unicode text files even though that is the order prescribed by
	  the Unicode Standard in the absence of higher-level protocols.
    </ul>
  <dt>Windows 95/98
    <dd><ul>
     <li>Qt provides Unicode internally, but no Windows internationalization
	    is used as it is greatly different from Unicode.
     <li>File I/O defaults to Latin-1, with Unicode options in QTextStream.
    </ul>
</dl>

<h2>Note about Kinput2</h2>

If using the Kinput2 XIM Server, users may need to apply the
bug-fix patch below.  Without this patch, Kinput2 produces bad
XIM Protocol, causing application lock-up.
<p>
For a recent version of Kinput2 that includes all users need, see
<a href=ftp://ftp.sra.co.jp/pub/x11/kinput2/>
ftp://ftp.sra.co.jp/pub/x11/kinput2/</a>

<p>Patch...
\code
--- lib/imlib/imrequest.c~	Mon Feb  3 10:21:46 1997
+++ lib/imlib/imrequest.c	Wed Mar 10 19:23:09 1999
@@ -844,6 +844,6 @@
 	IMSendBadLength(conn, icp->im->id, icp->id);
 	return;
     }
-    IMDestroyIC(icp);
     IMSendRequestWithIC(conn, XIM_DESTROY_IC_REPLY, 0, icp);
+    IMDestroyIC(icp);
 }
\endcode


<h2>Supporting more Input Methods</h2>

While Troll Tech doesn't have the resources or expertise in all
the languages of the world to immediately include support in Qt,
we are very keen to work with people who <em>do</em> have the
expertise.  Over the next few versions, we hope to add support
for <em>your</em> language of choice, until everyone can use Qt,
and all the programs developed with Qt, regardless of their
language.

Initially, languages with uni-directional single-byte encodings
(European Latin1 and KOI8-R, etc.)
will be refined.
Then, the uni-directional multi-byte encodings (East Asian
EUC-JP, etc.) will be supported. Finally, support for the "complex"
encodings - those requiring right-to-left input or complex character
composition (eg. Arabic and Thai script) will be implemented.
The current state of activity is:
<dl compact>
 <dt><b>Latin1</b>
  <dd>Fully supported, as before.
 <dt><b>KOI8-R</b>
  <dd>Fully supported.
 <dt><b>eucJP, JIS, and ShiftJIS</b>
  <dd>Supported with the XIMP protocol on X11.
	Windows NT support under development.
	Serika Kurusugawa is assisting with this effort.
	<a href=ftp://ftp.sra.co.jp/pub/x11/kinput2/>kinput2</a>
	is the tested input method.
 <dt><b>eucKR</b>
  <dd>Under development, 
	Mizi Research are assisting with this effort.
	<a href=http://www.mizi.com/>hanIM</a>
       	is the tested input method.
</dl>

Eventually, we hope to help Unix become as Unicode-oriented as
Windows NT is becoming.
This means better font support in the font servers,
with new developments like the True Type font servers
<a href=http://www.dcs.ed.ac.uk/home/jec/programs/xfsft/>xfsft</a>,
<a href=ftp://sunsite.unc.edu/pub/Linux/X11/fonts>xfstt</a>,
and
<a href=http://hawk.ise.chuo-u.ac.jp/student/person/tshiozak/x-tt/>x-tt</a>,
as well as UTF-8 (a Unicode encoding) filenames such as with the
<a href=http://www.sun.com/software/white-papers/wp-unicode/>Unicode
support in Solaris<sup class="tm"><font size="-1">TM</font></sup> 7</a>.

*/
