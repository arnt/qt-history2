/****************************************************************************
** $Id: $
**
** Explanation of moc and the meta object system
**
** Copyright (C) 1992-2000 Trolltech AS.  All rights reserved.
**
** This file is part of the Qt GUI Toolkit.
**
** This file may be distributed under the terms of the Q Public License
** as defined by Trolltech AS of Norway and appearing in the file
** LICENSE.QPL included in the packaging of this file.
**
** This file may be distributed and/or modified under the terms of the
** GNU General Public License version 2 as published by the Free Software
** Foundation and appearing in the file LICENSE.GPL included in the
** packaging of this file.
**
** Licensees holding valid Qt Enterprise Edition or Qt Professional Edition
** licenses may use this file in accordance with the Qt Commercial License
** Agreement provided with the Software.
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
**   information about Qt Commercial License Agreements.
** See http://www.trolltech.com/qpl/ for QPL licensing information.
** See http://www.trolltech.com/gpl/ for GPL licensing information.
**
** Contact info@trolltech.com if any conditions of this licensing are
** not clear to you.
**
**********************************************************************/

/*! \defgroup i18n

\title Internationalization with Qt

\keyword internationalization
\keyword i18n

The internationalization of an application is the process of making
the application usable by people in countries other than one's own. 

In some cases internationalization is simple, for example, making a US
application accessible to Australian or British users may require
little more than a few spelling corrections. But to make a US
application usable by Japanese users, or a Korean application usable
by German users, will require that the software operate not only in
different languages, but use different input techniques, character
encodings and presentation conventions.

See also the \link linguist-manual.book Qt Linguist\endlink manual.

\section1 Step by Step

Writing multiplatform international software with Qt is a gentle,
incremental process. Your software can become internationalized in
the following stages:

\section2 Use QString for all User-visible Text

Since QString uses the Unicode encoding internally, every
language in the world can be processed transparently using
familiar text processing operations. Also, since all Qt
functions that present text to the user take a QString as a
parameter, there is no char* to QString conversion time overhead.

Strings that are in "programmer space" (such as QObject names
and file format texts) need not use QString; the traditional
char* or the QCString class will suffice.

You're unlikely to notice that you are using Unicode;
QString, and QChar are just like easier versions of the crude
const char* and char from traditional C.

\section2 Use \link QObject::tr() tr()\endlink for all Literal Text

Wherever your program uses \c{"quoted text"} for text that will
be presented to the user, ensure that it is processed by the \l
QApplication::translate() function. Essentially all that is necessary
to achieve this is to use \l QObject::tr(). For example, assuming the
\c LoginWidget is a subclass of QWidget:

\code
    LoginWidget::LoginWidget()
    {
	QLabel *label = new QLabel( tr("Password:"), this );
	...
    }
\endcode

This accounts for 99% of the user-visible strings you're likely to
write.

If the quoted text is not in a member function of a
QObject subclass, use either the tr() function of an
appropriate class, or the QApplication::translate() function
directly:

\code
    void some_global_function( LoginWidget *logwid )
    {
	QLabel *label = new QLabel(
		LoginWidget::tr("Password:"), logwid );
    }

    void same_global_function( LoginWidget *logwid )
    {
	QLabel *label = new QLabel(
		qApp->translate("LoginWidget", "Password:"),
		logwid );
    }
\endcode

If you need to have translatable text completely
outside a function, there are two macros to help: QT_TR_NOOP()
and QT_TRANSLATE_NOOP(). They merely mark the text for
extraction by the \e lupdate utility described below.
The macros expand to just the text (without the context).

Example of QT_TR_NOOP():
\code
    QString FriendlyConversation::greeting( int greet_type )
    {
	static const char* greeting_strings[] = {
	    QT_TR_NOOP( "Hello" ),
	    QT_TR_NOOP( "Goodbye" )
	};
	return tr( greeting_strings[greet_type] );
    }
\endcode

Example of QT_TRANSLATE_NOOP():
\code
    static const char* greeting_strings[] = {
	QT_TRANSLATE_NOOP( "FriendlyConversation", "Hello" ),
	QT_TRANSLATE_NOOP( "FriendlyConversation", "Goodbye" )
    };

    QString FriendlyConversation::greeting( int greet_type )
    {
	return tr( greeting_strings[greet_type] );
    }

    QString global_greeting( int greet_type )
    {
	return qApp->translate( "FriendlyConversation",
				greeting_strings[greet_type] );
    }
\endcode

If you disable the const char* to QString automatic conversion
by compiling your software with the macro QT_NO_CAST_ASCII
defined, you'll be very likely to catch any strings you are
missing. See QString::fromLatin1() for more information.
Disabling the conversion makes programming cumbersome.

If your source language uses characters outside Latin-1, you
might find QObject::trUtf8() more convenient than
QObject::tr(), as tr() depends on the
QApplication::defaultCodec(), which makes it more fragile than
QObject::trUtf8().

\section2 Use QKeySequence() for Accelerator Values

Accelerator values such as Ctrl+Q or Alt+F need to be
translated too. If you hardcode \c CTRL+Key_Q for "Quit" in
your application, translators won't be able to override
it. The correct idiom is

\code
    QPopupMenu *file = new QPopupMenu( this );
    file->insertItem( tr("&Quit"), this, SLOT(quit()),
		      QKeySequence(tr("Ctrl+Q", "File|Quit")) );
\endcode

\section2 Use QString::arg() for Simple Arguments

The printf() style of inserting arguments in strings
is often a poor choice for internationalized text, as it is
sometimes necessary to change the order of arguments when
translating. Nonetheless, the QString::arg()
functions offer a simple means for substituting arguments:
\code
    void FileCopier::showProgress( int done, int total,
				   const QString& current_file )
    {
	label.setText( tr("%1 of %2 files copied.\nCopying: %3")
			.arg(done)
			.arg(total)
			.arg(current_file) );
    }
\endcode

\section2 Produce Translations

Once you are using tr() throughout an application, you can start
producing translations of the user-visible text in your program.

\link linguist-manual.book Qt Linguist\endlink's manual provides
further information about Qt's translation tools, \e{Qt Linguist}, \e
lupdate and \e lrelease.

Translation of a Qt application is a three-step process:

\list 1

\i Run \e lupdate to extract translatable text from the C++ source
code of the Qt application, resulting in a message file for
translators (a \c .ts file). The utility recognizes the tr() construct
and the QT_*_NOOP macros described above and produces \c .ts files
(usually one per language).

\i Provide translations for the source texts in the \c .ts file, using
\e{Qt Linguist}. Since \c .ts files are in XML format, you can also
edit them by hand.

\i Run \e lrelease to obtain a light-weight message file (a \c .qm
file) from the \c .ts file, suitable only for end use. Think of the \c
.ts files as "source files", and \c .qm files as "object files". The
translator edits the \c .ts files, but the users of your application
only need the \c .qm files. Both kinds of files are platform and
locale independent.

\endlist

Typically, you will repeat these steps for every release of your
application. The \e lupdate utility does its best to reuse the
translations from previous releases.

Before you run \e lupdate, you should prepare a project file. Here's
an example project file (\c .pro file):

\code
    HEADERS         = funnydialog.h \
		      wackywidget.h
    SOURCES         = funnydialog.cpp \
		      main.cpp \
		      wackywidget.cpp
    FORMS           = fancybox.ui
    TRANSLATIONS    = superapp_dk.ts \
		      superapp_fi.ts \
		      superapp_no.ts \
		      superapp_se.ts
\endcode

When you run \e lupdate or \e lrelease, you must give the name of the
project file as a command-line argument.

In this example, four exotic languages are supported: Danish, Finnish,
Norwegian and Swedish. If you use \link qmake-manual.book
qmake\endlink (or \c tmake), you usually don't need an extra project
file for \e lupdate; your \c qmake project file will work fine once
you add the \c TRANSLATIONS entry.

In your application, you must \l QTranslator::load() the translation
files appropriate for the user's language, and install them using \l
QApplication::installTranslator().

If you have been using the old Qt tools (\c findtr, \c msg2qm and \c
mergetr), you can use \e qm2ts to convert your old \c .qm files.

\e linguist, \e lupdate and \e lrelease are installed in the \c bin
subdirectory of the base directory Qt is installed into. Click Help|Manual
in \e{Qt Linguist} to access the user's manual; it contains a tutorial
to get you started.

While these utilities offer a convenient way to create \c .qm files,
any system that writes \c .qm files is sufficient. You could make an
application that adds translations to a QTranslator with
QTranslator::insert() and then writes a \c .qm file with
QTranslator::save(). This way the translations can come from any
source you choose.

\target qt-itself
Qt itself contains about 400 strings that will also need to be
translated into the languages that you are targeting. You will find
translation files for French and German in \c $QTDIR/translations as
well as a template for translating to other languages.

Typically, your application's main() function will look like this:
\code
    int main( int argc, char **argv )
    {
	QApplication app( argc, argv );

	// translation file for Qt
	QTranslator qt( 0 );
	qt.load( QString( "qt_" ) + QTextCodec::locale(), "." );
	app.installTranslator( &qt );

	// translation file for application strings
	QTranslator myapp( 0 );
	myapp.load( QString( "myapp_" ) + QTextCodec::locale(), "." );
	app.installTranslator( &myapp );

	...

	return app.exec();
    }
\endcode

\section2 Support for Encodings

The QTextCodec class and the facilities in QTextStream make it easy to
support many input and output encodings for your users' data. When an
application starts, the locale of the machine will determine the 8-bit
encoding used when dealing with 8-bit data: such as for font
selection, text display, 8-bit text I/O and character input.

The application may occasionally require encodings other than the
default local 8-bit encoding. For example, an application in a
Cyrillic KOI8-R locale (the de-facto standard locale in Russia) might
need to output Cyrillic in the ISO 8859-5 encoding. Code for this
would be:

\code
    QString string = ...; // some Unicode text

    QTextCodec* codec = QTextCodec::codecForName( "ISO 8859-5" );
    QCString encoded_string = codec->fromUnicode( string );

    ...; // use encoded_string in 8-bit operations
\endcode

For converting Unicode to local 8-bit encodings, a shortcut is
available: the \link QString::local8Bit() local8Bit\endlink() method
of QString returns such 8-bit data. Another useful shortcut is the
\link QString::utf8() utf8\endlink() method, which returns text in the
8-bit UTF-8 encoding: this perfectly preserves Unicode information
while looking like plain US-ASCII if the Unicode is wholly US-ASCII.

For converting the other way, there are the QString::fromUtf8() and
QString::fromLocal8Bit() convenience functions, or the general code,
demonstrated by this conversion from ISO 8859-5 Cyrillic to Unicode
conversion:

\code
    QCString encoded_string = ...; // Some ISO 8859-5 encoded text.

    QTextCodec* codec = QTextCodec::codecForName("ISO 8859-5");
    QString string = codec->toUnicode(encoded_string);

    ...; // Use string in all of Qt's QString operations.
\endcode

Ideally Unicode I/O should be used as this maximizes the portability
of documents between users around the world, but in reality it is
useful to support all the appropriate encodings that your users will
need to process existing documents. In general, Unicode (UTF-16 or
UTF-8) is best for information transferred between arbitrary people,
while within a language or national group, a local standard is often
more appropriate. The most important encoding to support is the one
returned by QTextCodec::codecForLocale(), as this is the one the user
is most likely to need for communicating with other people and
applications (this is the codec used by local8Bit()).

Since most Unix systems do not have built-in support for converting
between local 8-bit encodings and Unicode, it may be necessary to
write your own QTextCodec subclass. Depending on the urgency, it may
be useful to contact Trolltech technical support or ask on the
\c qt-interest mailing list to see if someone else is already working
on supporting the encoding. A useful interim measure can be to use the
QTextCodec::loadCharmapFile() function to build a data-driven codec,
although this approach has a memory and speed penalty, especially with
dynamically loaded libraries. For details of writing your own
QTextCodec, see the main QTextCodec class documentation.

\keyword localization

\section2 Localize

Localization is the process of adapting to local conventions such as
date and time presentations. Such localizations can be accomplished
using appropriate tr() strings, even "magic" words, as this somewhat
contrived example shows:

\code
    void Clock::setTime(const QTime& t)
    {
	if ( tr("AMPM") == "AMPM" ) {
	    // 12-hour clock
	} else {
	    // 24-hour clock
	}
    }
\endcode

Localizing images is not recommended. Choose clear icons that are
appropriate for all localities, rather than relying on local puns or
stretched metaphors.

\section1 System Support

Operating systems and window systems supporting Unicode are still in
the early stages of development. The level of support available in the
underlying system influences the support Qt provides on that platform,
but applications written with Qt need not generally be too concerned
with the actual limitations.

\section2 Unix/X11

\list
\i Locale-oriented fonts and input methods. Qt hides these and
    provides Unicode input and output.
\i Filesystem conventions such as
    \link http://www.ietf.org/rfc/rfc2279.txt UTF-8 \endlink
    are under development
    in some Unix variants. All Qt file functions allow Unicode,
    but convert all filenames to the local 8-bit encoding, as
    this is the Unix convention
    (see QFile::setEncodingFunction()
	to explore alternative encodings).
\i File I/O defaults to the local 8-bit encoding,
    with Unicode options in QTextStream.
\endlist

\section2 Windows

\list
\i Qt provides full Unicode support, including input methods, fonts,
    clipboard, drag-and-drop and file names.
\i File I/O defaults to Latin-1, with Unicode options in QTextStream.
    Note that some Windows programs do not understand big-endian
    Unicode text files even though that is the order prescribed by
    the Unicode Standard in the absence of higher-level protocols.
\i Unlike programs written with MFC or plain winlib, Qt programs
    are portable between Windows 95/98 and Windows NT.
    \e {You do not need different binaries to support Unicode.}
\endlist

\section1 Supporting More Input Methods

While Trolltech doesn't have the resources or expertise in all the
languages of the world to immediately include support in Qt, we are
very keen to work with people who do have the expertise. Over the next
few minor version numbers, we hope to add support for your language of
choice, until everyone can use Qt and all the programs developed with
Qt, regardless of their language.

Languages with single-byte encodings (European Latin-1 and KOI8-R,
etc.) and multi-byte encodings (East Asian EUC-JP, etc.) are
supported. Support for the "complex" encodings: those requiring
right-to-left input or complex character composition (e.g. Arabic,
Hebrew, and Thai script) is implemented, but the range of Indic
scripts (Hindi, Devanagari, Bengali, etc.) is still under development.
The current state of activity is:

\table
\header \i Encodings \i Status
\row 
\i All encodings on Windows
\i The local encoding is always supported.
\row
\i ISO standard encodings
	ISO 8859-1,
	ISO 8859-2,
	ISO 8859-3,
	ISO 8859-4,
	ISO 8859-5,
	ISO 8859-7,
	ISO 8859-9, and
	ISO 8859-15
\i Fully supported.
\row
\i KOI8-R
\i Fully supported.
\row
\i eucJP, JIS, and ShiftJIS
\i Fully supported. Uses eucJP with the XIM protocol on X11,
	and the IME Windows NT in Japanese Windows NT.
	Serika Kurusugawa and others are assisting with this effort.
	\link ftp://ftp.sra.co.jp/pub/x11/kinput2/ kinput2 \endlink
	is the tested input method for X11.
\row
\i eucKR
\i Supported.
	Mizi Research are assisting with this effort.
	\link http://www.mizi.com hanIM \endlink
       	is the tested input method.
\row
\i Big5
\i Qt contains a Big5 codec developed by Ming Che-Chuang.
	Testing is underway with the xcin (2.5.x) XIM server.
\row
\i eucTW
\i Under external development.
\endtable

More information on the support of different writing systems in Qt can
be found in \link scripts.html the documentation about writing systems
\endlink.

If you are interested in contributing to existing efforts, or
supporting new encodings beyond those mentioned above, your work can
be considered for inclusion in the official Qt distribution, or just
included with your application.

Eventually, we hope to help Unix become as Unicode-oriented as Windows
is becoming. This means better font support in the font servers, with
new developments like the True Type font servers \link
http://www.dcs.ed.ac.uk/home/jec/programs/xfsft/ xfsft \endlink, \link
ftp://sunsite.unc.edu/pub/Linux/X11/fonts/ xfstt \endlink, and x-tt,
as well as \link http://www.ietf.org/rfc/rfc2279.txt UTF-8 \endlink (a
Unicode encoding) filenames such as with the \link
http://www.sun.com/software/white-papers/wp-unicode/ Unicode support
in Solaris 7 \endlink.

\section1 Note about Locales on X11

Many Unix distributions contain only partial support for some locales.
For example, if you have a \c /usr/share/locale/ja_JP.EUC directory,
this does not necessarily mean you can display Japanese text; you also
need JIS encoded fonts (or Unicode fonts), and that \c
/usr/share/locale/ja_JP.EUC directory needs to be complete. For best
results, use complete locales from your system vendor.

\section1 Relevant Qt Classes

These classes are relevant to internationalizing Qt applications.
*/
