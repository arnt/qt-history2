/****************************************************************************
** $Id: i18n.doc,v 1.27 1999/06/30 16:04:33 warwick Exp $
**
** Explanation of moc and the meta object system
**
** Copyright (C) 1992-1999 Troll Tech AS.  All rights reserved.
**
** This file is part of the Qt GUI Toolkit.
**
** This file may be distributed under the terms of the Q Public License
** as defined by Troll Tech AS of Norway and appearing in the file
** LICENSE.QPL included in the packaging of this file.
**
** Licensees holding valid Qt Professional Edition licenses may use this
** file in accordance with the Qt Professional Edition License Agreement
** provided with the Qt Professional Edition.
**
** See http://www.troll.no/pricing.html or email sales@troll.no for
** information about the Professional Edition licensing, or see
** http://www.troll.no/qpl/ for QPL licensing information.
**
*****************************************************************************/

/*! \page i18n.html

<title>
Qt toolkit - Internationalization
</title></head><body bgcolor="#ffffff">

\postheader

<h1 align=center>Internationalization with Qt</h1><br clear="all">

Internationalization of software is the process of allowing the
software to be used efficiently by all people of the world.  This
means adapting to user and locality preferences such as language,
input techniques, character encodings, and presentation conventions.


<h2>Step by Step</h2>

Writing cross-platform international software with Qt is a gentle,
incremental process.  Your software can become internationalized
in the following stages:

<ol>
 <li><b>Use QString for all user-visible text.</b>
	<p>
	Since QString uses the Unicode encoding internally, all the
	languages of the world can be processed transparently using
	familiar text processing operations.  Also, since all Qt functions
	that present text to the user take a QString as a parameter,
	there is no char* to QString conversion time.
	<p>
	Strings that are in "programmer space" - such as QObject
	names and file format texts need not use QString - the
	traditional char*, or the QCString class will suffice.
	<p>
	You're unlikely to notice that you are using unicode - QString,
	and QChar are just like easier versions of the clumsy const char*
	and char from traditional C.
	</p>
 <li><b>Use \link QObject::tr() tr()\endlink for all literal text.</b>
	<p>
	Where your program uses <tt>"quoted text"</tt> for text
	that will be presented to the user, ensure it goes through
	the
	\link QApplication::translate() QApplication::translate()\endlink
       	function, usually this simply means using
	\link QObject::tr() tr()\endlink.
	For example, assuming
	<tt>LoginWidget</tt> is a subclass of QWidget:
	\code
	LoginWidget::LoginWidget()
	{
	    QLabel *label = new QLabel( tr("Password:"), this );
	    ...
	}
	\endcode

	This is 99% of the strings you're likely to write.

	If the quoted text is \e not in a member function of a
	QObject/QWidget subclass, use either
	the tr() function of an approriate class, or the
	QApplication::translate() function directly:
	\code
	void some_global_function(LoginWidget* logwid)
	{
	    QLabel *label = new QLabel( LoginWidget::tr("Password:"), logwid );
	}

	void same_global_function(LoginWidget* logwid)
	{
	    QLabel *label = new QLabel( qApp->translate("LoginWidget", "Password:"), logwid );
	}
	\endcode

	Finally, if you need to have translatable text completely
	outside a funciton, there are
	two macros to help: QT_TR_NOOP() and QT_TRANSLATE_NOOP().
	They merely mark the text for extraction by the <tt>findtr</tt>
	utility described below - the macros expand to just the text (without
	the scope). Example usages are shown below.

	\code
	QString FriendlyConversation::greeting(int greet_type)
	{
	    static const char* greeting_strings[] = {
		QT_TR_NOOP("Hello"),
		QT_TR_NOOP("Goodbye")
	    };
	    return tr(greeting_strings[greet_type]);
	}

	static const char* greeting_strings[] = {
	    QT_TRANSLATE_NOOP("FriendlyConversation","Hello"),
	    QT_TRANSLATE_NOOP("FriendlyConversation","Goodbye")
	};
	QString FriendlyConversation::greeting(int greet_type)
	{
	    return tr(greeting_strings[greet_type]);
	}
	\endcode
	<p>
	If you disable the const char* to QString automatic conversion by
	compiling your software with the macro QT_NO_CAST_ASCII defined,
	you'll be very likely to catch any strings you are missing. See
	QString::fromLatin1() for more details. Disabling the conversion
	can make programming cumbersome.
	</p>
 <li><b>Use QString::arg() for simple arguments.</b>
	<p>
	The printf() style of inserting arguments in strings
	is a poor choice for internationalized text, as it is sometimes
	necessary to change the order of arguments when translating.
	The
	\link QString::arg() QString::arg()\endlink
       	functions offer a simple
	means for substituting arguments:
	\code
	void FileCopier::showProgress(int done, int total,
				      const QString& current_file )
       	{
	    label.setText( tr("%1 of %2 files copied.\nCopying: %3")
			    .arg(done)
			    .arg(total)
			    .arg(current_file)
			 );
	}
	\endcode
	</p>
 <li><b>Produce translation.</b>
	<p>
	Once you are using tr() sufficiently, you can start producing
	translations of the user-visible text in your program.
	<p>
	Provided with Qt are three utility programs that assist
	in the management of translations:
	</p>
	<dl>
	  <dt><tt>findtr</tt>
	  <dd>Extracts information about text to be translated.
	    It recognizes the tr() constructs described above and
	    produces a file in ".po" format, a simple text format
	    that your translation team will copy and edit.  For example,
	    the <em>base</em> .po file might be <tt>myapp.po</tt> and
	    translated versions of the file would then be <tt>myapp_de.po</tt>,
	    <tt>myapp_fr.po</tt>, and <tt>myapp_ja.po</tt> for translations
	    in German, French and Japanese respectively.
	    \code
		findtr *.cpp *.h >myapp.po
		copy myapp.po myapp_de.po
		edit myapp_de.po
	    \endcode
	  <dt><tt>msg2qm</tt>
	  <dd>Converts translated .po files to a Qt-specific
	    binary format (".qm" Qt message files).  The Qt message
	    files are platform and locale independent, containing
	    translations in Unicode and various hash tables to
	    provide fast look-up.
	    \code
		msg2qm myapp_de.po myapp_de.qm
		msg2qm myapp_fr.po myapp_fr.qm
		msg2qm myapp_ja.po myapp_ja.qm
	    \endcode
	    In your application, use
	    \link QTranslator::load() QTranslator::load()\endlink
	    to load translation files appropriate for the
	    user's language.

	  <dt><tt>mergetr</tt>
	  <dd>When the texts in your program change as it
	    is developed, a the <em>base</em> .po file can be regenerated
	    using <tt>findtr</tt>, then <tt>mergetr</tt> can be used to
	    merge the changes into the other .po files:
	    \code
		mergetr myapp_de.po myapp.po
		mergetr myapp_fr.po myapp.po
		mergetr myapp_ja.po myapp.po
	    \endcode
	    The translation team then edits the new .po files to translate
	    the new or changed texts.  When texts change, the old text
	    is included in the .po file as a comment to guide the new
	    translation (no "fuzzy" matching is done).
	</dl>
	<p>
	<em>
	Note that Qt itself contains a small number of strings that will
	also need to be translated to the languages which you are targetting.
	In the near future Qt will ship with translations for some languages.
	We recommend that if you need to translate the Qt strings now
	that you put the translations in separate .po and .qm files.  This
	will simplify transition to the official Qt translations.
	</em>
	<p>
	The <tt>findtr</tt> ships in <tt>qt/bin</tt>, while the other
	utilities are under the <tt>qt/src/util</tt> directory
	and need to be compiled.
	</p>
 <li><b>Support encodings.</b>
	<p>
	The QTextCodec class and the facilities in QTextStream
	make it easy to support many input and
	output encodings for your users' data.  Ideally, we recommend
	that Unicode I/O be used as this maximizes the portability
	of documents between users around the world, but in reality
	it is useful to support all the appropriate formats that
	your users' will need to process existing documents. In general,
	Unicode (Utf16 or Utf8) is the best for information transferred
	between arbitrary people, while within a language or national group,
	a local standard is often more appropriate.  The most important
	encoding to support is the one returned by
	\link QTextCodec::codecForLocale() QTextCodec::codecForLocale()\endlink,
	as this is the one the user is most likely to need for communicating
	with other people and applications.
	</p>
 <li><b>Localization.</b>
	<p>
	Localization is the process of adapting to local conventions
	such as date and time presentations.  Such localizations can be
	accomplished using appropriate tr() strings, even "magic" words,
	as this somewhat contrived example shows:
	\code
	void Clock::setTime(const QTime& t)
	{
	    if ( tr("AMPM") == "AMPM" ) {
		// 12-hour clock
	    } else {
		// 24-hour clock
	    }
	}
	\endcode
	</p>

	In general, it is recommended that you do \e not attempt
	to localize images - choose clear icons that are appropriate
	for all localities, rather than relying on local puns or
	stretched metaphors.
</ol>


<h2>System Support</h2>

Operating systems and window systems supporting Unicode are still in
the early stages of development.  The level of support
available in the underlying system influences the support Qt provides
on that platform, but applications written with Qt need not generally
be too concerned with the actual limitations.
<dl compact>
  <dt>Unix/X11
    <dd><ul>
     <li>Locale-oriented fonts and input methods.  Qt hides these and
	    provides Unicode input and output.
     <li>Filesystem conventions such as
            <a href=http://www.ietf.org/rfc/rfc2279.txt>UTF-8</a>
            are under development
	    in some Unix variants.  All Qt file functions allow Unicode,
	    but currently converts all filenames to Latin-1.
     <li>File I/O defaults to Latin-1, with Unicode options in QTextStream.
     </ul>
  <dt>Windows 95/98/NT
    <dd><ul>
     <li>Qt provides full Unicode support, including input methods, fonts,
	  clipboard, drag-and-drop, and file names.
     <li>File I/O defaults to Latin-1, with Unicode options in QTextStream.
	  Note that some Windows programs do not understand big-endian
	  Unicode text files even though that is the order prescribed by
	  the Unicode Standard in the absence of higher-level protocols.
     <li>Note that unlike programs written with MFC or plain winlib, Qt programs
	  are portable between Windows 95/98 and Windows NT - 
	  <em>you do not need different binaries to support Unicode</em>.
    </ul>
</dl>

<h2>Supporting more Input Methods</h2>

While Troll Tech doesn't have the resources or expertise in all
the languages of the world to immediately include support in Qt,
we are very keen to work with people who <em>do</em> have the
expertise.  Over the next few minor version numbers, we hope to add support
for <em>your</em> language of choice, until everyone can use Qt
and all the programs developed with Qt, regardless of their
language.

Initially, languages with uni-directional single-byte encodings
(European Latin1 and KOI8-R, etc.)
and the uni-directional multi-byte encodings (East Asian
EUC-JP, etc.) will be supported. Later, support for the "complex"
encodings - those requiring right-to-left input or complex character
composition (eg. Arabic, Hebrew, and Thai script) will be implemented.
The current state of activity is:
<dl compact>
 <dt><b>All encodings on Windows</b>
    <dd>On Windows, the local encoding is always supported.
 <dt><b>ISO standard encodings
	ISO 8859-1,
	ISO 8859-2,
	ISO 8859-3,
	ISO 8859-4,
	ISO 8859-5,
	ISO 8859-7,
	ISO 8859-9, and
	ISO 8859-15
	</b>
  <dd>Fully supported.
	The Arabic (ISO 8859-6-I) and Hebrew (ISO 8859-8-I) encodings
	are not supported, but are under development externally.
 <dt><b>KOI8-R</b>
  <dd>Fully supported.
 <dt><b>eucJP, JIS, and ShiftJIS</b>
  <dd>Fully supported. Uses eucJP with the XIMP protocol on X11,
	and the IME Windows NT in Japanese Windows NT.
	Serika Kurusugawa and other are assisting with this effort.
	<a href=ftp://ftp.sra.co.jp/pub/x11/kinput2/>kinput2</a>
	is the tested input method for X11.
 <dt><b>eucKR</b>
  <dd>Under external development, 
	Mizi Research are assisting with this effort.
	<a href=http://www.mizi.com/>hanIM</a>
       	is the tested input method.
 <dt><b>eucTW</b>
  <dd>Under external development.
</dl>

If you are interested in contributing to existing efforts, or
supporting new encodings beyond the more standard ones above, your work
can be considered for inclusion in the official Qt distribution, or
just included with your application.

Eventually, we hope to help Unix become as Unicode-oriented as
Windows NT is becoming.
This means better font support in the font servers,
with new developments like the True Type font servers
<a href=http://www.dcs.ed.ac.uk/home/jec/programs/xfsft/>xfsft</a>,
<a href=ftp://sunsite.unc.edu/pub/Linux/X11/fonts>xfstt</a>,
and
<a href=http://hawk.ise.chuo-u.ac.jp/student/person/tshiozak/x-tt/>x-tt</a>,
as well as
<a href=http://www.ietf.org/rfc/rfc2279.txt>UTF-8</a>
(a Unicode encoding) filenames such as with the
<a href=http://www.sun.com/software/white-papers/wp-unicode/>Unicode
support in Solaris<sup class="tm"><font size="-1">TM</font></sup> 7</a>.

<h2>Note about Kinput2 on X11</h2>

If using the Kinput2 XIM Server, users may need to apply the
bug-fix patch below.  Without this patch, Kinput2 can produce bad
XIM Protocol, causing application lock-up.
<p>
For a recent version of Kinput2 that includes all users need, see
<a href=ftp://ftp.sra.co.jp/pub/x11/kinput2/>
ftp://ftp.sra.co.jp/pub/x11/kinput2/</a>

<p>Patch...
\code
--- lib/imlib/imrequest.c~	Mon Feb  3 10:21:46 1997
+++ lib/imlib/imrequest.c	Wed Mar 10 19:23:09 1999
@@ -844,6 +844,6 @@
 	IMSendBadLength(conn, icp->im->id, icp->id);
 	return;
     }
-    IMDestroyIC(icp);
     IMSendRequestWithIC(conn, XIM_DESTROY_IC_REPLY, 0, icp);
+    IMDestroyIC(icp);
 }
\endcode


*/
