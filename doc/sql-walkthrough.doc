/*! \page sql-walkthrough.html

\title Example SQL application walkthrough

This walkthrough shows simple use of QSqlIndex, QSqlQuery, QSqlCursor,
QSqlTable and QSqlForm - classes that a database front-end or database
application would want to use. It is not meant as a guide to Qt
programming in general, but rather to illustrate the most common use
of some of the classes in the SQL module. Explanations that cover
general widget creation and layout is in most cases skipped. To get
the most from this walkthrough, you should have read the documentation
on records, fields, indexes, queries and cursors ##link to blargh##.

This example is built on a set of database tables that are used to
keep track of pingpong scores. First, an overview of the database:

The database contains four simple tables: \a match, \a team, \a player
and \a player2team. The \a match table is used to store pingpong
matches, it includes fields like date, winner, loser and the number of
sets played.  The \a team table is simply a list of the teams, while
the \a player table is a list of the players. The \a player2team table
is used to assign players to teams. A player can be a member of
several teams. The database also contains a couple of views (\a
matchview and \a player2teamview) and a few key sequences used to
generate new primary keys.

Our goal is to create a simple application that makes it possible to
do the following:
<ul>
<li> enter match results</li>
<li> create and edit teams and players</li>
<li> generate team statistics, such as wins and losses</li>
<li> include a highscore table that ranks the different teams</li>
</ul>

The pingpong example program contains the following files:

<b>main.cpp</b> - Contains the main() function and shows how to connect to an existing database

<b>cursors.h/cpp</b>  - Contains reimplementations of QSqlCursor that are used for traversing data sets.

<b>dialogs.h/cpp</b> - Contains the implementation of dialogs that are used in the pingpong example.

<b>widgets.h/cpp</b> - Contains implementation of special widgets that are used to display statistics, highscores and such.

<b>pingpongfrontend.h/cpp</b>  - Implementation of the main window in the application.

<h2>Specifying a connection to a database (main.cpp)</h2>

\code
int main( int argc, char ** argv )
{
    QApplication a( argc, argv );

    QSqlDatabase * db = QSqlDatabase::addDatabase( "QPSQL6" );
    db->setDatabaseName( "pingpong" );
    db->setUserName( "db" );
    db->setPassword( "db" );
    db->setHostName( "silverfish" );

    if( !db->open() ){
	qWarning( "Unable to open database: " + db->lastError().driverText());
	qWarning( db->lastError().databaseText() );
	return 0;
    }

    PingpongFrontEnd dbapp;

    a.setMainWidget( &dbapp );
    dbapp.show();

    return a.exec();
}
\endcode

If we start with the main.cpp file, the first thing that is done after
the usual QApplication object is created, is to specify a connection to
the database we want to use.
\code
    QSqlDatabase * db = QSqlDatabase::addDatabase( "QPSQL6" );
\endcode 
The line above specifies which driver should be used to access the
database. The Qt SQL module currently supports the following drivers:

<ul>
<li>QPSQL6 - Postgres v6.x databases</li>
<li>QPSQL7 - Postgres v7.x databases</li>
<li>QMYSQL - MySQL databases</li>
<li>QODBC - ODBC databases</li>
<li>QOCI - Oracle databases</li>
</ul>

As we have used Postgres v6.5 to implement our Pingpong database we
choose the QPSQL6 driver to access the database. After specifying the
driver we need to specify the database name, user name and password,
and the host the database is running on.
\code
    db->setDatabaseName( "pingpong" );
    db->setUserName( "db" );
    db->setPassword( "db" );
    db->setHostName( "silverfish" );
\endcode
After all the necessary information is passed to QSqlDatabase, the
database connection is opened with the following statement:
\code
    if( !db->open() ){
	qWarning( "Unable to open database: " + db->lastError().driverText());
	qWarning( db->lastError().databaseText() );
	return 0;
    }
\endcode

If there was an error while opening the database it can be retrieved
by using the lastError() call (see QSqlError).

The connection that has just been created is from this point on used
by the low-level classes in the SQL modules to seamlessly access the
database. You will most likely not need to use the QSqlDatabase class
after the initialization.

After the database connection is up and running - we create an
instance of the main window widget, PingpongFrontEnd, and enter the
event loop as in any other Qt application.

<h2>Initialization</h2>

The main window consists of a tab widget that contains four different
tabs:
<ul>
<li>Match table - a table used to view the match results</li>
<li>Statistics - contains some simple statistical information about each team</li>
<li>Hall of Fame - ranks each team in the database according to their number of wins</li>
<li>Team editor - used to add/edit teams and players to the database</li>
</ul>

Except for the Match table, the definition and implementation of these
widgets can be found in the widgets.h/cpp files.

<em><b>The Match table</b></em>

The Match table is a QSqlTable object used to display the recordset
defined by MatchView. MatchView is a QSqlCursor that is associated
with the \a matchview view in our database.

From cursors.h:
\code
class MatchView : public QSqlCursor
{
public:
    MatchView();
};
\endcode

From cursors.cpp:
\code
MatchView::MatchView()
    : QSqlCursor( "matchview" )
{
    setDisplayLabel( "loserwins", "Loser Wins" );
    setDisplayLabel( "winnerwins", "Winner Wins" );
    setDisplayLabel( "date", "Date" );
    setDisplayLabel( "loser", "Loser" );
    setDisplayLabel( "winner", "Winner" );
    setDisplayLabel( "sets", "Sets" );
}
\endcode

The definition and implementation of the MatchView class is simple and
straight forward. In the constructor a QSqlCursor is instantiated,
with bindings to the \a matchview view. Also, a new set of display
labels are assigned to the different fields in the cursor. These
display labels are used by QSqlTable and QSqlForm when tables and
forms are generated.

The initialization of the Match table itself is done in the
constructor of the PingpongFrontEnd class.

From pingpongfrontend.cpp:
\code
    // Set up the initial match table
    matchView.select( matchView.index( "date" ) );
    matchTable->setCursor( &matchView, FALSE );
    matchTable->addColumn( matchView.field( "date" ) );
    matchTable->addColumn( matchView.field( "winner" ) );
    matchTable->addColumn( matchView.field( "winnerwins" ) );
    matchTable->addColumn( matchView.field( "loser" ) );
    matchTable->addColumn( matchView.field( "loserwins" ) );
    matchTable->addColumn( matchView.field( "sets" ) );
    matchTable->setSorting( TRUE );
    matchTable->setReadOnly( TRUE );
\endcode

First, a \a select is issued on the MatchView cursor:
\code
    matchView.select( matchView.index( "date" ) );
\endcode

This will generate a resultset which contains all the records in the
\a matchview view, sorted on the \a date field. In other words, a list
of all the matches, sorted on the date they were played.

\code
    matchTable->setCursor( &matchView, FALSE );
    matchTable->addColumn( matchView.field( "date" ) );
    matchTable->addColumn( matchView.field( "winner" ) );
    matchTable->addColumn( matchView.field( "winnerwins" ) );
    matchTable->addColumn( matchView.field( "loser" ) );
    matchTable->addColumn( matchView.field( "loserwins" ) );
    matchTable->addColumn( matchView.field( "sets" ) );
\endcode

The MatchView cursor acts as a datasource for the Match table.
setCursor() is called to associate the MatchView cursor with the Match
table. We call it with \a autoPopulate set to FALSE, because we want
to set the order and number of columns to display in the table
ourself. addColumn() is called to add the fields from the MatchView
cursor we want to appear in the table.

\code
    matchTable->setSorting( TRUE );
    matchTable->setReadOnly( TRUE );
\endcode

We also want to be able to sort the table on any of the columns, and
we don't want the user to insert/update/delete records directly in
this table. This is because the Match table is associated with a view
in the database, and in version 6.5 of Postgres it is not possible to
perform inserts, updates or deletes on a database view. We use a
separate cursor directly connected to the \a match table to perform
these operations (see Inserting, Updating and Deleting matches).

Our Match table widget has now been set up correctly to display a list
of all the matches that have been played, sorted on the date.

<em><b>The Statistics widget</b></em>

The Statistics widget is basically a collection of QLabel widgets that
are used to display a name and a value. The statistics are team based
and consists of sets won, matches won, sets lost, matches lost,
percentage of wins/losses, total sets played, total matches played,
who the team has lost most matches against, and who the team has beat
the most times. All the interesting things take place in the update()
function, where the database is queried and the values
generated. Also, notice the TeamPicker widget, which is an example of
a custom SQL field editor.

\code
class TeamPicker : public QComboBox
{
    Q_OBJECT
    Q_PROPERTY( int teamid READ teamId WRITE setTeamId )

public:
    TeamPicker( QWidget * parent = 0, const char * name = 0 );
    int teamId() const;
    void setTeamId( int id );

private:
    QMap< int, int > index2Id;
};
\endcode

The TeamPicker widget is a QComboBox, which contains the names of the
different teams in the database. The Q_PROPERTY macro is used to
define and associate the teamid property with the TeamPicker
class. This is used by the QSqlPropertyMap to insert/extract values
into/from the widget when it appears in a QSqlTable or a
QSqlForm. This is not the case here though, but we will use the
TeamPicker in a QSqlForm later on.

From the TeamPicker constructor in widgets.cpp:
\code
    QSqlCursor team( "team" );
    team.select( team.index("name") );
    int idx = 0;
    while( team.next() ) {
	insertItem( team.value("name").toString(), idx );
	index2Id[idx] = team.value("id").toInt();
	idx++;
    }
\endcode

When the TeamPicker widget is constructed, the database must be
queried for the team names. This is done by creating a cursor
associated with the \a team table, and by selecting all entries in
that table, sorted on the team name. We then iterate through the
resultset and insert the team names into the QComboBox. Notice also
that we store the primary key for each of the entries. This is
necessary if we later on want to use the \a teamid in queries, as the
team name itself not necessarily uniquely identifies a team. The \a
teamid is kept in a QMap, where the index of an item is mapped to a
\a teamid.

To calculate the statistical values, a series of queries are used. We
get the currently selected \a teamid from the TeamPicker to use as the
basis for our queries:

From the Statistics::update() function in widgets.cpp:
\code
    int teamId = teamPicker->teamId();
\endcode

Simple SQL queries are used to generate the values we need to display
the statistical data. One of these values are the number of sets a
team has won. The following lines queries the database and updates the
label used to view the value.

\code
    // Sets won
    QSqlQuery query( "select sum(winnerwins) from match where winnerid = " +
		     QString::number( teamId ) + ";" );
\endcode

Instantiate a QSqlQuery object with the SQL query we want to execute.

\code
    if( query.next() )
	sets = query.value(0).toInt();
\endcode

If the query return a resultset, store the number of sets the team has
won.

\code
    // Remember the sets won in matches that has been lost
    query.exec( "select sum(loserwins) from match where loserid = " +
		QString::number( teamId ) + ";" );
    if( query.next() )
	sets += query.value(0).toInt();
    setsWon->setText( QString::number( sets ) );
    numSets = sets;
\endcode

Also query for the number of sets the team has won in matches the team
has lost, add the numbers and update the label that is used to display
the value.

<em><b>The HighscoreList widget</b></em>

The HighscoreList widget is used to display a list of the teams in the
database, with the most winning team at the top of the list. The same
technique to query the database as was described in the Statistics
section above, is used. The result of the query is inserted into a
QListView widget for display. Look at the HighscoreList::update()
funtion in widgets.cpp to see how this is done.

<em><b>The TeamEditor widget</b></em>

The Team editor is used to add/remove teams, add/remove players and
add/remove players to teams. 

The editor mainly consists of three QSqlTable widgets that are used to
display a list of teams, players and the players that are on a
specific team. QSqlTable widgets are used because we want the user to
be able to insert, update and delete teams and players directly in the
table. Once the QSqlTable widgets are initialized properly, they can
handle inserts, updates and deletes themselves.

From the TeamEditor constructor in widgets.cpp:
\code
...
    teamCursor.select( teamCursor.index( "name" ) );
    teamTable = new QSqlTable( this );
    teamTable->setCursor( &teamCursor );
    teamTable->setSorting( TRUE );
    connect( teamTable, SIGNAL( currentChanged( const QSqlRecord * ) ),
	     SLOT( updateTeamMembers( const QSqlRecord * ) ) );
...
    playerCursor.select( playerCursor.index( "name" ) );
    playerTable = new QSqlTable( this );
    playerTable->setCursor( &playerCursor );
    playerTable->setSorting( TRUE );
...
    player2teamTable = new QSqlTable( this );
    player2teamTable->setCursor( &player2teamView );
    player2teamTable->setReadOnly( TRUE );
    player2teamTable->setSorting( TRUE );
...
\endcode

Each table is created and the appropriate cursor is set. Notice that
we use the \a autoPopulate (TRUE by default, in the setCursor()
function) feature of the QSqlTable widget, to automatically generate
the columns we want to display.

Also, we connect the currentChanged() signal that is emitted by the
teamTable widget, to a slot named updateTeamMembers(). This is because
we want to update the player2teamTable that shows which players that
are on a specific team each time a new team is selected in the
teamTable.

<h2>Inserting, updating and deleting matches</h2>

Inserting, updating and deleting match results are done using a
separate dialog, MatchDialog. The MatchDialog is interesting because
it is an example of how to use a manually layed out QSqlForm with a
custom editor widget. The role of the QSqlForm in the dialog is to
manage updates of widgets and database fields.

From the MatchDialog constructor in dialogs.cpp:
\code
...
    // Lay out the editor widgets manually
    QWidget * editor;
    QLabel * fLabel;
    QGridLayout * formLayout = new QGridLayout( w );

    formLayout->setSpacing( 5 );
    formLayout->setMargin( 5 );

    form = new QSqlForm( this, "matchform" );

    QSqlEditorFactory * ef = QSqlEditorFactory::defaultFactory();
    QSqlPropertyMap * pm   = new QSqlPropertyMap();

    pm->insert( "TeamPicker", "teamid" );
    form->installPropertyMap( pm );

    fLabel = new QLabel( buf->displayLabel( "winner" ), w );
    wteam = new TeamPicker( w );
    wteam->setTeamId( buf->value("winnerid").toInt() );
    formLayout->addWidget( fLabel, 0, 0 );
    formLayout->addWidget( wteam, 0, 1 );
    form->associate( wteam, buf->field("winnerid") );
...
\endcode

To be able to use the readRecord() and writeRecord() functions in
QSqlForm, we need to install a new property map to tell the form of
the \a teamid property in TeamPicker, which is our custom field
editor. If we only used the standard widgets that the default
QSqlEditorFactory creates, this would not have been necessary.

\code
    QSqlPropertyMap * pm   = new QSqlPropertyMap();

    pm->insert( "TeamPicker", "teamid" );
    form->installPropertyMap( pm );
\endcode

Above, we create a new QSqlProperyMap, add our TeamPicker class to the
map, and install the new map in the form we just created.


// ### Missing: explanation of the calculated fields in the MatchCursor

*/