/****************************************************************************
**
** Documentation for sql programming
**
** Copyright (C) 1992-2000 Trolltech AS.  All rights reserved.
**
** This file is part of the Qt GUI Toolkit.
**
** This file may be distributed under the terms of the Q Public License
** as defined by Trolltech AS of Norway and appearing in the file
** LICENSE.QPL included in the packaging of this file.
**
** This file may be distributed and/or modified under the terms of the
** GNU General Public License version 2 as published by the Free Software
** Foundation and appearing in the file LICENSE.GPL included in the
** packaging of this file.
**
** Licensees holding valid Qt Enterprise Edition or Qt Professional Edition
** licenses may use this file in accordance with the Qt Commercial License
** Agreement provided with the Software.
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
**   information about Qt Commercial License Agreements.
** See http://www.trolltech.com/qpl/ for QPL licensing information.
** See http://www.trolltech.com/gpl/ for GPL licensing information.
**
** Contact info@trolltech.com if any conditions of this licensing are
** not clear to you.
**
**********************************************************************/

/*! \page sql-walkthrough.html

\ingroup walkthroughs

\title Example SQL application walkthrough

This walkthrough shows simple use of QSqlIndex, QSqlQuery, QSqlCursor,
QSqlTable and QSqlForm - classes that a database front-end or database
application would be expected to use. It is not meant as a guide to Qt
programming in general, but rather to illustrate the most common use
of some of the classes in the SQL module. Explanations that cover
general widget creation and layout is in most cases skipped. To get
the most from this walkthrough, you should have read the 
<a href="sql.html">documentation</a> on records, fields, indexes,
queries and cursors.

This example uses a set of database tables which keep track of pingpong
teams and scores. The example program can be found in \c
$QTDIR/examples/pingpong. This directory also contains \e pingpong.sql
which is a SQL script for creating the tables and views used in this
example. First, an overview of the database:

The database contains four simple tables: 
<ul>
<li>\a match - Stores pingpong match results
<li>\a team - Stores the different teams
<li>\a player - Stores the different players
<li>\a player2team - Maps players to teams. A player can be a member of several teams.
</ul>

In addition, the database contains a couple of views (\a matchview and
\a player2teamview) and a few key sequences used to generate new
primary keys.

Our goal is to create a simple application that makes it possible to
do the following:
<ul>
<li> manage match results (insert/update/delete results)</li>
<li> create and edit teams and players</li>
<li> generate team statistics, such as wins and losses</li>
<li> include a highscore table that ranks the different teams</li>
</ul>

The \c pingpong example program consists of the following files:

\c main.cpp - Contains the main() function and shows how to connect to
an existing database<br>
\c cursors.h/cpp - Contains reimplementations of QSqlCursor that are
used for traversing datasets.<br>
\c dialogs.h/cpp - Contains the dialogs that are used in the pingpong
example.<br>
\c widgets.h/cpp - Contains the different widgets that are used to
display statistics, highscores, etc.<br>
\c pingpongfrontend.h/cpp - Implementation of the main window in the
application.<br>

Most of the widget layout and creation is performed using Qt Designer -
try loading the following files into the Designer:

\c teameditorbase.ui - \c TeamEditor widget form.<br>
\c statisticsbase.ui - \c Statistics widget form.<br>
\c matchdialogbase.ui - \c MatchDialog dialog form.<br>

<h2>Specifying a connection to a database (main.cpp)</h2>

\code
int main( int argc, char ** argv )
{
    QApplication a( argc, argv );

    QSqlDatabase * db = QSqlDatabase::addDatabase( "QPSQL6" );
    db->setDatabaseName( "pingpong" );
    db->setUserName( "db" );
    db->setPassword( "db" );
    db->setHostName( "silverfish" );

    if( !db->open() ){
	qWarning( "Unable to open database: " + db->lastError().driverText());
	qWarning( db->lastError().databaseText() );
	return 0;
    }

    PingpongFrontEnd dbapp;

    a.setMainWidget( &dbapp );
    dbapp.show();

    return a.exec();
}
\endcode

Starting with the \c main.cpp file, the first thing we do after the
usual QApplication object is created, is to specify a connection to the
database we want to use.
\code
    QSqlDatabase * db = QSqlDatabase::addDatabase( "QPSQL6" );
\endcode 
The line above specifies which driver should be used to access the
database. The Qt SQL module currently supports the following drivers:

<ul>
<li>QPSQL6 - Postgres v6.x databases</li>
<li>QPSQL7 - Postgres v7.x databases</li>
<li>QMYSQL - MySQL databases</li>
<li>QODBC - ODBC databases</li>
<li>QOCI - Oracle databases</li>
</ul>

As we have used Postgres version 6.5 to implement our \a pingpong
database, we choose the QPSQL6 driver to access the database. After
specifying the driver we need to specify the database name, user name
and password, and the host the database is running on.
\code
    db->setDatabaseName( "pingpong" );
    db->setUserName( "db" );
    db->setPassword( "db" );
    db->setHostName( "silverfish" );
\endcode
After all the necessary information is passed to QSqlDatabase, the
database we attempt to open the connection with the following statement:
\code
    if( !db->open() ){
	qWarning( "Unable to open database: " + db->lastError().driverText());
	qWarning( db->lastError().databaseText() );
	return 0;
    }
\endcode

If there was an error while opening the database it can be retrieved
by calling QSqlDatabase::lastError() (also see \l QSqlError).

The connection that has just been created will now be used as the
default database connection by the low-level classes in the SQL modules.
So long as you only need access to just one database you will not need
to use the QSqlDatabase class any further. There is no need to specify
the database connection in subsequent code since this default will be
assumed where no connection is given.

If multiple database connections are required they can be added using
calls to QSqlDatabase::addDatabase(). In this situation the particular
connection to be used for each call should be specified.

After the database connection is up and running - we create an
instance of the main window widget, \c PingpongFrontEnd, and enter the
event loop.

<h2>Main window initialization</h2>

The main window consists of a tab widget that contains four different
tabs:
<ul>
<li>Match table - a table used to view the match results (QSqlTable widget)
<li>Statistics - contains some simple statistical information about each team (Statistics widget)
<li>Hall of Fame - contains the highscore table (HighscoreList widget)
<li>Team editor - used to add/edit teams and players in the database (TeamEditor widget)
</ul>

Except for match table widget, the definition and implementation of
these widgets can be found in the \c widgets.h and \c widgets.cpp files.

<b>The match table widget</b>

The match table is a QSqlTable widget used to display the MatchView
cursor. MatchView is a QSqlCursor that is associated with the \a matchview 
view in our database.

From \c cursors.h:
\code
class MatchView : public QSqlCursor
{
public:
    MatchView();
};
\endcode

From \c cursors.cpp:
\code
MatchView::MatchView()
    : QSqlCursor( "matchview" )
{
    setDisplayLabel( "loserwins", "Loser Wins" );
    setDisplayLabel( "winnerwins", "Winner Wins" );
    setDisplayLabel( "date", "Date" );
    setDisplayLabel( "loser", "Loser" );
    setDisplayLabel( "winner", "Winner" );
    setDisplayLabel( "sets", "Sets" );
}
\endcode

The definition and implementation of the \c MatchView class is simple.
In the constructor a \l QSqlCursor is instantiated, with bindings to the
\a matchview database view. Also, a new set of display labels are
assigned to the different fields in the cursor. These display labels are
used by QSqlTable when displaying data on screen.

The initialization of the match table itself is performed in the
constructor of the \c PingpongFrontEnd class.

From \c pingpongfrontend.cpp:
\code
...
    // Set up the initial match table
    matchView.select( matchView.index( "date" ) );
    matchTable->setCursor( &matchView, FALSE );
    matchTable->addColumn( matchView.field( "date" ) );
    matchTable->addColumn( matchView.field( "winner" ) );
    matchTable->addColumn( matchView.field( "winnerwins" ) );
    matchTable->addColumn( matchView.field( "loser" ) );
    matchTable->addColumn( matchView.field( "loserwins" ) );
    matchTable->addColumn( matchView.field( "sets" ) );
    matchTable->setSorting( TRUE );
    matchTable->setReadOnly( TRUE );
...
\endcode

First, a \c select is issued on the \c MatchView cursor:

\code
    matchView.select( matchView.index( "date" ) );
\endcode

This will generate a resultset which contains all the records in the
\a matchview view, sorted on the \a date field. 

\code
    matchTable->setCursor( &matchView, FALSE );
    matchTable->addColumn( matchView.field( "date" ) );
    matchTable->addColumn( matchView.field( "winner" ) );
    matchTable->addColumn( matchView.field( "winnerwins" ) );
    matchTable->addColumn( matchView.field( "loser" ) );
    matchTable->addColumn( matchView.field( "loserwins" ) );
    matchTable->addColumn( matchView.field( "sets" ) );
\endcode

The \c MatchView cursor becomes the data source for the \c matchTable
table. \c setCursor() is called to associate the \c MatchView cursor
with \c matchTable. The cursor is added to the table with \a
autoPopulate set to FALSE, because we want to set the order and number
of columns to display in the table ourselves. \c addColumn() is called
to add the fields from the \c MatchView cursor which we want to appear
in the table.

\code
    matchTable->setSorting( TRUE );
    matchTable->setReadOnly( TRUE );
\endcode

We also want to be able to sort the table on any of the columns, and
we don't want the user to insert/update/delete records directly in
this table - we will be using a separate dialog for that (see 
<a href="#MatchDialog">MatchDialog</a>).

Our \c matchTable widget has now been set up correctly to display a
list of all the matches that have been played, sorted by \a date.

<b>The TeamPicker custom editor</b>

The \c TeamPicker widget is an example of a custom SQL field editor.

\code
class TeamPicker : public QComboBox
{
    Q_OBJECT
    Q_PROPERTY( int teamid READ teamId WRITE setTeamId )

public:
    TeamPicker( QWidget * parent = 0, const char * name = 0 );
    int teamId() const;
    void setTeamId( int id );

private:
    QMap< int, int > index2Id;
};
\endcode

The \c TeamPicker widget is a QComboBox that contains the names of the
different teams in the database. The Q_PROPERTY macro is used to
define and associate the \c teamid property with the \c TeamPicker
class. This is used by the QSqlPropertyMap to insert/extract values
into/from the widget when it appears in a QSqlTable or a QSqlForm.

From the \c TeamPicker constructor in \c widgets.cpp:

\code
TeamPicker::TeamPicker( QWidget * parent = 0, const char * name = 0 )
    : QComboBox( parent, name )
{
    QSqlCursor team( "team" );
    team.select( team.index("name") );
    int idx = 0;
    while( team.next() ) {
	insertItem( team.value("name").toString(), idx );
	index2Id[idx] = team.value("id").toInt();
	idx++;
    }
}
\endcode

When the \c TeamPicker widget is constructed, the database is queried
for the team names. We do this by creating a cursor associated with
the \a team table, and selecting all the entries in that table, sorted
on the team name. We then iterate through the cursor records and
insert the team names into the QComboBox. Notice also that we store
the primary key for each of these entries. This is necessary so that
we can use these primary index values later in our program, as the
team name itself does not necessarily uniquely identify a \a team
record.

<b>The Statistics widget</b>

The Statistics widget is a collection of QLabel widgets that are used
to display statistical information about our teams.  The statistics
consists of sets won, matches won, sets lost, etc. All the interesting
action takes place in the \c Statistics::update() function, where the
database is queried and the values generated and displayed. 

To calculate the statistical values, a series of simple SQL queries
are used. We get the currently selected \a teamid from the \c
TeamPicker (see above) to use as the basis for our queries:

From the \c Statistics::update() function in \c widgets.cpp:
\code
    int teamId = teamPicker->teamId();
\endcode

For example, the following lines query the database and update the
label used to view 'Total sets won':

\code
...
    // Sets won
    QSqlQuery query( "select sum(winnerwins) from match where winnerid = " +
		     QString::number( teamId ) + ";" );
    if( query.next() )
	sets = query.value(0).toInt();
    // Remember the sets won in matches that have been lost
    query.exec( "select sum(loserwins) from match where loserid = " +
		QString::number( teamId ) + ";" );
    if( query.next() )
	sets += query.value(0).toInt();
    setsWon->setText( QString::number( sets ) );
    numSets = sets;
...
    // Total sets
    totalSets->setText( QString::number( numSets ) );
...
    
\endcode

Other statistics are calculated in a similar way, using QSqlQuery to
send SQL statements to the database and retrieve query data.

Similarly, the \c HighscoreList widget is used to display a list of
the teams in the database, where the team with the most wins are at
the top of the list. The same technique to query the database is
used. The result of the query is inserted into a QListView widget for
display.

<b>The TeamEditor widget</b>

The Team editor is used to add/remove teams, add/remove players and
add/remove players from teams. 

The editor consists of three QSqlTable widgets that are used to
display a list of teams, players and the players that belong to a
specific team. QSqlTable widgets are used because we want the user to
be able to insert, update and delete teams and players directly in the
table. Once the QSqlTable widgets are initialized properly, they can
handle inserts, updates and deletes without additional code. 

From the TeamEditor constructor in widgets.cpp:
\code
TeamEditor::TeamEditor( QWidget * parent, const char * name )
    : TeamEditorBase( parent, name )
{
    teamCursor.select( teamCursor.index( "name" ) );
    teamTable->setCursor( &teamCursor );
    teamTable->setSorting( TRUE );

    playerCursor.select( playerCursor.index( "name" ) );
    playerTable->setCursor( &playerCursor );
    playerTable->setSorting( TRUE );

    player2teamTable->setCursor( &player2teamView ); // auto populates columns
    player2teamTable->setReadOnly( TRUE );
    player2teamTable->setSorting( TRUE );

    QSqlRecord t = teamTable->currentFieldSelection();
    updateTeamMembers( &t );
}
\endcode

Each table is associated with the appropriate cursor. Notice that we
use the \a autoPopulate feature of the QSqlTable::setCursor()
function. This automatically generates and updates the columns we want
to display.

Also, the currentChanged() signal emitted by the \c teamTable widget
is connected to a slot, \c updateTeamMembers(), which will update the
\c player2teamTable to display the members of the currently selected
team.

\code
void TeamEditor::updateTeamMembers( const QSqlRecord * record )
{
    player2teamView.select( "teamid = " + record->value( "id" ).toString());
    player2teamTable->refresh();
    player2teamLabel->setText( "Players on <i>" +
			       teamCursor.value("name").toString() + "</i>");
}
\endcode

<h2>Inserting, updating and deleting matches</h2>

Inserting, updating and deleting match results are done using a
separate dialog, <a name="MatchDialog">\c MatchDialog</a>. The \c
MatchDialog is a good example of how to use a QSqlForm with a custom
editor widget. The role of the QSqlForm is to manage the
synchronization of widgets and database fields in the dialog. The
widget creation and layout is done using the Qt Designer (see the \c
matchdialogbase.ui file).

From the \c MatchDialog constructor in \c dialogs.cpp:
\code
...
    form = new QSqlForm( this, "matchform" );
    QSqlPropertyMap * pm = new QSqlPropertyMap();
    
    pm->insert( "TeamPicker", "teamid" );
    form->installPropertyMap( pm );

    form->insert( winnerTeam, buf->field("winnerid") );
    form->insert( loserTeam, buf->field("loserid") );
    form->insert( winnerWins, buf->field("winnerwins") );
    form->insert( loserWins, buf->field("loserwins") );
    form->insert( date, buf->field("date") );
    
    form->readFields();
    updateSets();
...
\endcode

After creating the QSqlForm object, we need to install a customized
property map. This has to be done for our \c TeamPicker widget to
function properly. The map is used to insert and extract values from
the widgets in the form. QSqlForm::insert() is used to map a widget to
a specific database field. Once all our form widgets are mapped to
their respective database fields, we can use the \l QSqlForm::readFields() 
and \l QSqlForm::writeFields() functions to synchronize the widgets
and fields.

The actual inserts, updates and deletes occur in the \c insertMatch(),
\c updateMatch() and \c deleteMatch() functions in \c pingpongfrontend.cpp.

\code
void PingpongFrontEnd::insertMatch()
{
     MatchDialog dlg( matchCursor.insertBuffer(), MatchDialog::Insert, this );
     if( dlg.exec() == QDialog::Accepted ){
 	matchCursor.insert();
 	matchTable->refresh();
	highscore->update();
	statistics->update();
     }
}
\endcode

A \c MatchDialog is used to obtain the values we want to insert into
the database. We instantiate a \c MatchDialog with a QSqlRecord
buffer, which we get from the \c matchCursor. The
QSqlCursor::insertBuffer() function returns a pointer to an internal
buffer, which we can use to insert new records into the
cursor. QSqlCursor::insert() is called to insert the actual values
into the database. QSqlTable::refresh() is called to update our match
table. We also call functions that update the highscore table and the
statistics widget.


\code
void PingpongFrontEnd::updateMatch()
{
    QSqlRecord r = matchTable->currentFieldSelection();
    if ( !r.count() )
	return;
    matchCursor.setValue( "id", r.value( "id" ) );
    matchCursor.select( matchCursor.primaryIndex(), matchCursor.primaryIndex() );
    if ( matchCursor.next() ) {
	MatchDialog dlg( matchCursor.updateBuffer(), MatchDialog::Update, this );
	if( dlg.exec() == QDialog::Accepted ){
	    matchCursor.update();
	    matchTable->refresh();
	    highscore->update();
	    statistics->update();
	}
    }
}
\endcode

To update a match result we also use a \c MatchDialog. Firstly we obtain
the currently selected record from our \c matchTable widget. If the
record does not contain any fields we return without doing anything. The
next two lines retrieve the corresponding record from the actual \a
match table in the database. We cannot update the values directly in \c
matchTable, because it is based on a view in the database (a limitation
in Postgres databases). Instead, we retrieve the record we want to
update from the \a match table using the id from the \a matchview (bound
to our \c matchTable widget). A \c MatchDialog is instantiated with a
QSqlRecord buffer that contains the current values of the fields we want
to update. QSqlCursor::update() is then called to actually update the
fields in the database.


\code
void PingpongFrontEnd::deleteMatch()
{
    QSqlRecord r = matchTable->currentFieldSelection();
    if ( !r.count() )
	return;
    
    matchCursor.setValue( "id", r.value( "id" ) );
    matchCursor.select( matchCursor.primaryIndex(), matchCursor.primaryIndex() );
    if ( matchCursor.next() ) {
	MatchDialog dlg( matchCursor.updateBuffer(), MatchDialog::Delete, this );
	if( dlg.exec() == QDialog::Accepted ){
	    matchCursor.del();
	    matchTable->refresh();
	    highscore->update();
	    statistics->update();
	}
    }
}
\endcode

Deleting a match result from the match table is done in a similar
way. We retrieve the currently selected record from the \a match table
and display it in a \c MatchDialog. The QSqlCursor::del() function is
called to actually delete the record from the database.


*/
