/****************************************************************************
**
** Documentation for qmake
**
** Copyright (C) 1992-2001 Trolltech AS.  All rights reserved.
**
** This file is part of the Qt GUI Toolkit.
**
** This file may be distributed under the terms of the Q Public License
** as defined by Trolltech AS of Norway and appearing in the file
** LICENSE.QPL included in the packaging of this file.
**
** This file may be distributed and/or modified under the terms of the
** GNU General Public License version 2 as published by the Free Software
** Foundation and appearing in the file LICENSE.GPL included in the
** packaging of this file.
**
** Licensees holding valid Qt Enterprise Edition or Qt Professional Edition
** licenses may use this file in accordance with the Qt Commercial License
** Agreement provided with the Software.
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
**   information about Qt Commercial License Agreements.
** See http://www.trolltech.com/qpl/ for QPL licensing information.
** See http://www.trolltech.com/gpl/ for GPL licensing information.
**
** Contact info@trolltech.com if any conditions of this licensing are
** not clear to you.
**
**********************************************************************/

/*! \page qmake-guide.html

\title qmake User's Guide

<ul>
<li><a href="#About">About This Manual</a></li>
<li><a href="#Installation">Installing <em>qmake</em></a></li>
<li><a href="#QuickStart">Quick Start: Running <em>qmake</em></a></li> 
<li><a href="#Introduction">Introducing <em>qmake</em></a></li>
<li><a href="#Concepts"><em>qmake</em> Concepts</a></li> 
<li><a href="#Details"><em>qmake</em> Details</a></li> 
<li><a href="#Tutorial"><em>qmake</em> tutorial</a></li>
</ul>

See also the <a href="qmake-commandreference.html"><em>qmake</em> Command Reference</a>.

<h1><a name="About">About This Manual</a></h1>

This manual describes <em>qmake</em>, a cross-platform utility for
generating makefiles.  <em>qmake</em> was written by Trolltech to
provide a simple-to-use tool for supporting large and complex software
builds across many platforms, including:

<ul>
<li>MS/Windows - 95, 98, NT, and 2000</li>
<li>Unix/X11 - Linux, Sun Solaris, HP-UX, Tru64, IBM AIX, SGI IRIX and a wide range of others</li>
<li>Embedded - Linux platforms</li>
</ul>

<h1><a name="Installation">Installing <em>qmake</em></a></h1>

<em>qmake</em> is a standard part of the Qt library installation and
will be built and installed properly when building the Qt library.  To
install <em>qmake</em> separately:

<ol>
<li>Unpack the Qt archive, configure and build
<li>The 'qmake' executable will then be located in the 'bin' subdirectory
</ol>

After <em>qmake</em> is built:

<ol> <li>Set the QMAKESPEC environment variable to point to a directory
containing a description of your platform and compiler (see below) <li>Add
the 'qmake' executable to your PATH </ol>

Here are some examples:

<ul>
<li>Unix Bourne shell:<p>
\code
	QMAKESPEC=/usr/local/qt/mkspecs/linux-g++
	PATH=$PATH:/local/qmake/bin
	export QMAKESPEC PATH
\endcode

<li>Unix C shell:<p>
\code
	setenv QMAKESPEC /usr/local/qt/mkspecs/linux-g++
	setenv PATH $PATH:/local/qmake/bin
\endcode

<li>Microsoft Windows:<p>
\code
	set QMAKESPEC=c:\qt\mkspecs\win32-msvc
	set PATH=%PATH%;c:\qmake\bin
\endcode
</ul>

<em>qmake</em> is now installed.

<h1><a name="QuickStart">Quick Start: Running <em>qmake</em></a></h1> 

Let's assume you have a small Qt application consisting of one C++ header
file and two source files.

First you need to create a <em>qmake</em> project file,
e.g. hello.pro:

\code
  HEADERS   =  hello.h
  SOURCES   =  hello.cpp main.cpp
  TARGET    =  hello
\endcode

This file contains information about the 'hello' <a
href="#ProjectFiles">project</a>.  To create a makefile for this
project, invoke <em>qmake</em> as follows:

\code
  qmake hello.pro -o Makefile
\endcode

This creates a makefile for the 'hello' project.  To compile this
project, type:
 
\code
  make
\endcode


This builds the 'hello' program. Remember to set the <a href="#QMAKESPEC">QMAKESPEC</a> environment 
variable properly before you run qmake.

<h1><a name="Introduction">Introducing qmake</a></h1>

\e qmake is a simple tool from Trolltech to create and maintain
makefiles for software projects across multiple platforms.
<em>qmake</em> provides all of the functionality involved in
generating complex makefiles using a single 'project' specification.
That 'project' can be targeted to create makefiles for different
platforms.  It can be a painful task to manage makefiles manually,
especially if you develop for more than one platform or use more than
one compiler.  <em>qmake</em> automates and streamlines this process,
allowing you to spend your valuable time writing code, not
makefiles.

<em>qmake</em> can be used for any software project of any size,
and also contains special features to support developing
applications with <a href="http://www.trolltech.com/">Trolltech's</a>
<a href="http://www.trolltech.com/qt/"> Qt</a> library.

<em>qmake</em> is a part of the Qt library and is licensed under several
licenses, including the QPL, GPL and a commercial license.  See the <a
href="http://doc.trolltech.com/licenses.html">Qt</a> LICENSE file for
details.


<h1><a name="Concepts"><em>qmake</em> Concepts</a></h1> 

<h3>Running <em>qmake</em></h3>

<em>qmake</em> understands a simple language to describe a makefile,
and in turn will generate a project description as appropriate for
your target platform. <em>qmake</em> currently generates output
for:

<ul>
<li>borland make makefiles
<li>unix-style makefiles, i.e. suitable for gmake, etc.
<li>msdev nmake makefiles
<li>msdev dsp project files
</ul>

<h3><a name="QMAKESPEC">QMAKESPEC</a></h3>

<em>qmake</em> requires a description of your platform so that a
suitable makefile can be generated.  These descriptions are kept in a
'makefile specification' file called qmake.conf. <em>qmake</em>
needs this configuration file in order to generate appropriate
makefiles for specific platform and compiler combinations.  The \c
QMAKESPEC environment variable must be set to the name of a directory
which contains this configuration file.  The qmake.conf file will
contain such basic information as the compiler to use, the names of
system libraries and the location of system headers.  

On startup, <em>qmake</em> will attempt to locate the qmake.conf file
for your platform by using the QMAKESPEC environment variable.  Alternatively, 
load all of its default values.  The QMAKESPEC environment variable
can be used to tell <em>qmake</em> where to find this file, or a
command line option can be given.  <em>qmake</em> ships with many
standard QMAKESPEC files for many platform-compiler combinations.  See
the <a href="qmake-commandreference.html#QMAKESPEC"<em>qmake</em>
command reference</a> for more information.

The QMAKESPEC environment variable should point to a directory which
contains information about your platform and compiler.  When invoked,
<em>qmake</em> will use $QMAKESPEC to find your compiler specifications.
This configuration file contains compiler options and lists tools and
libraries.

You can find many platform-compiler combination descriptions in the
'mkspecs' directory of your Qt installation.


<h3><a name="ProjectFiles">Project Files</a></h3>

Armed with your platform description from the appropriate QMAKESPEC
file, <em>qmake</em> will then load any specified 'project files'
which describe your software project and generate a makefile to build
that project.  A <em>project file</em> will typically contain a list
of header and source files used by your project.  For Qt-based
projects, <em>qmake</em> will automatically generate dependencies for
<a href="moc.html">moc</a> and <a href="designer.html">uic</a>, if
they are needed by your project.  The project file will also contain
information about the type of project being created (for example, an
application or a library), as well as configuration information (such
as debug/release, project defines, and extra libraries used when
linking).

<h3>Project Templates</h3>

<em>qmake</em> understands several kinds of 'templates' which tell
<em>qmake</em> what kind of project it is building. The supported
values are:

<ul>
<li>app - Creates a makefile for building applications (the default)
<li>lib - Creates a makefile for building libraries
<li>subdirs - Creates a makefile for building targets in subdirectories
</ul>

A project 'template' is specified using the TEMPLATE system variable.
If no TEMPLATE is specified, 'app' is assumed.

<h3>The Application Template</h3>

The application template, 'app', lets you generate makefiles to
compile and link executable programs.

This template recognizes several system variables

<ul>
<li>HEADERS - Header files
<li>SOURCES - Source files
<li>LEXSOURCES - <em>qmake</em> will generate a makefile to process the listed files with
        lex, and then compile it
<li>YACCSOURCES - <em>qmake</em> will generate a makefile to process the listed files with
        yacc, and then compile it
<li>TARGET - Name of executable (adds .exe if on Windows).
<li>DESTDIR - Where to put the TARGET
<li>DEFINES - Tell compiler to define C preprocessor macros (-D option)
<li>INCLUDEPATH - Sets the include file search path for the compiler (-I option).
<li>DEPENDPATH - Sets the dependency search path for the compiler
<li>INTERFACES - Specify .ui files for addition to the build
<li>DEF_FILE - Win32 only: Link with a .def file
<li>RC_FILE - Win32 only: Use a .rc file (compile to temporary .res)
<li>RES_FILE - Win32 only: Link with a .res file
</ul>

<h3>The Library Template</h3>

The library template, 'lib', lets you generate makefiles to compile
and create static or shared libraries.

This template supports the same project variables as 'app' (see
above), as well as the following sytem variables:

<ul>
<li>VERSION - the version number of the target library, e.g. 1.40.  The version is
important for shared libraries.
</ul>

<h3>The Subdirs Template</h3>

The 'subdirs' template lets you generate makefiles to invoke
<em>qmake</em> within subdirectories.

This template recognizes the following system variables:

<ul>
<li>SUBDIRS - contains the name of all subdirectories to be processed
</ul>

<em>qmake</em> assumes that each subdirectory contains additional project
files to be processed.  Each sub-project file must be named the same as the
directory (ie in subdirectory display, you must have a display.pro which
will be made by built by qmake, and finally make the project).  See the
<em>qmake</em> <a href="qmakecommandreference.html#subdirs">reference
manual</a> for details.

<h3>Special Templates for Microsoft Visual C++</h3>

If you have Microsoft Visual C++ 5.0, 6.0 or higher, you can use two
special templates to generate a MSVC++ IDE project (.dsp file).  After
you have generated e.g. hello.dsp, choose "File"->"Open Workspace" and
select the hello.dsp file.  Visual C++ will then create a workspace
(.dsw file) for you.  The additional templates for Microsoft Visual C++
are:

<ul>
<li>vcapp - Creates an application project file
<li>vclib - Creates a library project file
</ul>

Run <em>qmake</em> to create a hello.dsp file (use -t to override the
default template):

\code
  qmake -t vcapp -o hello.dsp hello.pro
\endcode

<h3><a name="CONFIG">Project Configuration</a></h3>

The \c CONFIG system variable is recognized by <em>qmake</em> and
specifies what compiler options to use and which extra libraries to
link in. Anything may be assigned to this variable, however some
values will be recognized internally by <em>qmake</em> and have
special meaning as described below.

These options control the compilation flags:

<ul>
<li>release - Compile with optimization enabled, ignored if
    "debug" is specified
<li>debug - Compile with debug options enabled
<li>warn_on - The compiler should emit more warnings than normally, ignored if
     "warn_off" is specified
<li>warn_off - The compiler should emit as few warnings as possible,
preferably none at all.
</ul>

These options define the application/library type:

<ul>
<li>qt - The target is a Qt application/library and requires Qt header files/library.
<li>opengl - The target requires the OpenGL (or Mesa) headers/libraries.
<li>thread - The target is a multi-threaded application or library.
<li>x11 - The target is a X11 application or library.
<li>windows - The target is a Win32 window application (app only).
<li>console - The target is a console application (app only).
<li>dll - The target is a shared object/DLL.
<li>staticlib - The target is a static library (lib only).
<li>plugin - The target is a plugin (lib only). This enables dll as well.
</ul>

For example, if the 'hello' application uses both Qt and the OpenGL
libraries, and you want to compile it with debugging symbols, the
hello.pro project file should contain a \c CONFIG line like the
following:

\code
  CONFIG = qt opengl debug
\endcode

The CONFIG system variable is also used when <a
href="#Scopes">scoping</a> variable assignments.

The most common <em>qmake</em> options and project variables are
described here.  See the <em>qmake</em> <a
href="qmakecommandreference.html#CONFIG">reference manual</a> for
details.

<h1><a name="Details"><em>qmake</em> Details</a></h1> 

<em>qmake</em> project files (typically having a .pro extension) are
parsed from top to bottom and consist of a series of user defined
variables as well as operations on those variables.  When
<em>qmake</em> is finished parsing the file without error, a makefile
is generated for the platform-compiler combination specified by the
QMAKESPEC file.  The order of execution for <em>qmake</em> is:

<ol>
<li>Parse the QMAKESPEC config file (qmake.conf)
<li>Parse the cache file, if available (.qmake.cache)
<li>Parse and command line options
<li>Parse the project file
</ol>

When parsing, there are two classes of variables understood by
<em>qmake</em>: user-defined variables and internal system variables.
Many internal system variables begin with 'QMAKE_' (user variables
should of course use a different prefix), and there are a few
common system variables with simpler names, such as PROJECT, CONFIG,
SOURCES, HEADERS, etc (more on these project variables below). Below
is an outline of the language features understood by <em>qmake</em>.

<h3>Syntax</h3>

A <em>qmake</em> project file has a very simple syntax.  

The # character begins a comment which lasts until the end of the
line.

<h3>Variables</h3>

You may set project variables, append to project variables, and remove
from project variables.

To set a project variable:

\code
    HEADERS = gui.h xml.h url.h
\endcode

If you cannot fit everything on one line, use '\' to split it up:

\code
    HEADERS = gui.h \
	      xml.h \
	      url.h
\endcode

A user variable name can be any string.  The five operators (~=, *=,
=, -=, and +=) can be used together to operate on those
variables. Using $$ you can refer to another variable previously
defined in <em>qmake</em>.  There are several operators available to
work on lists of values.  For example:

\code
  PIG=oink moo    #$$PIG contains oink and moo 
  PIG-=moo        #$$PIG now contains only oink
  OTHERPIG=$$PIG  #$$OTHERPIG contains oink
  PIG+=snort      #$$PIG now contains oink and snort
  OTHERPIG=eat    #$$OTHERPIG now contains only eat
\endcode

See the <a href="qmake-commandreference.html#operators"<em>qmake</em>
command reference</a> for more info.

Project variables contains lists of items (for system variables, these
consist of things such as header files, compiler options etc.) and use
whitespace to separate the items.  This means that <em>qmake</em>
cannot deal with items containing whitespace.  The INCLUDEPATH
variable is an exception. If INCLUDEPATH contains one or more
semicolons (;), <em>qmake</em> uses the semicolon to separate the
include directories, hence you can have include directories containing
whitespace (this is quite common on Windows).

Here is an example:

\code
    INCLUDEPATH = C:\Program Files\DBLib\Include;C:\qt\include
\endcode

<em>qmake</em> supports <em>project variable expansion</em>. Use $$ to
expand any project variable:

\code
    ALLFILES = $$HEADERS $$SOURCES
\endcode

Most often you assign values to a project variable, but you can also
add to, remove from or replace parts of a project variable:

\code
    A   = abc
    X   = xyz
    A  += abc def		# A = abc def
    C   = $$A			# C = abc def
    C  += ghi			# C = abc def ghi
    B   = $$A			# B = abc def
    B  -= abc			# B = def
    B  *= abc def       # B = abc abc def
    A  ~= s/ab[xc]/xyz/ # A = xyz def
\endcode

<p> You can also set variables from the command line when running the
<em>qmake</em> program. For instance, if you want to generate a
makefile with debug information:

\code
    qmake "CONFIG+=debug" hello.pro
\endcode

<h3><a name="Scopes">Scopes</a></h3>

You may use scopes to conditionally assign to variables. There are
several ways to test for something being "in scope":

<ul>
<li>It appears in the CONFIG variable (see the <a href="#CONFIG">CONFIG</a> section)
<li>If <em>qmake</em> is in an OS mode (see the -unix/-win32 option in the
    <a href="qmake-commandreference"> command reference</a>) you may
    use the OS dependent scope (unix/win32)
<li>Function testing (see the <a href="#Functions">function tests</a> section)
<li>If a given compiler is used as specified by the QMAKESPEC (see the 
    <a href="#QMAKESPEC">QMAKESPEC</a> section).
</ul>

Scopes must be colon separated from their assignment for example:

\code
    SOURCES	   =   common.cpp   # common for all platforms
    unix:SOURCES   +=  unix.cpp	    # additional sources for Unix
    win32:SOURCES  +=  win32.cpp    # additional sources for Windows
    unix:LIBS	   +=  -lm	    # on Unix we need the math lib
\endcode

You may logically AND together scopes by separating multiple scopes with
colons, similarly you may negate a scope with the '!' character. In
some cases you may actually just want to execute the scope, and not do
an assignment, this is perfectly legal in <em>qmake</em> - and the
final colon is optional. For example:

\code
   win32:win32-msvc:USING_MSVC=1 #if this is win32, and the win32-msvc
                                 #compiler is to be used then set the variable
   unix:include(file.pri)  #if this is unix, then substitute the contents
                           #file.pri with this include line.
   !unix:debug:message(oh dear, unix should be debugged!):WEIRD=1
\endcode

The syntax scope:assignment can get a little cumbersome when a test is
performed multiple times. It also leads to a makefile becoming hard to
understand without digging into it, so scopes may be blocked to attempt to
modularize different tests. For example:

\code
   win32:dance {
      contains(dance, square_dance):CONFIG += howdown
      contains(dance, disco):CONFIG += nightfever
      ACTION += dancing
   }
\endcode

Because the syntax for qmake is line based it makes the blocking syntax
very strict, this means: You must have the { on the same line as the scope
test (you may have 1 assignment after it if you wish). Then the
following assignments must be one per line, and finally the block is
terminated with a line containing only a '}' character. There is a
provision for using only blocked style if you prefer on one line,
however it is discouraged, and the old style is still preferred for one
liners. For example:

\code
  test:VARIABLE = value  #is the same as...
  test { VARIABLE = value }
\endcode

<a name="Functions"><h3>Functions</h3></a>

As we've seen in some of the examples above, functions may be
used to do advanced tests. For the most part simply testing for
platform or the value appearing in the CONFIG variable should be
sufficent, but there are other built in functions which can be
used. The functions used by <em>qmake</em> may not be extended
externally, and this functionallity will probably not be added.  See
the <a href="qmake-commandreference.html#Functions"<em>qmake</em>
command reference</a> for more info.

<h3>Cache file</h3>

<em>qmake</em> can optionally use a 'cache' file to prevent mistaken
misconfiguration. <em>qmake</em> will never generate a cache file on its
own, it is the obligation of some outside program to do this. The
syntax is identical to a normal .pro file. The cache file must be called \c
.qmake.cache, and should be placed at the top directory of your project.
<em>qmake</em> will later walk backwards in your project hierarchy to find
it (ie starting at the your current working directory, then its parent, and
so on until it reaches a .qmake.cache, or the root).

<em>qmake</em> does not require the use of a .qmake.cache - and if it
does not exist <em>qmake</em> will not complain. If it does exist,
and you want to override it, you may use the -nocache option. See the <a
href="qmake-commandreference.html#cache"<em>qmake</em> command
reference</a> for more info.



<a name="Tutorial"><h3>Tutorial</h3></a>

With all the above you have enough to design a simple
build structure with <em>qmake</em>. In practice there are several
caveats to setting up such a project, and this tutorial will try to
run through a project file and describe what the output will be. It
will also try to give some helpful pointers on using <em>qmake</em> in a
similar fashion as Trolltech. 

So to start we will outline a simple build procedure. The first thing you
meet in many projects is a configure script. If you are writing a project
of any size you may want to do this by hand or even with autoconf. Once
this script has been run you need to create some Makefiles, similarly you
will probably want to create a .qmake.cache in your top level directory
(probably where your configure script is). If you create this .qmake.cache
each time the user runs configure you can guarantee that your whole tree
will be built using the same config options. The most useful things to put
in the .qmake.cache are:

CONFIG    - This will tell qmake what CONFIG's are in scope
QMAKESPEC - This will tell qmake what configuration should be used to
            create Makefiles. Strictly speaking this isn't necesary since
            the QMAKESPEC environment variable can be used instead, but
            placing it here will remove the necessity for the environment
            variable.

OBJ_DIR
UI_DIR
MOC_DIR   - If you want all your files to go to a directory (project-wide)
	        then specifying them in the .qmake.cache file will help.

After this has been done simply run qmake on the necesary .pro files and
you are are set. That is all that we'll mention about
configure scripts. If you are writing a small project (less than a couple
.pro files) then you may not need to bother with a configure script. 

How do we write project files for qmake to process? First you must
decide what kind of output you want, for example, a library or an
application. For demonstration purposes we will show an application:

\code
TEMPLATE=app
TARGET=hello_world
SOURCES=main.cpp hello.cpp
HEADERS=hello.h
\endcode
    
Taken line by line:

TEMPLATE=app
This will cause the output to be an application, it will be a fully
resolved object and will be placed in DESTDIR, which in this case is not set,
so will default to the current working directory.

TARGET=hello_world
An application will be created called hello_world

SOURCES=main.cpp hello.cpp
Both main.cpp and hello.cpp will be compiled and linked into the final
output of hello_world. It will look through these files and parse them as a
preprocessor and try to resolve all dependancies for the makefile.

HEADERS=hello.h
This tells qmake to look at hello.h. It doesn't mean it will actually do
anything in the Makefile, but instead qmake will try to decide if something
*should* be done. This mostly means if the header file needs to be moc'd
special rules will be added and it the new files will be added to the
project.

In many cases this is enough. With all this you are set to build a
hello_world project. But suppose your project was bigger and you had
some platform specific code:

\code
TEMPLATE=app
TARGET=hello_world
SOURCES=main.cpp hello.cpp
HEADERS=hello.h
unix:SOURCES+=hello_unix.cpp
win32 {
    SOURCES += hello_win.cpp
    CONFIG += bye_world
}
bye_world:DEFINES += DO_GOODBYE
data.path=$$target.path/data
data.files = data/*.dat
INSTALLS += data
target.path=/usr/local/$$TARGET
INSTALLS += target
\endcode

Explaining these new lines:

unix:SOURCES+=hello_unix.cpp
If the current target is unix then the file hello_unix.cpp will be included
in SOURCES and used as above.

win32 {
This starts a block, if win32 is the current target (then the above test
will have failed) and the following statements will be applied,
otherwise qmake will ignore them.

    SOURCES += hello_win.cpp
Similar to above hello_win.cpp will be added to the SOURCES, again this is
only if win32 was the current target

    CONFIG += bye_world
This will modify the CONFIG variable and add bye_world to the list of
active configurations.

}
This terminates the block, after this everything will be processed as
usual. It is safe to nest these conditionals (up to 32 deep), and qmake
will only process the correct blocks.

bye_world:DEFINES += DO_GOODBYE
If bye_world is in the CONFIG list, then DO_GOODBYE will be added to the
list of DEFINES, as above this case will only happen if:

\list 1
\i this is a win32 build, in which case the win32 block would have set it
\i if the QMAKESPEC/qmake.conf variable defined it (not likely)
\i if the .qmake.cache file specified it (in your configure script?)
\i on the command line to qmake.
\endlist

\code
data.path=$$target.path/data
data.files = data/*.dat
INSTALLS += data
\endcode
We'll look at these three lines together because they're related. First
we fill in an object called data. Strictly speaking these aren't
objects, as you are free to assign to anything in data (data.qmake for
example). Note that only certain variables will be looked at by qmake
(outlined in <a href="#InstallDetails">Install Targets</a>). 
Then it adds the 'data' object to the list of INSTALLS, which will later be
processed by qmake to create an install target. And then
<tt>target.path=/usr/local/$$TARGET</tt>
sets the target.path to /usr/local/hello_world

INSTALLS += target
This is similar to the above, but shows that target is a special install
object, that will use the .path member to decide where to put the things
qmake creates (in this case just $$TARGET, but in a library more could be created).

*/
