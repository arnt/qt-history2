/****************************************************************************
**
** Documentation for qmake
**
** Copyright (C) 1992-2001 Trolltech AS.  All rights reserved.
**
** This file is part of the Qt GUI Toolkit.
**
** This file may be distributed under the terms of the Q Public License
** as defined by Trolltech AS of Norway and appearing in the file
** LICENSE.QPL included in the packaging of this file.
**
** This file may be distributed and/or modified under the terms of the
** GNU General Public License version 2 as published by the Free Software
** Foundation and appearing in the file LICENSE.GPL included in the
** packaging of this file.
**
** Licensees holding valid Qt Enterprise Edition or Qt Professional Edition
** licenses may use this file in accordance with the Qt Commercial License
** Agreement provided with the Software.
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
**   information about Qt Commercial License Agreements.
** See http://www.trolltech.com/qpl/ for QPL licensing information.
** See http://www.trolltech.com/gpl/ for GPL licensing information.
**
** Contact info@trolltech.com if any conditions of this licensing are
** not clear to you.
**
**********************************************************************/

/*! \page qmake-guide.html

\title <em>qmake</em> User's Guide

<ul>
<li><a href="#About">About This Manual</a></li>
<li><a href="#Installation">Installing <em>qmake</em></a></li>
<li><a href="#QuickStart">Quick Start: Running <em>qmake</em></a></li> 
<li><a href="#Introduction">Introducing <em>qmake</em></a></li>
<li><a href="#Concepts"><em>qmake</em> Concepts</a></li> 
<li><a href="#Details"><em>qmake</em> Details</a></li> 
</ul>

See also the <a href="qmake-commandreference.html"><em>qmake</em> Command Reference</a>.

<h1><a name="About">About This Manual</a></li>

This manual describes <em>qmake</em>, a cross-platform utility for
generating makefiles.  <em>qmake</em> was written by Trolltech to
provide a simple-to-use tool for supporting large and complex software
builds across many platforms, including:

<ul>
<li>MS/Windows - 95, 98, NT, and 2000</li>
<li>Unix/X11 - Linux, Sun Solaris, HP-UX, Digital Unix, IBM AIX, SGI IRIX and a wide range of others</li>
<li>Embedded - Linux platforms <li>
</ul>

<h1><a name="Installation">Installing <em>qmake</em></a></h1>

<em>qmake</em> is a standard part of the Qt library installation and
will be built and installed properly when building the Qt library.  To
install <em>qmake</em> separately:

<ol>
<li>Unpack the Qt archive, configure and build
<li>The 'qmake' executable will then be located in the 'bin' subdirectory
</ol>

After <em>qmake</em> is built:

<ol>
<li>Set the QMAKEPATH environment variable to point to a directory containing a description of your platform and compiler (see below)
<li>Add the 'qmake' executable to your PATH
</ol>

Here are some examples:

<ul>
<li>Unix Bourne shell:<p>
\code
	QMAKEPATH=/home/db/mkspecs/linux-g++
	PATH=$PATH:/local/qmake/bin
	export QMAKEPATH PATH
\endcode

<li>Unix C shell:<p>
\code
	setenv QMAKEPATH /home/db/mkspecs/linux-g++
	setenv PATH $PATH:/local/qmake/bin
\endcode

<li>Microsoft Windows:<p>
\code
	set QMAKEPATH=c:\mkspecs\win32-msvc
	set PATH=%PATH%;c:\qmake\bin
\endcode
</ul>

<em>qmake</em> is now installed.

<h1><a name="QuickStart">Quick Start: Running <em>qmake</em></a></h1> 

Let's assume you have a small Qt application consisting of one C++ header
file and two source files.

First you need to create a <em>qmake</em> project file,
e.g. hello.pro:

\code
  HEADERS   =  hello.h
  SOURCES   =  hello.cpp main.cpp
  TARGET    =  hello
\endcode

This file contains information about the 'hello' <a
href="#ProjectFiles">project</a>.  To create a makefile for this
project, invoke <em>qmake</em> as follows:

\code
  qmake hello.pro -o Makefile
\endcode

This creates a makefile for the 'hello' project.  To compile this
project, type:
 
\code
  make
\endcode


This builds the 'hello' program. Remember to set the <a href="#QMAKEPATH">QMAKEPATH</a> environment 
variable properly before you run qmake.

<h1><a name="Introduction">Introducting qmake</a></li>

\e qmake is a simple tool from Trolltech to create and maintain
makefiles for software projects across multiple platforms.
<em>qmake</em> provides all of the functionality involved in
generating complex makefiles using a single 'project' specification.
That 'project' can be targeted to create makefiles for different
platforms.  It can be a painful task to manage makefiles manually,
especially if you develop for more than one platform or use more than
one compiler.  <em>qmake</em> automates and streamlines this process,
allowing you to spend your valuable time on writing code, not
makefiles.

<em>qmake</em> can be used for any software project of any size,
however <em>qmake</em> contains special features to support developing
applications with <a href="http://www.trolltech.com">Trolltech's</a>
<a href="http://www.trolltech.com/qt"> Qt</a> library.

<em>qmake</em> is a part of the Qt library and is licensed under several
licenses, including the QPL, GPL and a commercial license.  See the <a
href="http://doc.trolltech.com/licenses.html">Qt</a> LICENSE file for
details.


<h1><a name="Concepts"><em>qmake</em> Concepts</a></li> 

<h3>Running <em>qmake</em></h3>

<em>qmake</em> understands a simple language to describe a makefile,
and in turn will generate a project description as appropriate for
your destination platform. <em>qmake</em> currently generates output
for:

<ul>
<li>borland make makefiles</li>
<li>unix-style makefiles, i.e. suitable for gmake, etc.</li>
<li>msdev nmake makefiles</li>
<li>msdev dsp project files</li>
</ul>

<h3><a name="QMAKEPATH">QMAKEPATH</a></h3>

<em>qmake</em> requires a description of your platform so that a
suitable makefile can be generated.  These descriptions are kept in a
'makefile specification' files called qmake.conf. <em>qmake</em>
requires this configuration file in order to generate appropriate
makefiles for specific platform and compiler combinations.  The \c
QMAKEPATH environment variable must be set to the name of a directory
which contains this configuration file.  The qmake.conf file will
contain such basic information as the compiler to use, the names of
system libraries and location of system headers.  

On startup, <em>qmake</em> will attempt to locate the qmake.conf file
for your platform by using the QMAKEPATH environment variable.  Alternatively, 
load all of its default values.  The QMAKEPATH environment variable
can be used to tell <em>qmake</em> where to find this file, or a
command line option can be given.  <em>qmake</em> ships with many
standard QMAKEPATH files for many platform-compiler combinations.  See
the <a href="qmake-commandreference.html#QMAKEPATH"<em>qmake</em>
command reference</a> for more info.

The QMAKEPATH environment variable should point to a directory which
contains information about your platform and compiler.  When invoked,
<em>qmake</em> will use $QMAKEPATH to find your compiler specifications.
This configuration file contains compiler options and lists tools and
libraries.

You can find many platform-compiler combination descriptions in the
'mkspecs' directory of your Qt installation.


<h3><a name="ProjectFiles">Project Files</a></h3>

Armed with your platform description from the appropriate QMAKEPATH
file, <em>qmake</em> will then load any specified 'project files'
which describe your software project and generate a makefile to build
that project.  A <em>project file</em> will typically contain a list
of header and source files used by your project.  For Qt-based
projects, <em>qmake</em> will automatically generate dependancies for
<a href="moc.html">moc</a> and <a href="designer.html">uic</a>, if
they are needed by your project.  The project file will also contain
information about the type of project being created (for example, an
application or a library), as well as configuration information (such
as debug/release, project defines, and extra libraries used when
linking).

<h3>Project Templates</h3>

<em>qmake</em> understands several kinds of 'templates' which tell
<em>qmake</em> what kind of project it is building. The most common
values are:

<ul>
<li>app - Creates a makefile for building applications (the default)
<li>lib - Creates a makefile for building libraries
<li>subdirs - Creates a makefile for building targets in subdirectories
</ul>

A project 'template' is specified using the TEMPLATE system variable.
If no TEMPLATE is specified, 'app' is assumed.

<h3>The Application Template</h3>

The application template, 'app', lets you generate makefiles to
compile and link executable programs.

This template recognizes several system variables

<ul>
<li>HEADERS - Header files
<li>SOURCES - Source files
<li>LEXSOURCES - <em>qmake</em> will generate a makefile to process the listed files with
        lex, and then compile it
<li>YACCSOURCES - <em>qmake</em> will generate a makefile to process the listed files with
        yacc, and then compile it
<li>TARGET - Name of executable (adds .exe if on Windows).
<li>DESTDIR - Where to put the TARGET
<li>DEFINES - Tell compiler to define C preprocessor macros (-D option)
<li>INCLUDEPATH - Sets the include file search path for the compiler (-I option).
<li>DEPENDPATH - Sets the dependency search path for the compiler
<li>INTERFACES - Specify .ui files for addition to the build
<li>DEF_FILE - Win32 only: Link with a .def file
<li>RC_FILE - Win32 only: Use a .rc file (compile to temporary .res)
<li>RES_FILE - Win32 only: Link with a .res file
</ul>

<h3>The Library Template</h3>

The library template, 'lib', lets you generate makefiles to compile
and create static or shared libraries.

This template supports the same project variables as 'app' (see
above), as well as the following sytem variables:

<ul>
<li>VERSION - the version number of the target library, e.g. 1.40.  The version is
important for shared libraries.
</ul>

<h3>The Subdirs Template</h3>

The 'subdirs' template lets you generate makefiles to invoke
<em>qmake</em> within subdirectories.

This template recognizes the following system variables:

<ul>
<li>SUBDIRS - contains the name of all subdirectories to be processed
</ul>

<em>qmake</em> assumes that each subdirectory contains additional
project files to be processed.  See the <em>qmake</em> <a
href="qmakecommandreference.html#subdirs">reference manual</a> for
details.

<h3>Special Templates for Microsoft Visual C++</h3>

If you have Microsoft Visual C++ 5.0, 6.0 or higher, you can use two
special templates to generate a MSVC++ IDE project (.dsp file).  After
you have generated e.g. hello.dsp, choose "File"->"Open Workspace" and
select the hello.dsp file.  Visual C++ will then create a workspace
(.dsw file) for you.  The additional template for Microsoft Visual C++
are:

<ul>
<li>vcapp - Creates an application project file
<li>vclib - Creates a library project file
</ul>

Run <em>qmake</em> to create a hello.dsp file (use -t to override the
default template):

\code
  qmake -t vcapp -o hello.dsp hello.pro
\endcode

<h3><a name="CONFIG">Project Configuration</a></h3>

The \c CONFIG system variable is recognized by <em>qmake</em> and
specifies what compiler options to use and which extra libraries to
link in. Anything may be assigned to this variable, however some
values will be recognized internally by <em>qmake</em> and have
special meaning, they are as follows:

These options control the compilation flags:

<ul>
<li>release - Compile with optimization enabled, ignored if
    "debug" is specified
<li>debug - Compile with debug options enabled
<li>warn_on - The compiler should emit more warnings than normally, ignored if
     "warn_off" is specified
<li>warn_off - The compiler should emit no warnings or as few as possible.
</ul>

These options define the application/library type:

<ul>
<li>qt - The target is a Qt application/library and requires Qt header files/library.
<li>opengl - The target requires the OpenGL (or Mesa) headers/libraries.
<li>thread - The target is a multi-threaded application or library.
<li>x11 - The target is a X11 application or library.
<li>windows - The target is a Win32 window application (app only).
<li>console - The target is a console application (app only).
<li>dll - The target is a shared object/DLL.
<li>staticlib - The target is a static library (lib only).
<li>plugin - The target is a plugin (lib only). This enables dll as well.
</ul>

For example, if the 'hello' application uses both Qt and the OpenGL
libraries, and you want to compile it with debugging symbols, the
hello.pro project file should contain a \c CONFIG line like the
following:

\code
  CONFIG = qt opengl debug
\endcode

The CONFIG system variable is also used when <a
href="#Scopes">scoping</a> variable assignments.

The most common <em>qmake</em> options and project variables are
described here.  See the <em>qmake</em> <a
href="qmakecommandreference.html#CONFIG">reference manual</a> for
details.

<h1><a name="Details"><em>qmake</em> Details</a></li> 

<em>qmake</em> project files (typically having a .pro extension) are
parsed from top to bottom and consist of a series of user defined
variables as well as operations on those variables.  When
<em>qmake</em> is finished parsing the file without error, a makefile
is generated for the platform-compiler combination specified by the
QMAKEPATH file.  The order of execution for <em>qmake</em> is:

<ol>
<li>Parse the mkspec information
<li>Parse the cache file, if available
<li>Parse and commandline options
<li>Parse the project file
</ol>

When parsing, there are two classes of variables understood by
<em>qmake</em>: user-defined variables and internal system variables.
Many internal system variables begin with 'QMAKE_' (user variables
should of course use a different prefix), however there are a few
common system variables with simpler names, such as PROJECT, CONFIG,
SOURCES, HEADERS, etc (more on these project variables below). Below
is an outline of the language features understood by <em>qmake</em>.

<h3>Syntax</h3>

A <em>qmake</em> project file has a very simple syntax.  

The # character begins a comment which lasts until the end of the
line.

<h3>Variables</h3>

You may set project variables, append to project variables, and remove
from project variables.

To set a project variable:

\code
    HEADERS = gui.h xml.h url.h
\endcode

If you cannot fit everything on one line, use '\' to split it up:

\code
    HEADERS = gui.h \
	      xml.h \
	      url.h
\endcode

A user variable name can be any string.  The five operators (~=, *=,
=, -=, and +=) can be used together to operate on those
variables. Using $$ you can refer to another variable previously
defined in <em>qmake</em>.  There are several operators available to
work on lists of values.  For example:

\code
  PIG=oink moo    #$$PIG contains oink and moo 
  PIG-=moo        #$$PIG now contains only oink
  OTHERPIG=$$PIG  #$$OTHERPIG contains oink
  PIG+=snort      #$$PIG now contains oink and snort
  OTHERPIG=eat    #$$OTHERPIG now contains only eat
\endcode

See the <a href="qmake-commandreference.html#operators"<em>qmake</em>
command reference</a> for more info.

Project variables contains lists of items (for system variables, these
consist of things such as header files, compiler options etc.) and use
whitespace to separate the items.  This means that <em>qmake</em>
cannot deal with items containing whitespace.  The INCLUDEPATH
variable is an exception. If INCLUDEPATH contains one or more
semicolons (;), <em>qmake</em> uses the semicolon to separate the
include directories, hence you can have include directories containing
whitespace (this is quite common on Windows).

Here is an example:

\code
    INCLUDEPATH = C:\Program Files\DBLib\Include;C:\qt\include
\endcode

<em>qmake</em> supports <em>project variable expension</em>. Use $$ to
expand any project variable:

\code
    ALLFILES = $$HEADERS $$SOURCES
\endcode

Most often you assign values to a project variable, but you can also
add to, remove from or replace parts of a project variable:

\code
    A   = abc
    X   = xyz
    A  += abc def		# A = abc def
    B   = $$A			# B = abc def
    B  -= abc			# B = def
    B  *= abc def       # B = abc abc def
    A  ~= s/ab[xc]/xyz/ # A = xyz def
\endcode

<p> You can also set variables from the command line when running the
<em>qmake</em> program. For instance, if you want to generate a
makefile with debug information:

\code
    qmake "CONFIG+=debug" hello.pro
\endcode

<h3><a name="Scopes">Scopes</a></h3>

You may use scopes to conditionally assign to variables. There are
several ways to test for something being "in scope":

<ul>
<li>It appears in the CONFIG variable (see the <a href="#CONFIG">CONFIG</a> section)
<li>If <em>qmake</em> is in an OS mode (see the -unix/-win32 option in the
    <a href="qmake-commandreference"> command reference</a>) you may
    use the OS dependant scope (unix/win32)
<li>Function testing (see the <a href="#Functions">function tests</a> section)
<li>If a given compiler is used as specified by the QMAKEPATH (see the 
    <a href="#QMAKEPATH">QMAKEPATH</a> section).
</ul>

Scopes must be colon separated from their assignment for example:

\code
    SOURCES	   =   common.cpp   # common for all platforms
    unix:SOURCES   +=  unix.cpp	    # additional sources for Unix
    win32:SOURCES  +=  win32.cpp    # additional sources for Windows
    unix:LIBS	   +=  -lm	    # on Unix we need the math lib
\endcode

You may logically AND together scopes by separating multiple ones with
colons, similarly you may negate as scope with the '!' character. In
some cases you may actually just want to execute the scope, and not do
an assignment, this is perfectly legal in <em>qmake</em> - and the
final colon is optional. For example:

\code
   win32:win32-msvc:USING_MSVC=1 #if this is win32, and the win32-msvc
                                 #compiler is to be used then set the variable
   unix:include(file.pri)  #if this is unix, then substitute the contents
                           #file.pri with this include line.
   !unix:debug:message(oh dear, unix should be debugged!):WEIRD=1
\endcode

The syntax scope:assignment can get a little cumbersome when a test is
performed multiple times. It also leads to a makefile becoming hard to
understand without digging into it, so scopes may be blocked to attempt to
modularize different tests. For example:

\code
   win32:dance {
      contains(dance, square_dance):CONFIG += howdown
      contains(dance, disco):CONFIG += nightfever
      ACTION += dancing
   }
\endcode

Because the syntax for qmake is line based it makes the blocking syntax
very strict, this means: You must have the { on the same line as the scope
test (you may have 1 assignment after it if you so desire). Then the
following assignments must be one per line, and finally must be finished
with the line containing only a '}' character. There is a provision for
using only blocked style if you prefer on one line, however it is
discouraged, and the old style is still preferred for one liners. For
example:

\code
  test:VARIABLE = value  #is the same as...
  test { VARIABLE = value }
\endcode

<a name="Functions"><h3>Functions</h3></a>

As has appeared in some of the example tests above, functions may be
used to do advanced tests. For the most part simply testing for
platform or the value appearing in the CONFIG variable should be
sufficent, but there are other built in functions which can be
used. The functions used by <em>qmake</em> may not be extended
externally, and this functionallity will probably not be added.  See
the <a href="qmake-commandreference.html#Functions"<em>qmake</em>
command reference</a> for more info.

<h3>Cache file</h3>

<em>qmake</em> can optionally consults a 'cache' file to prevent
mistaken misconfiguration. <em>qmake</em> will never generate a cache
file on its own, it is the obligation of some outside program to do
this, however the syntax is controlled and is similar to a standard
.pro. The cache file must be called \c .qmake.cache, and should be
placed at the top directory of your project.  <em>qmake</em> will
later walk backwards in your project hierarchy to find it.  Currently
defined in the .qmake.cache is the following:

   QMAKEPATH : This variable will tell qmake what mkspec was used on
   previous runs, and will prefer to default to using this spec.
   CONFIG : This variable will tell qmake what CONFIG's you had turned on
   in the previous qmake, it will use this list as its list of currently
   "in scope" variables.

<em>qmake</em> does not require the use of a .qmake.cache - and if it
does not exist will silently ignore it. If however it exists and you
want to override it, you may use the -nocache option. See the <a
href="qmake-commandreference.html#cache"<em>qmake</em> command
reference</a> for more info.

*/




