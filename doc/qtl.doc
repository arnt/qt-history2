/****************************************************************************
** $Id: qtl.doc,v 1.5 1999/09/25 14:54:22 ettrich Exp $
**
** Qt template library classes documentation
**
** Copyright (C) 1992-1999 Troll Tech AS.  All rights reserved.
**
** This file is part of the Qt GUI Toolkit.
**
** This file may be distributed under the terms of the Q Public License
** as defined by Troll Tech AS of Norway and appearing in the file
** LICENSE.QPL included in the packaging of this file.
**
** Licensees holding valid Qt Professional Edition licenses may use this
** file in accordance with the Qt Professional Edition License Agreement
** provided with the Qt Professional Edition.
**
** See http://www.troll.no/pricing.html or email sales@troll.no for
** information about the Professional Edition licensing, or see
** http://www.troll.no/qpl/ for QPL licensing information.
**
*****************************************************************************/

/*!
\page qtl.html

<title>Qt Template library</title>
</head><body bgcolor="#ffffff">

\postheader

<h1 align=center>Qt Template Library</h1><br clear="all">

The Qt template library  contains the following classes:

<ul>
<li> \l QMap a dictionary
<li> \l QMapIterator and \l QMapConstIterator iterators for QMap.
<li> \l QValueList a linked list
<li> \l QValueListIterator and \l QValueListConstIterator iterators for QValueList.
<li> \l QStringList a list of strings
<li> \l QValueStack a stack
<li> \l QArray a dynamic array
</ul>

In contrast to the containers based on QCollection, the Qt template
library has a value based approach comparable to the C++ Standard
Template Library (STL).  While QCollection and friends store pointers
to objects, these classes store copies of the actual objects,
i.e. values. Both concepts have their specific pros and cons,
depending on the kind of data you want to store.

If you can not make copies of the objects you want to store you are
better off with QCollection and friends. They were designed to handle
exactly that kind of pointer semantics. This applies for example to
all classes derived from QObject. QObjects don't have a copy
constructor, so using them them in the STL as storage type is
impossible.  Of course you could store pointers to QObjects in a
QValueList, but using QList directly seems to be the better choice for
this kind of application domain as QCollection containers provide more
sanity checking.

If you have objects which have value semantics, you should use the Qt
template library.  Value semantics require at least a copy
constructor, an assignment operator and a default constructor that
does not take any arguments. Note that a fast copy constructor is
absolutely crucial for the overall performance of the container.

Example for value based classes are QRect, QPoint, QSize and all C++
base types such as int, bool or double.

The Qt template library is designed for speed. This means on the
drawback side that compared to the QCollection-based containers, less
error checking is provided. Especially iterators are extremely
fast. But since the template library containers do not track
associated iterators, certain validy checks, for example on removing
items, cannot be performed automatically.

<h2> Iterators </h2>

The Qt template library deals with value objects, not with pointers.
For that reason, there is no other way of iterating over containers
than using iterators. This is no disadvantage as the size of an
iterator matches the size of a normal pointer, namely 32 or 64 bits
depending on your CPU architecture.

In order to iterate over some container, do it like this:

\code
	typedef QValueList<int> List;
	List l;
	for( List::Iterator it = l.begin(); it != l.end(); ++it )
		printf("Number is %i\n",*it);
\endcode

The most important facts here are, that begin() delivers the iterator pointing
at the first element while end() returns an iterator pointing behind the last
element. It follows from that, that you may not use the item referenced by end()
iterator, since the end() iterator points behind the last item in the list.

In the above example you should especially notice that the prefix increment
operator is used for the iterator instead of the postfix one. The reason is
that the prefix one is faster. In addition you should notice the term
List::Iterator. You could have used QValueListIterator<int> instead but is not
as convenient to use with typedefs. To sum it up: The official Qt style of
coding is the one using the scoping operator.

All QTL classes can be iterated over by using the same syntax.
The following example demonstrates this:

\code
	typedef QMap<QString,QString> Map;
	Map map;
	for( Map::Iterator it = map.begin(); it != map.end(); ++it )
		printf("Key=%s Data=%s\n", it.key().ascii(), it.data().ascii() );

	typedef QArray<int> Array;
	Array array;
	for( Array::Iterator it = array.begin(); it != array.end(); ++it )
		printf("Data=%i\n", *it );
\endcode

Note that there are two kind of iterators, the volatile iterator as
shown in the example above and ConstIterator. Both are exactly the
same apart from ConstIterator returning a const reference to its
current object. Use the ConstIterator if the container is const or if
you are in a const function. Note that assigning ConstIterator to an
Interator is not allowed since it would break the const semantics.

<h2> Template functions </h2>

There is more in the template library then just container
classes. Since the containers are templates, the code is instantiated
for every different kind of incarnation. As an example,
QValueList<int> and QValueList<double> cause the QValueList code to
appear twice in your application. To avoid bloat, the template classes
therefore have been designed to be as slim as possible. Any more
advanced functionality that requries more code has been moved to
template functions outside the classes. The functions are in turn
usable with a wide range of containers.

Currently, the library only implements a few template functions,
namely qHeapSort(), qBubbleSort(), qSwap() and qCopy().

qHeapSort() and qBubbleSort() implement the well known sorting
algorithms. You can use them like this;

\code
	typedef QValueList<int> List;
	List l;
	l << 42 << 100 << 1234 << 12 << 8;
	qHeapSort( l );
	
	List l2;
	l2 << 42 << 100 << 1234 << 12 << 8;
	List::Iterator b = l2.find( 100 );
	List::Iterator e = l2.find( 8 );
	qHeapSort( b, e );

	double arr[] = { 3.2, 5.6, 8.9 };
	qHeapSort( arr, arr + 3 );
\endcode

The first example sorts the entire list. The second one sorts all
elements enclosed in the two iterators, namely 100, 1234 and 12.  The
third example shows that iterators really are just pointers and can be
treated as such.

Note that the sorting templates won't work with ConstIterators.

A second utility is qSwap(). It exchanges the values of two variables:

\code
	QString second( "Einstein" );
	QString name( "Albert" );
	qSwap( second, name );
\endcode

Another template function is qCopy(). It copies a container or
a slice of it to an OutputIterator. Currently there is only
the QTextOStream Iterator which can be used with a QTextOStream.
Using this class you can easily print out a list.

\code
	typedef QValueList<int> List;
	List l;
	l << 100 << 200 << 300;
	QTextOStream str( stdout );
	qCopy( l, QTextOStreamIterator( str ) );
\endcode

In addition, you can use usual iterators as OutputIterator. But you
have to make sure that right hand of the iterator there are as many
elements present as you want to insert. The following example
illustrates that:

\code
	QStringList l1, l2;
	l1 << "Weis" << "Ettrich" << "Arnt" << "Sue";
	l2 << "Torben" << "Matthias";
	qCopy( l2, l1.begin();
\endcode

At the end of this code fragment the List l1 contains "Torben",
"Matthias", "Arnt" and "Sue", with the prior contents being
overwritten Another flavour of qCopy() takes three arguments to make
it possible to copy a slice of a container:

\code
	typedef QValueList<int> List;
	List l;
	l << 42 << 100 << 1234 << 12 << 8;
	List::Iterator b = l.find( 100 );
	List::Iterator e = l.find( 8 );
	QTextOStream str( stdout );
	qCopy( b, e, QTextOStreamIterator( str ) );
\endcode

If you write new algorithms, consider writing them as template
functions in order to make them usable for as many containers
possible.  In the above example you could easily print out a standard
C++ array like this:

\code
	int arr[] = { 100, 200, 300 };
	QTextOStream str( stdout );
	qCopy( arr, arr + 3, QTextOStreamIterator( str ) );	
\endcode

<h2> Streaming </h2>

All containers can be be serialized with the streaming operators. Here
is an example. It assumes that \c str is some QDataStream:

\code
	QValueList<QRect> l;
	// ... fill the list here
	str << l;
\endcode

The container can be read in again like this;

\code
	QValueList<QRect> l;
	str >> l;
\endcode

The same applies to QStringList and QMap.

*/
