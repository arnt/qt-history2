/****************************************************************************
** $Id: qtl.doc,v 1.5 1999/09/25 14:54:22 ettrich Exp $
**
** Qt template library classes documentation
**
** Copyright (C) 1992-1999 Troll Tech AS.  All rights reserved.
**
** This file is part of the Qt GUI Toolkit.
**
** This file may be distributed under the terms of the Q Public License
** as defined by Troll Tech AS of Norway and appearing in the file
** LICENSE.QPL included in the packaging of this file.
**
** Licensees holding valid Qt Professional Edition licenses may use this
** file in accordance with the Qt Professional Edition License Agreement
** provided with the Qt Professional Edition.
**
** See http://www.troll.no/pricing.html or email sales@troll.no for
** information about the Professional Edition licensing, or see
** http://www.troll.no/qpl/ for QPL licensing information.
**
*****************************************************************************/

/*!
\page qtl.html

<title>Qt Template library</title>
</head><body bgcolor="#ffffff">

\postheader

<h1 align=center>Qt Template Library</h1><br clear="all">

In contrast to the containers based on \l QCollection, the Qt template
library implements a value based approach comparable to the C++
Standard Template Library (STL).

It currently provides the containers \l QMap, \l QValueList and \l
QValueStack plus a set of iterators operating on these classes ( \l
QMapIterator, \l QMapConstIterator, \l QValueListIterator and \l
QValueListConstIterator ). For convenience, it also includes a
predefined class \l QStringList that stores a list of unicode string.

While QCollection and friends store pointers to objects, these classes
store copies of the actual objects,
i.e. values. Both concepts have their specific pros and cons,
depending on the kind of data you want to store.

If you can not make copies of the objects you want to store you are
better off with QCollection and friends. They were designed to handle
exactly that kind of pointer semantics. This applies for example to
all classes derived from \l QObject. A QObject does not have a copy
constructor, so using it as value is impossible. You may choose be
store pointers to QObjects in a QValueList, but using QList directly
seems to be the better choice for this kind of application
domain. QList, like all other QCollection based containers, provides
far more sanity checking than a speed-optimized value
based container.

If you have objects that implement value semantics, use the Qt
template library.  Value semantics require at least
<ul>
<li>a copy constructor,
<li>an assignment operator and
<li> a default constructor, i.e. a constructor that does not take
any arguments.
</ul>
Note that a fast copy constructor is absolutely crucial for a good
overall performance of the container, since many copy operations are
going to happen.

Examples for value based classes are QRect, QPoint, QSize and all
simple C++ types like int, bool or double.

The Qt template library is designed for speed. Especially iterators
are extremely fast. On the drawback side, lesser error checking than
in the QCollection based containers is done. A template library
container for example does not track associated iterators. This makes
certain validy checks, like on removing items, impossible to perform
automatically.

<h2> Iterators </h2>

The Qt template library deals with value objects, not with pointers.
For that reason, there is no other way of iterating over containers
than using iterators. This is no disadvantage as the size of an
iterator matches the size of a normal pointer, namely 32 or 64 bits
depending on your CPU architecture.

In order to iterate over some container, do like this:

\code
	typedef QValueList<int> List;
	List l;
	for( List::Iterator it = l.begin(); it != l.end(); ++it )
		printf("Number is %i\n",*it);
\endcode

begin() returns the iterator pointing at the first element, while
end() returns an iterator that points \e behind the last
element. end() marks an invalid position, it can never be
dereferenced. It's the break condition in any iteration, may it be
from begin() or fromLast(). For maximum speed, use increment or
decrement iterators with the prefix operator instead of the the
postfix one, since these are slightly faster.

The same concept applies to the other container classes:

\code
	typedef QMap<QString,QString> Map;
	Map map;
	for( Map::Iterator it = map.begin(); it != map.end(); ++it )
		printf("Key=%s Data=%s\n", it.key().ascii(), it.data().ascii() );

	typedef QArray<int> Array;
	Array array;
	for( Array::Iterator it = array.begin(); it != array.end(); ++it )
		printf("Data=%i\n", *it );
\endcode

There are two kind of iterators, the volatile iterator shown in the
examples above and a version that returns a const reference to its
current object, the ConstIterator. Const iterators are required
whenever the container itself is const, for example a member variable
inside a const function. Assigning a ConstIterator to a normal
Iterator is not allowed as it would violate const semantics.

<h2> Template functions </h2>

There is more to the template library then just container
classes. Since the containers are templates, the code is instantiated
for every different kind of incarnation. As an example, the two
declarations QValueList\<int\> and QValueList\<double\> would cause
the QValueList code to appear twice in your application. To avoid
bloat, the template classes therefore have been designed to be as slim
as possible. Any more advanced functionality that requries more code
has been moved to template functions outside the classes. These
functions are in turn usable with a wide range of containers.

Currently, the library provides the template functions qHeapSort(),
qBubbleSort(), qSwap() and qCopy().

qHeapSort() and qBubbleSort() implement the well known sorting
algorithms. You can use them like this:

\code
	typedef QValueList<int> List;
	List l;
	l << 42 << 100 << 1234 << 12 << 8;
	qHeapSort( l );
	
	List l2;
	l2 << 42 << 100 << 1234 << 12 << 8;
	List::Iterator b = l2.find( 100 );
	List::Iterator e = l2.find( 8 );
	qHeapSort( b, e );

	double arr[] = { 3.2, 5.6, 8.9 };
	qHeapSort( arr, arr + 3 );
\endcode

The first example sorts the entire list. The second one sorts all
elements enclosed in the two iterators, namely 100, 1234 and 12.  The
third example shows that iterators really are just pointers and can be
treated as such.

Note that the sorting templates naturally won't work with
const iterators.

A second utility is qSwap(). It exchanges the values of two variables:

\code
	QString second( "Einstein" );
	QString name( "Albert" );
	qSwap( second, name );
\endcode

Another template function is qCopy(). It copies a container or a slice
of it to an OutputIterator, in this case a QTextOStreamIterator:

\code
	typedef QValueList<int> List;
	List l;
	l << 100 << 200 << 300;
	QTextOStream str( stdout );
	qCopy( l, QTextOStreamIterator( str ) );
\endcode

In addition, you can use any usual iterator as OutputIterator. Just
make sure that right hand of the iterator are as many elements present
as you want to insert. The following example illustrates that:

\code
	QStringList l1, l2;
	l1 << "Weis" << "Ettrich" << "Arnt" << "Sue";
	l2 << "Torben" << "Matthias";
	qCopy( l2, l1.begin();
\endcode

At the end of this code fragment, the List l1 contains "Torben",
"Matthias", "Arnt" and "Sue", with the prior contents being
overwritten. Another flavour of qCopy() takes three arguments to make
it possible to copy a slice of a container:

\code
	typedef QValueList<int> List;
	List l;
	l << 42 << 100 << 1234 << 12 << 8;
	List::Iterator b = l.find( 100 );
	List::Iterator e = l.find( 8 );
	QTextOStream str( stdout );
	qCopy( b, e, QTextOStreamIterator( str ) );
\endcode

If you write new algorithms, consider writing them as template
functions in order to make them usable with as many containers
possible.  In the above example, you could just as well print out a
standard C++ array with qCopy():

\code
	int arr[] = { 100, 200, 300 };
	QTextOStream str( stdout );
	qCopy( arr, arr + 3, QTextOStreamIterator( str ) );	
\endcode

<h2> Streaming </h2>

All mentioned containers can be serialized with the respective
streaming operators. Here is an example. It assumes that \c str is
some \l QDataStream:

\code
	QValueList<QRect> l;
	// ... fill the list here
	str << l;
\endcode

The container can be read in again with:

\code
	QValueList<QRect> l;
	str >> l;
\endcode

The same applies to QStringList, QValueStack and QMap.

*/
