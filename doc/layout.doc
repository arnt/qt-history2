/****************************************************************************
** $Id: layout.doc,v 2.4 1999/04/28 09:53:57 aavit Exp $
**
** Explanation of the layout subsystem
**
** Copyright (C) 1992-1999 Troll Tech AS.  All rights reserved.
**
** This file is part of the Qt GUI Toolkit.
**
** This file may be distributed under the terms of the Q Public License
** as defined by Troll Tech AS of Norway and appearing in the file
** LICENSE.QPL included in the packaging of this file.
**
** Licensees holding valid Qt Professional Edition licenses may use this
** file in accordance with the Qt Professional Edition License Agreement
** provided with the Qt Professional Edition.
**
** See http://www.troll.no/pricing.html or email sales@troll.no for
** information about the Professional Edition licensing, or see
** http://www.troll.no/qpl/ for QPL licensing information.
**
*****************************************************************************/

/*! \page layout.html

<title>
Qt toolkit - Layout
</title></head><body bgcolor="#ffffff">

\postheader

<h1 align=center>Qt Layout Classes</h1><br clear="all">

The Qt layout system provides a simple and powerful way of specifying
the layout of child widgets.
<p>
By specifying the logical layout once, you get the following benefits:
<ul>
<li> Positioning of child widgets.
<li> Sensible default sizes for top-level widgets.
<li> Sensible minimum sizes for top-level widgets.
<li> Resize handling.
<li> Automatic update when contents change:
	<ul>
	<li> Font size, text or other contents of subwidgets.
	<li> Hiding or showing a subwidget.
	<li> Removal of subwidget.
	</ul>
</ul>

<h2>Layout Widgets</h2>

The easiest way to give your widgets a good layout is to use the
layout widgets: \link QHBox QHBox\endlink, \link QVBox QVBox\endlink
 and \link QGrid QGrid \endlink. A layout widget automatically
lays out its children in the order they are constructed. To make more
complex layouts, you can nest layout widgets inside each other.

<dl>
  <dt>\link QHBox QHBox\endlink
      <dd>A QHBox lays out its children in a horizontal row, left to right.
	<br><img src="qhbox.gif" alt="QHBox with five children.">

  <dt>\link QVBox QVBox\endlink
      <dd>A QVBox lays out its children in a vertical row, top to bottom.
	<br><img src="qvbox.gif" alt="QVBox with five children.">
  <dt>\link QGrid QGrid\endlink
      <dd>A QGrid lays out its children in a table. You specify how
	many columns the table has, and it is filled left to right,
	beginning a new row when the previous is filled up. The grid
	is fixed; the children will not flow to other rows as the
	widget is resized.
	<br><img src="qgrid.gif" alt="Two-column QGrid with five children.">
</dl>

The grid above can be produced by the following code:
\code
    QGrid *main = new QGrid( 2 ); // a 2 x n grid
    new QLabel( "One", main );
    new QLabel( "Two", main );
    new QLabel( "Three", main );
    new QLabel( "Four", main );
    new QLabel( "Five", main );
\endcode


You can adjust the layout somewhat by calling \link
QWidget::setMinimumSize() setMinimumSize()\endlink or 
\link QWidget::setFixedSize() setFixedSize()\endlink on
the children.

<h2>QLayout</h2>

If you need more control over the layout, use a \link QLayout QLayout\endlink
 subclass. The layout classes included in Qt 2.0 are \link QGridLayout
 QGridLayout\endlink and \link QBoxLayout QBoxLayout\endlink.
(\link QHBoxLayout  QHBoxLayout\endlink and 
\link QVBoxLayout  QVBoxLayout\endlink are trivial subclasses of QBoxLayout,
that are simpler to use and make the code easier to read.)

<p>
When you use a layout, you have to insert each child both into its
parent widget (done in the constructor) and into its layout (typically
done with a function called \c addWidget()). This way, you can give
layout parameters for each widget, specifying properties like
alignment, stretch, and placement.
<p>
The following code makes a grid like the one above:
\code
    QWidget *main = new QWidget;
    //make a 1x1 grid, it will auto-expand:
    QGridLayout *grid = new QGridLayout( main, 1, 1 ); 
    grid->addWidget( new QLabel( "One", main ), 0, 0 );
    grid->addWidget( new QLabel( "Two", main ), 0, 1 );
    grid->addWidget( new QLabel( "Three", main ), 1, 0 );
    grid->addWidget( new QLabel( "Four", main ), 1, 1 );
    grid->addWidget( new QLabel( "Five", main ), 2, 0 );
\endcode

<p>

You can insert layouts inside a layout by giving the parent layout as
a parameter in the constructor. 
\code
    QWidget *main = new QWidget;

    QVBoxLayout *vbox = new QVBoxLayout( main ); 
    vbox->addWidget( new QLabel( "Where do you want to go?", main ) );
    QLineEdit *lined = new QLineEdit( main );
    vbox->addWidget( lined );

    QHBoxLayout *buttons = new QHBoxLayout( vbox );
    QPushButton *ok = new QPushButton( "OK", main );
    buttons->addWidget( ok );
    QPushButton *cancel = new QPushButton( "Cancel", main );
    buttons->addWidget( cancel );
\endcode
If you are not satisfied with the
default placement, you can create the layout without a parent and
then insert it with \c addLayout().

<h2>Custom Layouts</h2>

If the built-in layout classes are not sufficient, you can define your
own. You will have to make a subclass of \link QLayout QLayout\endlink
that handles resizing and size calculations, as well as a subclass of
\link QGLayoutIterator QGLayoutIterator\endlink to iterate over your
layout class.

<h2>Custom Widgets In Layouts</h2>

When you make your own widget class, you should also communicate its
layout properties. If the widget has a QLayout, this is already taken
care of. If the widget does not have any children, or uses manual
layout, you should implement the following functions:

<dl>
  <dt>\link QWidget::sizeHint() sizeHint()\endlink
      <dd> Returns the preferred size of the widget.
  <dt>\link QWidget::minimumSizeHint() minimumSizeHint()\endlink
      <dd> Returns the smallest size the widget can have.
  <dt>\link \link QWidget::sizePolicy() sizePolicy()\endlink
      <dd> Returns a \link QSizePolicy QSizePolicy\endlink; a value
      describing the space requirements of the widget.

</dl>

Call \link QWidget::updateGeometry() updateGeometry()\endlink whenever
the size hint, minimum size hint or size policy changes. This will
cause a layout recalculation. Multiple calls to updateGeometry() will
only cause one recalculation.

If the preferred height of your widget depends on its actual width
(eg. a label with automatic word-breaking), set the \c hasHeightForWidth()
flag in \c sizePolicy(), and implement \link QWidget::heightForWidth()
heightForWidth()\endlink.

Even if you implement heightForWidth(), it is still necessary to
provide a good sizeHint(). The sizeHint() provides the preferred width
of the widget. In addition, QLayout subclasses do not need to
implement support for heightForWidth() (is is supported by both
QGridLayout and QBoxLayout).

<h2>Manual Layout</h2>

If you are making a one-of-a-kind special layout, you can also make a
custom widget as described above. Reimplement \link
QWidget::resizeEvent() resizeEvent()\endlink to calculate the
required distribution of sizes and call \link QWidget::setGeometry()
setGeometry()\endlink on each child.

The widget will get a \c LayoutHint event when the layout needs to be
recalculated. Reimplement \link QWidget::event() event()\endlink
to be notified.

*/

