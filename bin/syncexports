#!/usr/bin/perl -w

use strict;

my $QTDIR_INCLUDE = "$ENV{QTDIR}/include";

while ( $#ARGV >= 0 ) {
    if ( $ARGV[0] eq "-single" ) {
    } else {
    }
    shift;
}

sub find_exports {
    my ($export_dir, $export_symbol, $export_name) = @_;
    $export_dir =~ s=\\=/=g;
    $export_dir = "." if($export_dir eq "");
    my $export_map = "$export_dir/${export_name}.map";

    my @subdirs;
    if (opendir(D,$export_dir)) {
	if ($export_dir eq ".") {
	    $export_dir = "";
	} else {
	    ($export_dir =~ /\/$/) || ($export_dir .= "/");
	}
	foreach (readdir(D)) {
	    next if($_  =~ /^\.\.?$/);
	    my $file = $export_dir . $_;
	    if(!-l $file) {
		if (-d $file) {
		    push @subdirs, $file;
		} elsif($file =~ m/\.cpp$/ || $file =~ m/\.h$/) {
		    my $parsable = "";
		    if(open(F, "<$file")) {
			while(<F>) {
			    my $line = $_;
			    chomp $line;
			    if($line =~ /^\#/) {
				if($line =~ /\\$/) {
				    while($line = <F>) {
					chomp $line;
					last unless($line =~ /\\$/);
				    }
				} else {
				    $line = 0;
				}
			    }
			    $line =~ s,//.*$,,; #remove c++ comments
			    $parsable .= $line if($line);
			}
			close(F);
		    }

		    my $last_interesting = 0;
		    my $interesting = 0;
		    for(my $i = 0; $i < length($parsable); $i++) {
			my $definition = 0;
			my $character = substr($parsable, $i, 1);
			if($character eq "/" && substr($parsable, $i+1, 1) eq "*") {
			    for($i+=2; $i < length($parsable); $i++) {
				my $end = substr($parsable, $i, 2);
				if($end eq "*/") {
				    $last_interesting = $i+2;
				    $i++;
				    last;
				}
			    }
			} elsif($character eq "{") {
			    my $brace_depth = 1;
			    my $block_start = $i + 1;
			    BLOCK: for($i+=1; $i < length($parsable); $i++) {
				my $ignore = substr($parsable, $i, 1);
				if($ignore eq "{") {
				    $brace_depth++;
				} elsif($ignore eq "}") {
				    $brace_depth--;
				    unless($brace_depth) {
					for(my $i2 = $i+1; $i2 < length($parsable); $i2++) {
					    my $end = substr($parsable, $i2, 1);
					    if($end eq ";" || $end ne " ") {
						$definition = substr($parsable, $last_interesting, $block_start - $last_interesting) . "}";
						$i = $i2 if($end eq ";");
						$last_interesting = $i + 1;
						last BLOCK;
					    }
					}
				    }
				}
			    }
			} elsif($character eq ";") {
			    $definition = substr($parsable, $last_interesting, $i - $last_interesting + 1);
			    $last_interesting = $i + 1;
			}
			if($definition) {
			    if($definition =~ /^typedef /) {
				#perhaps typedefs are interesting too..
			    } elsif($definition =~ /^(class|struct) $export_symbol ([^ ]*) ?((,|:) (public|private) .*)? ?\{\}$/) {
				    print "$file: I see $1 of $2 in library $export_name\n";
			    }
			}
		    }
		} 
	    }
	}
	closedir(D);
	foreach (@subdirs) {
	    find_exports($_, $export_symbol, $export_name);
	}
    } else {
	print "Failure!!!!!!!!!!! $export_dir\n";
    }
}
find_exports("$ENV{QTDIR}/src/gui", "Q_GUI_EXPORT", "QtGUI");
find_exports("$ENV{QTDIR}/src/opengl", "Q_OPENGl_EXPORT", "QtOpenGL");
find_exports("$ENV{QTDIR}/src/core", "Q_CORE_EXPORT", "QtCore");
find_exports("$ENV{QTDIR}/src/xml", "Q_XML_EXPORT", "QtXML");
find_exports("$ENV{QTDIR}/src/sql", "Q_SQL_EXPORT", "QtSQL");
find_exports("$ENV{QTDIR}/src/network", "Q_NETWORK_EXPORT", "QtNetwork");
find_exports("$ENV{QTDIR}/src/canvas", "Q_CANVAS_EXPORT", "QtCanvas");

